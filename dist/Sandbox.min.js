function parseHexToInt(e){return!e.match(/[^a-f0-9]/i)?parseInt(e,16):NaN}function validateAndParseHex(e,t,n){const i=parseHexToInt(e);if(Number.isNaN(i)||void 0!==n&&n!==e.length)throw new SyntaxError(t+": "+e);return i}function parseHexadecimalCode(e){const t=validateAndParseHex(e,"Malformed Hexadecimal",2);return String.fromCharCode(t)}function parseUnicodeCode(e,t){const n=validateAndParseHex(e,"Malformed Unicode",4);if(void 0!==t){const e=validateAndParseHex(t,"Malformed Unicode",4);return String.fromCharCode(n,e)}return String.fromCharCode(n)}function isCurlyBraced(e){return"{"===e.charAt(0)&&"}"===e.charAt(e.length-1)}function parseUnicodeCodePointCode(e){if(!isCurlyBraced(e))throw new SyntaxError("Malformed Unicode: +"+e);const t=validateAndParseHex(e.slice(1,-1),"Malformed Unicode");try{return String.fromCodePoint(t)}catch(e){throw e instanceof RangeError?new SyntaxError("Code Point Limit:"+t):e}}const singleCharacterEscapes=new Map([["b","\b"],["f","\f"],["n","\n"],["r","\r"],["t","\t"],["v","\v"],["0","\0"]]);function parseSingleCharacterCode(e){return singleCharacterEscapes.get(e)||e}const escapeMatch=/\\(?:(\\)|x([\s\S]{0,2})|u(\{[^}]*\}?)|u([\s\S]{4})\\u([^{][\s\S]{0,3})|u([\s\S]{0,4})|([0-3]?[0-7]{1,2})|([\s\S])|$)/g;function unraw(e){return e.replace(escapeMatch,(function(e,t,n,i,r,s,o,a,c){if(void 0!==t)return"\\";if(void 0!==n)return parseHexadecimalCode(n);if(void 0!==i)return parseUnicodeCodePointCode(i);if(void 0!==r)return parseUnicodeCode(r,s);if(void 0!==o)return parseUnicodeCode(o);if("0"===a)return"\0";if(void 0!==a)throw new SyntaxError("Octal Deprecation: "+a);if(void 0!==c)return parseSingleCharacterCode(c);throw new SyntaxError("End of string")}))}let lispTypes=new Map;class ParseError extends Error{constructor(e,t){super(e),this.code=t}}class Lisp{constructor(e){this.op=e.op,this.a=e.a,this.b=e.b}}class If{constructor(e,t){this.t=e,this.f=t}}class KeyVal{constructor(e,t){this.key=e,this.val=t}}class SpreadObject{constructor(e){this.item=e}}class SpreadArray{constructor(e){this.item=e}}function toLispArray(e){return e.lisp=!0,e}const inlineIfElse=/^:/,space=/^\s/;let expectTypes={splitter:{types:{split:/^(&(?!&)|<=|>=|<(?!<)|>(?!>)|!==|!=(?!\=)|===|==|\|(?!\|)|\+(?!(\+))|\-(?!(\-))|\^|<<|>>(?!>)|>>>|instanceof(?![\w\$])|in(?![\w\$]))(?!\=)/,op:/^(\/|\*\*|\*(?!\*)|\%)(?!\=)/,boolOp:/^(&&|\|\|)/},next:["modifier","value","prop","incrementerBefore"]},inlineIf:{types:{inlineIf:/^\?(?!\.)/},next:["expEnd"]},assignment:{types:{assignModify:/^(\-=|\+=|\/=|\*\*=|\*=|%=|\^=|\&=|\|=|>>>=|>>=|<<=)/,assign:/^(=)(?!=)/},next:["modifier","value","prop","incrementerBefore"]},incrementerBefore:{types:{incrementerBefore:/^(\+\+|\-\-)/},next:["prop"]},expEdge:{types:{call:/^(\?\.)?[\(]/,incrementerAfter:/^(\+\+|\-\-)/},next:["splitter","expEdge","inlineIf","dot","expEnd"]},modifier:{types:{not:/^!/,inverse:/^~/,negative:/^\-(?!\-)/,positive:/^\+(?!\+)/,typeof:/^typeof(?![\w\$\_])/,delete:/^delete(?![\w\$\_])/},next:["modifier","value","prop","incrementerBefore"]},dot:{types:{arrayProp:/^(\?\.)?\[/,dot:/^(\?)?\.(?!\()/},next:["splitter","assignment","expEdge","inlineIf","dot","expEnd"]},prop:{types:{prop:/^[a-zA-Z\$\_][a-zA-Z\d\$\_]*/},next:["splitter","assignment","expEdge","inlineIf","dot","expEnd"]},value:{types:{createObject:/^\{/,createArray:/^\[/,number:/^(0x[\da-f]+(_[\da-f]+)*|(\d+(_\d+)*(\.\d+(_\d+)*)?|\.\d+(_\d+)*))(e[\+\-]?\d+(_\d+)*)?(n)?(?!\d)/i,string:/^"(\d+)"/,literal:/^`(\d+)`/,regex:/^\/(\d+)\/r(?![\w\$\_])/,boolean:/^(true|false)(?![\w\$\_])/,null:/^null(?![\w\$\_])/,und:/^undefined(?![\w\$\_])/,arrowFunctionSingle:/^(async\s+)?([a-zA-Z\$_][a-zA-Z\d\$_]*)\s*=>\s*({)?/,arrowFunction:/^(async\s*)?\(\s*((\.\.\.)?\s*[a-zA-Z\$_][a-zA-Z\d\$_]*(\s*,\s*(\.\.\.)?\s*[a-zA-Z\$_][a-zA-Z\d\$_]*)*)?\s*\)\s*=>\s*({)?/,inlineFunction:/^(async\s+)?function(\s*[a-zA-Z\$_][a-zA-Z\d\$_]*)?\s*\(\s*((\.\.\.)?\s*[a-zA-Z\$_][a-zA-Z\d\$_]*(\s*,\s*(\.\.\.)?\s*[a-zA-Z\$_][a-zA-Z\d\$_]*)*)?\s*\)\s*{/,group:/^\(/,NaN:/^NaN(?![\w\$\_])/,Infinity:/^Infinity(?![\w\$\_])/,void:/^void(?![\w\$\_])\s*/,await:/^await(?![\w\$\_])\s*/,new:/^new(?![\w\$\_])\s*/,throw:/^throw(?![\w\$\_])\s*/},next:["splitter","expEdge","inlineIf","dot","expEnd"]},initialize:{types:{initialize:/^(var|let|const)\s+([a-zA-Z\$_][a-zA-Z\d\$_]*)\s*(=)?/,return:/^return(?![\w\$\_])/},next:["modifier","value","prop","incrementerBefore","expEnd"]},spreadObject:{types:{spreadObject:/^\.\.\./},next:["value","prop"]},spreadArray:{types:{spreadArray:/^\.\.\./},next:["value","prop"]},expEnd:{types:{},next:[]},expSingle:{types:{for:/^(([a-zA-Z\$\_][\w\$\_]*)\s*:)?\s*for\s*\(/,do:/^(([a-zA-Z\$\_][\w\$\_]*)\s*:)?\s*do(?![\w\$])\s*(\{)?/,while:/^(([a-zA-Z\$\_][\w\$\_]*)\s*:)?\s*while\s*\(/,loopAction:/^(break|continue)(?![\w\$\_])/,if:/^if\s*\(/,try:/^try\s*{/,block:/^{/,function:/^(async\s+)?function(\s*[a-zA-Z\$_][a-zA-Z\d\$_]*)\s*\(\s*((\.\.\.)?\s*[a-zA-Z\$_][a-zA-Z\d\$_]*(\s*,\s*(\.\.\.)?\s*[a-zA-Z\$_][a-zA-Z\d\$_]*)*)?\s*\)\s*{/,switch:/^(([a-zA-Z\$\_][\w\$\_]*)\s*:)?\s*switch\s*\(/},next:["expEnd"]}},closings={"(":")","[":"]","{":"}","'":"'",'"':'"',"`":"`"};function testMultiple(e,t){let n;for(let i=0;i<t.length;i++){if(n=t[i].exec(e),n)break}return n}const okFirstChars=/^[\+\-~ !]/,aChar=/^[\w\$]/,aNumber=expectTypes.value.types.number,wordReg=/^((if|for|while|do|function)(?![\w\$])|[\w\$]+)/;function restOfExp(e,t,n,i,r,s,o={}){o.words=o.words||[];let a=!0;n=n||[];let c,l=!1,p=!1,u=!1,f="",d=!1;for(c=0;c<t.length&&!p;c++){let h=t[c];if(u=aChar.test(h),'"'===i||"'"===i||"`"===i){if("`"!==i||"$"!==h||"{"!==t[c+1]||l){if(h===i&&!l)return t.substring(0,c)}else{c+=restOfExp(e,t.substring(c+2),[],"{").length+2}l=!l&&"\\"===h}else if(closings[h]){if(d&&"{"===h&&(d=!1),h===r){p=!0;break}if(c+=restOfExp(e,t.substring(c+1),[],h).length+1,a=!1,s){let e;(e=testMultiple(t.substring(c),s))&&(o.regRes=e,p=!0)}}else if(i){if(h===closings[i])return t.substring(0,c)}else{let e,i,r=t.substring(c);if(s){let e;(e=testMultiple(r,s))&&(o.regRes=e,p=!0)}if(i=aNumber.exec(r))c+=i[0].length-1,r=t.substring(c);else if(e=wordReg.exec(r)){d=!0,e[2]&&(o.words.push(e[1]),o.lastAnyWord=e[1],o.lastWord=e[2]);let t=testMultiple(r,n);t&&(s&&t[1].length&&(c+=t[1].length-1),p=!0),!p&&e[0].length>2&&(c+=e[0].length-2)}else if(f!=h){let e=testMultiple(r,n);e&&(s&&(c+=e[1].length-1),p=!0)}if(a&&(okFirstChars.test(r)?p=!1:a=!1),p)break}f=h}if(i)throw new SyntaxError("Unclosed '"+i+"': "+i+t.substring(0,Math.min(c,40)));return o&&(o.oneliner=d),t.substring(0,c)}restOfExp.next=["splitter","expEnd","inlineIf"];const startingExecpted=["initialize","expSingle","value","modifier","prop","incrementerBefore","expEnd"],setLispType=(e,t)=>{e.forEach((e=>{lispTypes.set(e,t)}))},closingsCreate={createArray:/^\]/,createObject:/^\}/,group:/^\)/,arrayProp:/^\]/,call:/^\)/};setLispType(["createArray","createObject","group","arrayProp","call"],((e,t,n,i,r,s)=>{let o="",a=[],c=!1,l=i[0].length;for(;l<n.length&&!c;)o=restOfExp(e,n.substring(l),[closingsCreate[t],/^,/]),l+=o.length,o&&a.push(o),","!==n[l]?c=!0:l++;const p=["value","modifier","prop","incrementerBefore","expEnd"];let u,f;switch(t){case"group":case"arrayProp":u=lispifyExpr(e,a.join(","));break;case"call":case"createArray":u=toLispArray(a.map((t=>lispify(e,t,[...p,"spreadArray"]))));break;case"createObject":u=toLispArray(a.map((t=>{let n,i;if(t=t.trimStart(),f=expectTypes.expSingle.types.function.exec("function "+t),f)i=f[2].trimStart(),n=lispify(e,"function "+t.replace(i,""));else{let r=restOfExp(e,t,[/^:/]);if(i=lispify(e,r,[...p,"spreadObject"]),i instanceof Lisp&&"prop"===i.op&&(i=i.b),r.length===t.length)return i;n=lispify(e,t.substring(r.length+1))}return new Lisp({op:"keyVal",a:i,b:n})})))}t="arrayProp"===t?i[1]?"?prop":"prop":"call"===t?i[1]?"?call":"call":t,s.lispTree=lispify(e,n.substring(l+1),expectTypes[r].next,new Lisp({op:t,a:s.lispTree,b:u}))})),setLispType(["inverse","not","negative","positive","typeof","delete","op"],((e,t,n,i,r,s)=>{let o=restOfExp(e,n.substring(i[0].length),[/^[^\s\.\w\$]/]);s.lispTree=lispify(e,n.substring(o.length+i[0].length),restOfExp.next,new Lisp({op:["positive","negative"].includes(t)?"$"+i[0]:i[0],a:s.lispTree,b:lispify(e,o,expectTypes[r].next)}))})),setLispType(["incrementerBefore"],((e,t,n,i,r,s)=>{let o=restOfExp(e,n.substring(2),[/^[^\s\.\w\d\$]/]);s.lispTree=lispify(e,n.substring(o.length+2),restOfExp.next,new Lisp({op:i[0]+"$",a:lispify(e,o,expectTypes[r].next)}))})),setLispType(["incrementerAfter"],((e,t,n,i,r,s)=>{s.lispTree=lispify(e,n.substring(i[0].length),expectTypes[r].next,new Lisp({op:"$"+i[0],a:s.lispTree}))})),setLispType(["assign","assignModify","boolOp"],((e,t,n,i,r,s)=>{s.lispTree=new Lisp({op:i[0],a:s.lispTree,b:lispify(e,n.substring(i[0].length),expectTypes[r].next)})})),setLispType(["split"],((e,t,n,i,r,s)=>{let o=restOfExp(e,n.substring(i[0].length),[expectTypes.splitter.types.split,expectTypes.splitter.types.boolOp,expectTypes.inlineIf.types.inlineIf,inlineIfElse]);s.lispTree=lispify(e,n.substring(o.length+i[0].length),restOfExp.next,new Lisp({op:i[0],a:s.lispTree,b:lispify(e,o,expectTypes[r].next)}))})),setLispType(["inlineIf"],((e,t,n,i,r,s)=>{let o=!1,a="",c=1;for(;!o&&a.length<n.length;)a+=restOfExp(e,n.substring(a.length+1),[expectTypes.inlineIf.types.inlineIf,inlineIfElse]),"?"===n[a.length+1]?c++:c--,c?a+=n[a.length+1]:o=!0;s.lispTree=new Lisp({op:"?",a:s.lispTree,b:new Lisp({op:":",a:lispifyExpr(e,a),b:lispifyExpr(e,n.substring(i[0].length+a.length+1))})})})),setLispType(["if"],((e,t,n,i,r,s)=>{let o=restOfExp(e,n.substring(i[0].length),[],"(");const a=/^\s*\{/.exec(n.substring(i[0].length+o.length+1)),c=i[0].length+o.length+1+(a?a[0].length:0);let l=restOfExp(e,n.substring(c),a?[/^\}/]:[/^;/]),p="";if(c+l.length+(a?a[0].length:0)<n.length){const e=n.substring(c+l.length+(a?a[0].length:1)),t=/^;?\s*else(?![\w\$])\s*/.exec(e);t&&(p=e.substring(t[0].length))}o=o.trim(),l=l.trim(),p=p.trim(),"{"===l[0]&&(l=l.slice(1,-1)),"{"===p[0]&&(p=p.slice(1,-1)),s.lispTree=new Lisp({op:"if",a:lispifyExpr(e,o),b:new If(lispifyBlock(l,e),p?lispifyBlock(p,e):void 0)})})),setLispType(["switch"],((e,t,n,i,r,s)=>{const o=restOfExp(e,n.substring(i[0].length),[],"(");let a=n.indexOf("{",i[0].length+o.length+1);if(-1===a)throw new SyntaxError("Invalid switch: "+n);let c,l=insertSemicolons(e,restOfExp(e,n.substring(a+1),[],"{"));const p=/^\s*(case\s|default)\s*/;let u=[],f=!1;for(;c=p.exec(l);){if("default"===c[1]){if(f)throw new SyntaxError("Only one default switch case allowed:"+l);f=!0}let t=restOfExp(e,l.substring(c[0].length),[/^:/]),n="",i=a=c[0].length+t.length+1,r=/^\s*\{/.exec(l.substring(i)),s=[];if(r)i+=r[0].length,n=restOfExp(e,l.substring(i),[],"{"),i+=n.length+1,s=lispifyBlock(n,e);else{let t=restOfExp(e,l.substring(i),[p]);if(t.trim()){let t=[];for(;(n=restOfExp(e,l.substring(i),[/^;/]))&&(t.push(n),i+=n.length+1,!p.test(l.substring(i))););s=lispifyBlock(t.join(";"),e)}else s=[],i+=t.length}l=l.substring(i),u.push(new Lisp({op:"case",a:"default"===c[1]?void 0:lispifyExpr(e,t),b:toLispArray(s)}))}s.lispTree=new Lisp({op:"switch",a:lispifyExpr(e,o),b:toLispArray(u)})})),setLispType(["dot","prop"],((e,t,n,i,r,s)=>{let o=i[0],a=i[0].length,c="prop";if("dot"===t){i[1]&&(c="?prop");let e=n.substring(i[0].length).match(expectTypes.prop.types.prop);if(!e||!e.length)throw new SyntaxError("Hanging  dot:"+n);o=e[0],a=o.length+i[0].length}s.lispTree=lispify(e,n.substring(a),expectTypes[r].next,new Lisp({op:c,a:s.lispTree,b:o}))})),setLispType(["spreadArray","spreadObject"],((e,t,n,i,r,s)=>{s.lispTree=new Lisp({op:t,b:lispify(e,n.substring(i[0].length),expectTypes[r].next)})})),setLispType(["return"],((e,t,n,i,r,s)=>{s.lispTree=new Lisp({op:t,b:lispifyExpr(e,n.substring(i[0].length))})}));const primitives={true:!0,false:!1,null:null,Infinity:1/0,NaN:NaN,und:void 0};setLispType(["number","boolean","null","und","NaN","Infinity"],((e,t,n,i,r,s)=>{s.lispTree=lispify(e,n.substring(i[0].length),expectTypes[r].next,"number"===t?i[10]?BigInt(i[1]):Number(i[0]):primitives["boolean"===t?i[0]:t])})),setLispType(["string","literal","regex"],((e,t,n,i,r,s)=>{s.lispTree=lispify(e,n.substring(i[0].length),expectTypes[r].next,new Lisp({op:t,b:parseInt(JSON.parse(i[1]),10)}))})),setLispType(["initialize"],((e,t,n,i,r,s)=>{i[3]?s.lispTree=new Lisp({op:i[1],a:i[2],b:lispify(e,n.substring(i[0].length),expectTypes[r].next)}):s.lispTree=lispify(e,n.substring(i[0].length),expectTypes[r].next,new Lisp({op:i[1],a:i[2]}))})),setLispType(["function","inlineFunction","arrowFunction","arrowFunctionSingle"],((e,t,n,i,r,s)=>{const o="function"!==t&&"inlineFunction"!==t,a=o&&!i[i.length-1],c=o?2:3,l=!!i[1],p=i[c]?i[c].replace(/\s+/g,"").split(/,/g):[];o||p.unshift((i[2]||"").trimStart());let u=!1;p.forEach((e=>{if(u)throw new SyntaxError("Rest parameter must be last formal parameter");e.startsWith("...")&&(u=!0)})),p.unshift(l);const f=(a?"return ":"")+restOfExp(e,n.substring(i[0].length),a?[/^[,;\)\}\]]/]:[/^}/]);s.lispTree=lispify(e,n.substring(i[0].length+f.length+1),expectTypes[r].next,new Lisp({op:o?"arrowFunc":t,a:toLispArray(p),b:e.eager?lispifyFunction(f,e):f}))}));const iteratorRegex=/^((let|var|const)\s+)?\s*([a-zA-Z\$_][a-zA-Z\d\$_]*)\s+(in|of)(?![\w\$])/;setLispType(["for","do","while"],((e,t,n,i,r,s)=>{let o,a,c,l=0,p=!0,u=toLispArray([]),f=!1,d=!0,h=!0;switch(t){case"while":l=n.indexOf("(")+1;let t=restOfExp(e,n.substring(l),[],"(");a=lispifyExpr(e,t),c=restOfExp(e,n.substring(l+t.length+1)).trim(),"{"===c[0]&&(c=c.slice(1,-1));break;case"for":l=n.indexOf("(")+1;let r,s=[],x="";for(let t=0;t<3&&(x=restOfExp(e,n.substring(l),[/^[;\)]/]),s.push(x.trim()),l+=x.length+1,")"!==n[l-1]);t++);if(1===s.length&&(r=iteratorRegex.exec(s[0])))"of"===r[4]?(o=lispifyExpr(e,s[0].substring(r[0].length)),u=toLispArray([ofStart2,ofStart3]),a=ofCondition,h=ofStep,f=lispify(e,(r[1]||"let ")+r[3]+" = $$next.value",["initialize"])):(o=lispifyExpr(e,s[0].substring(r[0].length)),u=toLispArray([inStart2,inStart3]),h=inStep,a=inCondition,f=lispify(e,(r[1]||"let ")+r[3]+" = $$keys[$$keyIndex]",["initialize"]));else{if(3!==s.length)throw new SyntaxError("Invalid for loop definition: "+s.join(";"));p=lispifyExpr(e,s.shift(),startingExecpted),a=lispifyExpr(e,s.shift()),h=lispifyExpr(e,s.shift())}c=restOfExp(e,n.substring(l)).trim(),"{"===c[0]&&(c=c.slice(1,-1));break;case"do":d=!1;const y=!!i[3];c=restOfExp(e,n.substring(i[0].length),y?[/^\}/]:[/^;/]),a=lispifyExpr(e,restOfExp(e,n.substring(n.indexOf("(",i[0].length+c.length)+1),[],"("))}const x=[d,u,o,p,h,a,f];x.lisp=!0,s.lispTree=new Lisp({op:"loop",a:x,b:lispifyBlock(c,e)})})),setLispType(["block"],((e,t,n,i,r,s)=>{s.lispTree=lispifyBlock(restOfExp(e,n.substring(1),[],"{"),e)})),setLispType(["loopAction"],((e,t,n,i,r,s)=>{s.lispTree=new Lisp({op:"loopAction",a:i[1]})}));const catchReg=/^\s*(catch\s*(\(\s*([a-zA-Z\$_][a-zA-Z\d\$_]*)\s*\))?|finally)\s*\{/;setLispType(["try"],((e,t,n,i,r,s)=>{const o=restOfExp(e,n.substring(i[0].length),[],"{");let a,c,l,p=catchReg.exec(n.substring(i[0].length+o.length+1)),u=0;p[1].startsWith("catch")?(p=catchReg.exec(n.substring(i[0].length+o.length+1)),c=p[2],l=restOfExp(e,n.substring(i[0].length+o.length+1+p[0].length),[],"{"),u=i[0].length+o.length+1+p[0].length+l.length+1,(p=catchReg.exec(n.substring(u)))&&p[1].startsWith("finally")&&(a=restOfExp(e,n.substring(u+p[0].length),[],"{"))):a=restOfExp(e,n.substring(i[0].length+o.length+1+p[0].length),[],"{");const f=[c,lispifyBlock(insertSemicolons(e,l||""),e),lispifyBlock(insertSemicolons(e,a||""),e)];f.lisp=!0,s.lispTree=new Lisp({op:"try",a:lispifyBlock(insertSemicolons(e,o),e),b:f})})),setLispType(["void","await","throw"],((e,t,n,i,r,s)=>{const o=restOfExp(e,n.substring(i[0].length),[/^[^\s\.\w\d\$]/]);s.lispTree=lispify(e,n.substring(i[0].length+o.length),expectTypes[r].next,new Lisp({op:t,a:lispify(e,o)}))})),setLispType(["new"],((e,t,n,i,r,s)=>{let o=i[0].length;const a=restOfExp(e,n.substring(o),[],void 0,"(");o+=a.length+1;const c=[];if("("===n[o-1]){const t=restOfExp(e,n.substring(o),[],"(");let i;o+=t.length+1;let r=0;for(;i=restOfExp(e,t.substring(r),[/^,/]);)r+=i.length+1,c.push(i.trim())}s.lispTree=lispify(e,n.substring(o),expectTypes.expEdge.next,new Lisp({op:t,a:lispify(e,a,expectTypes.initialize.next),b:toLispArray(c.map((t=>lispify(e,t,expectTypes.initialize.next))))}))}));const ofStart2=lispify(void 0,"let $$iterator = $$obj[Symbol.iterator]()",["initialize"]),ofStart3=lispify(void 0,"let $$next = $$iterator.next()",["initialize"]),ofCondition=lispify(void 0,"return !$$next.done",["initialize"]),ofStep=lispify(void 0,"$$next = $$iterator.next()"),inStart2=lispify(void 0,"let $$keys = Object.keys($$obj)",["initialize"]),inStart3=lispify(void 0,"let $$keyIndex = 0",["initialize"]),inStep=lispify(void 0,"$$keyIndex++"),inCondition=lispify(void 0,"return $$keyIndex < $$keys.length",["initialize"]);var lastType,lastPart,lastLastPart,lastLastLastPart;function lispify(e,t,n,i){if(n=n||expectTypes.initialize.next,void 0===t)return i;if(!(t=t.trim()).length&&!n.includes("expEnd"))throw new SyntaxError("Unexpected end of expression: "+lastLastLastPart);if(!t)return i;let r,s={lispTree:i};for(let i of n)if("expEnd"!==i){for(let n in expectTypes[i].types)if("expEnd"!==n&&(r=expectTypes[i].types[n].exec(t))){lastType=n,lastLastLastPart=lastLastPart,lastLastPart=lastPart,lastPart=t,lispTypes.get(n)(e,n,t,r,i,s);break}if(r)break}if(!r&&t.length)throw SyntaxError(`Unexpected token (${lastType}): ${lastPart.substring(0,100)}`);return s.lispTree}const startingExpectedWithoutSingle=startingExecpted.filter((e=>"expSingle"!==e));function lispifyExpr(e,t,n){if(!t.trim())return;let i,r=[],s=0;if((n=n||expectTypes.initialize.next).includes("expSingle")&&testMultiple(t,Object.values(expectTypes.expSingle.types)))return lispify(e,t,["expSingle"]);for(n===startingExecpted&&(n=startingExpectedWithoutSingle);i=restOfExp(e,t.substring(s),[/^,/]);)r.push(i.trimStart()),s+=i.length+1;if(1===r.length)return lispify(e,t,n);if(n.includes("initialize")){let i=expectTypes.initialize.types.initialize.exec(r[0]);if(i)return toLispArray(r.map(((t,n)=>lispify(e,n?i[1]+" "+t:t,["initialize"]))));if(expectTypes.initialize.types.return.exec(r[0]))return lispify(e,t,n)}const o=toLispArray(r.map(((t,i)=>lispify(e,t,n))));return new Lisp({op:"multi",a:o})}function lispifyBlock(e,t){if(!(e=insertSemicolons(t,e)).trim())return toLispArray([]);let n,i=[],r=0,s={},o=[];for(;n=restOfExp(t,e.substring(r),[/^;/],void 0,void 0,void 0,s);)s.words.includes("if")&&/^\s*else(?![\w\$])/.test(e.substring(r+n.length+1))||s.words.includes("do")&&/^\s*while(?![\w\$])/.test(e.substring(r+n.length+1))?o.push(n,";"):(i.push(o.join("")+n),o=[]),s={},r+=n.length+1;return o.length&&i.push(o.join("")),toLispArray(i.filter(Boolean).map(((e,n)=>lispifyExpr(t,e.trimStart(),startingExecpted))).flat())}function lispifyFunction(e,t){if(!e.trim())return toLispArray([]);const n=lispifyBlock(e,t);let i=toLispArray([]);return hoist(n,i),toLispArray(i.concat(n))}function hoist(e,t){if(Array.isArray(e)){const n=[];for(let i of e)hoist(i,t)||n.push(i);n.length!==e.length&&(e.length=0,e.push(...n))}else if(e instanceof Lisp)if("try"===e.op||"if"===e.op||"loop"===e.op||"switch"===e.op)hoist(e.a,t),hoist(e.b,t);else if("var"===e.op)t.push(new Lisp({op:"var",a:e.a}));else if("function"===e.op&&e.a[1])return t.push(e),!0;return!1}const closingsNoInsertion=/^(\})\s*(catch|finally|else|while|instanceof)(?![\w\$])/,colonsRegex=/^((([\w\$\]\)]|\+\+|\-\-)\s*\r?\n\s*([\w\$\+\-\!~]))|(\}\s*[\w\$\!~\+\-\{\(]))/;function insertSemicolons(e,t){let n=t,i="",r=[],s={};for(;i=restOfExp(e,n,[],void 0,void 0,[colonsRegex],s);){let e=!1,t=i,o=i.length;if(s.regRes){e=!0;const[,,r,,,a]=s.regRes;if(o="++"===s.regRes[3]||"--"===s.regRes[3]?i.length+1:i.length,t=n.substring(0,o),a){let t=closingsNoInsertion.exec(n.substring(i.length-1));t?e="while"===t[2]&&"do"===s.lastWord:"function"===s.lastWord&&"}"===s.regRes[5][0]&&"("===s.regRes[5].slice(-1)&&(e=!1)}else r&&("if"!==s.lastWord&&"while"!==s.lastWord||(e=!1))}r.push(t),e&&r.push(";"),n=n.substring(o),s={}}return r.join("")}function checkRegex(e){let t=1,n=!1,i=!1,r=!1;for(;t<e.length&&!i&&!r;)i="/"===e[t]&&!n,n="\\"===e[t]&&!n,r="\n"===e[t],t++;let s=e.substring(t);if(r=r||!i||/^\s*\d/.test(s),r)return null;let o=/^[a-z]*/.exec(s);return/^\s+[\w\$]/.test(e.substring(t+o[0].length))?null:{regex:e.substring(1,t-1),flags:o&&o[0]||"",length:t+(o&&o[0].length||0)}}const notDivide=/(typeof|delete|instanceof|return|in|of|throw|new|void|do|if)$/,possibleDivide=/^([\w\$\]\)]|\+\+|\-\-)[^\w\$\]\)\+\-]/;function extractConstants(e,t,n=""){let i,r,s=[],o=!1,a="",c=-1,l=toLispArray([]),p="";const u=[],f=[];let d;for(var h=0;h<t.length;h++)if(p=t[h],a)p===a&&("*"===a&&"/"===t[h+1]?(a="",h++):"\n"===a&&(a=""));else{if(o){o=!1,s.push(p);continue}if(i)if("`"===i&&"$"===p&&"{"===t[h+1]){let n=extractConstants(e,t.substring(h+2),"{");l.push(n.str),s.push(`\${${l.length-1}}`),h+=n.length+2}else i===p?("`"===i?(e.literals.push({op:"literal",a:unraw(s.join("")),b:l}),u.push(`\`${e.literals.length-1}\``)):(e.strings.push(unraw(s.join(""))),u.push(`"${e.strings.length-1}"`)),i=null,s=[]):s.push(p);else{if("'"===p||'"'===p||"`"===p)l=toLispArray([]),i=p;else{if(closings[n]===p&&!f.length)return{str:u.join(""),length:h};closings[p]?(f.push(p),u.push(p)):closings[f[f.length-1]]===p?(f.pop(),u.push(p)):"/"!==p||"*"!==t[h+1]&&"/"!==t[h+1]?"/"===p&&!d&&(r=checkRegex(t.substring(h)))?(e.regexes.push(r),u.push(`/${e.regexes.length-1}/r`),h+=r.length-1):u.push(p):(a="*"===t[h+1]?"*":"\n",c=h)}d&&space.test(p)||(d=possibleDivide.exec(t.substring(h)))&&notDivide.test(t.substring(0,h+d[1].length))&&(d=null)}o=i&&"\\"===p}if(a&&"*"===a)throw new SyntaxError("Unclosed comment '/*': "+t.substring(c));return{str:u.join(""),length:h}}function parse(e,t=!1){if("string"!=typeof e)throw new ParseError("Cannot parse "+e,e);let n=" "+e;const i={strings:[],literals:[],regexes:[],eager:t};n=extractConstants(i,n).str;try{for(let e of i.literals)e.b=toLispArray(e.b.map((e=>lispifyExpr(i,e))));return{tree:lispifyFunction(n,i),constants:i}}catch(e){throw e}}class ExecReturn{constructor(e,t,n,i=!1,r=!1){this.auditReport=e,this.result=t,this.returned=n,this.breakLoop=i,this.continueLoop=r}}class Prop{constructor(e,t,n=!1,i=!1,r=!1){this.context=e,this.prop=t,this.isConst=n,this.isGlobal=i,this.isVariable=r}}const optional=Symbol("optional"),reservedWords=new Set(["instanceof","typeof","return","try","catch","if","finally","else","in","of","var","let","const","for","delete","false","true","while","do","break","continue","new","function","async","await","switch","case"]);var VarType;!function(e){e.let="let",e.const="const",e.var="var"}(VarType||(VarType={}));class Scope{constructor(e,t={},n){this.const=new Set,this.let=new Set;const i=void 0!==n||null===e;this.parent=e,this.allVars=t,this.let=i?this.let:new Set(Object.keys(t)),this.var=i?new Set(Object.keys(t)):this.var,this.globals=null===e?new Set(Object.keys(t)):new Set,this.functionThis=n}get(e,t=!1){if("this"===e&&void 0!==this.functionThis)return new Prop({this:this.functionThis},e,!0,!1,!0);if(reservedWords.has(e))throw new SyntaxError("Unexepected token '"+e+"'");if(null===this.parent||!t||void 0!==this.functionThis){if(this.globals.has(e))return new Prop(this.functionThis,e,!1,!0,!0);if(e in this.allVars&&(!(e in{})||this.allVars.hasOwnProperty(e)))return new Prop(this.allVars,e,this.const.has(e),this.globals.has(e),!0);if(null===this.parent)return new Prop(void 0,e)}return this.parent.get(e,t)}set(e,t){if("this"===e)throw new SyntaxError('"this" cannot be assigned');if(reservedWords.has(e))throw new SyntaxError("Unexepected token '"+e+"'");let n=this.get(e);if(void 0===n.context)throw new ReferenceError(`Variable '${e}' was not declared.`);if(n.isConst)throw new TypeError(`Cannot assign to const variable '${e}'`);if(n.isGlobal)throw new SandboxError(`Cannot override global variable '${e}'`);return n.context[n]=t,n}declare(e,t=null,n,i=!1){if("this"===e)throw new SyntaxError('"this" cannot be declared');if(reservedWords.has(e))throw new SyntaxError("Unexepected token '"+e+"'");if("var"===t&&void 0===this.functionThis&&null!==this.parent)return this.parent.declare(e,t,n,i);if((!this[t].has(e)||"const"===t||this.globals.has(e))&&e in this.allVars)throw new SandboxError(`Identifier '${e}' has already been declared`);return i&&this.globals.add(e),this[t].add(e),this.allVars[e]=n,new Prop(this.allVars,e,this.const.has(e),i)}}class SandboxError extends Error{}let currentTicks;function sandboxFunction(e){return function SandboxFunction(...t){let n=parse(t.pop()||"");return createFunction(t,n.tree,currentTicks,{ctx:e,constants:n.constants,tree:n.tree},void 0,"anonymous")}}const sandboxedFunctions=new WeakSet;function createFunction(e,t,n,i,r,s){if(i.ctx.options.forbidFunctionCreation)throw new SandboxError("Function creation is forbidden");let o=function(...o){const a={};e.forEach(((e,t)=>{e.startsWith("...")?a[e.substring(3)]=o.slice(t):a[e]=o[t]}));return executeTree(n,i,t,void 0===r?[]:[new Scope(r,a,void 0===s?void 0:this)]).result};return sandboxedFunctions.add(o),o}function createFunctionAsync(e,t,n,i,r,s){var o;if(i.ctx.options.forbidFunctionCreation)throw new SandboxError("Function creation is forbidden");if(!(null===(o=i.ctx.options.prototypeWhitelist)||void 0===o?void 0:o.has(Promise)))throw new SandboxError("Async/await not permitted");let a=async function(...o){const a={};e.forEach(((e,t)=>{e.startsWith("...")?a[e.substring(3)]=o.slice(t):a[e]=o[t]}));return(await executeTreeAsync(n,i,t,void 0===r?[]:[new Scope(r,a,void 0===s?void 0:this)])).result};return sandboxedFunctions.add(a),a}function sandboxedEval(e){return function(t){return e(t)()}}function sandboxedSetTimeout(e){return function(t,...n){return"string"!=typeof t?setTimeout(t,...n):setTimeout(e(t),...n)}}function sandboxedSetInterval(e){return function(t,...n){return"string"!=typeof t?setInterval(t,...n):setInterval(e(t),...n)}}function assignCheck(e,t,n="assign"){var i,r,s,o;if(void 0===e.context)throw new ReferenceError(`Cannot ${n} value to undefined.`);if("object"!=typeof e.context&&"function"!=typeof e.context)throw new SyntaxError(`Cannot ${n} value to a primitive.`);if(e.isConst)throw new TypeError(`Cannot set value to const variable '${e.prop}'`);if(e.isGlobal)throw new SandboxError(`Cannot ${n} property '${e.prop}' of a global object`);if("function"==typeof e.context[e.prop]&&!e.context.hasOwnProperty(e.prop))throw new SandboxError(`Override prototype property '${e.prop}' not allowed`);"delete"===n?e.context.hasOwnProperty(e.prop)&&(null===(i=t.ctx.changeSubscriptions.get(e.context))||void 0===i||i.forEach((t=>t({type:"delete",prop:e.prop})))):e.context.hasOwnProperty(e.prop)?null===(s=null===(r=t.ctx.setSubscriptions.get(e.context))||void 0===r?void 0:r.get(e.prop))||void 0===s||s.forEach((e=>e({type:"replace"}))):null===(o=t.ctx.changeSubscriptions.get(e.context))||void 0===o||o.forEach((t=>t({type:"create",prop:e.prop})))}const arrayChange=new Set([[].push,[].pop,[].shift,[].unshift,[].splice,[].reverse,[].sort,[].copyWithin]),literalRegex=/(\$\$)*(\$)?\${(\d+)}/g;let ops2={prop:(e,t,n,i,r,s,o,a)=>{if(null===i)throw new TypeError(`Cannot get property ${r} of null`);const c=typeof i;if("undefined"===c&&void 0===s){let e=a.get(r);if(void 0===e.context)throw new ReferenceError(r+" is not defined");if(e.context===o.ctx.sandboxGlobal){o.ctx.options.audit&&o.ctx.auditReport.globalsAccess.add(r);const e=o.ctx.globalsWhitelist.has(o.ctx.sandboxGlobal[r])?o.ctx.evals.get(o.ctx.sandboxGlobal[r]):void 0;if(e)return void t(void 0,e)}return e.context&&e.context[r]===globalThis?void t(void 0,o.ctx.globalScope.get("this")):(o.ctx.getSubscriptions.forEach((t=>t(e.context,e.prop))),void t(void 0,e))}if(void 0===i)throw new SandboxError("Cannot get property '"+r+"' of undefined");if("object"!==c)"number"===c?i=new Number(i):"string"===c?i=new String(i):"boolean"===c&&(i=new Boolean(i));else if(void 0===i.hasOwnProperty)return void t(void 0,new Prop(void 0,r));const l="function"===c;let p=l||!(i.hasOwnProperty(r)||"number"==typeof r);if(o.ctx.options.audit&&p&&"string"==typeof r){let e=i.constructor.prototype;do{e.hasOwnProperty(r)&&(o.ctx.auditReport.prototypeAccess[e.constructor.name]||(o.ctx.auditReport.prototypeAccess[e.constructor.name]=new Set),o.ctx.auditReport.prototypeAccess[e.constructor.name].add(r))}while(e=Object.getPrototypeOf(e))}if(p)if(l){if(!["name","length","constructor"].includes(r)&&i.hasOwnProperty(r)){const e=o.ctx.options.prototypeWhitelist.get(i),n=o.ctx.options.prototypeReplacements.get(i);if(n)return void t(void 0,new Prop(n(i,!0),r));if(!e||e.size&&!e.has(r))throw new SandboxError(`Static method or property access not permitted: ${i.name}.${r}`)}}else if("constructor"!==r){let e=i.constructor.prototype;do{if(e.hasOwnProperty(r)){const n=o.ctx.options.prototypeWhitelist.get(e.constructor),s=o.ctx.options.prototypeReplacements.get(e.constuctor);if(s)return void t(void 0,new Prop(s(i,!1),r));if(n&&(!n.size||n.has(r)))break;throw new SandboxError(`Method or property access not permitted: ${e.constructor.name}.${r}`)}}while(e=Object.getPrototypeOf(e))}if(o.ctx.evals.has(i[r]))return void t(void 0,o.ctx.evals.get(i[r]));if(i[r]===globalThis)return void t(void 0,o.ctx.globalScope.get("this"));let u=s.isGlobal||l&&!sandboxedFunctions.has(i)||o.ctx.globalsWhitelist.has(i);u||o.ctx.getSubscriptions.forEach((e=>e(i,r))),t(void 0,new Prop(i,r,!1,u))},call:(e,t,n,i,r,s,o,a)=>{if(o.ctx.options.forbidFunctionCalls)throw new SandboxError("Method calls are not allowed");if("function"!=typeof i)throw new TypeError(s.prop+" is not a function");execMany(n,e,toLispArray(r.map((e=>e instanceof SpreadArray?[...e.item]:[e])).flat()),((e,n)=>{var i;if(e)t(e);else if("function"!=typeof s){if(s.context[s.prop]===JSON.stringify&&o.ctx.getSubscriptions.size){const e=new Set,t=n=>{if(n&&"object"==typeof n&&!e.has(n)){e.add(n);for(let e in n)o.ctx.getSubscriptions.forEach((t=>t(n,e))),t(n[e])}};t(n[0])}if(s.context instanceof Array&&arrayChange.has(s.context[s.prop])&&o.ctx.changeSubscriptions.get(s.context)){let e,t=!1;if("push"===s.prop)e={type:"push",added:n},t=!!n.length;else if("pop"===s.prop)e={type:"pop",removed:s.context.slice(-1)},t=!!e.removed.length;else if("shift"===s.prop)e={type:"shift",removed:s.context.slice(0,1)},t=!!e.removed.length;else if("unshift"===s.prop)e={type:"unshift",added:n},t=!!n.length;else if("splice"===s.prop)e={type:"splice",startIndex:n[0],deleteCount:void 0===n[1]?s.context.length:n[1],added:n.slice(2),removed:s.context.slice(n[0],void 0===n[1]?void 0:n[0]+n[1])},t=!!e.added.length||!!e.removed.length;else if("reverse"===s.prop||"sort"===s.prop)e={type:s.prop},t=!!s.context.length;else if("copyWithin"===s.prop){let i=void 0===n[2]?s.context.length-n[1]:Math.min(s.context.length,n[2]-n[1]);e={type:"copyWithin",startIndex:n[0],endIndex:n[0]+i,added:s.context.slice(n[1],n[1]+i),removed:s.context.slice(n[0],n[0]+i)},t=!!e.added.length||!!e.removed.length}t&&(null===(i=o.ctx.changeSubscriptions.get(s.context))||void 0===i||i.forEach((t=>t(e))))}t(void 0,s.context[s.prop](...n))}else t(void 0,s(...n))}),a,o)},createObject:(e,t,n,i,r,s,o,a)=>{let c={};for(let e of r)e instanceof SpreadObject?c={...c,...e.item}:c[e.key]=e.val;t(void 0,c)},keyVal:(e,t,n,i,r)=>t(void 0,new KeyVal(i,r)),createArray:(e,t,n,i,r,s,o,a)=>{execMany(n,e,toLispArray(r.map((e=>e instanceof SpreadArray?[...e.item]:[e])).flat()),t,a,o)},group:(e,t,n,i,r)=>t(void 0,r),string:(e,t,n,i,r,s,o)=>t(void 0,o.constants.strings[r]),regex:(e,t,n,i,r,s,o)=>{const a=o.constants.regexes[r];if(!o.ctx.globalsWhitelist.has(RegExp))throw new SandboxError("Regex not permitted");t(void 0,new RegExp(a.regex,a.flags))},literal:(e,t,n,i,r,s,o,a)=>{let c,l=o.constants.literals[r].a,p=toLispArray([]),u=[];for(;c=literalRegex.exec(l);)c[2]||(p.push(o.constants.literals[r].b[parseInt(c[3],10)]),u.push(c[3]));execMany(n,e,p,((e,n)=>{const i={};if(e)t(e);else{for(let e in u){const t=u[e];i[t]=n[e]}t(void 0,l.replace(/(\\\\)*(\\)?\${(\d+)}/g,((e,t,n,r)=>{if(n)return e;let s=i[r];return s=s instanceof Prop?s.context[s.prop]:s,(t||"")+""+s})))}}),a,o)},spreadArray:(e,t,n,i,r,s,o,a)=>{e(n,r,a,o,((e,n)=>{e?t(e):t(void 0,new SpreadArray(n))}))},spreadObject:(e,t,n,i,r,s,o,a)=>{e(n,r,a,o,((e,n)=>{e?t(e):t(void 0,new SpreadObject(n))}))},"!":(e,t,n,i,r)=>t(void 0,!r),"~":(e,t,n,i,r)=>t(void 0,~r),"++$":(e,t,n,i,r,s,o)=>{assignCheck(s,o),t(void 0,++s.context[s.prop])},"$++":(e,t,n,i,r,s,o)=>{assignCheck(s,o),t(void 0,s.context[s.prop]++)},"--$":(e,t,n,i,r,s,o)=>{assignCheck(s,o),t(void 0,--s.context[s.prop])},"$--":(e,t,n,i,r,s,o)=>{assignCheck(s,o),t(void 0,s.context[s.prop]--)},"=":(e,t,n,i,r,s,o)=>{assignCheck(s,o),s.context[s.prop]=r,t(void 0,new Prop(s.context,s.prop,!1,s.isGlobal))},"+=":(e,t,n,i,r,s,o)=>{assignCheck(s,o),t(void 0,s.context[s.prop]+=r)},"-=":(e,t,n,i,r,s,o)=>{assignCheck(s,o),t(void 0,s.context[s.prop]-=r)},"/=":(e,t,n,i,r,s,o)=>{assignCheck(s,o),t(void 0,s.context[s.prop]/=r)},"*=":(e,t,n,i,r,s,o)=>{assignCheck(s,o),t(void 0,s.context[s.prop]*=r)},"**=":(e,t,n,i,r,s,o)=>{assignCheck(s,o),t(void 0,s.context[s.prop]**=r)},"%=":(e,t,n,i,r,s,o)=>{assignCheck(s,o),t(void 0,s.context[s.prop]%=r)},"^=":(e,t,n,i,r,s,o)=>{assignCheck(s,o),t(void 0,s.context[s.prop]^=r)},"&=":(e,t,n,i,r,s,o)=>{assignCheck(s,o),t(void 0,s.context[s.prop]&=r)},"|=":(e,t,n,i,r,s,o)=>{assignCheck(s,o),t(void 0,s.context[s.prop]|=r)},"<<=":(e,t,n,i,r,s,o)=>{assignCheck(s,o),t(void 0,s.context[s.prop]<<=r)},">>=":(e,t,n,i,r,s,o)=>{assignCheck(s,o),t(void 0,s.context[s.prop]>>=r)},">>>=":(e,t,n,i,r,s,o)=>{assignCheck(s,o),t(void 0,s.context[s.prop]>>=r)},"?":(e,t,n,i,r)=>{if(!(r instanceof If))throw new SyntaxError("Invalid inline if");t(void 0,i?r.t:r.f)},">":(e,t,n,i,r)=>t(void 0,i>r),"<":(e,t,n,i,r)=>t(void 0,i<r),">=":(e,t,n,i,r)=>t(void 0,i>=r),"<=":(e,t,n,i,r)=>t(void 0,i<=r),"==":(e,t,n,i,r)=>t(void 0,i==r),"===":(e,t,n,i,r)=>t(void 0,i===r),"!=":(e,t,n,i,r)=>t(void 0,i!=r),"!==":(e,t,n,i,r)=>t(void 0,i!==r),"&&":(e,t,n,i,r)=>t(void 0,i&&r),"||":(e,t,n,i,r)=>t(void 0,i||r),"&":(e,t,n,i,r)=>t(void 0,i&r),"|":(e,t,n,i,r)=>t(void 0,i|r),":":(e,t,n,i,r)=>t(void 0,new If(i,r)),"+":(e,t,n,i,r)=>t(void 0,i+r),"-":(e,t,n,i,r)=>t(void 0,i-r),"$+":(e,t,n,i,r)=>t(void 0,+r),"$-":(e,t,n,i,r)=>t(void 0,-r),"/":(e,t,n,i,r)=>t(void 0,i/r),"^":(e,t,n,i,r)=>t(void 0,i^r),"*":(e,t,n,i,r)=>t(void 0,i*r),"%":(e,t,n,i,r)=>t(void 0,i%r),"<<":(e,t,n,i,r)=>t(void 0,i<<r),">>":(e,t,n,i,r)=>t(void 0,i>>r),">>>":(e,t,n,i,r)=>t(void 0,i>>>r),typeof:(e,t,n,i,r)=>t(void 0,typeof r),instanceof:(e,t,n,i,r)=>t(void 0,i instanceof r),in:(e,t,n,i,r)=>t(void 0,i in r),delete:(e,t,n,i,r,s,o,a,c)=>{void 0!==c.context?(assignCheck(c,o,"delete"),c.isVariable?t(void 0,!1):t(void 0,delete c.context[c.prop])):t(void 0,!0)},return:(e,t,n,i,r,s,o)=>t(void 0,r),var:(e,t,n,i,r,s,o,a,c)=>{e(n,r,a,o,((e,n)=>{e?t(e):t(void 0,a.declare(i,VarType.var,n))}))},let:(e,t,n,i,r,s,o,a,c)=>{e(n,r,a,o,((e,n)=>{e?t(e):t(void 0,a.declare(i,VarType.let,n,c&&c.isGlobal))}))},const:(e,t,n,i,r,s,o,a,c)=>{e(n,r,a,o,((e,n)=>{e?t(e):t(void 0,a.declare(i,VarType.const,n))}))},arrowFunc:(e,t,n,i,r,s,o,a)=>{i=[...i],"string"==typeof s.b&&(s.b=r=lispifyFunction(s.b,o.constants)),i.shift()?t(void 0,createFunctionAsync(i,r,n,o,a)):t(void 0,createFunction(i,r,n,o,a))},function:(e,t,n,i,r,s,o,a)=>{"string"==typeof s.b&&(s.b=r=lispifyFunction(s.b,o.constants));let c,l=i.shift(),p=i.shift();c=l?createFunctionAsync(i,r,n,o,a,p):createFunction(i,r,n,o,a,p),p&&a.declare(p,VarType.var,c),t(void 0,c)},inlineFunction:(e,t,n,i,r,s,o,a)=>{"string"==typeof s.b&&(s.b=r=lispifyFunction(s.b,o.constants));let c,l=i.shift(),p=i.shift();p&&(a=new Scope(a,{})),c=l?createFunctionAsync(i,r,n,o,a,p):createFunction(i,r,n,o,a,p),p&&a.declare(p,VarType.let,c),t(void 0,c)},loop:(e,t,n,i,r,s,o,a)=>{const[c,l,p,u,f,d,h]=i;let x=!0;const y=new Scope(a,{});let g={$$obj:void 0};const b=new Scope(y,g);if(e===execAsync)(async()=>{for(await asyncDone((t=>e(n,u,y,o,t))),g.$$obj=(await asyncDone((t=>e(n,p,y,o,t)))).result,await asyncDone((t=>e(n,l,b,o,t))),c&&(x=(await asyncDone((t=>e(n,d,b,o,t)))).result);x;){let i={};await asyncDone((t=>e(n,h,new Scope(b,i),o,t)));let s=await executeTreeAsync(n,o,r,[new Scope(y,i)],"loop");if(s instanceof ExecReturn&&s.returned)return void t(void 0,s);if(s instanceof ExecReturn&&s.breakLoop)break;await asyncDone((t=>e(n,f,b,o,t))),x=(await asyncDone((t=>e(n,d,b,o,t)))).result}t()})().catch(t);else{for(syncDone((t=>e(n,u,y,o,t))),g.$$obj=syncDone((t=>e(n,p,y,o,t))).result,syncDone((t=>e(n,l,b,o,t))),c&&(x=syncDone((t=>e(n,d,b,o,t))).result);x;){let i={};syncDone((t=>e(n,h,new Scope(b,i),o,t)));let s=executeTree(n,o,r,[new Scope(y,i)],"loop");if(s instanceof ExecReturn&&s.returned)return void t(void 0,s);if(s instanceof ExecReturn&&s.breakLoop)break;syncDone((t=>e(n,f,b,o,t))),x=syncDone((t=>e(n,d,b,o,t))).result}t()}},loopAction:(e,t,n,i,r,s,o,a,c,l)=>{if("switch"===l&&"continue"===i||!l)throw new SandboxError("Illegal "+i+" statement");t(void 0,new ExecReturn(o.ctx.auditReport,void 0,!1,"break"===i,"continue"===i))},if:(e,t,n,i,r,s,o,a,c,l)=>{if(!(r instanceof If))throw new SyntaxError("Invalid if");e(n,i,a,o,((i,s)=>{i?t(i):executeTreeWithDone(e,t,n,o,s?r.t:r.f,[new Scope(a)],l)}))},switch:(e,t,n,i,r,s,o,a)=>{e(n,i,a,o,((i,s)=>{if(i)t(i);else if(e===execSync){let i,c=!1;for(let l of r)if(c||(c=!l.a||s===valueOrProp(syncDone((t=>e(n,l.a,a,o,t))).result))){if(!l.b)continue;if(i=executeTree(n,o,l.b,[a],"switch"),i.breakLoop)break;if(i.returned)return void t(void 0,i);if(!l.a)break}t()}else(async()=>{let i,c=!1;for(let l of r)if(c||(c=!l.a||s===valueOrProp((await asyncDone((t=>e(n,l.a,a,o,t)))).result))){if(!l.b)continue;if(i=await executeTreeAsync(n,o,l.b,[a],"switch"),i.breakLoop)break;if(i.returned)return void t(void 0,i);if(!l.a)break}t()})().catch(t)}))},try:(e,t,n,i,r,s,o,a,c,l)=>{const[p,u,f]=r;executeTreeWithDone(e,((i,r)=>{executeTreeWithDone(e,(s=>{s?t(s):i?executeTreeWithDone(e,t,n,o,u,[new Scope(a)],l):t(void 0,r)}),n,o,f,[new Scope(a,{})])}),n,o,i,[new Scope(a)],l)},void:(e,t,n,i)=>{t()},new:(e,t,n,i,r,s,o)=>{if(!o.ctx.globalsWhitelist.has(i)&&!sandboxedFunctions.has(i))throw new SandboxError("Object construction not allowed: "+i.constructor.name);t(void 0,new i(...r))},throw:(e,t,n,i)=>{t(i)},multi:(e,t,n,i)=>t(void 0,i.pop())},ops=new Map;for(let e in ops2)ops.set(e,ops2[e]);function valueOrProp(e){return e instanceof Prop?e.context[e.prop]:e}function execMany(e,t,n,i,r,s,o){t===execSync?_execManySync(e,n,i,r,s,o):_execManyAsync(e,n,i,r,s,o).catch(i)}function _execManySync(e,t,n,i,r,s){let o=[];for(let a=0;a<t.length;a++){let c;try{c=syncDone((n=>execSync(e,t[a],i,r,n,s))).result}catch(e){return void n(e)}if(c instanceof ExecReturn&&(c.returned||c.breakLoop||c.continueLoop))return void n(void 0,c);o.push(c)}n(void 0,o)}async function _execManyAsync(e,t,n,i,r,s){let o=[];for(let a=0;a<t.length;a++){let c;try{c=(await asyncDone((n=>execAsync(e,t[a],i,r,n,s)))).result}catch(e){return void n(e)}if(c instanceof ExecReturn&&(c.returned||c.breakLoop||c.continueLoop))return void n(void 0,c);o.push(c)}n(void 0,o)}function asyncDone(e){return new Promise(((t,n)=>{e(((e,i)=>{e?n(e):t({result:i})}))}))}function syncDone(e){let t,n;if(e(((e,i)=>{n=e,t=i})),n)throw n;return{result:t}}function execAsync(e,t,n,i,r,s){return new Promise(((o,a)=>{execWithDone(e,t,n,i,((e,t)=>{r(e,t),o()}),!0,s)}))}function execSync(e,t,n,i,r,s){execWithDone(e,t,n,i,r,!1,s)}function execWithDone(e,t,n,i,r,s,o){var a;const c=s?execAsync:execSync;if(i.ctx.options.executionQuota<=e.ticks&&("function"!=typeof i.ctx.options.onExecutionQuotaReached||!i.ctx.options.onExecutionQuotaReached(e,n,i,t)))throw new SandboxError("Execution quota exceeded");if(e.ticks++,currentTicks=e,t instanceof Prop)r(void 0,t.context[t.prop]);else if(Array.isArray(t)&&t.lisp)execMany(e,c,t,r,n,i,o);else if(t instanceof Lisp)if(["arrowFunc","function","inlineFunction","loop","try","switch","if"].includes(t.op))try{ops.get(t.op)(c,r,e,t.a,t.b,t,i,n,void 0,o)}catch(e){r(e)}else"await"===t.op?s?(null===(a=i.ctx.options.prototypeWhitelist)||void 0===a?void 0:a.has(Promise))?execAsync(e,t.a,n,i,(async(e,t)=>{e?r(e):r(void 0,await t)}),o).catch(r):r(new SandboxError("Async/await is not permitted")):r(new SandboxError("Illegal use of 'await', must be inside async function")):execWithDone(e,t.a,n,i,((a,l)=>{if(a)return void r(a);let p=l instanceof Prop?l.context?l.context[l.prop]:void 0:l,u=t.op;if("?prop"===u||"?call"===u){if(null==p)return void r(void 0,optional);u=u.slice(1)}if(p===optional){if("prop"===u||"call"===u)return void r(void 0,p);p=void 0}execWithDone(e,t.b,n,i,((t,s)=>{if(t)return void r(t);let a=s instanceof Prop?s.context?s.context[s.prop]:void 0:s;if(a===optional&&(a=void 0),ops.has(u))try{ops.get(u)(c,r,e,p,a,l,i,n,s,o)}catch(e){r(e)}else r(new SyntaxError("Unknown operator: "+u))}),s,o)}),s,o);else r(void 0,t)}function executeTree(e,t,n,i=[],r){return syncDone((s=>executeTreeWithDone(execSync,s,e,t,n,i,r))).result}async function executeTreeAsync(e,t,n,i=[],r){return(await asyncDone((s=>executeTreeWithDone(execAsync,s,e,t,n,i,r)))).result}function executeTreeWithDone(e,t,n,i,r,s=[],o){if(!r)return void t();if(!(r instanceof Array))throw new SyntaxError("Bad execution tree");let a,c=i.ctx.globalScope;for(;a=s.shift();)"object"==typeof a&&(c=a instanceof Scope?a:new Scope(c,a,null));i.ctx.options.audit&&!i.ctx.auditReport&&(i.ctx.auditReport={globalsAccess:new Set,prototypeAccess:{}}),e===execSync?_executeWithDoneSync(t,n,i,r,c,o):_executeWithDoneAsync(t,n,i,r,c,o).catch(t)}function _executeWithDoneSync(e,t,n,i,r,s){if(!(i instanceof Array))throw new SyntaxError("Bad execution tree");let o=0;for(o=0;o<i.length;o++){let a,c;const l=i[o];try{execSync(t,l,r,n,((e,t)=>{c=e,a=t}),s)}catch(e){c=e}if(c)return void e(c);if(a instanceof ExecReturn)return void e(void 0,a);if(l instanceof Lisp&&"return"===l.op)return void e(void 0,new ExecReturn(n.ctx.auditReport,a,!0))}e(void 0,new ExecReturn(n.ctx.auditReport,void 0,!1))}async function _executeWithDoneAsync(e,t,n,i,r,s){if(!(i instanceof Array))throw new SyntaxError("Bad execution tree");let o=0;for(o=0;o<i.length;o++){let a,c;const l=i[o];try{await execAsync(t,l,r,n,((e,t)=>{c=e,a=t}),s)}catch(e){c=e}if(c)return void e(c);if(a instanceof ExecReturn)return void e(void 0,a);if(l instanceof Lisp&&"return"===l.op)return void e(void 0,new ExecReturn(n.ctx.auditReport,a,!0))}e(void 0,new ExecReturn(n.ctx.auditReport,void 0,!1))}const extend=()=>({expectTypes:expectTypes,setLispType:setLispType,executionOps:ops,assignCheck:assignCheck,execMany:execMany,execAsync:execAsync,execSync:execSync,asyncDone:asyncDone,syncDone:syncDone,executeTree:executeTree,executeTreeAsync:executeTreeAsync});class SandboxGlobal{constructor(e){if(e===globalThis)return globalThis;for(let t in e)this[t]=e[t]}}class Sandbox{constructor(options){options=Object.assign({audit:!1,forbidFunctionCalls:!1,forbidFunctionCreation:!1,globals:Sandbox.SAFE_GLOBALS,prototypeWhitelist:Sandbox.SAFE_PROTOTYPES,prototypeReplacements:new Map},options||{});const sandboxGlobal=new SandboxGlobal(options.globals);this.context={sandbox:this,globalsWhitelist:new Set(Object.values(options.globals)),options:options,globalScope:new Scope(null,options.globals,sandboxGlobal),sandboxGlobal:sandboxGlobal,evals:new Map,getSubscriptions:new Set,setSubscriptions:new WeakMap,changeSubscriptions:new WeakMap};const func=sandboxFunction(this.context);this.context.evals.set(Function,func),this.context.evals.set(eval,sandboxedEval(func)),this.context.evals.set(setTimeout,sandboxedSetTimeout(func)),this.context.evals.set(setInterval,sandboxedSetInterval(func))}static get SAFE_GLOBALS(){return{Function:Function,console:{debug:console.debug,error:console.error,info:console.info,log:console.log,table:console.table,warn:console.warn},isFinite:isFinite,isNaN:isNaN,parseFloat:parseFloat,parseInt:parseInt,decodeURI:decodeURI,decodeURIComponent:decodeURIComponent,encodeURI:encodeURI,encodeURIComponent:encodeURIComponent,escape:escape,unescape:unescape,Boolean:Boolean,Number:Number,BigInt:BigInt,String:String,Object:Object,Array:Array,Symbol:Symbol,Error:Error,EvalError:EvalError,RangeError:RangeError,ReferenceError:ReferenceError,SyntaxError:SyntaxError,TypeError:TypeError,URIError:URIError,Int8Array:Int8Array,Uint8Array:Uint8Array,Uint8ClampedArray:Uint8ClampedArray,Int16Array:Int16Array,Uint16Array:Uint16Array,Int32Array:Int32Array,Uint32Array:Uint32Array,Float32Array:Float32Array,Float64Array:Float64Array,Map:Map,Set:Set,WeakMap:WeakMap,WeakSet:WeakSet,Promise:Promise,Intl:Intl,JSON:JSON,Math:Math,Date:Date,RegExp:RegExp}}static get SAFE_PROTOTYPES(){let e=[SandboxGlobal,Function,Boolean,Number,BigInt,String,Date,Error,Array,Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array,Map,Set,WeakMap,WeakSet,Promise,Symbol,Date,RegExp],t=new Map;return e.forEach((e=>{t.set(e,new Set)})),t.set(Object,new Set(["entries","fromEntries","getOwnPropertyNames","is","keys","hasOwnProperty","isPrototypeOf","propertyIsEnumerable","toLocaleString","toString","valueOf","values"])),t}subscribeGet(e){return this.context.getSubscriptions.add(e),{unsubscribe:()=>this.context.getSubscriptions.delete(e)}}subscribeSet(e,t,n){const i=this.context.setSubscriptions.get(e)||new Map;this.context.setSubscriptions.set(e,i);const r=i.get(t)||new Set;let s;return i.set(t,r),r.add(n),e&&e[t]&&"object"==typeof e[t]&&(s=this.context.changeSubscriptions.get(e[t])||new Set,s.add(n),this.context.changeSubscriptions.set(e[t],s)),{unsubscribe:()=>{r.delete(n),s&&s.delete(n)}}}static audit(e,t=[]){const n={};for(let e of Object.getOwnPropertyNames(globalThis))n[e]=globalThis[e];return new Sandbox({globals:n,audit:!0}).executeTree(parse(e),t)}static parse(e){return parse(e)}executeTree(e,t=[]){return executeTree({ticks:BigInt(0)},{ctx:this.context,constants:e.constants,tree:e.tree},e.tree,t)}executeTreeAsync(e,t=[]){return executeTreeAsync({ticks:BigInt(0)},{ctx:this.context,constants:e.constants,tree:e.tree},e.tree,t)}compile(e,t=!1){const n=parse(e,t);return(...e)=>this.executeTree(n,e).result}compileAsync(e,t=!1){const n=parse(e,t);return async(...e)=>(await this.executeTreeAsync(n,e)).result}compileExpression(e,t=!1){const n=parse(e,t);return n.tree.length=1,(...e)=>this.executeTree(n,e).result}compileExpressionAsync(e,t=!1){const n=parse(e,t);return n.tree.length=1,async(...e)=>(await this.executeTreeAsync(n,e)).result}}export default Sandbox;export{SandboxGlobal,extend};
//# sourceMappingURL=Sandbox.min.js.map
