function parseHexToInt(e){return!e.match(/[^a-f0-9]/i)?parseInt(e,16):NaN}function validateAndParseHex(e,t,n){const r=parseHexToInt(e);if(Number.isNaN(r)||void 0!==n&&n!==e.length)throw new SyntaxError(t+": "+e);return r}function parseHexadecimalCode(e){const t=validateAndParseHex(e,"Malformed Hexadecimal",2);return String.fromCharCode(t)}function parseUnicodeCode(e,t){const n=validateAndParseHex(e,"Malformed Unicode",4);if(void 0!==t){const e=validateAndParseHex(t,"Malformed Unicode",4);return String.fromCharCode(n,e)}return String.fromCharCode(n)}function isCurlyBraced(e){return"{"===e.charAt(0)&&"}"===e.charAt(e.length-1)}function parseUnicodeCodePointCode(e){if(!isCurlyBraced(e))throw new SyntaxError("Malformed Unicode: +"+e);const t=validateAndParseHex(e.slice(1,-1),"Malformed Unicode");try{return String.fromCodePoint(t)}catch(e){throw e instanceof RangeError?new SyntaxError("Code Point Limit:"+t):e}}const singleCharacterEscapes=new Map([["b","\b"],["f","\f"],["n","\n"],["r","\r"],["t","\t"],["v","\v"],["0","\0"]]);function parseSingleCharacterCode(e){return singleCharacterEscapes.get(e)||e}const escapeMatch=/\\(?:(\\)|x([\s\S]{0,2})|u(\{[^}]*\}?)|u([\s\S]{4})\\u([^{][\s\S]{0,3})|u([\s\S]{0,4})|([0-3]?[0-7]{1,2})|([\s\S])|$)/g;function unraw(e){return e.replace(escapeMatch,(function(e,t,n,r,i,s,o,a,c){if(void 0!==t)return"\\";if(void 0!==n)return parseHexadecimalCode(n);if(void 0!==r)return parseUnicodeCodePointCode(r);if(void 0!==i)return parseUnicodeCode(i,s);if(void 0!==o)return parseUnicodeCode(o);if("0"===a)return"\0";if(void 0!==a)throw new SyntaxError("Octal Deprecation: "+a);if(void 0!==c)return parseSingleCharacterCode(c);throw new SyntaxError("End of string")}))}let lispTypes=new Map;class ParseError extends Error{constructor(e,t){super(e+": "+t.substring(0,40)),this.code=t}}class Lisp{constructor(e){this.op=e.op,this.a=e.a,this.b=e.b}}class If{constructor(e,t){this.t=e,this.f=t}}class KeyVal{constructor(e,t){this.key=e,this.val=t}}class SpreadObject{constructor(e){this.item=e}}class SpreadArray{constructor(e){this.item=e}}const lispArrayKey={};function toLispArray(e){return e.lisp=lispArrayKey,e}const inlineIfElse=/^:/,elseIf=/^else(?![\w\$])/,ifElse=/^if(?![\w\$])/,space=/^\s/;let expectTypes={splitter:{types:{opHigh:/^(\/|\*\*|\*(?!\*)|\%)(?!\=)/,op:/^(\+(?!(\+))|\-(?!(\-)))(?!\=)/,comparitor:/^(<=|>=|<(?!<)|>(?!>)|!==|!=(?!\=)|===|==)/,boolOp:/^(&&|\|\||instanceof(?![\w\$])|in(?![\w\$]))/,bitwise:/^(&(?!&)|\|(?!\|)|\^|<<|>>(?!>)|>>>)(?!\=)/},next:["modifier","value","prop","incrementerBefore"]},inlineIf:{types:{inlineIf:/^\?(?!\.(?!\d))/},next:["expEnd"]},assignment:{types:{assignModify:/^(\-=|\+=|\/=|\*\*=|\*=|%=|\^=|\&=|\|=|>>>=|>>=|<<=)/,assign:/^(=)(?!=)/},next:["modifier","value","prop","incrementerBefore"]},incrementerBefore:{types:{incrementerBefore:/^(\+\+|\-\-)/},next:["prop"]},expEdge:{types:{call:/^(\?\.)?[\(]/,incrementerAfter:/^(\+\+|\-\-)/},next:["splitter","expEdge","dot","inlineIf","expEnd"]},modifier:{types:{not:/^!/,inverse:/^~/,negative:/^\-(?!\-)/,positive:/^\+(?!\+)/,typeof:/^typeof(?![\w\$])/,delete:/^delete(?![\w\$])/},next:["modifier","value","prop","incrementerBefore"]},dot:{types:{arrayProp:/^(\?\.)?\[/,dot:/^(\?)?\.(?=\s*[a-zA-Z\$\_])/},next:["splitter","assignment","expEdge","dot","inlineIf","expEnd"]},prop:{types:{prop:/^[a-zA-Z\$\_][a-zA-Z\d\$\_]*/},next:["splitter","assignment","expEdge","dot","inlineIf","expEnd"]},value:{types:{createObject:/^\{/,createArray:/^\[/,number:/^(0x[\da-f]+(_[\da-f]+)*|(\d+(_\d+)*(\.\d+(_\d+)*)?|\.\d+(_\d+)*))(e[\+\-]?\d+(_\d+)*)?(n)?(?!\d)/i,string:/^"(\d+)"/,literal:/^`(\d+)`/,regex:/^\/(\d+)\/r(?![\w\$])/,boolean:/^(true|false)(?![\w\$])/,null:/^null(?![\w\$])/,und:/^undefined(?![\w\$])/,arrowFunctionSingle:/^(async\s+)?([a-zA-Z\$_][a-zA-Z\d\$_]*)\s*=>\s*({)?/,arrowFunction:/^(async\s*)?\(\s*((\.\.\.)?\s*[a-zA-Z\$_][a-zA-Z\d\$_]*(\s*,\s*(\.\.\.)?\s*[a-zA-Z\$_][a-zA-Z\d\$_]*)*)?\s*\)\s*=>\s*({)?/,inlineFunction:/^(async\s+)?function(\s*[a-zA-Z\$_][a-zA-Z\d\$_]*)?\s*\(\s*((\.\.\.)?\s*[a-zA-Z\$_][a-zA-Z\d\$_]*(\s*,\s*(\.\.\.)?\s*[a-zA-Z\$_][a-zA-Z\d\$_]*)*)?\s*\)\s*{/,group:/^\(/,NaN:/^NaN(?![\w\$])/,Infinity:/^Infinity(?![\w\$])/,void:/^void(?![\w\$])\s*/,await:/^await(?![\w\$])\s*/,new:/^new(?![\w\$])\s*/,throw:/^throw(?![\w\$])\s*/},next:["splitter","expEdge","dot","inlineIf","expEnd"]},initialize:{types:{initialize:/^(var|let|const)\s+([a-zA-Z\$_][a-zA-Z\d\$_]*)\s*(=)?/,return:/^return(?![\w\$])/},next:["modifier","value","prop","incrementerBefore","expEnd"]},spreadObject:{types:{spreadObject:/^\.\.\./},next:["value","prop"]},spreadArray:{types:{spreadArray:/^\.\.\./},next:["value","prop"]},expEnd:{types:{},next:[]},expFunction:{types:{function:/^(async\s+)?function(\s*[a-zA-Z\$_][a-zA-Z\d\$_]*)\s*\(\s*((\.\.\.)?\s*[a-zA-Z\$_][a-zA-Z\d\$_]*(\s*,\s*(\.\.\.)?\s*[a-zA-Z\$_][a-zA-Z\d\$_]*)*)?\s*\)\s*{/},next:["expEdge","expEnd"]},expSingle:{types:{for:/^(([a-zA-Z\$\_][\w\$]*)\s*:)?\s*for\s*\(/,do:/^(([a-zA-Z\$\_][\w\$]*)\s*:)?\s*do(?![\w\$])\s*(\{)?/,while:/^(([a-zA-Z\$\_][\w\$]*)\s*:)?\s*while\s*\(/,loopAction:/^(break|continue)(?![\w\$])\s*([a-zA-Z\$\_][\w\$]*)?/,if:/^((([a-zA-Z\$\_][\w\$]*)\s*:)?\s*)if\s*\(/,try:/^try\s*{/,block:/^{/,switch:/^(([a-zA-Z\$\_][\w\$]*)\s*:)?\s*switch\s*\(/},next:["expEnd"]}},closings={"(":")","[":"]","{":"}","'":"'",'"':'"',"`":"`"};function testMultiple(e,t){let n;for(let r=0;r<t.length;r++){if(n=t[r].exec(e),n)break}return n}class CodeString{constructor(e){this.ref={str:""},e instanceof CodeString?(this.ref=e.ref,this.start=e.start,this.end=e.end):(this.ref.str=e,this.start=0,this.end=e.length)}substring(e,t){if(!this.length)return this;(e=this.start+e)<0&&(e=0),e>this.end&&(e=this.end),(t=void 0===t?this.end:this.start+t)<0&&(t=0),t>this.end&&(t=this.end);const n=new CodeString(this);return n.start=e,n.end=t,n}get length(){const e=this.end-this.start;return e<0?0:e}char(e){if(this.start!==this.end)return this.ref.str[this.start+e]}toString(){return this.ref.str.substring(this.start,this.end)}trimStart(){const e=/^\s+/.exec(this.toString()),t=new CodeString(this);return e&&(t.start+=e[0].length),t}slice(e,t){return e<0&&(e=this.end-this.start+e),e<0&&(e=0),void 0===t&&(t=this.end-this.start),t<0&&(t=this.end-this.start+t),t<0&&(t=0),this.substring(e,t)}trim(){const e=this.trimStart(),t=/\s+$/.exec(e.toString());return t&&(e.end-=t[0].length),e}valueOf(){return this.toString()}}const emptyString=new CodeString(""),okFirstChars=/^[\+\-~ !]/,aNumber=expectTypes.value.types.number,wordReg=/^((if|for|else|while|do|function)(?![\w\$])|[\w\$]+)/,semiColon=/^;/,insertedSemicolons=new WeakMap,quoteCache=new WeakMap;function restOfExp(e,t,n,r,i,s,o={}){if(!t.length)return t;o.words=o.words||[];let a=!0;const c=(n=n||[]).includes(semiColon);c&&(n=n.filter((e=>e!==semiColon)));const l=insertedSemicolons.get(t.ref)||[],p=quoteCache.get(t.ref)||new Map;if(quoteCache.set(t.ref,p),r&&p.has(t.start-1))return t.substring(0,p.get(t.start-1)-t.start);let u,d=!1,f=!1,h="",g=!1,y=!1;for(u=0;u<t.length&&!f;u++){let x=t.char(u);if('"'===r||"'"===r||"`"===r){if("`"!==r||"$"!==x||"{"!==t.char(u+1)||d){if(x===r&&!d)return t.substring(0,u)}else{u+=restOfExp(e,t.substring(u+2),[],"{").length+2}d=!d&&"\\"===x}else if(closings[x]){if(!y&&l[u+t.start]){if(y=!0,c)break;u--,h=";";continue}if(g&&"{"===x&&(g=!1),x===i){f=!0;break}{let n=restOfExp(e,t.substring(u+1),[],x);if(p.set(n.start-1,n.end),u+=n.length+1,a=!1,s){let e;(e=testMultiple(t.substring(u).toString(),s))&&(o.regRes=e,f=!0)}}}else if(r){if(x===closings[r])return t.substring(0,u)}else{let e,r,i=t.substring(u).toString();if(s){let e;if(e=testMultiple(i,s)){o.regRes=e,u++,f=!0;break}}if(r=aNumber.exec(i))u+=r[0].length-1,i=t.substring(u).toString();else if(h!=x){let r;if(";"===x||l[u+t.start]&&!a&&!y){if(c)r=[";"];else if(l[u+t.start]){y=!0,u--,h=";";continue}x=i=";"}else y=!1;r||(r=testMultiple(i,n)),r&&(f=!0),!f&&(e=wordReg.exec(i))&&(g=!0,e[0].length>1&&(o.words.push(e[1]),o.lastAnyWord=e[1],e[2]&&(o.lastWord=e[2])),e[0].length>2&&(u+=e[0].length-2))}if(a&&(okFirstChars.test(i)?f=!1:a=!1),f)break}h=x}if(r)throw new SyntaxError("Unclosed '"+r+"'");return o&&(o.oneliner=g),t.substring(0,u)}restOfExp.next=["splitter","expEnd","inlineIf"];const startingExecpted=["initialize","expSingle","expFunction","value","modifier","prop","incrementerBefore","expEnd"],setLispType=(e,t)=>{e.forEach((e=>{lispTypes.set(e,t)}))},closingsCreate={createArray:/^\]/,createObject:/^\}/,group:/^\)/,arrayProp:/^\]/,call:/^\)/};function extractIfElse(e,t){var n;let r,i,s=0,o=t.substring(0,0),a=emptyString,c=!0,l={};for(;(o=restOfExp(e,t.substring(o.end-t.start),[elseIf,ifElse,semiColon],void 0,void 0,void 0,l)).length||c;){c=!1;const p=t.substring(o.end-t.start).toString();if(p.startsWith("if"))o.end++,s++;else if(p.startsWith("else"))r=t.substring(0,o.end-t.start),o.end++,s--,s||o.end--;else{if(!(i=/^;?\s*else(?![\w\$])/.exec(p))){r=a.length?r:t.substring(0,o.end-t.start);break}r=t.substring(0,o.end-t.start),o.end+=i[0].length-1,s--,s||(o.end-=i[0].length-1)}if(!s){a=extractIfElse(e,t.substring(o.end-t.start+(null===(n=/^;?\s*else(?![\w\$])/.exec(p))||void 0===n?void 0:n[0].length))).all;break}l={}}return r=r||t.substring(0,o.end-t.start),{all:t.substring(0,Math.max(r.end,a.end)-t.start),true:r,false:a}}setLispType(["createArray","createObject","group","arrayProp","call"],((e,t,n,r,i,s)=>{let o=emptyString,a=[],c=!1,l=r[0].length;const p=l;for(;l<n.length&&!c;)o=restOfExp(e,n.substring(l),[closingsCreate[t],/^,/]),l+=o.length,o.length&&a.push(o),","!==n.char(l)?c=!0:l++;const u=["value","modifier","prop","incrementerBefore","expEnd"];let d,f;switch(t){case"group":case"arrayProp":d=lispifyExpr(e,n.substring(p,l));break;case"call":case"createArray":d=toLispArray(a.map((t=>lispify(e,t,[...u,"spreadArray"]))));break;case"createObject":d=toLispArray(a.map((t=>{let n,r;if(t=t.trimStart(),f=expectTypes.expFunction.types.function.exec("function "+t),f)r=f[2].trimStart(),n=lispify(e,new CodeString("function "+t.toString().replace(r,"")));else{let i=restOfExp(e,t,[/^:/]);if(r=lispify(e,i,[...u,"spreadObject"]),r instanceof Lisp&&"prop"===r.op&&(r=r.b),i.length===t.length)return r;n=lispify(e,t.substring(i.length+1))}return new Lisp({op:"keyVal",a:r,b:n})})))}t="arrayProp"===t?r[1]?"?prop":"prop":"call"===t?r[1]?"?call":"call":t,s.lispTree=lispify(e,n.substring(l+1),expectTypes[i].next,new Lisp({op:t,a:s.lispTree,b:d}))})),setLispType(["inverse","not","negative","positive","typeof","delete"],((e,t,n,r,i,s)=>{let o=restOfExp(e,n.substring(r[0].length),[/^[^\s\.\w\$]/]);s.lispTree=lispify(e,n.substring(o.length+r[0].length),restOfExp.next,new Lisp({op:["positive","negative"].includes(t)?"$"+r[0]:r[0],a:s.lispTree,b:lispify(e,o,expectTypes[i].next)}))})),setLispType(["incrementerBefore"],((e,t,n,r,i,s)=>{let o=restOfExp(e,n.substring(2),[/^[^\s\.\w\$]/]);s.lispTree=lispify(e,n.substring(o.length+2),restOfExp.next,new Lisp({op:r[0]+"$",a:lispify(e,o,expectTypes[i].next)}))})),setLispType(["incrementerAfter"],((e,t,n,r,i,s)=>{s.lispTree=lispify(e,n.substring(r[0].length),expectTypes[i].next,new Lisp({op:"$"+r[0],a:s.lispTree}))})),setLispType(["assign","assignModify","boolOp"],((e,t,n,r,i,s)=>{s.lispTree=new Lisp({op:r[0],a:s.lispTree,b:lispify(e,n.substring(r[0].length),expectTypes[i].next)})})),setLispType(["opHigh","op","comparitor","bitwise"],((e,t,n,r,i,s)=>{const o=[expectTypes.inlineIf.types.inlineIf,inlineIfElse];switch(t){case"opHigh":o.push(expectTypes.splitter.types.opHigh);case"op":o.push(expectTypes.splitter.types.op);case"comparitor":o.push(expectTypes.splitter.types.comparitor);case"bitwise":o.push(expectTypes.splitter.types.bitwise),o.push(expectTypes.splitter.types.boolOp)}let a=restOfExp(e,n.substring(r[0].length),o);s.lispTree=lispify(e,n.substring(a.length+r[0].length),restOfExp.next,new Lisp({op:r[0],a:s.lispTree,b:lispify(e,a,expectTypes[i].next)}))})),setLispType(["inlineIf"],((e,t,n,r,i,s)=>{let o=!1,a=n.substring(0,0),c=1;for(;!o&&a.length<n.length;)a.end=restOfExp(e,n.substring(a.length+1),[expectTypes.inlineIf.types.inlineIf,inlineIfElse]).end,"?"===n.char(a.length)?c++:c--,c||(o=!0);a.start=n.start+1,s.lispTree=new Lisp({op:"?",a:s.lispTree,b:new Lisp({op:":",a:lispifyExpr(e,a),b:lispifyExpr(e,n.substring(r[0].length+a.length+1))})})})),setLispType(["if"],((e,t,n,r,i,s)=>{let o=restOfExp(e,n.substring(r[0].length),[],"(");const a=extractIfElse(e,n.substring(r[1].length)),c=(/^\s*\{/.exec(n.substring(r[0].length+o.length+1).toString()),r[0].length-r[1].length+o.length+1);let l=a.true.substring(c),p=a.false;o=o.trim(),l=l.trim(),p=p.trim(),"{"===l.char(0)&&(l=l.slice(1,-1)),"{"===p.char(0)&&(p=p.slice(1,-1)),s.lispTree=new Lisp({op:"if",a:lispifyExpr(e,o),b:new If(lispifyBlock(l,e),p.length?lispifyBlock(p,e):void 0)})})),setLispType(["switch"],((e,t,n,r,i,s)=>{const o=restOfExp(e,n.substring(r[0].length),[],"(");let a=n.toString().indexOf("{",r[0].length+o.length+1);if(-1===a)throw new SyntaxError("Invalid switch");let c,l=insertSemicolons(e,restOfExp(e,n.substring(a+1),[],"{"));const p=/^\s*(case\s|default)\s*/;let u=[],d=!1;for(;c=p.exec(l.toString());){if("default"===c[1]){if(d)throw new SyntaxError("Only one default switch case allowed");d=!0}let t=restOfExp(e,l.substring(c[0].length),[/^:/]),n=emptyString,r=a=c[0].length+t.length+1,i=/^\s*\{/.exec(l.substring(r).toString()),s=[];if(i)r+=i[0].length,n=restOfExp(e,l.substring(r),[],"{"),r+=n.length+1,s=lispifyBlock(n,e);else{let t=restOfExp(e,l.substring(r),[p]);if(t.trim().length){for(;(n=restOfExp(e,l.substring(r),[semiColon])).length&&(r+=n.length+(";"===l.char(r+n.length)?1:0),!p.test(l.substring(r).toString())););s=lispifyBlock(l.substring(a,n.end-l.start),e)}else s=[],r+=t.length}l=l.substring(r),u.push(new Lisp({op:"case",a:"default"===c[1]?void 0:lispifyExpr(e,t),b:toLispArray(s)}))}s.lispTree=new Lisp({op:"switch",a:lispifyExpr(e,o),b:toLispArray(u)})})),setLispType(["dot","prop"],((e,t,n,r,i,s)=>{let o=r[0],a=r[0].length,c="prop";if("dot"===t){r[1]&&(c="?prop");let e=n.substring(r[0].length).toString().match(expectTypes.prop.types.prop);if(!e||!e.length)throw new SyntaxError("Hanging  dot");o=e[0],a=o.length+r[0].length}s.lispTree=lispify(e,n.substring(a),expectTypes[i].next,new Lisp({op:c,a:s.lispTree,b:o}))})),setLispType(["spreadArray","spreadObject"],((e,t,n,r,i,s)=>{s.lispTree=new Lisp({op:t,b:lispify(e,n.substring(r[0].length),expectTypes[i].next)})})),setLispType(["return","throw"],((e,t,n,r,i,s)=>{s.lispTree=new Lisp({op:t,b:lispifyExpr(e,n.substring(r[0].length))})}));const primitives={true:!0,false:!1,null:null,Infinity:1/0,NaN:NaN,und:void 0};setLispType(["number","boolean","null","und","NaN","Infinity"],((e,t,n,r,i,s)=>{s.lispTree=lispify(e,n.substring(r[0].length),expectTypes[i].next,"number"===t?r[10]?BigInt(r[1]):Number(r[0]):primitives["boolean"===t?r[0]:t])})),setLispType(["string","literal","regex"],((e,t,n,r,i,s)=>{s.lispTree=lispify(e,n.substring(r[0].length),expectTypes[i].next,new Lisp({op:t,b:parseInt(JSON.parse(r[1]),10)}))})),setLispType(["initialize"],((e,t,n,r,i,s)=>{r[3]?s.lispTree=new Lisp({op:r[1],a:r[2],b:lispify(e,n.substring(r[0].length),expectTypes[i].next)}):s.lispTree=lispify(e,n.substring(r[0].length),expectTypes[i].next,new Lisp({op:r[1],a:r[2]}))})),setLispType(["function","inlineFunction","arrowFunction","arrowFunctionSingle"],((e,t,n,r,i,s)=>{const o="function"!==t&&"inlineFunction"!==t,a=o&&!r[r.length-1],c=o?2:3,l=!!r[1],p=r[c]?r[c].replace(/\s+/g,"").split(/,/g):[];o||p.unshift((r[2]||"").trimStart());let u=!1;p.forEach((e=>{if(u)throw new SyntaxError("Rest parameter must be last formal parameter");e.startsWith("...")&&(u=!0)})),p.unshift(l);const d=restOfExp(e,n.substring(r[0].length),a?[/^[,\)\}\]]/,semiColon]:[/^}/]),f=a?"return "+d:d;s.lispTree=lispify(e,n.substring(r[0].length+f.length+1),expectTypes[i].next,new Lisp({op:o?"arrowFunc":t,a:toLispArray(p),b:e.eager?lispifyFunction(new CodeString(f),e):f}))}));const iteratorRegex=/^((let|var|const)\s+)?\s*([a-zA-Z\$_][a-zA-Z\d\$_]*)\s+(in|of)(?![\w\$])/;setLispType(["for","do","while"],((e,t,n,r,i,s)=>{let o,a,c,l=0,p=!0,u=toLispArray([]),d=!1,f=!0,h=!0;switch(t){case"while":l=n.toString().indexOf("(")+1;let t=restOfExp(e,n.substring(l),[],"(");a=lispifyReturnExpr(e,t),c=restOfExp(e,n.substring(l+t.length+1)).trim(),"{"===c[0]&&(c=c.slice(1,-1));break;case"for":l=n.toString().indexOf("(")+1;let i,s=[],g=emptyString;for(let t=0;t<3&&(g=restOfExp(e,n.substring(l),[/^[;\)]/]),s.push(g.trim()),l+=g.length+1,")"!==n.char(l-1));t++);if(1===s.length&&(i=iteratorRegex.exec(s[0].toString())))"of"===i[4]?(o=lispifyReturnExpr(e,s[0].substring(i[0].length)),u=toLispArray([ofStart2,ofStart3]),a=ofCondition,h=ofStep,d=lispify(e,new CodeString((i[1]||"let ")+i[3]+" = $$next.value"),["initialize"])):(o=lispifyReturnExpr(e,s[0].substring(i[0].length)),u=toLispArray([inStart2,inStart3]),h=inStep,a=inCondition,d=lispify(e,new CodeString((i[1]||"let ")+i[3]+" = $$keys[$$keyIndex]"),["initialize"]));else{if(3!==s.length)throw new SyntaxError("Invalid for loop definition");p=lispifyExpr(e,s.shift(),startingExecpted),a=lispifyReturnExpr(e,s.shift()),h=lispifyExpr(e,s.shift())}c=restOfExp(e,n.substring(l)).trim(),"{"===c[0]&&(c=c.slice(1,-1));break;case"do":f=!1;const y=!!r[3];c=restOfExp(e,n.substring(r[0].length),y?[/^\}/]:[semiColon]),a=lispifyReturnExpr(e,restOfExp(e,n.substring(n.toString().indexOf("(",r[0].length+c.length)+1),[],"("))}const g=toLispArray([f,u,o,p,h,a,d]);s.lispTree=new Lisp({op:"loop",a:g,b:lispifyBlock(c,e)})})),setLispType(["block"],((e,t,n,r,i,s)=>{s.lispTree=lispifyBlock(restOfExp(e,n.substring(1),[],"{"),e)})),setLispType(["loopAction"],((e,t,n,r,i,s)=>{s.lispTree=new Lisp({op:"loopAction",a:r[1]})}));const catchReg=/^\s*(catch\s*(\(\s*([a-zA-Z\$_][a-zA-Z\d\$_]*)\s*\))?|finally)\s*\{/;setLispType(["try"],((e,t,n,r,i,s)=>{const o=restOfExp(e,n.substring(r[0].length),[],"{");let a,c,l,p=catchReg.exec(n.substring(r[0].length+o.length+1).toString()),u=0;p[1].startsWith("catch")?(p=catchReg.exec(n.substring(r[0].length+o.length+1).toString()),c=p[2],l=restOfExp(e,n.substring(r[0].length+o.length+1+p[0].length),[],"{"),u=r[0].length+o.length+1+p[0].length+l.length+1,(p=catchReg.exec(n.substring(u).toString()))&&p[1].startsWith("finally")&&(a=restOfExp(e,n.substring(u+p[0].length),[],"{"))):a=restOfExp(e,n.substring(r[0].length+o.length+1+p[0].length),[],"{");const d=toLispArray([c,lispifyBlock(insertSemicolons(e,l||emptyString),e),lispifyBlock(insertSemicolons(e,a||emptyString),e)]);s.lispTree=new Lisp({op:"try",a:lispifyBlock(insertSemicolons(e,o),e),b:d})})),setLispType(["void","await"],((e,t,n,r,i,s)=>{const o=restOfExp(e,n.substring(r[0].length),[/^[^\s\.\w\$]/]);s.lispTree=lispify(e,n.substring(r[0].length+o.length),expectTypes[i].next,new Lisp({op:t,a:lispify(e,o)}))})),setLispType(["new"],((e,t,n,r,i,s)=>{let o=r[0].length;const a=restOfExp(e,n.substring(o),[],void 0,"(");o+=a.length+1;const c=[];if("("===n.char(o-1)){const t=restOfExp(e,n.substring(o),[],"(");let r;o+=t.length+1;let i=0;for(;(r=restOfExp(e,t.substring(i),[/^,/])).length;)i+=r.length+1,c.push(r.trim())}s.lispTree=lispify(e,n.substring(o),expectTypes.expEdge.next,new Lisp({op:t,a:lispify(e,a,expectTypes.initialize.next),b:toLispArray(c.map((t=>lispify(e,t,expectTypes.initialize.next))))}))}));const ofStart2=lispify(void 0,new CodeString("let $$iterator = $$obj[Symbol.iterator]()"),["initialize"]),ofStart3=lispify(void 0,new CodeString("let $$next = $$iterator.next()"),["initialize"]),ofCondition=lispify(void 0,new CodeString("return !$$next.done"),["initialize"]),ofStep=lispify(void 0,new CodeString("$$next = $$iterator.next()")),inStart2=lispify(void 0,new CodeString("let $$keys = Object.keys($$obj)"),["initialize"]),inStart3=lispify(void 0,new CodeString("let $$keyIndex = 0"),["initialize"]),inStep=lispify(void 0,new CodeString("$$keyIndex++")),inCondition=lispify(void 0,new CodeString("return $$keyIndex < $$keys.length"),["initialize"]);var lastType;function lispify(e,t,n,r,i=!1){if(n=n||expectTypes.initialize.next,void 0===t)return r;const s=(t=t.trimStart()).toString();if(!t.length&&!n.includes("expEnd"))throw new SyntaxError("Unexpected end of expression");if(!t.length)return r;let o,a={lispTree:r};for(let r of n)if("expEnd"!==r){for(let n in expectTypes[r].types)if("expEnd"!==n&&(o=expectTypes[r].types[n].exec(s))){lastType=n;try{lispTypes.get(n)(e,n,t,o,r,a)}catch(e){if(i&&e instanceof SyntaxError)throw new ParseError(e.message,s);throw e}break}if(o)break}if(!o&&t.length){t.char(0);if(i)throw new ParseError(`Unexpected token after ${lastType}: ${t.char(0)}`,s);throw new SyntaxError(`Unexpected token after ${lastType}: ${t.char(0)}`)}return a.lispTree}const startingExpectedWithoutSingle=startingExecpted.filter((e=>"expSingle"!==e));function lispifyExpr(e,t,n){if(!t.trimStart().length)return;let r,i=[],s=0;if((n=n||expectTypes.initialize.next).includes("expSingle")&&testMultiple(t.toString(),Object.values(expectTypes.expSingle.types)))return lispify(e,t,["expSingle"],void 0,!0);for(n===startingExecpted&&(n=startingExpectedWithoutSingle);(r=restOfExp(e,t.substring(s),[/^,/])).length;)i.push(r.trimStart()),s+=r.length+1;if(1===i.length)return lispify(e,t,n,void 0,!0);if(n.includes("initialize")){let r=expectTypes.initialize.types.initialize.exec(i[0].toString());if(r)return toLispArray(i.map(((t,n)=>lispify(e,n?new CodeString(r[1]+" "+t):t,["initialize"],void 0,!0))));if(expectTypes.initialize.types.return.exec(i[0].toString()))return lispify(e,t,n,void 0,!0)}const o=toLispArray(i.map(((t,r)=>lispify(e,t,n,void 0,!0))));return new Lisp({op:"multi",a:o})}function lispifyReturnExpr(e,t){return new Lisp({op:"return",b:lispifyExpr(e,t)})}function lispifyBlock(e,t,n=!1){if(!(e=insertSemicolons(t,e)).trim().length)return toLispArray([]);let r,i=[],s=0,o=0,a={},c=!1,l=!1;for(;(r=restOfExp(t,e.substring(s),[semiColon],void 0,void 0,void 0,a)).length&&(l=e.char(s+r.length)&&";"!==e.char(s+r.length),s+=r.length+(l?0:1),/^\s*else(?![\w\$])/.test(e.substring(s).toString())||a.words.includes("do")&&/^\s*while(?![\w\$])/.test(e.substring(s).toString())?c=!0:(c=!1,i.push(e.substring(o,s-(l?0:1))),o=s),a={},!n););return c&&i.push(e.substring(o,s-(l?0:1))),toLispArray(i.map((e=>e.trimStart())).filter((e=>e.length)).map(((e,n)=>lispifyExpr(t,e.trimStart(),startingExecpted))).flat())}function lispifyFunction(e,t,n=!1){if(!e.trim().length)return toLispArray([]);const r=lispifyBlock(e,t,n);let i=toLispArray([]);return hoist(r,i),toLispArray(i.concat(r))}function hoist(e,t){if(Array.isArray(e)){const n=[];for(let r of e)hoist(r,t)||n.push(r);n.length!==e.length&&(e.length=0,e.push(...n))}else if(e instanceof Lisp)if("try"===e.op||"if"===e.op||"loop"===e.op||"switch"===e.op)hoist(e.a,t),hoist(e.b,t);else if("var"===e.op)t.push(new Lisp({op:"var",a:e.a}));else if("function"===e.op&&e.a[1])return t.push(e),!0;return!1}const closingsNoInsertion=/^(\})\s*(catch|finally|else|while|instanceof)(?![\w\$])/,colonsRegex=/^((([\w\$\]\)\"\'\`]|\+\+|\-\-)\s*\r?\n\s*([\w\$\+\-\!~]))|(\}\s*[\w\$\!~\+\-\{\(\"\'\`]))/;function insertSemicolons(e,t){let n=t,r=emptyString,i={};const s=insertedSemicolons.get(t.ref)||new Array(t.ref.str.length);for(;(r=restOfExp(e,n,[],void 0,void 0,[colonsRegex],i)).length;){let e=!1,t=r,o=r.length;if(i.regRes){e=!0;const[,,s,,,a]=i.regRes;if(o="++"===i.regRes[3]||"--"===i.regRes[3]?r.length+1:r.length,t=n.substring(0,o),a){let t=closingsNoInsertion.exec(n.substring(r.length-1).toString());t?e="while"===t[2]&&"do"!==i.lastWord:"function"===i.lastWord&&"}"===i.regRes[5][0]&&"("===i.regRes[5].slice(-1)&&(e=!1)}else s&&("if"!==i.lastWord&&"while"!==i.lastWord&&"for"!==i.lastWord&&"else"!==i.lastWord||(e=!1))}e&&(s[t.end]=!0),n=n.substring(o),i={}}return insertedSemicolons.set(t.ref,s),t}function checkRegex(e){let t=1,n=!1,r=!1,i=!1;for(;t<e.length&&!r&&!i;)r="/"===e[t]&&!n,n="\\"===e[t]&&!n,i="\n"===e[t],t++;let s=e.substring(t);if(i=i||!r||/^\s*\d/.test(s),i)return null;let o=/^[a-z]*/.exec(s);return/^\s+[\w\$]/.test(e.substring(t+o[0].length))?null:{regex:e.substring(1,t-1),flags:o&&o[0]||"",length:t+(o&&o[0].length||0)}}const notDivide=/(typeof|delete|instanceof|return|in|of|throw|new|void|do|if)$/,possibleDivide=/^([\w\$\]\)]|\+\+|\-\-)[\s\/]/;function extractConstants(e,t,n=""){let r,i,s=[],o=!1,a="",c=-1,l=toLispArray([]),p="";const u=[],d=[];let f;for(var h=0;h<t.length;h++)if(p=t[h],a)p===a&&("*"===a&&"/"===t[h+1]?(a="",h++):"\n"===a&&(a=""));else{if(o){o=!1,s.push(p);continue}if(r)if("`"===r&&"$"===p&&"{"===t[h+1]){let n=extractConstants(e,t.substring(h+2),"{");l.push(n.str),s.push("${",l.length-1,"}"),h+=n.length+2}else r===p?("`"===r?(e.literals.push({op:"literal",a:unraw(s.join("")),b:l}),u.push("`",e.literals.length-1,"`")):(e.strings.push(unraw(s.join(""))),u.push('"',e.strings.length-1,'"')),r=null,s=[]):s.push(p);else{if("'"===p||'"'===p||"`"===p)l=toLispArray([]),r=p;else{if(closings[n]===p&&!d.length)return{str:u.join(""),length:h};closings[p]?(d.push(p),u.push(p)):closings[d[d.length-1]]===p?(d.pop(),u.push(p)):"/"!==p||"*"!==t[h+1]&&"/"!==t[h+1]?"/"===p&&!f&&(i=checkRegex(t.substring(h)))?(e.regexes.push(i),u.push("/",e.regexes.length-1,"/r"),h+=i.length-1):u.push(p):(a="*"===t[h+1]?"*":"\n",c=h)}f&&space.test(p)||(f=possibleDivide.exec(t.substring(h)))&&notDivide.test(t.substring(0,h+f[1].length))&&(f=null)}o=r&&"\\"===p}if(a&&"*"===a)throw new SyntaxError("Unclosed comment '/*': "+t.substring(c));return{str:u.join(""),length:h}}function parse(e,t=!1,n=!1){if("string"!=typeof e)throw new ParseError("Cannot parse "+e,e);let r=" "+e;const i={strings:[],literals:[],regexes:[],eager:t};r=extractConstants(i,r).str;for(let e of i.literals)e.b=toLispArray(e.b.map((e=>lispifyExpr(i,new CodeString(e)))));return{tree:lispifyFunction(new CodeString(r),i,n),constants:i}}class ExecReturn{constructor(e,t,n,r=!1,i=!1){this.auditReport=e,this.result=t,this.returned=n,this.breakLoop=r,this.continueLoop=i}}class Prop{constructor(e,t,n=!1,r=!1,i=!1){this.context=e,this.prop=t,this.isConst=n,this.isGlobal=r,this.isVariable=i}get(){if(void 0===this.context)throw new ReferenceError(this.prop+" is not defined");return this.context[this.prop]}}const optional={},reservedWords=new Set(["instanceof","typeof","return","try","catch","if","finally","else","in","of","var","let","const","for","delete","false","true","while","do","break","continue","new","function","async","await","switch","case"]);var VarType;function keysOnly(e){const t=Object.assign({},e);for(let e in t)t[e]=!0;return t}!function(e){e.let="let",e.const="const",e.var="var"}(VarType||(VarType={}));class Scope{constructor(e,t={},n){this.const={},this.let={},this.var={};const r=void 0!==n||null===e;this.parent=e,this.allVars=t,this.let=r?this.let:keysOnly(t),this.var=r?keysOnly(t):this.var,this.globals=null===e?keysOnly(t):{},this.functionThis=n}get(e,t=!1){if("this"===e&&void 0!==this.functionThis)return new Prop({this:this.functionThis},e,!0,!1,!0);if(reservedWords.has(e))throw new SyntaxError("Unexepected token '"+e+"'");if(null===this.parent||!t||void 0!==this.functionThis){if(this.globals.hasOwnProperty(e))return new Prop(this.functionThis,e,!1,!0,!0);if(e in this.allVars&&(!(e in{})||this.allVars.hasOwnProperty(e)))return new Prop(this.allVars,e,this.const.hasOwnProperty(e),this.globals.hasOwnProperty(e),!0);if(null===this.parent)return new Prop(void 0,e)}return this.parent.get(e,t)}set(e,t){if("this"===e)throw new SyntaxError('"this" cannot be assigned');if(reservedWords.has(e))throw new SyntaxError("Unexepected token '"+e+"'");let n=this.get(e);if(void 0===n.context)throw new ReferenceError(`Variable '${e}' was not declared.`);if(n.isConst)throw new TypeError(`Cannot assign to const variable '${e}'`);if(n.isGlobal)throw new SandboxError(`Cannot override global variable '${e}'`);return n.context[n]=t,n}declare(e,t=null,n,r=!1){if("this"===e)throw new SyntaxError('"this" cannot be declared');if(reservedWords.has(e))throw new SyntaxError("Unexepected token '"+e+"'");if("var"===t&&void 0===this.functionThis&&null!==this.parent)return this.parent.declare(e,t,n,r);if((!this[t].hasOwnProperty(e)||"const"===t||this.globals.hasOwnProperty(e))&&e in this.allVars)throw new SandboxError(`Identifier '${e}' has already been declared`);return r&&(this.globals[e]=!0),this[t][e]=!0,this.allVars[e]=n,new Prop(this.allVars,e,this.const.hasOwnProperty(e),r)}}class FunctionScope{}class LocalScope{}class SandboxError extends Error{}let currentTicks;function sandboxFunction(e,t){return function SandboxFunction(...n){let r=parse(n.pop()||"");return createFunction(n,r.tree,t||currentTicks,{ctx:e,constants:r.constants,tree:r.tree},void 0,"anonymous")}}function generateArgs(e,t){const n={};return e.forEach(((e,r)=>{e.startsWith("...")?n[e.substring(3)]=t.slice(r):n[e]=t[r]})),n}const sandboxedFunctions=new WeakSet;function createFunction(e,t,n,r,i,s){if(r.ctx.options.forbidFunctionCreation)throw new SandboxError("Function creation is forbidden");let o;return o=void 0===s?(...s)=>{const o=generateArgs(e,s);return executeTree(n,r,t,void 0===i?[]:[new Scope(i,o)]).result}:function(...s){const o=generateArgs(e,s);return executeTree(n,r,t,void 0===i?[]:[new Scope(i,o,this)]).result},sandboxedFunctions.add(o),o}function createFunctionAsync(e,t,n,r,i,s){var o;if(r.ctx.options.forbidFunctionCreation)throw new SandboxError("Function creation is forbidden");if(!(null===(o=r.ctx.prototypeWhitelist)||void 0===o?void 0:o.has(Promise.prototype)))throw new SandboxError("Async/await not permitted");let a;return a=void 0===s?async(...s)=>{const o=generateArgs(e,s);return(await executeTreeAsync(n,r,t,void 0===i?[]:[new Scope(i,o)])).result}:async function(...s){const o=generateArgs(e,s);return(await executeTreeAsync(n,r,t,void 0===i?[]:[new Scope(i,o,this)])).result},sandboxedFunctions.add(a),a}function sandboxedEval(e){return function(t){return e(t)()}}function sandboxedSetTimeout(e){return function(t,...n){return"string"!=typeof t?setTimeout(t,...n):setTimeout(e(t),...n)}}function sandboxedSetInterval(e){return function(t,...n){return"string"!=typeof t?setInterval(t,...n):setInterval(e(t),...n)}}function assignCheck(e,t,n="assign"){var r,i,s,o;if(void 0===e.context)throw new ReferenceError(`Cannot ${n} value to undefined.`);if("object"!=typeof e.context&&"function"!=typeof e.context)throw new SyntaxError(`Cannot ${n} value to a primitive.`);if(e.isConst)throw new TypeError(`Cannot set value to const variable '${e.prop}'`);if(e.isGlobal)throw new SandboxError(`Cannot ${n} property '${e.prop}' of a global object`);if("function"==typeof e.context[e.prop]&&!e.context.hasOwnProperty(e.prop))throw new SandboxError(`Override prototype property '${e.prop}' not allowed`);"delete"===n?e.context.hasOwnProperty(e.prop)&&(null===(r=t.ctx.changeSubscriptions.get(e.context))||void 0===r||r.forEach((t=>t({type:"delete",prop:e.prop})))):e.context.hasOwnProperty(e.prop)?null===(s=null===(i=t.ctx.setSubscriptions.get(e.context))||void 0===i?void 0:i.get(e.prop))||void 0===s||s.forEach((e=>e({type:"replace"}))):null===(o=t.ctx.changeSubscriptions.get(e.context))||void 0===o||o.forEach((t=>t({type:"create",prop:e.prop})))}const arrayChange=new Set([[].push,[].pop,[].shift,[].unshift,[].splice,[].reverse,[].sort,[].copyWithin]),literalRegex=/(\$\$)*(\$)?\${(\d+)}/g;let ops2={prop:(e,t,n,r,i,s,o,a)=>{if(null===r)throw new TypeError(`Cannot get property ${i} of null`);const c=typeof r;if("undefined"===c&&void 0===s){let e=a.get(i);if(e.context===o.ctx.sandboxGlobal){o.ctx.options.audit&&o.ctx.auditReport.globalsAccess.add(i);const e=o.ctx.globalsWhitelist.has(o.ctx.sandboxGlobal[i])?o.ctx.evals.get(o.ctx.sandboxGlobal[i]):void 0;if(e)return void t(void 0,e)}return e.context&&e.context[i]===globalThis?void t(void 0,o.ctx.globalScope.get("this")):(o.ctx.getSubscriptions.forEach((t=>t(e.context,e.prop))),void t(void 0,e))}if(void 0===r)throw new SandboxError("Cannot get property '"+i+"' of undefined");if("object"!==c)"number"===c?r=new Number(r):"string"===c?r=new String(r):"boolean"===c&&(r=new Boolean(r));else if(void 0===r.hasOwnProperty)return void t(void 0,new Prop(void 0,i));const l="function"===c;let p=l||!(r.hasOwnProperty(i)||"number"==typeof i);if(o.ctx.options.audit&&p&&"string"==typeof i){let e=Object.getPrototypeOf(r);do{e.hasOwnProperty(i)&&(o.ctx.auditReport.prototypeAccess[e.constructor.name]||(o.ctx.auditReport.prototypeAccess[e.constructor.name]=new Set),o.ctx.auditReport.prototypeAccess[e.constructor.name].add(i))}while(e=Object.getPrototypeOf(e))}if(p)if(l){if(!["name","length","constructor"].includes(i)&&r.hasOwnProperty(i)){const e=o.ctx.prototypeWhitelist.get(r.prototype),n=o.ctx.options.prototypeReplacements.get(r);if(n)return void t(void 0,new Prop(n(r,!0),i));if(!e||e.size&&!e.has(i))throw new SandboxError(`Static method or property access not permitted: ${r.name}.${i}`)}}else if("constructor"!==i){let e=r;for(;e=Object.getPrototypeOf(e);)if(e.hasOwnProperty(i)){const n=o.ctx.prototypeWhitelist.get(e),s=o.ctx.options.prototypeReplacements.get(e.constuctor);if(s)return void t(void 0,new Prop(s(r,!1),i));if(n&&(!n.size||n.has(i)))break;throw new SandboxError(`Method or property access not permitted: ${e.constructor.name}.${i}`)}}if(o.ctx.evals.has(r[i]))return void t(void 0,o.ctx.evals.get(r[i]));if(r[i]===globalThis)return void t(void 0,o.ctx.globalScope.get("this"));let u=s.isGlobal||l&&!sandboxedFunctions.has(r)||o.ctx.globalsWhitelist.has(r);u||o.ctx.getSubscriptions.forEach((e=>e(r,i))),t(void 0,new Prop(r,i,!1,u))},call:(e,t,n,r,i,s,o,a)=>{if(o.ctx.options.forbidFunctionCalls)throw new SandboxError("Function invocations are not allowed");if("function"!=typeof r)throw new TypeError(s.prop+" is not a function");execMany(n,e,toLispArray(i.map((e=>e instanceof SpreadArray?[...e.item]:[e])).flat()),((e,n)=>{var r;if(e)t(e);else if("function"!=typeof s){if(s.context[s.prop]===JSON.stringify&&o.ctx.getSubscriptions.size){const e=new Set,t=n=>{if(n&&"object"==typeof n&&!e.has(n)){e.add(n);for(let e in n)o.ctx.getSubscriptions.forEach((t=>t(n,e))),t(n[e])}};t(n[0])}if(s.context instanceof Array&&arrayChange.has(s.context[s.prop])&&o.ctx.changeSubscriptions.get(s.context)){let e,t=!1;if("push"===s.prop)e={type:"push",added:n},t=!!n.length;else if("pop"===s.prop)e={type:"pop",removed:s.context.slice(-1)},t=!!e.removed.length;else if("shift"===s.prop)e={type:"shift",removed:s.context.slice(0,1)},t=!!e.removed.length;else if("unshift"===s.prop)e={type:"unshift",added:n},t=!!n.length;else if("splice"===s.prop)e={type:"splice",startIndex:n[0],deleteCount:void 0===n[1]?s.context.length:n[1],added:n.slice(2),removed:s.context.slice(n[0],void 0===n[1]?void 0:n[0]+n[1])},t=!!e.added.length||!!e.removed.length;else if("reverse"===s.prop||"sort"===s.prop)e={type:s.prop},t=!!s.context.length;else if("copyWithin"===s.prop){let r=void 0===n[2]?s.context.length-n[1]:Math.min(s.context.length,n[2]-n[1]);e={type:"copyWithin",startIndex:n[0],endIndex:n[0]+r,added:s.context.slice(n[1],n[1]+r),removed:s.context.slice(n[0],n[0]+r)},t=!!e.added.length||!!e.removed.length}t&&(null===(r=o.ctx.changeSubscriptions.get(s.context))||void 0===r||r.forEach((t=>t(e))))}t(void 0,s.context[s.prop](...n))}else t(void 0,s(...n))}),a,o)},createObject:(e,t,n,r,i,s,o,a)=>{let c={};for(let e of i)e instanceof SpreadObject?c={...c,...e.item}:c[e.key]=e.val;t(void 0,c)},keyVal:(e,t,n,r,i)=>t(void 0,new KeyVal(r,i)),createArray:(e,t,n,r,i,s,o,a)=>{execMany(n,e,toLispArray(i.map((e=>e instanceof SpreadArray?[...e.item]:[e])).flat()),t,a,o)},group:(e,t,n,r,i)=>t(void 0,i),string:(e,t,n,r,i,s,o)=>t(void 0,o.constants.strings[i]),regex:(e,t,n,r,i,s,o)=>{const a=o.constants.regexes[i];if(!o.ctx.globalsWhitelist.has(RegExp))throw new SandboxError("Regex not permitted");t(void 0,new RegExp(a.regex,a.flags))},literal:(e,t,n,r,i,s,o,a)=>{let c,l=o.constants.literals[i].a,p=toLispArray([]),u=[];for(;c=literalRegex.exec(l);)c[2]||(p.push(o.constants.literals[i].b[parseInt(c[3],10)]),u.push(c[3]));execMany(n,e,p,((e,n)=>{const r={};if(e)t(e);else{for(let e in u){const t=u[e];r[t]=n[e]}t(void 0,l.replace(/(\\\\)*(\\)?\${(\d+)}/g,((e,t,n,i)=>{if(n)return e;let s=r[i];return s=s instanceof Prop?s.get():s,(t||"")+""+s})))}}),a,o)},spreadArray:(e,t,n,r,i,s,o,a)=>{e(n,i,a,o,((e,n)=>{e?t(e):t(void 0,new SpreadArray(n))}))},spreadObject:(e,t,n,r,i,s,o,a)=>{e(n,i,a,o,((e,n)=>{e?t(e):t(void 0,new SpreadObject(n))}))},"!":(e,t,n,r,i)=>t(void 0,!i),"~":(e,t,n,r,i)=>t(void 0,~i),"++$":(e,t,n,r,i,s,o)=>{assignCheck(s,o),t(void 0,++s.context[s.prop])},"$++":(e,t,n,r,i,s,o)=>{assignCheck(s,o),t(void 0,s.context[s.prop]++)},"--$":(e,t,n,r,i,s,o)=>{assignCheck(s,o),t(void 0,--s.context[s.prop])},"$--":(e,t,n,r,i,s,o)=>{assignCheck(s,o),t(void 0,s.context[s.prop]--)},"=":(e,t,n,r,i,s,o)=>{assignCheck(s,o),s.context[s.prop]=i,t(void 0,new Prop(s.context,s.prop,!1,s.isGlobal))},"+=":(e,t,n,r,i,s,o)=>{assignCheck(s,o),t(void 0,s.context[s.prop]+=i)},"-=":(e,t,n,r,i,s,o)=>{assignCheck(s,o),t(void 0,s.context[s.prop]-=i)},"/=":(e,t,n,r,i,s,o)=>{assignCheck(s,o),t(void 0,s.context[s.prop]/=i)},"*=":(e,t,n,r,i,s,o)=>{assignCheck(s,o),t(void 0,s.context[s.prop]*=i)},"**=":(e,t,n,r,i,s,o)=>{assignCheck(s,o),t(void 0,s.context[s.prop]**=i)},"%=":(e,t,n,r,i,s,o)=>{assignCheck(s,o),t(void 0,s.context[s.prop]%=i)},"^=":(e,t,n,r,i,s,o)=>{assignCheck(s,o),t(void 0,s.context[s.prop]^=i)},"&=":(e,t,n,r,i,s,o)=>{assignCheck(s,o),t(void 0,s.context[s.prop]&=i)},"|=":(e,t,n,r,i,s,o)=>{assignCheck(s,o),t(void 0,s.context[s.prop]|=i)},"<<=":(e,t,n,r,i,s,o)=>{assignCheck(s,o),t(void 0,s.context[s.prop]<<=i)},">>=":(e,t,n,r,i,s,o)=>{assignCheck(s,o),t(void 0,s.context[s.prop]>>=i)},">>>=":(e,t,n,r,i,s,o)=>{assignCheck(s,o),t(void 0,s.context[s.prop]>>=i)},"?":(e,t,n,r,i)=>{if(!(i instanceof If))throw new SyntaxError("Invalid inline if");t(void 0,r?i.t:i.f)},">":(e,t,n,r,i)=>t(void 0,r>i),"<":(e,t,n,r,i)=>t(void 0,r<i),">=":(e,t,n,r,i)=>t(void 0,r>=i),"<=":(e,t,n,r,i)=>t(void 0,r<=i),"==":(e,t,n,r,i)=>t(void 0,r==i),"===":(e,t,n,r,i)=>t(void 0,r===i),"!=":(e,t,n,r,i)=>t(void 0,r!=i),"!==":(e,t,n,r,i)=>t(void 0,r!==i),"&&":(e,t,n,r,i)=>t(void 0,r&&i),"||":(e,t,n,r,i)=>t(void 0,r||i),"&":(e,t,n,r,i)=>t(void 0,r&i),"|":(e,t,n,r,i)=>t(void 0,r|i),":":(e,t,n,r,i)=>t(void 0,new If(r,i)),"+":(e,t,n,r,i)=>t(void 0,r+i),"-":(e,t,n,r,i)=>t(void 0,r-i),"$+":(e,t,n,r,i)=>t(void 0,+i),"$-":(e,t,n,r,i)=>t(void 0,-i),"/":(e,t,n,r,i)=>t(void 0,r/i),"^":(e,t,n,r,i)=>t(void 0,r^i),"*":(e,t,n,r,i)=>t(void 0,r*i),"%":(e,t,n,r,i)=>t(void 0,r%i),"<<":(e,t,n,r,i)=>t(void 0,r<<i),">>":(e,t,n,r,i)=>t(void 0,r>>i),">>>":(e,t,n,r,i)=>t(void 0,r>>>i),typeof:(e,t,n,r,i,s,o,a)=>{e(n,i,a,o,((e,n)=>{n instanceof Prop&&(n=void 0===n.context?void 0:n.context[n.prop]),t(void 0,typeof n)}))},instanceof:(e,t,n,r,i)=>t(void 0,r instanceof i),in:(e,t,n,r,i)=>t(void 0,r in i),delete:(e,t,n,r,i,s,o,a,c)=>{void 0!==c.context?(assignCheck(c,o,"delete"),c.isVariable?t(void 0,!1):t(void 0,delete c.context[c.prop])):t(void 0,!0)},return:(e,t,n,r,i,s,o)=>t(void 0,i),var:(e,t,n,r,i,s,o,a,c)=>{e(n,i,a,o,((e,n)=>{e?t(e):t(void 0,a.declare(r,VarType.var,n))}))},let:(e,t,n,r,i,s,o,a,c)=>{e(n,i,a,o,((e,n)=>{e?t(e):t(void 0,a.declare(r,VarType.let,n,c&&c.isGlobal))}))},const:(e,t,n,r,i,s,o,a,c)=>{e(n,i,a,o,((e,n)=>{e?t(e):t(void 0,a.declare(r,VarType.const,n))}))},arrowFunc:(e,t,n,r,i,s,o,a)=>{r=[...r],("string"==typeof s.b||s.b instanceof CodeString)&&(s.b=i=lispifyFunction(new CodeString(s.b),o.constants)),r.shift()?t(void 0,createFunctionAsync(r,i,n,o,a)):t(void 0,createFunction(r,i,n,o,a))},function:(e,t,n,r,i,s,o,a)=>{("string"==typeof s.b||s.b instanceof CodeString)&&(s.b=i=lispifyFunction(new CodeString(s.b),o.constants));let c,l=r.shift(),p=r.shift();c=l?createFunctionAsync(r,i,n,o,a,p):createFunction(r,i,n,o,a,p),p&&a.declare(p,VarType.var,c),t(void 0,c)},inlineFunction:(e,t,n,r,i,s,o,a)=>{("string"==typeof s.b||s.b instanceof CodeString)&&(s.b=i=lispifyFunction(new CodeString(s.b),o.constants));let c,l=r.shift(),p=r.shift();p&&(a=new Scope(a,{})),c=l?createFunctionAsync(r,i,n,o,a,p):createFunction(r,i,n,o,a,p),p&&a.declare(p,VarType.let,c),t(void 0,c)},loop:(e,t,n,r,i,s,o,a)=>{const[c,l,p,u,d,f,h]=r;let g=!0;const y=new Scope(a,{});let x={$$obj:void 0};const b=new Scope(y,x);if(e===execAsync)(async()=>{let r;for(r=asyncDone((t=>e(n,u,y,o,t))),x.$$obj=!0===(r=asyncDone((t=>e(n,p,y,o,t)))).isInstant?r.instant:(await r.p).result,r=asyncDone((t=>e(n,l,b,o,t))),c&&(g=!0===(r=asyncDone((t=>e(n,f,b,o,t)))).isInstant?r.instant:(await r.p).result);g;){let s={};r=asyncDone((t=>e(n,h,new Scope(b,s),o,t))),!0===r.isInstant?r.instant:(await r.p).result;let a=await executeTreeAsync(n,o,i,[new Scope(y,s)],"loop");if(a instanceof ExecReturn&&a.returned)return void t(void 0,a);if(a instanceof ExecReturn&&a.breakLoop)break;r=asyncDone((t=>e(n,d,b,o,t))),g=!0===(r=asyncDone((t=>e(n,f,b,o,t)))).isInstant?r.instant:(await r.p).result}t()})().catch(t);else{for(syncDone((t=>e(n,u,y,o,t))),x.$$obj=syncDone((t=>e(n,p,y,o,t))).result,syncDone((t=>e(n,l,b,o,t))),c&&(g=syncDone((t=>e(n,f,b,o,t))).result);g;){let r={};syncDone((t=>e(n,h,new Scope(b,r),o,t)));let s=executeTree(n,o,i,[new Scope(y,r)],"loop");if(s instanceof ExecReturn&&s.returned)return void t(void 0,s);if(s instanceof ExecReturn&&s.breakLoop)break;syncDone((t=>e(n,d,b,o,t))),g=syncDone((t=>e(n,f,b,o,t))).result}t()}},loopAction:(e,t,n,r,i,s,o,a,c,l)=>{if("switch"===l&&"continue"===r||!l)throw new SandboxError("Illegal "+r+" statement");t(void 0,new ExecReturn(o.ctx.auditReport,void 0,!1,"break"===r,"continue"===r))},if:(e,t,n,r,i,s,o,a,c,l)=>{if(!(i instanceof If))throw new SyntaxError("Invalid if");e(n,r,a,o,((r,s)=>{r?t(r):executeTreeWithDone(e,t,n,o,s?i.t:i.f,[new Scope(a)],l)}))},switch:(e,t,n,r,i,s,o,a)=>{e(n,r,a,o,((r,s)=>{if(r)t(r);else if(e===execSync){let r,c=!1;for(let l of i)if(c||(c=!l.a||s===valueOrProp(syncDone((t=>e(n,l.a,a,o,t))).result))){if(!l.b)continue;if(r=executeTree(n,o,l.b,[a],"switch"),r.breakLoop)break;if(r.returned)return void t(void 0,r);if(!l.a)break}t()}else(async()=>{let r,c=!1;for(let l of i){let i;if(c||(c=!l.a||s===valueOrProp(!0===(i=asyncDone((t=>e(n,l.a,a,o,t)))).isInstant?i.instant:(await i.p).result))){if(!l.b)continue;if(r=await executeTreeAsync(n,o,l.b,[a],"switch"),r.breakLoop)break;if(r.returned)return void t(void 0,r);if(!l.a)break}}t()})().catch(t)}))},try:(e,t,n,r,i,s,o,a,c,l)=>{const[p,u,d]=i;executeTreeWithDone(e,((r,i)=>{executeTreeWithDone(e,(s=>{s?t(s):r?executeTreeWithDone(e,t,n,o,u,[new Scope(a)],l):t(void 0,i)}),n,o,d,[new Scope(a,{})])}),n,o,r,[new Scope(a)],l)},void:(e,t,n,r)=>{t()},new:(e,t,n,r,i,s,o)=>{if(!o.ctx.globalsWhitelist.has(r)&&!sandboxedFunctions.has(r))throw new SandboxError("Object construction not allowed: "+r.constructor.name);t(void 0,new r(...i))},throw:(e,t,n,r)=>{t(r)},multi:(e,t,n,r)=>t(void 0,r.pop())},ops=new Map;for(let e in ops2)ops.set(e,ops2[e]);function valueOrProp(e){return e instanceof Prop?e.get():e}function execMany(e,t,n,r,i,s,o){t===execSync?_execManySync(e,n,r,i,s,o):_execManyAsync(e,n,r,i,s,o).catch(r)}function _execManySync(e,t,n,r,i,s){let o=[];for(let a=0;a<t.length;a++){let c;try{c=syncDone((n=>execSync(e,t[a],r,i,n,s))).result}catch(e){return void n(e)}if(c instanceof ExecReturn&&(c.returned||c.breakLoop||c.continueLoop))return void n(void 0,c);o.push(c)}n(void 0,o)}async function _execManyAsync(e,t,n,r,i,s){let o=[];for(let a=0;a<t.length;a++){let c;try{let n;c=!0===(n=asyncDone((n=>execAsync(e,t[a],r,i,n,s)))).isInstant?n.instant:(await n.p).result}catch(e){return void n(e)}if(c instanceof ExecReturn&&(c.returned||c.breakLoop||c.continueLoop))return void n(void 0,c);o.push(c)}n(void 0,o)}function asyncDone(e){let t,n=!1;const r=new Promise(((r,i)=>{e(((e,s)=>{e?i(e):(n=!0,t=s,r({result:s}))}))}));return{isInstant:n,instant:t,p:r}}function syncDone(e){let t,n;if(e(((e,r)=>{n=e,t=r})),n)throw n;return{result:t}}async function execAsync(e,t,n,r,i,s){let o=i;const a=new Promise((e=>{o=(t,n)=>{i(t,n),e()}}));if(_execNoneRecurse(e,t,n,r,o,!0,s));else if(t instanceof Lisp){let i;try{let o;i=!0===(o=asyncDone((i=>execAsync(e,t.a,n,r,i,s)))).isInstant?o.instant:(await o.p).result}catch(e){return void o(e)}let a=i;try{a=i instanceof Prop?i.get():i}catch(e){return void o(e)}let c,l=t.op;if("?prop"===l||"?call"===l){if(null==a)return void o(void 0,optional);l=l.slice(1)}if(a===optional){if("prop"===l||"call"===l)return void o(void 0,a);a=void 0}try{let i;c=!0===(i=asyncDone((i=>execAsync(e,t.b,n,r,i,s)))).isInstant?i.instant:(await i.p).result}catch(e){return void o(e)}let p=c;try{p=c instanceof Prop?c.get():c}catch(e){return void o(e)}if(p===optional&&(p=void 0),ops.has(l))try{ops.get(l)(execAsync,o,e,a,p,i,r,n,c,s)}catch(e){o(e)}else o(new SyntaxError("Unknown operator: "+l))}await a}function execSync(e,t,n,r,i,s){if(_execNoneRecurse(e,t,n,r,i,!1,s));else if(t instanceof Lisp){let o;try{o=syncDone((i=>execSync(e,t.a,n,r,i,s))).result}catch(e){return void i(e)}let a=o;try{a=o instanceof Prop?o.get():o}catch(e){return void i(e)}let c,l=t.op;if("?prop"===l||"?call"===l){if(null==a)return void i(void 0,optional);l=l.slice(1)}if(a===optional){if("prop"===l||"call"===l)return void i(void 0,a);a=void 0}try{c=syncDone((i=>execSync(e,t.b,n,r,i,s))).result}catch(e){return void i(e)}let p=c;try{p=c instanceof Prop?c.get():c}catch(e){return void i(e)}if(p===optional&&(p=void 0),ops.has(l))try{ops.get(l)(execSync,i,e,a,p,o,r,n,c,s)}catch(e){i(e)}else i(new SyntaxError("Unknown operator: "+l))}}const unexecTypes=new Set(["arrowFunc","function","inlineFunction","loop","try","switch","if","typeof"]);function _execNoneRecurse(e,t,n,r,i,s,o){var a;const c=s?execAsync:execSync;if(!(r.ctx.options.executionQuota<=e.ticks)||"function"==typeof r.ctx.options.onExecutionQuotaReached&&r.ctx.options.onExecutionQuotaReached(e,n,r,t)){if(e.ticks++,currentTicks=e,t instanceof Prop)i(void 0,t.get());else if(Array.isArray(t)&&t.lisp===lispArrayKey)execMany(e,c,t,i,n,r,o);else if(t instanceof Lisp)if(unexecTypes.has(t.op))try{ops.get(t.op)(c,i,e,t.a,t.b,t,r,n,void 0,o)}catch(e){i(e)}else{if("await"!==t.op)return!1;s?(null===(a=r.ctx.prototypeWhitelist)||void 0===a?void 0:a.has(Promise.prototype))?execAsync(e,t.a,n,r,(async(e,t)=>{if(e)i(e);else try{i(void 0,await t)}catch(e){i(e)}}),o).catch(i):i(new SandboxError("Async/await is not permitted")):i(new SandboxError("Illegal use of 'await', must be inside async function"))}else i(void 0,t);return!0}i(new SandboxError("Execution quota exceeded"))}function executeTree(e,t,n,r=[],i){return syncDone((s=>executeTreeWithDone(execSync,s,e,t,n,r,i))).result}async function executeTreeAsync(e,t,n,r=[],i){let s;return!0===(s=asyncDone((s=>executeTreeWithDone(execAsync,s,e,t,n,r,i)))).isInstant?s.instant:(await s.p).result}function executeTreeWithDone(e,t,n,r,i,s=[],o){if(!i)return void t();if(!(i instanceof Array))throw new SyntaxError("Bad execution tree");let a,c=r.ctx.globalScope;for(;a=s.shift();)"object"==typeof a&&(c=a instanceof Scope?a:new Scope(c,a,a instanceof LocalScope?void 0:null));r.ctx.options.audit&&!r.ctx.auditReport&&(r.ctx.auditReport={globalsAccess:new Set,prototypeAccess:{}}),e===execSync?_executeWithDoneSync(t,n,r,i,c,o):_executeWithDoneAsync(t,n,r,i,c,o).catch(t)}function _executeWithDoneSync(e,t,n,r,i,s){if(!(r instanceof Array))throw new SyntaxError("Bad execution tree");let o=0;for(o=0;o<r.length;o++){let a,c;const l=r[o];try{execSync(t,l,i,n,((e,t)=>{c=e,a=t}),s)}catch(e){c=e}if(c)return void e(c);if(a instanceof ExecReturn)return void e(void 0,a);if(l instanceof Lisp&&"return"===l.op)return void e(void 0,new ExecReturn(n.ctx.auditReport,a,!0))}e(void 0,new ExecReturn(n.ctx.auditReport,void 0,!1))}async function _executeWithDoneAsync(e,t,n,r,i,s){if(!(r instanceof Array))throw new SyntaxError("Bad execution tree");let o=0;for(o=0;o<r.length;o++){let a,c;const l=r[o];try{await execAsync(t,l,i,n,((e,t)=>{c=e,a=t}),s)}catch(e){c=e}if(c)return void e(c);if(a instanceof ExecReturn)return void e(void 0,a);if(l instanceof Lisp&&"return"===l.op)return void e(void 0,new ExecReturn(n.ctx.auditReport,a,!0))}e(void 0,new ExecReturn(n.ctx.auditReport,void 0,!1))}class SandboxGlobal{constructor(e){if(e===globalThis)return globalThis;for(let t in e)this[t]=e[t]}}class Sandbox{constructor(options){options=Object.assign({audit:!1,forbidFunctionCalls:!1,forbidFunctionCreation:!1,globals:Sandbox.SAFE_GLOBALS,prototypeWhitelist:Sandbox.SAFE_PROTOTYPES,prototypeReplacements:new Map},options||{});const sandboxGlobal=new SandboxGlobal(options.globals);this.context={sandbox:this,globalsWhitelist:new Set(Object.values(options.globals)),prototypeWhitelist:new Map([...options.prototypeWhitelist].map((e=>[e[0].prototype,e[1]]))),options:options,globalScope:new Scope(null,options.globals,sandboxGlobal),sandboxGlobal:sandboxGlobal,evals:new Map,getSubscriptions:new Set,setSubscriptions:new WeakMap,changeSubscriptions:new WeakMap},this.context.prototypeWhitelist.set(Object.getPrototypeOf([][Symbol.iterator]()),new Set);const func=sandboxFunction(this.context);this.context.evals.set(Function,func),this.context.evals.set(eval,sandboxedEval(func)),this.context.evals.set(setTimeout,sandboxedSetTimeout(func)),this.context.evals.set(setInterval,sandboxedSetInterval(func)),this.Function=sandboxFunction(this.context,{ticks:BigInt(0)})}static get SAFE_GLOBALS(){return{Function:Function,console:{debug:console.debug,error:console.error,info:console.info,log:console.log,table:console.table,warn:console.warn},isFinite:isFinite,isNaN:isNaN,parseFloat:parseFloat,parseInt:parseInt,decodeURI:decodeURI,decodeURIComponent:decodeURIComponent,encodeURI:encodeURI,encodeURIComponent:encodeURIComponent,escape:escape,unescape:unescape,Boolean:Boolean,Number:Number,BigInt:BigInt,String:String,Object:Object,Array:Array,Symbol:Symbol,Error:Error,EvalError:EvalError,RangeError:RangeError,ReferenceError:ReferenceError,SyntaxError:SyntaxError,TypeError:TypeError,URIError:URIError,Int8Array:Int8Array,Uint8Array:Uint8Array,Uint8ClampedArray:Uint8ClampedArray,Int16Array:Int16Array,Uint16Array:Uint16Array,Int32Array:Int32Array,Uint32Array:Uint32Array,Float32Array:Float32Array,Float64Array:Float64Array,Map:Map,Set:Set,WeakMap:WeakMap,WeakSet:WeakSet,Promise:Promise,Intl:Intl,JSON:JSON,Math:Math,Date:Date,RegExp:RegExp}}static get SAFE_PROTOTYPES(){let e=[SandboxGlobal,Function,Boolean,Number,BigInt,String,Date,Error,Array,Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array,Map,Set,WeakMap,WeakSet,Promise,Symbol,Date,RegExp],t=new Map;return e.forEach((e=>{t.set(e,new Set)})),t.set(Object,new Set(["entries","fromEntries","getOwnPropertyNames","is","keys","hasOwnProperty","isPrototypeOf","propertyIsEnumerable","toLocaleString","toString","valueOf","values"])),t}subscribeGet(e){return this.context.getSubscriptions.add(e),{unsubscribe:()=>this.context.getSubscriptions.delete(e)}}subscribeSet(e,t,n){const r=this.context.setSubscriptions.get(e)||new Map;this.context.setSubscriptions.set(e,r);const i=r.get(t)||new Set;let s;return r.set(t,i),i.add(n),e&&e[t]&&"object"==typeof e[t]&&(s=this.context.changeSubscriptions.get(e[t])||new Set,s.add(n),this.context.changeSubscriptions.set(e[t],s)),{unsubscribe:()=>{i.delete(n),s&&s.delete(n)}}}static audit(e,t=[]){const n={};for(let e of Object.getOwnPropertyNames(globalThis))n[e]=globalThis[e];return new Sandbox({globals:n,audit:!0}).executeTree(parse(e),t)}static parse(e){return parse(e)}executeTree(e,t=[]){return executeTree({ticks:BigInt(0)},{ctx:this.context,constants:e.constants,tree:e.tree},e.tree,t)}executeTreeAsync(e,t=[]){return executeTreeAsync({ticks:BigInt(0)},{ctx:this.context,constants:e.constants,tree:e.tree},e.tree,t)}compile(e,t=!1){const n=parse(e,t);return(...e)=>this.executeTree(n,e).result}compileAsync(e,t=!1){const n=parse(e,t);return async(...e)=>(await this.executeTreeAsync(n,e)).result}compileExpression(e,t=!1){const n=parse(e,t,!0);return(...e)=>this.executeTree(n,e).result}compileExpressionAsync(e,t=!1){const n=parse(e,t,!0);return async(...e)=>(await this.executeTreeAsync(n,e)).result}}export default Sandbox;export{FunctionScope,LocalScope,SandboxGlobal,assignCheck,asyncDone,execAsync,execMany,execSync,executeTree,executeTreeAsync,ops as executionOps,expectTypes,setLispType,syncDone};
//# sourceMappingURL=Sandbox.min.js.map
