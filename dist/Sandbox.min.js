function parseHexToInt(e){return!e.match(/[^a-f0-9]/i)?parseInt(e,16):NaN}function validateAndParseHex(e,t,n){const i=parseHexToInt(e);if(Number.isNaN(i)||void 0!==n&&n!==e.length)throw new SyntaxError(t+": "+e);return i}function parseHexadecimalCode(e){const t=validateAndParseHex(e,"Malformed Hexadecimal",2);return String.fromCharCode(t)}function parseUnicodeCode(e,t){const n=validateAndParseHex(e,"Malformed Unicode",4);if(void 0!==t){const e=validateAndParseHex(t,"Malformed Unicode",4);return String.fromCharCode(n,e)}return String.fromCharCode(n)}function isCurlyBraced(e){return"{"===e.charAt(0)&&"}"===e.charAt(e.length-1)}function parseUnicodeCodePointCode(e){if(!isCurlyBraced(e))throw new SyntaxError("Malformed Unicode: +"+e);const t=validateAndParseHex(e.slice(1,-1),"Malformed Unicode");try{return String.fromCodePoint(t)}catch(e){throw e instanceof RangeError?new SyntaxError("Code Point Limit:"+t):e}}const singleCharacterEscapes=new Map([["b","\b"],["f","\f"],["n","\n"],["r","\r"],["t","\t"],["v","\v"],["0","\0"]]);function parseSingleCharacterCode(e){return singleCharacterEscapes.get(e)||e}const escapeMatch=/\\(?:(\\)|x([\s\S]{0,2})|u(\{[^}]*\}?)|u([\s\S]{4})\\u([^{][\s\S]{0,3})|u([\s\S]{0,4})|([0-3]?[0-7]{1,2})|([\s\S])|$)/g;function unraw(e){return e.replace(escapeMatch,(function(e,t,n,i,r,s,o,a,c){if(void 0!==t)return"\\";if(void 0!==n)return parseHexadecimalCode(n);if(void 0!==i)return parseUnicodeCodePointCode(i);if(void 0!==r)return parseUnicodeCode(r,s);if(void 0!==o)return parseUnicodeCode(o);if("0"===a)return"\0";if(void 0!==a)throw new SyntaxError("Octal Deprecation: "+a);if(void 0!==c)return parseSingleCharacterCode(c);throw new SyntaxError("End of string")}))}let lispTypes=new Map;class ParseError extends Error{constructor(e,t){super(e),this.code=t}}class Lisp{constructor(e){this.op=e.op,this.a=e.a,this.b=e.b}}class If{constructor(e,t){this.t=e,this.f=t}}class KeyVal{constructor(e,t){this.key=e,this.val=t}}class SpreadObject{constructor(e){this.item=e}}class SpreadArray{constructor(e){this.item=e}}function toLispArray(e){return e.lisp=!0,e}const inlineIfElse=/^:/,space=/^\s/;let expectTypes={splitter:{types:{split:/^(&&|&(?!&)|\|\||\|(?!\|)|<=|>=|<(?!<)|>(?!>)|!==|!=(?!\=)|===|==(?!\=)|\+(?!\+)|\-(?!\-)|\^|<<|>>(?!>)|>>>|instanceof(?![\w\$\_])|in(?![\w\$\_]))(?!\=)/,op:/^(\/|\*\*|\*(?!\*)|\%)(?!\=)/},next:["modifier","value","prop","incrementerBefore"]},inlineIf:{types:{inlineIf:/^\?/},next:["expEnd"]},assignment:{types:{assignModify:/^(\-=|\+=|\/=|\*\*=|\*=|%=|\^=|\&=|\|=|>>>=|>>=|<<=)/,assign:/^(=)(?!=)/},next:["modifier","value","prop","incrementerBefore"]},incrementerBefore:{types:{incrementerBefore:/^(\+\+|\-\-)/},next:["prop"]},expEdge:{types:{call:/^[\(]/,incrementerAfter:/^(\+\+|\-\-)/},next:["splitter","expEdge","inlineIf","dot","expEnd"]},modifier:{types:{not:/^!/,inverse:/^~/,negative:/^\-(?!\-)/,positive:/^\+(?!\+)/,typeof:/^typeof(?![\w\$\_])/,delete:/^delete(?![\w\$\_])/},next:["modifier","value","prop","incrementerBefore"]},dot:{types:{arrayProp:/^[\[]/,dot:/^\.(?!\.)/},next:["splitter","assignment","expEdge","inlineIf","dot","expEnd"]},prop:{types:{prop:/^[a-zA-Z\$\_][a-zA-Z\d\$\_]*/},next:["splitter","assignment","expEdge","inlineIf","dot","expEnd"]},value:{types:{createObject:/^\{/,createArray:/^\[/,number:/^(0x[\da-f]+|\d+(\.\d+)?(e[\+\-]?\d+)?)(?![\d])/i,string:/^"(\d+)"/,literal:/^`(\d+)`/,regex:/^\/(\d+)\/r(?![\w\$\_])/,boolean:/^(true|false)(?![\w\$\_])/,null:/^null(?![\w\$\_])/,und:/^undefined(?![\w\$\_])/,arrowFunctionSingle:/^(async\s+)?([a-zA-Z\$_][a-zA-Z\d\$_]*)\s*=>\s*({)?/,arrowFunction:/^(async\s*)?\(\s*((\.\.\.)?\s*[a-zA-Z\$_][a-zA-Z\d\$_]*(\s*,\s*(\.\.\.)?\s*[a-zA-Z\$_][a-zA-Z\d\$_]*)*)?\s*\)\s*=>\s*({)?/,inlineFunction:/^(async\s+)?function(\s*[a-zA-Z\$_][a-zA-Z\d\$_]*)?\s*\(\s*((\.\.\.)?\s*[a-zA-Z\$_][a-zA-Z\d\$_]*(\s*,\s*(\.\.\.)?\s*[a-zA-Z\$_][a-zA-Z\d\$_]*)*)?\s*\)\s*{/,group:/^\(/,NaN:/^NaN(?![\w\$\_])/,Infinity:/^Infinity(?![\w\$\_])/,void:/^void(?![\w\$\_])\s*/,await:/^await(?![\w\$\_])\s*/,new:/^new(?![\w\$\_])\s*/,throw:/^throw(?![\w\$\_])\s*/},next:["splitter","expEdge","inlineIf","dot","expEnd"]},initialize:{types:{initialize:/^(var|let|const)\s+([a-zA-Z\$_][a-zA-Z\d\$_]*)\s*(=)?/,return:/^return(?![\w\$\_])/},next:["modifier","value","prop","incrementerBefore","expEnd"]},spreadObject:{types:{spreadObject:/^\.\.\./},next:["value","prop"]},spreadArray:{types:{spreadArray:/^\.\.\./},next:["value","prop"]},expEnd:{types:{},next:[]},expSingle:{types:{for:/^(([a-zA-Z\$\_][\w\$\_]*)\s*:)?\s*for\s*\(/,do:/^(([a-zA-Z\$\_][\w\$\_]*)\s*:)?\s*do\s*\{/,while:/^(([a-zA-Z\$\_][\w\$\_]*)\s*:)?\s*while\s*\(/,loopAction:/^(break|continue)(?![\w\$\_])/,if:/^if\s*\(/,try:/^try\s*{/,function:/^(async\s+)?function(\s*[a-zA-Z\$_][a-zA-Z\d\$_]*)\s*\(\s*((\.\.\.)?\s*[a-zA-Z\$_][a-zA-Z\d\$_]*(\s*,\s*(\.\.\.)?\s*[a-zA-Z\$_][a-zA-Z\d\$_]*)*)?\s*\)\s*{/,switch:/^(([a-zA-Z\$\_][\w\$\_]*)\s*:)?\s*switch\s*\(/},next:["expEnd"]}},closings={"(":")","[":"]","{":"}","'":"'",'"':'"',"`":"`"};const okFirstChars=/^[\+\-~ !]/,aChar=/^[\w\$]/,aNumber=expectTypes.value.types.number;function restOfExp(e,t,n,i,r,s,o={},a){let c=!0;n=n||[];let p,l=!1,f=!1,u=!1,d=!1,h="",x="";for(p=0;p<t.length&&!f;p++){let y=t[p];if(u=d,d=aChar.test(y),d||space.test(y)||closings[y]||(x=""),d&&s&&(x+=y),'"'===i||"'"===i||"`"===i){if("`"!==i||"$"!==y||"{"!==t[p+1]||l){if(y===i&&!l)return t.substring(0,p)}else{p+=restOfExp(e,t.substring(p+2),[],"{").length+2}l=!l&&"\\"===y}else if(closings[y]){if(y===r){f=!0;break}if(p+=restOfExp(e,t.substring(p+1),[],y).length+1,c=!1,s){let e=t.substring(p);for(let t of s){t.lastIndex=0;const n=t.exec(e);if(n&&(p+=n[1].length-1,o.word=x,f=!0,f))break}}}else if(i){if(y===closings[i])return t.substring(0,p)}else{let e,i=t.substring(p);if((e=aNumber.exec(i))&&(p+=e[0].length-1,i=t.substring(p)),a||(!u||!d)&&h!==y)for(let e of n){const t=e.exec(i);if(t){s&&(p+=t[1].length),f=!0;break}}if(c&&(okFirstChars.test(i)?f=!1:c=!1),f)break}h=y}if(i)throw new SyntaxError("Unclosed '"+i+"': "+i+t.substring(0,Math.min(p,40)));return t.substring(0,p)}restOfExp.next=["splitter","expEnd","inlineIf"];const setLispType=(e,t)=>{e.forEach((e=>{lispTypes.set(e,t)}))},closingsCreate={createArray:/^\]/,createObject:/^\}/,group:/^\)/,arrayProp:/^\]/,call:/^\)/};setLispType(["createArray","createObject","group","arrayProp","call"],((e,t,n,i,r,s)=>{let o="",a=[],c=!1,p=1;for(;p<n.length&&!c;)o=restOfExp(e,n.substring(p),[closingsCreate[t],/^,/]),p+=o.length,o&&a.push(o),","!==n[p]?c=!0:p++;const l=["value","modifier","prop","incrementerBefore","expEnd"];let f,u;switch(t){case"group":case"arrayProp":f=lispifyExpr(e,a.join(","));break;case"call":case"createArray":f=toLispArray(a.map((t=>lispify(e,t,[...l,"spreadArray"]))));break;case"createObject":f=toLispArray(a.map((t=>{let n,i;if(t=t.trimStart(),u=expectTypes.expSingle.types.function.exec("function "+t),u)i=u[2].trimStart(),n=lispify(e,"function "+t.replace(i,""));else{let r=restOfExp(e,t,[/^:/]);if(i=lispify(e,r,[...l,"spreadObject"]),i instanceof Lisp&&"prop"===i.op&&(i=i.b),r.length===t.length)return i;n=lispify(e,t.substring(r.length+1))}return new Lisp({op:"keyVal",a:i,b:n})})))}t="arrayProp"===t?"prop":t,s.lispTree=lispify(e,n.substring(p+1),expectTypes[r].next,new Lisp({op:t,a:s.lispTree,b:f}))})),setLispType(["inverse","not","negative","positive","typeof","delete","op"],((e,t,n,i,r,s)=>{let o=restOfExp(e,n.substring(i[0].length),[/^[^\s\.\w\d\$]/]);s.lispTree=lispify(e,n.substring(o.length+i[0].length),restOfExp.next,new Lisp({op:["positive","negative"].includes(t)?"$"+i[0]:i[0],a:s.lispTree,b:lispify(e,o,expectTypes[r].next)}))})),setLispType(["incrementerBefore"],((e,t,n,i,r,s)=>{let o=restOfExp(e,n.substring(2),[/^[^\s\.\w\d\$]/]);s.lispTree=lispify(e,n.substring(o.length+2),restOfExp.next,new Lisp({op:i[0]+"$",a:lispify(e,o,expectTypes[r].next)}))})),setLispType(["incrementerAfter"],((e,t,n,i,r,s)=>{s.lispTree=lispify(e,n.substring(i[0].length),expectTypes[r].next,new Lisp({op:"$"+i[0],a:s.lispTree}))})),setLispType(["assign","assignModify"],((e,t,n,i,r,s)=>{s.lispTree=new Lisp({op:i[0],a:s.lispTree,b:lispify(e,n.substring(i[0].length),expectTypes[r].next)})})),setLispType(["split"],((e,t,n,i,r,s)=>{let o=restOfExp(e,n.substring(i[0].length),[expectTypes.splitter.types.split,expectTypes.inlineIf.types.inlineIf,inlineIfElse]);s.lispTree=lispify(e,n.substring(o.length+i[0].length).trim(),restOfExp.next,new Lisp({op:i[0].trim(),a:s.lispTree,b:lispify(e,o,expectTypes[r].next)}))})),setLispType(["inlineIf"],((e,t,n,i,r,s)=>{let o=!1,a="",c=1;for(;!o&&a.length<n.length;)a+=restOfExp(e,n.substring(a.length+1),[expectTypes.inlineIf.types.inlineIf,inlineIfElse]),"?"===n[a.length+1]?c++:c--,c?a+=n[a.length+1]:o=!0;s.lispTree=new Lisp({op:"?",a:s.lispTree,b:new Lisp({op:":",a:lispifyExpr(e,a),b:lispifyExpr(e,n.substring(i[0].length+a.length+1))})})})),setLispType(["if"],((e,t,n,i,r,s)=>{let o=restOfExp(e,n.substring(i[0].length),[],"(");const a=/^\s*\{/.exec(n.substring(i[0].length+o.length+1)),c=i[0].length+o.length+1+(a?a[0].length:0);let p=restOfExp(e,n.substring(c),a?[/^\}/]:[/^else(?!\w\$)/]),l="";if(c+p.length+(a?a[0].length:0)<n.length){const e=n.substring(c+p.length+(a?a[0].length:0)),t=/\s*else(?!\w\$\s)\s*/.exec(e);t&&(l=e.substring(t[0].length))}o=o.trim(),p=p.trim(),l=l.trim(),"{"===p[0]&&(p=p.slice(1,-1)),"{"===l[0]&&(l=l.slice(1,-1)),s.lispTree=new Lisp({op:"if",a:lispifyExpr(e,o),b:new If(lispifyBlock(p,e),l?lispifyBlock(l,e):void 0)})})),setLispType(["switch"],((e,t,n,i,r,s)=>{const o=restOfExp(e,n.substring(i[0].length),[],"(");let a=n.indexOf("{",i[0].length+o.length+1);if(-1===a)throw new SyntaxError("Invalid switch: "+n);let c,p=insertSemicolons(e,restOfExp(e,n.substring(a+1),[],"{"),!1);const l=/^\s*(case\s|default)\s*/;let f=[],u=!1;for(;c=l.exec(p);){if("default"===c[1]){if(u)throw new SyntaxError("Only one default switch case allowed:"+p);u=!0}let t=restOfExp(e,p.substring(c[0].length),[/^:/]),n="",i=a=c[0].length+t.length+1,r=/^\s*\{/.exec(p.substring(i)),s=[];if(r)i+=r[0].length,n=restOfExp(e,p.substring(i),[],"{"),i+=n.length+1,s=lispifyBlock(n,e);else{let t=restOfExp(e,p.substring(i),[l]);if(t.trim()){let t=[];for(;(n=restOfExp(e,p.substring(i),[/^;/]))&&(t.push(n),i+=n.length+1,!l.test(p.substring(i))););s=lispifyBlock(t.join(";"),e)}else s=void 0,i+=t.length}p=p.substring(i),f.push(new Lisp({op:"case",a:"default"===c[1]?void 0:lispifyExpr(e,t),b:toLispArray(s)}))}s.lispTree=new Lisp({op:"switch",a:lispifyExpr(e,o),b:toLispArray(f)})})),setLispType(["dot","prop"],((e,t,n,i,r,s)=>{let o=i[0],a=i[0].length;if("."===i[0]){let e=n.substring(i[0].length).match(expectTypes.prop.types.prop);if(!e||!e.length)throw new SyntaxError("Hanging  dot:"+n);o=e[0],a=o.length+i[0].length}s.lispTree=lispify(e,n.substring(a),expectTypes[r].next,new Lisp({op:"prop",a:s.lispTree,b:o}))})),setLispType(["spreadArray","spreadObject"],((e,t,n,i,r,s)=>{s.lispTree=new Lisp({op:t,b:lispify(e,n.substring(i[0].length),expectTypes[r].next)})})),setLispType(["return"],((e,t,n,i,r,s)=>{s.lispTree=new Lisp({op:t,b:lispifyExpr(e,n.substring(i[0].length))})}));const primitives={true:!0,false:!1,null:null,Infinity:1/0,NaN:NaN,und:void 0};setLispType(["number","boolean","null","und","NaN","Infinity"],((e,t,n,i,r,s)=>{s.lispTree=lispify(e,n.substring(i[0].length),expectTypes[r].next,"number"===t?Number(i[0]):primitives["boolean"===t?i[0]:t])})),setLispType(["string","literal","regex"],((e,t,n,i,r,s)=>{s.lispTree=lispify(e,n.substring(i[0].length),expectTypes[r].next,new Lisp({op:t,b:parseInt(JSON.parse(i[1]),10)}))})),setLispType(["initialize"],((e,t,n,i,r,s)=>{i[3]?s.lispTree=new Lisp({op:i[1],a:i[2],b:lispify(e,n.substring(i[0].length),expectTypes[r].next)}):s.lispTree=lispify(e,n.substring(i[0].length),expectTypes[r].next,new Lisp({op:i[1],a:i[2]}))})),setLispType(["function","inlineFunction","arrowFunction","arrowFunctionSingle"],((e,t,n,i,r,s)=>{const o="function"!==t&&"inlineFunction"!==t,a=o&&!i[i.length-1],c=o?2:3,p=!!i[1],l=i[c]?i[c].replace(/\s+/g,"").split(/,/g):[];o||l.unshift((i[2]||"").trimStart());let f=!1;l.forEach((e=>{if(f)throw new SyntaxError("Rest parameter must be last formal parameter");e.startsWith("...")&&(f=!0)})),l.unshift(p);const u=(a?"return ":"")+restOfExp(e,n.substring(i[0].length),a?[/^[,;\)\}\]]/]:[/^}/]);s.lispTree=lispify(e,n.substring(i[0].length+u.length+1),expectTypes[r].next,new Lisp({op:o?"arrowFunc":t,a:toLispArray(l),b:e.eager?lispifyFunction(u,e):u}))}));const iteratorRegex=/^((let|var|const)\s+)?\s*([a-zA-Z\$_][a-zA-Z\d\$_]*)\s+(in|of)\s+/;setLispType(["for","do","while"],((e,t,n,i,r,s)=>{let o,a,c=n.indexOf("(")+1,p=!0,l=toLispArray([]),f=!1,u=!0,d=!0;switch(t){case"while":let t=restOfExp(e,n.substring(c),[],"(");o=lispifyExpr(e,t),a=restOfExp(e,n.substring(c+t.length+1)).trim(),"{"===a[0]&&(a=a.slice(1,-1));break;case"for":let i,r=[],s="";for(let t=0;t<3&&(s=restOfExp(e,n.substring(c),[/^[;\)]/]),r.push(s.trim()),c+=s.length+1,")"!==n[c-1]);t++);if(1===r.length&&(i=iteratorRegex.exec(r[0])))"of"===i[4]?(l=toLispArray([lispify(e,"let $$obj = "+r[0].substring(i[0].length),["initialize"]),ofStart2,ofStart3]),o=ofCondition,d=ofStep,f=lispify(e,(i[1]||"let ")+i[3]+" = $$next.value",["initialize"])):(l=toLispArray([lispify(e,"let $$obj = "+r[0].substring(i[0].length),["initialize"]),inStart2,inStart3]),d=inStep,o=inCondition,f=lispify(e,(i[1]||"let ")+i[3]+" = $$keys[$$keyIndex]",["initialize"]));else{if(3!==r.length)throw new SyntaxError("Invalid for loop definition");p=lispifyExpr(e,r.shift(),startingExecpted),o=lispifyExpr(e,r.shift()),d=lispifyExpr(e,r.shift())}a=restOfExp(e,n.substring(c)).trim(),"{"===a[0]&&(a=a.slice(1,-1));break;case"do":u=!1;const h=n.indexOf("{")+1;a=restOfExp(e,n.substring(h),[],"{"),o=lispifyExpr(e,restOfExp(e,n.substring(n.indexOf("(",h+a.length)+1),[],"("))}const h=[u,l,p,d,o,f];h.lisp=!0,s.lispTree=new Lisp({op:"loop",a:h,b:lispifyBlock(a,e)})})),setLispType(["block"],((e,t,n,i,r,s)=>{s.lispTree=lispifyBlock(restOfExp(e,n.substring(1),[],"{"),e)})),setLispType(["loopAction"],((e,t,n,i,r,s)=>{s.lispTree=new Lisp({op:"loopAction",a:i[1]})}));const catchReg=/^\s*(catch\s*(\(\s*([a-zA-Z\$_][a-zA-Z\d\$_]*)\s*\))?|finally)\s*\{/;setLispType(["try"],((e,t,n,i,r,s)=>{const o=restOfExp(e,n.substring(i[0].length),[],"{");let a,c,p,l=catchReg.exec(n.substring(i[0].length+o.length+1)),f=0;l[1].startsWith("catch")?(l=catchReg.exec(n.substring(i[0].length+o.length+1)),c=l[2],p=restOfExp(e,n.substring(i[0].length+o.length+1+l[0].length),[],"{"),f=i[0].length+o.length+1+l[0].length+p.length+1,(l=catchReg.exec(n.substring(f)))&&l[1].startsWith("finally")&&(a=restOfExp(e,n.substring(f+l[0].length),[],"{"))):a=restOfExp(e,n.substring(i[0].length+o.length+1+l[0].length),[],"{");const u=[c,lispifyBlock(insertSemicolons(e,p||"",!1),e),lispifyBlock(insertSemicolons(e,a||"",!1),e)];u.lisp=!0,s.lispTree=new Lisp({op:"try",a:lispifyBlock(insertSemicolons(e,o,!1),e),b:u})})),setLispType(["void","await","throw"],((e,t,n,i,r,s)=>{const o=restOfExp(e,n.substring(i[0].length),[/^[^\s\.\w\d\$]/]);s.lispTree=lispify(e,n.substring(i[0].length+o.length),expectTypes[r].next,new Lisp({op:t,a:lispify(e,o)}))})),setLispType(["new"],((e,t,n,i,r,s)=>{let o=i[0].length;const a=restOfExp(e,n.substring(o),[],void 0,"(");o+=a.length+1;const c=[];if("("===n[o-1]){const t=restOfExp(e,n.substring(o),[],"(");let i;o+=t.length+1;let r=0;for(;i=restOfExp(e,t.substring(r),[/^,/]);)r+=i.length+1,c.push(i.trim())}s.lispTree=lispify(e,n.substring(o),expectTypes.expEdge.next,new Lisp({op:t,a:lispify(e,a,expectTypes.initialize.next),b:toLispArray(c.map((t=>lispify(e,t,expectTypes.initialize.next))))}))}));const ofStart2=lispify(void 0,"let $$iterator = $$obj[Symbol.iterator]()",["initialize"]),ofStart3=lispify(void 0,"let $$next = $$iterator.next()",["initialize"]),ofCondition=lispify(void 0,"return !$$next.done",["initialize"]),ofStep=lispify(void 0,"$$next = $$iterator.next()"),inStart2=lispify(void 0,"let $$keys = Object.keys($$obj)",["initialize"]),inStart3=lispify(void 0,"let $$keyIndex = 0",["initialize"]),inStep=lispify(void 0,"$$keyIndex++"),inCondition=lispify(void 0,"return $$keyIndex < $$keys.length",["initialize"]),startingExecpted=["initialize","expSingle","value","modifier","prop","incrementerBefore","expEnd"];var lastType,lastPart;function lispify(e,t,n,i){if(n=n||expectTypes.initialize.next,void 0===t)return i;if(!(t=t.trimStart()).length&&!n.includes("expEnd"))throw new SyntaxError("Unexpected end of expression: "+lastPart);if(!t)return i;let r,s={lispTree:i};for(let i of n)if("expEnd"!==i){for(let n in expectTypes[i].types)if("expEnd"!==n&&(r=expectTypes[i].types[n].exec(t))){lastType=n,lastPart=t,lispTypes.get(n)(e,n,t,r,i,s);break}if(r)break}if(!r&&t.length)throw SyntaxError(`Unexpected token (${lastType}): ${t.substring(0,40)}`);return s.lispTree}function lispifyExpr(e,t,n){if(!t.trim())return;let i,r=[],s=0;for(n=n||expectTypes.initialize.next;i=restOfExp(e,t.substring(s),[/^,/]);)r.push(i.trimStart()),s+=i.length+1;if(1===r.length)return lispify(e,t,n);if(n===startingExecpted){let i=expectTypes.initialize.types.initialize.exec(r[0]);if(i)return toLispArray(r.map(((t,n)=>lispify(e,n?i[1]+" "+t:t,["initialize"]))));if(expectTypes.initialize.types.return.exec(r[0]))return lispify(e,t,n)}const o=toLispArray(r.map(((t,i)=>lispify(e,t,n))));return new Lisp({op:"multi",a:o})}function lispifyBlock(e,t){if(!(e=insertSemicolons(t,e,!1)).trim())return toLispArray([]);let n,i=[],r=0;for(;n=restOfExp(t,e.substring(r),[/^;/]);)i.push(n.trim()),r+=n.length+1;return toLispArray(i.filter(Boolean).map(((e,n)=>lispifyExpr(t,e,startingExecpted))).flat())}function lispifyFunction(e,t){if(!e.trim())return toLispArray([]);const n=lispifyBlock(e,t);let i=toLispArray([]);return hoist(n,i),toLispArray(i.concat(n))}function hoist(e,t){if(Array.isArray(e)){const n=[];for(let i of e)hoist(i,t)||n.push(i);n.length!==e.length&&(e.length=0,e.push(...n))}else if(e instanceof Lisp)if("try"===e.op||"if"===e.op||"loop"===e.op||"switch"===e.op)hoist(e.a,t),hoist(e.b,t);else if("var"===e.op)t.push(new Lisp({op:"var",a:e.a}));else if("function"===e.op&&e.a[1])return t.push(e),!0;return!1}const edgesForInsertion=[/^([\w\$]|\+\+|\-\-)\s*\r?\n\s*([\w\$\+\-])/,/^([^\w\$](return|continue|break|throw))\s*\r?\n\s*[^\s]/],closingsForInsertion=[/^([\)\]])\s*\r?\n\s*([\w\$\{\+\-])/,/^(\})\s*\r?\n?\s*([\(])/,/^(\})\s*(\r?\n)?\s*([\w\[\+\-])/],closingsNoInsertion=/^(\})\s*(catch|finally|else|while|instanceof)(?![\w\$])/,whileEnding=/^\}\s*while/;function insertSemicolons(e,t,n){let i=t,r="",s=[],o={};for(;r=restOfExp(e,i,edgesForInsertion,void 0,void 0,n?void 0:closingsForInsertion,o,!0);)s.push(r),closingsNoInsertion.test(i.substring(r.length-1))?"do"!==o.word&&whileEnding.test(i.substring(r.length-1))&&s.push(";"):s.push(";"),i=i.substring(r.length);return s.pop(),s.join("")}const oneLinerBlocks=/[^\w\$](if|do)(?![\w\$])/g;function convertOneLiners(e,t){let n,i=0,r=[];for(;n=oneLinerBlocks.exec(t);){let s=t.substring(n.index+n[0].length),o=n.index+n[0].length;if("if"===n[1]){let a=s.indexOf("(")+1;o+=a;let c=restOfExp(e,s.substring(a),[],"(");oneLinerBlocks.lastIndex=n.index+a+c.length+1,r.push(t.substring(i,o),[c],")"),o+=c.length+1}else r.push(t.substring(i,o));if(o+=/^\s*/.exec(t.substring(o))[0].length,s=t.substring(o),"{"!==s[0]){let t=restOfExp(e,s,[/^([;\)\]\}]|\r?\n)/]),a=0;";"===s[t.length]&&(a=1),r.push("{",t,"}");let c=s.substring(t.length+a);"if"!==n[1]||/^\s*else(?![\w\$])/.test(c)||r.push(";"),i=o+t.length+a}else i=o}r.push(t.substring(i));for(let t of r)if(t instanceof Array){let n=convertOneLiners(e,t[0]);t.length=0,t.push(n)}return r.flat().join("")}function checkRegex(e){let t=1,n=!1,i=!1,r=!1;for(;t<e.length&&!i&&!r;)i="/"===e[t]&&!n,n="\\"===e[t]&&!n,r="\n"===e[t],t++;let s=e.substring(t);if(r=r||!i||/^\s*\d/.test(s),r)return null;let o=/^[a-z]*/.exec(s);return/^\s+[\w\$]/.test(e.substring(t+o[0].length))?null:{regex:e.substring(1,t-1),flags:o&&o[0]||"",length:t+(o&&o[0].length||0)}}const notDivide=/(typeof|delete|instanceof|return|in|of|throw|new|void|do|if)$/,possibleDivide=/^([\w\$\]\)]|\+\+|\-\-)[^\w\$\]\)\+\-]/;function extractConstants(e,t,n=""){let i,r,s=[],o=!1,a="",c=-1,p=toLispArray([]),l="";const f=[],u=[];let d;for(var h=0;h<t.length;h++)if(l=t[h],a)l===a&&("*"===a&&"/"===t[h+1]?(a="",h++):"\n"===a&&(a=""));else{if(o){o=!1,s.push(l);continue}if(i)if("`"===i&&"$"===l&&"{"===t[h+1]){let n=extractConstants(e,t.substring(h+2),"{");p.push(n.str),s.push(`\${${p.length-1}}`),h+=n.length+2}else i===l?("`"===i?(e.literals.push({op:"literal",a:unraw(s.join("")),b:p}),f.push(`\`${e.literals.length-1}\``)):(e.strings.push(unraw(s.join(""))),f.push(`"${e.strings.length-1}"`)),i=null,s=[]):s.push(l);else{if("'"===l||'"'===l||"`"===l)p=toLispArray([]),i=l;else{if(closings[n]===l&&!u.length)return{str:f.join(""),length:h};closings[l]?(u.push(l),f.push(l)):closings[u[u.length-1]]===l?(u.pop(),f.push(l)):"/"!==l||"*"!==t[h+1]&&"/"!==t[h+1]?"/"===l&&!d&&(r=checkRegex(t.substring(h)))?(e.regexes.push(r),f.push(`/${e.regexes.length-1}/r`),h+=r.length-1):f.push(l):(a="*"===t[h+1]?"*":"\n",c=h)}d&&space.test(l)||(d=possibleDivide.exec(t.substring(h)))&&notDivide.test(t.substring(0,h+d[1].length))&&(d=null)}o=i&&"\\"===l}if(a&&"*"===a)throw new SyntaxError("Unclosed comment '/*': "+t.substring(c));return{str:f.join(""),length:h}}function parse(e,t=!1){if("string"!=typeof e)throw new ParseError("Cannot parse "+e,e);let n=" "+e;const i={strings:[],literals:[],regexes:[],eager:t};n=extractConstants(i,n).str,n=insertSemicolons(i,n,!0),n=convertOneLiners(i,n);try{for(let e of i.literals)e.b=toLispArray(e.b.map((e=>lispifyExpr(i,e))));return{tree:lispifyFunction(n,i),constants:i}}catch(e){throw e}}class ExecReturn{constructor(e,t,n,i=!1,r=!1){this.auditReport=e,this.result=t,this.returned=n,this.breakLoop=i,this.continueLoop=r}}class Prop{constructor(e,t,n=!1,i=!1,r=!1){this.context=e,this.prop=t,this.isConst=n,this.isGlobal=i,this.isVariable=r}}const reservedWords=new Set(["instanceof","typeof","return","try","catch","if","finally","else","in","of","var","let","const","for","delete","false","true","while","do","break","continue","new","function","async","await","switch","case"]);var VarType;!function(e){e.let="let",e.const="const",e.var="var"}(VarType||(VarType={}));class Scope{constructor(e,t={},n){this.const=new Set,this.let=new Set;const i=void 0!==n||null===e;this.parent=e,this.allVars=t,this.let=i?this.let:new Set(Object.keys(t)),this.var=i?new Set(Object.keys(t)):this.var,this.globals=null===e?new Set(Object.keys(t)):new Set,this.functionThis=n}get(e,t=!1){if("this"===e&&void 0!==this.functionThis)return new Prop({this:this.functionThis},e,!0,!1,!0);if(reservedWords.has(e))throw new SyntaxError("Unexepected token '"+e+"'");if(null===this.parent||!t||void 0!==this.functionThis){if(this.globals.has(e))return new Prop(this.functionThis,e,!1,!0,!0);if(e in this.allVars&&(!(e in{})||this.allVars.hasOwnProperty(e)))return new Prop(this.allVars,e,this.const.has(e),this.globals.has(e),!0);if(null===this.parent)return new Prop(void 0,e)}return this.parent.get(e,t)}set(e,t){if("this"===e)throw new SyntaxError('"this" cannot be assigned');if(reservedWords.has(e))throw new SyntaxError("Unexepected token '"+e+"'");let n=this.get(e);if(void 0===n.context)throw new ReferenceError(`Variable '${e}' was not declared.`);if(n.isConst)throw new TypeError(`Cannot assign to const variable '${e}'`);if(n.isGlobal)throw new SandboxError(`Cannot override global variable '${e}'`);return n.context[n]=t,n}declare(e,t=null,n,i=!1){if("this"===e)throw new SyntaxError('"this" cannot be declared');if(reservedWords.has(e))throw new SyntaxError("Unexepected token '"+e+"'");if("var"===t&&void 0===this.functionThis&&null!==this.parent)return this.parent.declare(e,t,n,i);if((!this[t].has(e)||"const"===t||this.globals.has(e))&&e in this.allVars)throw new SandboxError(`Identifier '${e}' has already been declared`);return i&&this.globals.add(e),this[t].add(e),this.allVars[e]=n,new Prop(this.allVars,e,this.const.has(e),i)}}class SandboxError extends Error{}let currentTicks;function sandboxFunction(e){return function SandboxFunction(...t){let n=parse(t.pop()||"");return createFunction(t,n.tree,currentTicks,{ctx:e,constants:n.constants},void 0,"anonymous")}}const sandboxedFunctions=new WeakSet;function createFunction(e,t,n,i,r,s){let o=function(...o){const a={};e.forEach(((e,t)=>{e.startsWith("...")?a[e.substring(3)]=o.slice(t):a[e]=o[t]}));return executeTree(n,i,t,void 0===r?[]:[new Scope(r,a,void 0===s?void 0:this)]).result};return sandboxedFunctions.add(o),o}function createFunctionAsync(e,t,n,i,r,s){let o=async function(...o){const a={};e.forEach(((e,t)=>{e.startsWith("...")?a[e.substring(3)]=o.slice(t):a[e]=o[t]}));return(await executeTreeAsync(n,i,t,void 0===r?[]:[new Scope(r,a,void 0===s?void 0:this)])).result};return sandboxedFunctions.add(o),o}function sandboxedEval(e){return function(t){return e(t)()}}function sandboxedSetTimeout(e){return function(t,...n){return"string"!=typeof t?setTimeout(t,...n):setTimeout(e(t),...n)}}function sandboxedSetInterval(e){return function(t,...n){return"string"!=typeof t?setInterval(t,...n):setInterval(e(t),...n)}}function assignCheck(e,t,n="assign"){var i,r,s,o;if(void 0===e.context)throw new ReferenceError(`Cannot ${n} value to undefined.`);if("object"!=typeof e.context&&"function"!=typeof e.context)throw new SyntaxError(`Cannot ${n} value to a primitive.`);if(e.isConst)throw new TypeError(`Cannot set value to const variable '${e.prop}'`);if(e.isGlobal)throw new SandboxError(`Cannot ${n} property '${e.prop}' of a global object`);if("function"==typeof e.context[e.prop]&&!e.context.hasOwnProperty(e.prop))throw new SandboxError(`Override prototype property '${e.prop}' not allowed`);"delete"===n?e.context.hasOwnProperty(e.prop)&&(null===(i=t.ctx.changeSubscriptions.get(e.context))||void 0===i||i.forEach((t=>t({type:"delete",prop:e.prop})))):e.context.hasOwnProperty(e.prop)?null===(s=null===(r=t.ctx.setSubscriptions.get(e.context))||void 0===r?void 0:r.get(e.prop))||void 0===s||s.forEach((e=>e({type:"replace"}))):null===(o=t.ctx.changeSubscriptions.get(e.context))||void 0===o||o.forEach((t=>t({type:"create",prop:e.prop})))}const arrayChange=new Set([[].push,[].pop,[].shift,[].unshift,[].splice,[].reverse,[].sort,[].copyWithin]),literalRegex=/(\$\$)*(\$)?\${(\d+)}/g;let ops2={prop:(e,t,n,i,r,s,o,a)=>{if(null===i)throw new TypeError(`Cannot get property ${r} of null`);const c=typeof i;if("undefined"===c&&void 0===s){let e=a.get(r);if(void 0===e.context)throw new ReferenceError(r+" is not defined");if(e.context===o.ctx.sandboxGlobal){o.ctx.options.audit&&o.ctx.auditReport.globalsAccess.add(r);const e=o.ctx.globalsWhitelist.has(o.ctx.sandboxGlobal[r])?o.ctx.evals.get(o.ctx.sandboxGlobal[r]):void 0;if(e)return void t(void 0,e)}return e.context&&e.context[r]===globalThis?void t(void 0,o.ctx.globalScope.get("this")):(o.ctx.getSubscriptions.forEach((t=>t(e.context,e.prop))),void t(void 0,e))}if(void 0===i)throw new SandboxError("Cannot get property '"+r+"' of undefined");if("object"!==c)"number"===c?i=new Number(i):"string"===c?i=new String(i):"boolean"===c&&(i=new Boolean(i));else if(void 0===i.hasOwnProperty)return void t(void 0,new Prop(void 0,r));const p="function"===c;let l=p||!(i.hasOwnProperty(r)||"number"==typeof r);if(o.ctx.options.audit&&l&&"string"==typeof r){let e=i.constructor.prototype;do{e.hasOwnProperty(r)&&(o.ctx.auditReport.prototypeAccess[e.constructor.name]||(o.ctx.auditReport.prototypeAccess[e.constructor.name]=new Set),o.ctx.auditReport.prototypeAccess[e.constructor.name].add(r))}while(e=Object.getPrototypeOf(e))}if(l)if(p){if(!["name","length","constructor"].includes(r)&&i.hasOwnProperty(r)){const e=o.ctx.options.prototypeWhitelist.get(i),n=o.ctx.options.prototypeReplacements.get(i);if(n)return void t(void 0,new Prop(n(i,!0),r));if(!e||e.size&&!e.has(r))throw new SandboxError(`Static method or property access not permitted: ${i.name}.${r}`)}}else if("constructor"!==r){let e=i.constructor.prototype;do{if(e.hasOwnProperty(r)){const n=o.ctx.options.prototypeWhitelist.get(e.constructor),s=o.ctx.options.prototypeReplacements.get(e.constuctor);if(s)return void t(void 0,new Prop(s(i,!1),r));if(n&&(!n.size||n.has(r)))break;throw new SandboxError(`Method or property access not permitted: ${e.constructor.name}.${r}`)}}while(e=Object.getPrototypeOf(e))}if(o.ctx.evals.has(i[r]))return void t(void 0,o.ctx.evals.get(i[r]));if(i[r]===globalThis)return void t(void 0,o.ctx.globalScope.get("this"));let f=s.isGlobal||p&&!sandboxedFunctions.has(i)||o.ctx.globalsWhitelist.has(i);f||o.ctx.getSubscriptions.forEach((e=>e(i,r))),t(void 0,new Prop(i,r,!1,f))},call:(e,t,n,i,r,s,o,a)=>{if(o.ctx.options.forbidMethodCalls)throw new SandboxError("Method calls are not allowed");if("function"!=typeof i)throw new TypeError(s.prop+" is not a function");execMany(n,e,toLispArray(r.map((e=>e instanceof SpreadArray?[...e.item]:[e])).flat()),((e,n)=>{var i;if(e)t(e);else if("function"!=typeof s){if(s.context[s.prop]===JSON.stringify&&o.ctx.getSubscriptions.size){const e=new Set,t=n=>{if(n&&"object"==typeof n&&!e.has(n)){e.add(n);for(let e in n)o.ctx.getSubscriptions.forEach((t=>t(n,e))),t(n[e])}};t(n[0])}if(s.context instanceof Array&&arrayChange.has(s.context[s.prop])&&o.ctx.changeSubscriptions.get(s.context)){let e,t=!1;if("push"===s.prop)e={type:"push",added:n},t=!!n.length;else if("pop"===s.prop)e={type:"pop",removed:s.context.slice(-1)},t=!!e.removed.length;else if("shift"===s.prop)e={type:"shift",removed:s.context.slice(0,1)},t=!!e.removed.length;else if("unshift"===s.prop)e={type:"unshift",added:n},t=!!n.length;else if("splice"===s.prop)e={type:"splice",startIndex:n[0],deleteCount:void 0===n[1]?s.context.length:n[1],added:n.slice(2),removed:s.context.slice(n[0],void 0===n[1]?void 0:n[0]+n[1])},t=!!e.added.length||!!e.removed.length;else if("reverse"===s.prop||"sort"===s.prop)e={type:s.prop},t=!!s.context.length;else if("copyWithin"===s.prop){let i=void 0===n[2]?s.context.length-n[1]:Math.min(s.context.length,n[2]-n[1]);e={type:"copyWithin",startIndex:n[0],endIndex:n[0]+i,added:s.context.slice(n[1],n[1]+i),removed:s.context.slice(n[0],n[0]+i)},t=!!e.added.length||!!e.removed.length}t&&(null===(i=o.ctx.changeSubscriptions.get(s.context))||void 0===i||i.forEach((t=>t(e))))}t(void 0,s.context[s.prop](...n))}else t(void 0,s(...n))}),a,o)},createObject:(e,t,n,i,r,s,o,a)=>{let c={};for(let e of r)e instanceof SpreadObject?c={...c,...e.item}:c[e.key]=e.val;t(void 0,c)},keyVal:(e,t,n,i,r)=>t(void 0,new KeyVal(i,r)),createArray:(e,t,n,i,r,s,o,a)=>{execMany(n,e,toLispArray(r.map((e=>e instanceof SpreadArray?[...e.item]:[e])).flat()),t,a,o)},group:(e,t,n,i,r)=>t(void 0,r),string:(e,t,n,i,r,s,o)=>t(void 0,o.constants.strings[r]),regex:(e,t,n,i,r,s,o)=>{const a=o.constants.regexes[r];if(!o.ctx.globalsWhitelist.has(RegExp))throw new SandboxError("Regex not permitted");t(void 0,new RegExp(a.regex,a.flags))},literal:(e,t,n,i,r,s,o,a)=>{let c,p=o.constants.literals[r].a,l=toLispArray([]),f=[];for(;c=literalRegex.exec(p);)c[2]||(l.push(o.constants.literals[r].b[parseInt(c[3],10)]),f.push(c[3]));execMany(n,e,l,((e,n)=>{const i={};if(e)t(e);else{for(let e in f){const t=f[e];i[t]=n[e]}t(void 0,p.replace(/(\\\\)*(\\)?\${(\d+)}/g,((e,t,n,r)=>{if(n)return e;let s=i[r];return s=s instanceof Prop?s.context[s.prop]:s,(t||"")+""+s})))}}),a,o)},spreadArray:(e,t,n,i,r,s,o,a)=>{e(n,r,a,o,((e,n)=>{e?t(e):t(void 0,new SpreadArray(n))}))},spreadObject:(e,t,n,i,r,s,o,a)=>{e(n,r,a,o,((e,n)=>{e?t(e):t(void 0,new SpreadObject(n))}))},"!":(e,t,n,i,r)=>t(void 0,!r),"~":(e,t,n,i,r)=>t(void 0,~r),"++$":(e,t,n,i,r,s,o)=>{assignCheck(s,o),t(void 0,++s.context[s.prop])},"$++":(e,t,n,i,r,s,o)=>{assignCheck(s,o),t(void 0,s.context[s.prop]++)},"--$":(e,t,n,i,r,s,o)=>{assignCheck(s,o),t(void 0,--s.context[s.prop])},"$--":(e,t,n,i,r,s,o)=>{assignCheck(s,o),t(void 0,s.context[s.prop]--)},"=":(e,t,n,i,r,s,o)=>{assignCheck(s,o),s.context[s.prop]=r,t(void 0,new Prop(s.context,s.prop,!1,s.isGlobal))},"+=":(e,t,n,i,r,s,o)=>{assignCheck(s,o),t(void 0,s.context[s.prop]+=r)},"-=":(e,t,n,i,r,s,o)=>{assignCheck(s,o),t(void 0,s.context[s.prop]-=r)},"/=":(e,t,n,i,r,s,o)=>{assignCheck(s,o),t(void 0,s.context[s.prop]/=r)},"*=":(e,t,n,i,r,s,o)=>{assignCheck(s,o),t(void 0,s.context[s.prop]*=r)},"**=":(e,t,n,i,r,s,o)=>{assignCheck(s,o),t(void 0,s.context[s.prop]**=r)},"%=":(e,t,n,i,r,s,o)=>{assignCheck(s,o),t(void 0,s.context[s.prop]%=r)},"^=":(e,t,n,i,r,s,o)=>{assignCheck(s,o),t(void 0,s.context[s.prop]^=r)},"&=":(e,t,n,i,r,s,o)=>{assignCheck(s,o),t(void 0,s.context[s.prop]&=r)},"|=":(e,t,n,i,r,s,o)=>{assignCheck(s,o),t(void 0,s.context[s.prop]|=r)},"<<=":(e,t,n,i,r,s,o)=>{assignCheck(s,o),t(void 0,s.context[s.prop]<<=r)},">>=":(e,t,n,i,r,s,o)=>{assignCheck(s,o),t(void 0,s.context[s.prop]>>=r)},">>>=":(e,t,n,i,r,s,o)=>{assignCheck(s,o),t(void 0,s.context[s.prop]>>=r)},"?":(e,t,n,i,r)=>{if(!(r instanceof If))throw new SyntaxError("Invalid inline if");t(void 0,i?r.t:r.f)},">":(e,t,n,i,r)=>t(void 0,i>r),"<":(e,t,n,i,r)=>t(void 0,i<r),">=":(e,t,n,i,r)=>t(void 0,i>=r),"<=":(e,t,n,i,r)=>t(void 0,i<=r),"==":(e,t,n,i,r)=>t(void 0,i==r),"===":(e,t,n,i,r)=>t(void 0,i===r),"!=":(e,t,n,i,r)=>t(void 0,i!=r),"!==":(e,t,n,i,r)=>t(void 0,i!==r),"&&":(e,t,n,i,r)=>t(void 0,i&&r),"||":(e,t,n,i,r)=>t(void 0,i||r),"&":(e,t,n,i,r)=>t(void 0,i&r),"|":(e,t,n,i,r)=>t(void 0,i|r),":":(e,t,n,i,r)=>t(void 0,new If(i,r)),"+":(e,t,n,i,r)=>t(void 0,i+r),"-":(e,t,n,i,r)=>t(void 0,i-r),"$+":(e,t,n,i,r)=>t(void 0,+r),"$-":(e,t,n,i,r)=>t(void 0,-r),"/":(e,t,n,i,r)=>t(void 0,i/r),"^":(e,t,n,i,r)=>t(void 0,i^r),"*":(e,t,n,i,r)=>t(void 0,i*r),"%":(e,t,n,i,r)=>t(void 0,i%r),"<<":(e,t,n,i,r)=>t(void 0,i<<r),">>":(e,t,n,i,r)=>t(void 0,i>>r),">>>":(e,t,n,i,r)=>t(void 0,i>>>r),typeof:(e,t,n,i,r)=>t(void 0,typeof r),instanceof:(e,t,n,i,r)=>t(void 0,i instanceof r),in:(e,t,n,i,r)=>t(void 0,i in r),delete:(e,t,n,i,r,s,o,a,c)=>{void 0!==c.context?(assignCheck(c,o,"delete"),c.isVariable?t(void 0,!1):t(void 0,delete c.context[c.prop])):t(void 0,!0)},return:(e,t,n,i,r,s,o)=>t(void 0,r),var:(e,t,n,i,r,s,o,a,c)=>{e(n,r,a,o,((e,n)=>{e?t(e):t(void 0,a.declare(i,VarType.var,n))}))},let:(e,t,n,i,r,s,o,a,c)=>{e(n,r,a,o,((e,n)=>{e?t(e):t(void 0,a.declare(i,VarType.let,n,c&&c.isGlobal))}))},const:(e,t,n,i,r,s,o,a,c)=>{e(n,r,a,o,((e,n)=>{e?t(e):t(void 0,a.declare(i,VarType.const,n))}))},arrowFunc:(e,t,n,i,r,s,o,a)=>{i=[...i],"string"==typeof s.b&&(s.b=r=lispifyFunction(s.b,o.constants)),i.shift()?t(void 0,createFunctionAsync(i,r,n,o,a)):t(void 0,createFunction(i,r,n,o,a))},function:(e,t,n,i,r,s,o,a)=>{"string"==typeof s.b&&(s.b=r=lispifyFunction(s.b,o.constants));let c,p=i.shift(),l=i.shift();c=p?createFunctionAsync(i,r,n,o,a,l):createFunction(i,r,n,o,a,l),l&&a.declare(l,VarType.var,c),t(void 0,c)},inlineFunction:(e,t,n,i,r,s,o,a)=>{"string"==typeof s.b&&(s.b=r=lispifyFunction(s.b,o.constants));let c,p=i.shift(),l=i.shift();l&&(a=new Scope(a,{})),c=p?createFunctionAsync(i,r,n,o,a,l):createFunction(i,r,n,o,a,l),l&&a.declare(l,VarType.let,c),t(void 0,c)},loop:(e,t,n,i,r,s,o,a)=>{const[c,p,l,f,u,d]=i;let h=!0;const x=new Scope(a,{}),y=new Scope(x,{});if(e===execAsync)(async()=>{for(await asyncDone((t=>e(n,l,x,o,t))),await asyncDone((t=>e(n,p,y,o,t))),c&&(h=(await asyncDone((t=>e(n,u,y,o,t)))).result);h;){let i={};await asyncDone((t=>e(n,d,new Scope(y,i),o,t)));let s=await executeTreeAsync(n,o,r,[new Scope(x,i)],"loop");if(s instanceof ExecReturn&&s.returned)return void t(void 0,s);if(s instanceof ExecReturn&&s.breakLoop)break;await asyncDone((t=>e(n,f,y,o,t))),h=(await asyncDone((t=>e(n,u,y,o,t)))).result}t()})().catch(t);else{for(syncDone((t=>e(n,l,x,o,t))),syncDone((t=>e(n,p,y,o,t))),c&&(h=syncDone((t=>e(n,u,y,o,t))).result);h;){let i={};syncDone((t=>e(n,d,new Scope(y,i),o,t)));let s=executeTree(n,o,r,[new Scope(x,i)],"loop");if(s instanceof ExecReturn&&s.returned)return void t(void 0,s);if(s instanceof ExecReturn&&s.breakLoop)break;syncDone((t=>e(n,f,y,o,t))),h=syncDone((t=>e(n,u,y,o,t))).result}t()}},loopAction:(e,t,n,i,r,s,o,a,c,p)=>{if("switch"===p&&"continue"===i||!p)throw new SandboxError("Illegal "+i+" statement");t(void 0,new ExecReturn(o.ctx.auditReport,void 0,!1,"break"===i,"continue"===i))},if:(e,t,n,i,r,s,o,a,c,p)=>{if(!(r instanceof If))throw new SyntaxError("Invalid if");e(n,i,a,o,((i,s)=>{i?t(i):executeTreeWithDone(e,t,n,o,s?r.t:r.f,[new Scope(a)],p)}))},switch:(e,t,n,i,r,s,o,a)=>{e(n,i,a,o,((i,s)=>{if(i)t(i);else if(e===execSync){let i,c=!1;for(let p of r)if(c||(c=!p.a||s===valueOrProp(syncDone((t=>e(n,p.a,a,o,t))).result))){if(!p.b)continue;if(i=executeTree(n,o,p.b,[a],"switch"),i.breakLoop)break;if(i.returned)return void t(void 0,i);if(!p.a)break}t()}else(async()=>{let i,c=!1;for(let p of r)if(c||(c=!p.a||s===valueOrProp((await asyncDone((t=>e(n,p.a,a,o,t)))).result))){if(!p.b)continue;if(i=await executeTreeAsync(n,o,p.b,[a],"switch"),i.breakLoop)break;if(i.returned)return void t(void 0,i);if(!p.a)break}t()})().catch(t)}))},try:(e,t,n,i,r,s,o,a,c,p)=>{const[l,f,u]=r;executeTreeWithDone(e,((i,r)=>{executeTreeWithDone(e,(s=>{s?t(s):i?executeTreeWithDone(e,t,n,o,f,[new Scope(a)],p):t(void 0,r)}),n,o,u,[new Scope(a,{})])}),n,o,i,[new Scope(a)],p)},void:(e,t,n,i)=>{t()},new:(e,t,n,i,r,s,o)=>{if(!o.ctx.globalsWhitelist.has(i)&&!sandboxedFunctions.has(i))throw new SandboxError("Object construction not allowed: "+i.constructor.name);t(void 0,new i(...r))},throw:(e,t,n,i)=>{t(i)},multi:(e,t,n,i,r,s,o,a)=>t(void 0,i.pop())},ops=new Map;for(let e in ops2)ops.set(e,ops2[e]);function valueOrProp(e){return e instanceof Prop?e.context[e.prop]:e}function execMany(e,t,n,i,r,s,o){t===execSync?_execManySync(e,t,n,i,r,s,o):_execManyAsync(e,t,n,i,r,s,o).catch(i)}function _execManySync(e,t,n,i,r,s,o){let a=[];for(let c=0;c<n.length;c++){let p;try{p=syncDone((i=>t(e,n[c],r,s,i,o))).result}catch(e){return void i(e)}if(p instanceof ExecReturn&&(p.returned||p.breakLoop||p.continueLoop))return void i(void 0,p);a.push(p)}i(void 0,a)}async function _execManyAsync(e,t,n,i,r,s,o){let a=[];for(let c=0;c<n.length;c++){let p;try{p=(await asyncDone((i=>t(e,n[c],r,s,i,o)))).result}catch(e){return void i(e)}if(p instanceof ExecReturn&&(p.returned||p.breakLoop||p.continueLoop))return void i(void 0,p);a.push(p)}i(void 0,a)}function asyncDone(e){return new Promise(((t,n)=>{e(((e,i)=>{e?n(e):t({result:i})}))}))}function syncDone(e){let t,n;if(e(((e,i)=>{n=e,t=i})),n)throw n;return{result:t}}function execAsync(e,t,n,i,r,s){return new Promise(((o,a)=>{execWithDone(e,t,n,i,((e,t)=>{r(e,t),o()}),!0,s)}))}function execSync(e,t,n,i,r,s){execWithDone(e,t,n,i,r,!1,s)}function execWithDone(e,t,n,i,r,s,o){const a=s?execAsync:execSync;if(t instanceof Prop)r(void 0,t.context[t.prop]);else if(Array.isArray(t)&&t.lisp)execMany(e,a,t,r,n,i,o);else if(t instanceof Lisp)if(["arrowFunc","function","inlineFunction","loop","try","switch","if"].includes(t.op))try{ops.get(t.op)(a,r,e,t.a,t.b,t,i,n,void 0,o)}catch(e){r(e)}else"await"===t.op?s?execAsync(e,t.a,n,i,(async(e,t)=>{e?r(e):r(void 0,await t)}),o):r(new SandboxError("Illegal use of 'await', must be inside async function")):execWithDone(e,t.a,n,i,((c,p)=>{if(c)return void r(c);let l=p instanceof Prop?p.context?p.context[p.prop]:void 0:p;execWithDone(e,t.b,n,i,((s,c)=>{if(s)return void r(s);let f=c instanceof Prop?c.context?c.context[c.prop]:void 0:c;if(ops.has(t.op))try{ops.get(t.op)(a,r,e,l,f,p,i,n,c,o)}catch(e){r(e)}else r(new SyntaxError("Unknown operator: "+t.op))}),s,o)}),s,o);else r(void 0,t)}function executeTree(e,t,n,i=[],r){return syncDone((s=>executeTreeWithDone(execSync,s,e,t,n,i,r))).result}async function executeTreeAsync(e,t,n,i=[],r){return(await asyncDone((s=>executeTreeWithDone(execAsync,s,e,t,n,i,r)))).result}function executeTreeWithDone(e,t,n,i,r,s=[],o){if(!r)return void t();if(!(r instanceof Array))throw new SyntaxError("Bad execution tree");currentTicks=n;let a,c=i.ctx.globalScope;for(;a=s.shift();)"object"==typeof a&&(c=a instanceof Scope?a:new Scope(c,a,null));i.ctx.options.audit&&!i.ctx.auditReport&&(i.ctx.auditReport={globalsAccess:new Set,prototypeAccess:{}}),e===execSync?_executeWithDoneSync(t,n,i,r,c,o):_executeWithDoneAsync(t,n,i,r,c,o).catch(t)}function _executeWithDoneSync(e,t,n,i,r,s){if(!(i instanceof Array))throw new SyntaxError("Bad execution tree");let o=0;for(o=0;o<i.length;o++){let a,c;const p=i[o];try{execSync(t,p,r,n,((e,t)=>{c=e,a=t}),s)}catch(e){c=e}if(c)return void e(c);if(a instanceof ExecReturn)return void e(void 0,a);if(p instanceof Lisp&&"return"===p.op)return void e(void 0,new ExecReturn(n.ctx.auditReport,a,!0))}e(void 0,new ExecReturn(n.ctx.auditReport,void 0,!1))}async function _executeWithDoneAsync(e,t,n,i,r,s){if(!(i instanceof Array))throw new SyntaxError("Bad execution tree");let o=0;for(o=0;o<i.length;o++){let a,c;const p=i[o];try{await execAsync(t,p,r,n,((e,t)=>{c=e,a=t}),s)}catch(e){c=e}if(c)return void e(c);if(a instanceof ExecReturn)return void e(void 0,a);if(p instanceof Lisp&&"return"===p.op)return void e(void 0,new ExecReturn(n.ctx.auditReport,a,!0))}e(void 0,new ExecReturn(n.ctx.auditReport,void 0,!1))}class SandboxGlobal{constructor(e){if(e===globalThis)return globalThis;for(let t in e)this[t]=e[t]}}class Sandbox{constructor(options){options=Object.assign({audit:!1,forbidMethodCalls:!1,globals:Sandbox.SAFE_GLOBALS,prototypeWhitelist:Sandbox.SAFE_PROTOTYPES,prototypeReplacements:new Map,executionPause:Promise.resolve()},options||{});const sandboxGlobal=new SandboxGlobal(options.globals);this.context={sandbox:this,globalsWhitelist:new Set(Object.values(options.globals)),options:options,globalScope:new Scope(null,options.globals,sandboxGlobal),sandboxGlobal:sandboxGlobal,evals:new Map,getSubscriptions:new Set,setSubscriptions:new WeakMap,changeSubscriptions:new WeakMap};const func=sandboxFunction(this.context);this.context.evals.set(Function,func),this.context.evals.set(eval,sandboxedEval(func)),this.context.evals.set(setTimeout,sandboxedSetTimeout(func)),this.context.evals.set(setInterval,sandboxedSetInterval(func))}static get SAFE_GLOBALS(){return{Function:Function,console:{debug:console.debug,error:console.error,info:console.info,log:console.log,table:console.table,warn:console.warn},isFinite:isFinite,isNaN:isNaN,parseFloat:parseFloat,parseInt:parseInt,decodeURI:decodeURI,decodeURIComponent:decodeURIComponent,encodeURI:encodeURI,encodeURIComponent:encodeURIComponent,escape:escape,unescape:unescape,Boolean:Boolean,Number:Number,String:String,Object:Object,Array:Array,Symbol:Symbol,Error:Error,EvalError:EvalError,RangeError:RangeError,ReferenceError:ReferenceError,SyntaxError:SyntaxError,TypeError:TypeError,URIError:URIError,Int8Array:Int8Array,Uint8Array:Uint8Array,Uint8ClampedArray:Uint8ClampedArray,Int16Array:Int16Array,Uint16Array:Uint16Array,Int32Array:Int32Array,Uint32Array:Uint32Array,Float32Array:Float32Array,Float64Array:Float64Array,Map:Map,Set:Set,WeakMap:WeakMap,WeakSet:WeakSet,Promise:Promise,Intl:Intl,JSON:JSON,Math:Math,Date:Date,RegExp:RegExp}}static get SAFE_PROTOTYPES(){let e=[SandboxGlobal,Function,Boolean,Number,String,Date,Error,Array,Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array,Map,Set,WeakMap,WeakSet,Promise,Symbol,Date,RegExp],t=new Map;return e.forEach((e=>{t.set(e,new Set)})),t.set(Object,new Set(["entries","fromEntries","getOwnPropertyNames","is","keys","hasOwnProperty","isPrototypeOf","propertyIsEnumerable","toLocaleString","toString","valueOf","values"])),t}subscribeGet(e){return this.context.getSubscriptions.add(e),{unsubscribe:()=>this.context.getSubscriptions.delete(e)}}subscribeSet(e,t,n){const i=this.context.setSubscriptions.get(e)||new Map;this.context.setSubscriptions.set(e,i);const r=i.get(t)||new Set;let s;return i.set(t,r),r.add(n),e&&e[t]&&"object"==typeof e[t]&&(s=this.context.changeSubscriptions.get(e[t])||new Set,s.add(n),this.context.changeSubscriptions.set(e[t],s)),{unsubscribe:()=>{r.delete(n),s&&s.delete(n)}}}static audit(e,t=[]){const n={};for(let e of Object.getOwnPropertyNames(globalThis))n[e]=globalThis[e];return new Sandbox({globals:n,audit:!0}).executeTree(parse(e),t)}static parse(e){return parse(e)}executeTree(e,t=[],n=BigInt(0)){return executeTree({ticks:BigInt(0)},{ctx:this.context,constants:e.constants},e.tree,t)}executeTreeAsync(e,t=[],n=BigInt(0)){return executeTreeAsync({ticks:BigInt(0)},{ctx:this.context,constants:e.constants},e.tree,t)}compile(e,t=!1){const n=parse(e,t);return(...e)=>this.executeTree(n,e).result}compileAsync(e,t=!1){const n=parse(e,t);return async(...e)=>(await this.executeTreeAsync(n,e)).result}}export default Sandbox;export{SandboxGlobal};
//# sourceMappingURL=Sandbox.min.js.map
