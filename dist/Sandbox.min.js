function parseHexToInt(e){return!e.match(/[^a-f0-9]/i)?parseInt(e,16):NaN}function validateAndParseHex(e,t,n){const i=parseHexToInt(e);if(Number.isNaN(i)||void 0!==n&&n!==e.length)throw new SyntaxError(t+": "+e);return i}function parseHexadecimalCode(e){const t=validateAndParseHex(e,"Malformed Hexadecimal",2);return String.fromCharCode(t)}function parseUnicodeCode(e,t){const n=validateAndParseHex(e,"Malformed Unicode",4);if(void 0!==t){const e=validateAndParseHex(t,"Malformed Unicode",4);return String.fromCharCode(n,e)}return String.fromCharCode(n)}function isCurlyBraced(e){return"{"===e.charAt(0)&&"}"===e.charAt(e.length-1)}function parseUnicodeCodePointCode(e){if(!isCurlyBraced(e))throw new SyntaxError("Malformed Unicode: +"+e);const t=validateAndParseHex(e.slice(1,-1),"Malformed Unicode");try{return String.fromCodePoint(t)}catch(e){throw e instanceof RangeError?new SyntaxError("Code Point Limit:"+t):e}}const singleCharacterEscapes=new Map([["b","\b"],["f","\f"],["n","\n"],["r","\r"],["t","\t"],["v","\v"],["0","\0"]]);function parseSingleCharacterCode(e){return singleCharacterEscapes.get(e)||e}const escapeMatch=/\\(?:(\\)|x([\s\S]{0,2})|u(\{[^}]*\}?)|u([\s\S]{4})\\u([^{][\s\S]{0,3})|u([\s\S]{0,4})|([0-3]?[0-7]{1,2})|([\s\S])|$)/g;function unraw(e){return e.replace(escapeMatch,(function(e,t,n,i,s,r,o,a,l){if(void 0!==t)return"\\";if(void 0!==n)return parseHexadecimalCode(n);if(void 0!==i)return parseUnicodeCodePointCode(i);if(void 0!==s)return parseUnicodeCode(s,r);if(void 0!==o)return parseUnicodeCode(o);if("0"===a)return"\0";if(void 0!==a)throw new SyntaxError("Octal Deprecation: "+a);if(void 0!==l)return parseSingleCharacterCode(l);throw new SyntaxError("End of string")}))}let lispTypes=new Map;class ParseError extends Error{constructor(e,t){super(e),this.code=t}}class Lisp{constructor(e){this.op=e.op,this.a=e.a,this.b=e.b}}class If{constructor(e,t){this.t=e,this.f=t}}class KeyVal{constructor(e,t){this.key=e,this.val=t}}class SpreadObject{constructor(e){this.item=e}}class SpreadArray{constructor(e){this.item=e}}const inlineIfElse=/^:/,space=/^\s/;let expectTypes={splitter:{types:{split:/^(&&|&(?!&)|\|\||\|(?!\|)|<=|>=|<(?!<)|>(?!>)|!==|!=(?!\=)|===|==(?!\=)|\+(?!\+)|\-(?!\-)|\^|<<|>>(?!>)|>>>|instanceof(?![\w\$\_])|in(?![\w\$\_]))(?!\=)/,op:/^(\/|\*\*|\*(?!\*)|\%)(?!\=)/},next:["modifier","value","prop","incrementerBefore"]},inlineIf:{types:{inlineIf:/^\?/},next:["expEnd"]},assignment:{types:{assignModify:/^(\-=|\+=|\/=|\*\*=|\*=|%=|\^=|\&=|\|=|>>>=|>>=|<<=)/,assign:/^(=)(?!=)/},next:["modifier","value","prop","incrementerBefore"]},incrementerBefore:{types:{incrementerBefore:/^(\+\+|\-\-)/},next:["prop"]},expEdge:{types:{call:/^[\(]/,incrementerAfter:/^(\+\+|\-\-)/},next:["splitter","expEdge","inlineIf","dot","expEnd"]},modifier:{types:{not:/^!/,inverse:/^~/,negative:/^\-(?!\-)/,positive:/^\+(?!\+)/,typeof:/^typeof(?![\w\$\_])/,delete:/^delete(?![\w\$\_])/},next:["modifier","value","prop","incrementerBefore"]},dot:{types:{arrayProp:/^[\[]/,dot:/^\.(?!\.)/},next:["splitter","assignment","expEdge","inlineIf","dot","expEnd"]},prop:{types:{prop:/^[a-zA-Z\$\_][a-zA-Z\d\$\_]*/},next:["splitter","assignment","expEdge","inlineIf","dot","expEnd"]},value:{types:{createObject:/^\{/,createArray:/^\[/,number:/^(0x[\da-f]+|\d+(\.\d+)?(e[\+\-]?\d+)?)/i,string:/^"(\d+)"/,literal:/^`(\d+)`/,regex:/^\/(\d+)\/r(?![\w\$\_])/,boolean:/^(true|false)(?![\w\$\_])/,null:/^null(?![\w\$\_])/,und:/^undefined(?![\w\$\_])/,arrowFunctionSingle:/^(async\s+)?([a-zA-Z\$_][a-zA-Z\d\$_]*)\s*=>\s*({)?/,arrowFunction:/^(async\s*)?\(\s*((\.\.\.)?\s*[a-zA-Z\$_][a-zA-Z\d\$_]*(\s*,\s*(\.\.\.)?\s*[a-zA-Z\$_][a-zA-Z\d\$_]*)*)?\s*\)\s*=>\s*({)?/,inlineFunction:/^(async\s+)?function(\s*[a-zA-Z\$_][a-zA-Z\d\$_]*)?\s*\(\s*((\.\.\.)?\s*[a-zA-Z\$_][a-zA-Z\d\$_]*(\s*,\s*(\.\.\.)?\s*[a-zA-Z\$_][a-zA-Z\d\$_]*)*)?\s*\)\s*{/,group:/^\(/,NaN:/^NaN(?![\w\$\_])/,Infinity:/^Infinity(?![\w\$\_])/,void:/^void(?![\w\$\_])\s*/,await:/^await(?![\w\$\_])\s*/,new:/^new(?![\w\$\_])\s*/,throw:/^throw(?![\w\$\_])\s*/},next:["splitter","expEdge","inlineIf","dot","expEnd"]},initialize:{types:{initialize:/^(var|let|const)\s+([a-zA-Z\$_][a-zA-Z\d\$_]*)\s*(=)?/,return:/^return(?![\w\$\_])/},next:["modifier","value","prop","incrementerBefore","expEnd"]},spreadObject:{types:{spreadObject:/^\.\.\./},next:["value","prop"]},spreadArray:{types:{spreadArray:/^\.\.\./},next:["value","prop"]},expEnd:{types:{},next:[]},expSingle:{types:{for:/^(([a-zA-Z\$\_][\w\$\_]*)\s*:)?\s*for\s*\(/,do:/^(([a-zA-Z\$\_][\w\$\_]*)\s*:)?\s*do\s*\{/,while:/^(([a-zA-Z\$\_][\w\$\_]*)\s*:)?\s*while\s*\(/,loopAction:/^(break|continue)(?![\w\$\_])/,if:/^if\s*\(/,try:/^try\s*{/,function:/^(async\s+)?function(\s*[a-zA-Z\$_][a-zA-Z\d\$_]*)\s*\(\s*((\.\.\.)?\s*[a-zA-Z\$_][a-zA-Z\d\$_]*(\s*,\s*(\.\.\.)?\s*[a-zA-Z\$_][a-zA-Z\d\$_]*)*)?\s*\)\s*{/,switch:/^(([a-zA-Z\$\_][\w\$\_]*)\s*:)?\s*switch\s*\(/},next:["expEnd"]}},closings={"(":")","[":"]","{":"}","'":"'",'"':'"',"`":"`"};const okFirstChars=/^[\+\-~ !]/,aChar=/^[\w\$]/,aNumber=expectTypes.value.types.number;function restOfExp(e,t,n,i,s,r,o={},a){let l=!0;n=n||[];let c,p=!1,f=!1,u=!1,d=!1,h="",x="";for(c=0;c<t.length&&!f;c++){let g=t[c];if(u=d,d=aChar.test(g),d||space.test(g)||closings[g]||(x=""),d&&r&&(x+=g),'"'===i||"'"===i||"`"===i){if("`"!==i||"$"!==g||"{"!==t[c+1]||p){if(g===i&&!p)return t.substring(0,c)}else{c+=restOfExp(e,t.substring(c+2),[],"{").length+2}p=!p&&"\\"===g}else if(closings[g]){if(g===s){f=!0;break}if(c+=restOfExp(e,t.substring(c+1),[],g).length+1,l=!1,r){let e=t.substring(c);for(let t of r){t.lastIndex=0;const n=t.exec(e);if(n&&(c+=n[1].length-1,o.word=x,f=!0,f))break}}}else if(i){if(g===closings[i])return t.substring(0,c)}else{let e,i=t.substring(c);if((e=aNumber.exec(i))&&(c+=e[0].length-1,i=t.substring(c)),a||(!u||!d)&&h!==g)for(let e of n){const t=e.exec(i);if(t){r&&(c+=t[1].length),f=!0;break}}if(l&&(okFirstChars.test(i)?f=!1:l=!1),f)break}h=g}if(i)throw new SyntaxError("Unclosed '"+i+"': "+i+t.substring(0,Math.min(c,40)));return t.substring(0,c)}restOfExp.next=["splitter","expEnd","inlineIf"];const setLispType=(e,t)=>{e.forEach((e=>{lispTypes.set(e,t)}))},closingsCreate={createArray:/^\]/,createObject:/^\}/,group:/^\)/,arrayProp:/^\]/,call:/^\)/};setLispType(["createArray","createObject","group","arrayProp","call"],((e,t,n,i,s,r)=>{let o="",a=[],l=!1,c=1;for(;c<n.length&&!l;)o=restOfExp(e,n.substring(c),[closingsCreate[t],/^,/]),c+=o.length,o&&a.push(o),","!==n[c]?l=!0:c++;const p=["value","modifier","prop","incrementerBefore","expEnd"];let f,u;switch(t){case"group":case"arrayProp":f=lispifyExpr(e,a.join(","));break;case"call":case"createArray":f=a.map((t=>lispify(e,t,[...p,"spreadArray"])));break;case"createObject":f=a.map((t=>{let n,i;if(t=t.trimStart(),u=expectTypes.expSingle.types.function.exec("function "+t),u)i=u[2].trimStart(),n=lispify(e,"function "+t.replace(i,""));else{let s=restOfExp(e,t,[/^:/]);if(i=lispify(e,s,[...p,"spreadObject"]),i instanceof Lisp&&"prop"===i.op&&(i=i.b),s.length===t.length)return i;n=lispify(e,t.substring(s.length+1))}return new Lisp({op:"keyVal",a:i,b:n})}))}t="arrayProp"===t?"prop":t,r.lispTree=lispify(e,n.substring(c+1),expectTypes[s].next,new Lisp({op:t,a:r.lispTree,b:f}))})),setLispType(["inverse","not","negative","positive","typeof","delete","op"],((e,t,n,i,s,r)=>{let o=restOfExp(e,n.substring(i[0].length),[/^[^\s\.\w\d\$]/]);r.lispTree=lispify(e,n.substring(o.length+i[0].length),restOfExp.next,new Lisp({op:["positive","negative"].includes(t)?"$"+i[0]:i[0],a:r.lispTree,b:lispify(e,o,expectTypes[s].next)}))})),setLispType(["incrementerBefore"],((e,t,n,i,s,r)=>{let o=restOfExp(e,n.substring(2),[/^[^\s\.\w\d\$]/]);r.lispTree=lispify(e,n.substring(o.length+2),restOfExp.next,new Lisp({op:i[0]+"$",a:lispify(e,o,expectTypes[s].next)}))})),setLispType(["incrementerAfter"],((e,t,n,i,s,r)=>{r.lispTree=lispify(e,n.substring(i[0].length),expectTypes[s].next,new Lisp({op:"$"+i[0],a:r.lispTree}))})),setLispType(["assign","assignModify"],((e,t,n,i,s,r)=>{r.lispTree=new Lisp({op:i[0],a:r.lispTree,b:lispify(e,n.substring(i[0].length),expectTypes[s].next)})})),setLispType(["split"],((e,t,n,i,s,r)=>{let o=restOfExp(e,n.substring(i[0].length),[expectTypes.splitter.types.split,expectTypes.inlineIf.types.inlineIf,inlineIfElse]);r.lispTree=lispify(e,n.substring(o.length+i[0].length).trim(),restOfExp.next,new Lisp({op:i[0].trim(),a:r.lispTree,b:lispify(e,o,expectTypes[s].next)}))})),setLispType(["inlineIf"],((e,t,n,i,s,r)=>{let o=!1,a="",l=1;for(;!o&&a.length<n.length;)a+=restOfExp(e,n.substring(a.length+1),[expectTypes.inlineIf.types.inlineIf,inlineIfElse]),"?"===n[a.length+1]?l++:l--,l?a+=n[a.length+1]:o=!0;r.lispTree=new Lisp({op:"?",a:r.lispTree,b:new Lisp({op:":",a:lispifyExpr(e,a),b:lispifyExpr(e,n.substring(i[0].length+a.length+1))})})})),setLispType(["if"],((e,t,n,i,s,r)=>{let o=restOfExp(e,n.substring(i[0].length),[],"(");const a=/^\s*\{/.exec(n.substring(i[0].length+o.length+1)),l=i[0].length+o.length+1+(a?a[0].length:0);let c=restOfExp(e,n.substring(l),a?[/^\}/]:[/^else(?!\w\$)/]),p="";if(l+c.length+(a?a[0].length:0)<n.length){const e=n.substring(l+c.length+(a?a[0].length:0)),t=/\s*else(?!\w\$\s)\s*/.exec(e);t&&(p=e.substring(t[0].length))}o=o.trim(),c=c.trim(),p=p.trim(),"{"===c[0]&&(c=c.slice(1,-1)),"{"===p[0]&&(p=p.slice(1,-1)),r.lispTree=new Lisp({op:"if",a:lispifyExpr(e,o),b:new If(lispifyBlock(c,e),p?lispifyBlock(p,e):void 0)})})),setLispType(["switch"],((e,t,n,i,s,r)=>{const o=restOfExp(e,n.substring(i[0].length),[],"(");let a=n.indexOf("{",i[0].length+o.length+1);if(-1===a)throw new SyntaxError("Invalid switch: "+n);let l,c=insertSemicolons(e,restOfExp(e,n.substring(a+1),[],"{"),!1);const p=/^\s*(case\s|default)\s*/;let f=[],u=!1;for(;l=p.exec(c);){if("default"===l[1]){if(u)throw new SyntaxError("Only one default switch case allowed:"+c);u=!0}let t=restOfExp(e,c.substring(l[0].length),[/^:/]),n="",i=a=l[0].length+t.length+1,s=/^\s*\{/.exec(c.substring(i)),r=[];if(s)i+=s[0].length,n=restOfExp(e,c.substring(i),[],"{"),i+=n.length+1,r=lispifyBlock(n,e);else{let t=restOfExp(e,c.substring(i),[p]);if(t.trim()){let t=[];for(;(n=restOfExp(e,c.substring(i),[/^;/]))&&(t.push(n),i+=n.length+1,!p.test(c.substring(i))););r=lispifyBlock(t.join(";"),e)}else r=void 0,i+=t.length}c=c.substring(i),f.push(new Lisp({op:"case",a:"default"===l[1]?void 0:lispifyExpr(e,t),b:r}))}r.lispTree=new Lisp({op:"switch",a:lispifyExpr(e,o),b:f})})),setLispType(["dot","prop"],((e,t,n,i,s,r)=>{let o=i[0],a=i[0].length;if("."===i[0]){let e=n.substring(i[0].length).match(expectTypes.prop.types.prop);if(!e||!e.length)throw new SyntaxError("Hanging  dot:"+n);o=e[0],a=o.length+i[0].length}r.lispTree=lispify(e,n.substring(a),expectTypes[s].next,new Lisp({op:"prop",a:r.lispTree,b:o}))})),setLispType(["spreadArray","spreadObject"],((e,t,n,i,s,r)=>{r.lispTree=new Lisp({op:t,b:lispify(e,n.substring(i[0].length),expectTypes[s].next)})})),setLispType(["return"],((e,t,n,i,s,r)=>{r.lispTree=new Lisp({op:t,b:lispifyExpr(e,n.substring(i[0].length))})}));const primitives={true:!0,false:!1,null:null,Infinity:1/0,NaN:NaN,und:void 0};setLispType(["number","boolean","null","und","NaN","Infinity"],((e,t,n,i,s,r)=>{r.lispTree=lispify(e,n.substring(i[0].length),expectTypes[s].next,"number"===t?Number(i[0]):primitives["boolean"===t?i[0]:t])})),setLispType(["string","literal","regex"],((e,t,n,i,s,r)=>{r.lispTree=lispify(e,n.substring(i[0].length),expectTypes[s].next,new Lisp({op:t,b:parseInt(JSON.parse(i[1]),10)}))})),setLispType(["initialize"],((e,t,n,i,s,r)=>{i[3]?r.lispTree=new Lisp({op:i[1],a:i[2],b:lispify(e,n.substring(i[0].length),expectTypes[s].next)}):r.lispTree=lispify(e,n.substring(i[0].length),expectTypes[s].next,new Lisp({op:i[1],a:i[2]}))})),setLispType(["function","inlineFunction","arrowFunction","arrowFunctionSingle"],((e,t,n,i,s,r)=>{const o="function"!==t&&"inlineFunction"!==t,a=o&&!i[i.length-1],l=o?2:3,c=!!i[1],p=i[l]?i[l].replace(/\s+/g,"").split(/,/g):[];o||p.unshift((i[2]||"").trimStart());let f=!1;p.forEach((e=>{if(f)throw new SyntaxError("Rest parameter must be last formal parameter");e.startsWith("...")&&(f=!0)})),p.unshift(c);const u=(a?"return ":"")+restOfExp(e,n.substring(i[0].length),a?[/^[,;\)\}\]]/]:[/^}/]);r.lispTree=lispify(e,n.substring(i[0].length+u.length+1),expectTypes[s].next,new Lisp({op:o?"arrowFunc":t,a:p,b:lispifyFunction(u,e)}))}));const iteratorRegex=/^((let|var|const)\s+)?\s*([a-zA-Z\$_][a-zA-Z\d\$_]*)\s+(in|of)\s+/;setLispType(["for","do","while"],((e,t,n,i,s,r)=>{let o,a,l=n.indexOf("(")+1,c=!0,p=[],f=!1,u=!0,d=!0;switch(t){case"while":let t=restOfExp(e,n.substring(l),[],"(");o=lispifyExpr(e,t),a=restOfExp(e,n.substring(l+t.length+1)).trim(),"{"===a[0]&&(a=a.slice(1,-1));break;case"for":let i,s=[],r="";for(let t=0;t<3&&(r=restOfExp(e,n.substring(l),[/^[;\)]/]),s.push(r.trim()),l+=r.length+1,")"!==n[l-1]);t++);if(1===s.length&&(i=iteratorRegex.exec(s[0])))"of"===i[4]?(p=[lispify(e,"let $$obj = "+s[0].substring(i[0].length),["initialize"]),ofStart2,ofStart3],o=ofCondition,d=ofStep,f=lispify(e,(i[1]||"let ")+i[3]+" = $$next.value",["initialize"])):(p=[lispify(e,"let $$obj = "+s[0].substring(i[0].length),["initialize"]),inStart2,inStart3],d=inStep,o=inCondition,f=lispify(e,(i[1]||"let ")+i[3]+" = $$keys[$$keyIndex]",["initialize"]));else{if(3!==s.length)throw new SyntaxError("Invalid for loop definition");c=lispifyExpr(e,s.shift(),startingExecpted),o=lispifyExpr(e,s.shift()),d=lispifyExpr(e,s.shift())}a=restOfExp(e,n.substring(l)).trim(),"{"===a[0]&&(a=a.slice(1,-1));break;case"do":u=!1;const h=n.indexOf("{")+1;a=restOfExp(e,n.substring(h),[],"{"),o=lispifyExpr(e,restOfExp(e,n.substring(n.indexOf("(",h+a.length)+1),[],"("))}r.lispTree=new Lisp({op:"loop",a:[u,p,c,d,o,f],b:lispifyBlock(a,e)})})),setLispType(["block"],((e,t,n,i,s,r)=>{r.lispTree=lispifyBlock(restOfExp(e,n.substring(1),[],"{"),e)})),setLispType(["loopAction"],((e,t,n,i,s,r)=>{r.lispTree=new Lisp({op:"loopAction",a:i[1]})}));const catchReg=/^\s*(catch\s*(\(\s*([a-zA-Z\$_][a-zA-Z\d\$_]*)\s*\))?|finally)\s*\{/;setLispType(["try"],((e,t,n,i,s,r)=>{const o=restOfExp(e,n.substring(i[0].length),[],"{");let a,l,c,p=catchReg.exec(n.substring(i[0].length+o.length+1)),f=0;p[1].startsWith("catch")?(p=catchReg.exec(n.substring(i[0].length+o.length+1)),l=p[2],c=restOfExp(e,n.substring(i[0].length+o.length+1+p[0].length),[],"{"),f=i[0].length+o.length+1+p[0].length+c.length+1,(p=catchReg.exec(n.substring(f)))&&p[1].startsWith("finally")&&(a=restOfExp(e,n.substring(f+p[0].length),[],"{"))):a=restOfExp(e,n.substring(i[0].length+o.length+1+p[0].length),[],"{"),r.lispTree=new Lisp({op:"try",a:lispifyBlock(insertSemicolons(e,o,!1),e),b:[l,lispifyBlock(insertSemicolons(e,c||"",!1),e),lispifyBlock(insertSemicolons(e,a||"",!1),e)]})})),setLispType(["void","await","throw"],((e,t,n,i,s,r)=>{const o=restOfExp(e,n.substring(i[0].length),[/^[^\s\.\w\d\$]/]);r.lispTree=lispify(e,n.substring(i[0].length+o.length),expectTypes[s].next,new Lisp({op:t,a:lispify(e,o)}))})),setLispType(["new"],((e,t,n,i,s,r)=>{let o=i[0].length;const a=restOfExp(e,n.substring(o),[],void 0,"(");o+=a.length+1;const l=[];if("("===n[o-1]){const t=restOfExp(e,n.substring(o),[],"(");let i;o+=t.length+1;let s=0;for(;i=restOfExp(e,t.substring(s),[/^,/]);)s+=i.length+1,l.push(i.trim())}r.lispTree=lispify(e,n.substring(o),expectTypes.expEdge.next,new Lisp({op:t,a:lispify(e,a,expectTypes.initialize.next),b:l.map((t=>lispify(e,t,expectTypes.initialize.next)))}))}));const ofStart2=lispify(void 0,"let $$iterator = $$obj[Symbol.iterator]()",["initialize"]),ofStart3=lispify(void 0,"let $$next = $$iterator.next()",["initialize"]),ofCondition=lispify(void 0,"return !$$next.done",["initialize"]),ofStep=lispify(void 0,"$$next = $$iterator.next()"),inStart2=lispify(void 0,"let $$keys = Object.keys($$obj)",["initialize"]),inStart3=lispify(void 0,"let $$keyIndex = 0",["initialize"]),inStep=lispify(void 0,"$$keyIndex++"),inCondition=lispify(void 0,"return $$keyIndex < $$keys.length",["initialize"]),startingExecpted=["initialize","expSingle","value","modifier","prop","incrementerBefore","expEnd"];var lastType,lastPart;function lispify(e,t,n,i){if(n=n||expectTypes.initialize.next,void 0===t)return i;if(!(t=t.trimStart()).length&&!n.includes("expEnd"))throw new SyntaxError("Unexpected end of expression: "+lastPart);if(!t)return i;let s,r={lispTree:i};for(let i of n)if("expEnd"!==i){for(let n in expectTypes[i].types)if("expEnd"!==n&&(s=expectTypes[i].types[n].exec(t))){lastType=n,lastPart=t,lispTypes.get(n)(e,n,t,s,i,r);break}if(s)break}if(!s&&t.length)throw SyntaxError(`Unexpected token (${lastType}): ${t.substring(0,40)}`);return r.lispTree}function lispifyExpr(e,t,n){if(!t.trim())return;let i,s=[],r=0;for(n=n||expectTypes.initialize.next;i=restOfExp(e,t.substring(r),[/^,/]);)s.push(i.trimStart()),r+=i.length+1;if(1===s.length)return lispify(e,t,n);if(n===startingExecpted){let i=expectTypes.initialize.types.initialize.exec(s[0]);if(i)return s.map(((t,n)=>lispify(e,n?i[1]+" "+t:t,["initialize"])));if(expectTypes.initialize.types.return.exec(s[0]))return lispify(e,t,n)}const o=s.map(((t,i)=>lispify(e,t,n)));return new Lisp({op:"multi",a:o})}function lispifyBlock(e,t){if(!(e=insertSemicolons(t,e,!1)).trim())return[];let n,i=[],s=0;for(;n=restOfExp(t,e.substring(s),[/^;/]);)i.push(n.trim()),s+=n.length+1;return i.filter(Boolean).map(((e,n)=>lispifyExpr(t,e,startingExecpted))).flat()}function lispifyFunction(e,t){if(!e.trim())return[];const n=lispifyBlock(e,t);let i=[];return hoist(n,i),i.concat(n)}function hoist(e,t){if(Array.isArray(e)){const n=[];for(let i of e)hoist(i,t)||n.push(i);n.length!==e.length&&(e.length=0,e.push(...n))}else if(e instanceof Lisp)if("try"===e.op||"if"===e.op||"loop"===e.op||"switch"===e.op)hoist(e.a,t),hoist(e.b,t);else if("var"===e.op)t.push(new Lisp({op:"var",a:e.a}));else if("function"===e.op&&e.a[1])return t.push(e),!0;return!1}const edgesForInsertion=[/^([\w\$]|\+\+|\-\-)\s*\r?\n\s*([\w\$\+\-])/,/^([^\w\$](return|continue|break|throw))\s*\r?\n\s*[^\s]/],closingsForInsertion=[/^([\)\]])\s*\r?\n\s*([\w\$\{\+\-])/,/^(\})\s*\r?\n?\s*([\(])/,/^(\})\s*(\r?\n)?\s*([\w\[\+\-])/],closingsNoInsertion=/^(\})\s*(catch|finally|else|while|instanceof)(?![\w\$])/,whileEnding=/^\}\s*while/;function insertSemicolons(e,t,n){let i=t,s="",r=[],o={};for(;s=restOfExp(e,i,edgesForInsertion,void 0,void 0,n?void 0:closingsForInsertion,o,!0);)r.push(s),closingsNoInsertion.test(i.substring(s.length-1))?"do"!==o.word&&whileEnding.test(i.substring(s.length-1))&&r.push(";"):r.push(";"),i=i.substring(s.length);return r.pop(),r.join("")}const oneLinerBlocks=/[^\w\$](if|do)(?![\w\$])/g;function convertOneLiners(e,t){let n,i=0,s=[];for(;n=oneLinerBlocks.exec(t);){let r=t.substring(n.index+n[0].length),o=n.index+n[0].length;if("if"===n[1]){let a=r.indexOf("(")+1;o+=a;let l=restOfExp(e,r.substring(a),[],"(");oneLinerBlocks.lastIndex=n.index+a+l.length+1,s.push(t.substring(i,o),[l],")"),o+=l.length+1}else s.push(t.substring(i,o));if(o+=/^\s*/.exec(t.substring(o))[0].length,r=t.substring(o),"{"!==r[0]){let t=restOfExp(e,r,[/^([;\)\]\}]|\r?\n)/]),a=0;";"===r[t.length]&&(a=1),s.push("{",t,"}");let l=r.substring(t.length+a);"if"!==n[1]||/^\s*else(?![\w\$])/.test(l)||s.push(";"),i=o+t.length+a}else i=o}s.push(t.substring(i));for(let t of s)if(t instanceof Array){let n=convertOneLiners(e,t[0]);t.length=0,t.push(n)}return s.flat().join("")}function checkRegex(e){let t=1,n=!1,i=!1,s=!1;for(;t<e.length&&!i&&!s;)i="/"===e[t]&&!n,n="\\"===e[t]&&!n,s="\n"===e[t],t++;let r=e.substring(t);if(s=s||!i||/^\s*\d/.test(r),s)return null;let o=/^[a-z]*/.exec(r);return/^\s+[\w\$]/.test(e.substring(t+o[0].length))?null:{regex:e.substring(1,t-1),flags:o&&o[0]||"",length:t+(o&&o[0].length||0)}}const notDivide=/(typeof|delete|instanceof|return|in|of|throw|new|void|do|if)$/,possibleDivide=/^([\w\$\]\)]|\+\+|\-\-)[^\w\$\]\)\+\-]/;function extractConstants(e,t,n=""){let i,s,r=[],o=!1,a="",l=-1,c=[],p="";const f=[],u=[];let d;for(var h=0;h<t.length;h++)if(p=t[h],a)p===a&&("*"===a&&"/"===t[h+1]?(a="",h++):"\n"===a&&(a=""));else{if(o){o=!1,r.push(p);continue}if(i)if("`"===i&&"$"===p&&"{"===t[h+1]){let n=extractConstants(e,t.substring(h+2),"{");c.push(n.str),r.push(`\${${c.length-1}}`),h+=n.length+2}else i===p?("`"===i?(e.literals.push({op:"literal",a:unraw(r.join("")),b:c}),f.push(`\`${e.literals.length-1}\``)):(e.strings.push(unraw(r.join(""))),f.push(`"${e.strings.length-1}"`)),i=null,r=[]):r.push(p);else{if("'"===p||'"'===p||"`"===p)c=[],i=p;else{if(closings[n]===p&&!u.length)return{str:f.join(""),length:h};closings[p]?(u.push(p),f.push(p)):closings[u[u.length-1]]===p?(u.pop(),f.push(p)):"/"!==p||"*"!==t[h+1]&&"/"!==t[h+1]?"/"===p&&!d&&(s=checkRegex(t.substring(h)))?(e.regexes.push(s),f.push(`/${e.regexes.length-1}/r`),h+=s.length-1):f.push(p):(a="*"===t[h+1]?"*":"\n",l=h)}d&&space.test(p)||(d=possibleDivide.exec(t.substring(h)))&&notDivide.test(t.substring(0,h+d[1].length))&&(d=null)}o=i&&"\\"===p}if(a&&"*"===a)throw new SyntaxError("Unclosed comment '/*': "+t.substring(l));return{str:f.join(""),length:h}}function parse(e){if("string"!=typeof e)throw new ParseError("Cannot parse "+e,e);let t=" "+e;const n={strings:[],literals:[],regexes:[]};t=extractConstants(n,t).str,t=insertSemicolons(n,t,!0),t=convertOneLiners(n,t);try{for(let e of n.literals)e.b=e.b.map((e=>lispifyExpr(n,e)));return{tree:lispifyFunction(t,n),constants:n}}catch(e){throw e}}class ExecReturn{constructor(e,t,n,i=!1,s=!1){this.auditReport=e,this.result=t,this.returned=n,this.breakLoop=i,this.continueLoop=s}}class Prop{constructor(e,t,n=!1,i=!1,s=!1){this.context=e,this.prop=t,this.isConst=n,this.isGlobal=i,this.isVariable=s}}const reservedWords=new Set(["instanceof","typeof","return","try","catch","if","finally","else","in","of","var","let","const","for","delete","false","true","while","do","break","continue","new","function","async","await","switch","case"]);var VarType;!function(e){e.let="let",e.const="const",e.var="var"}(VarType||(VarType={}));class Scope{constructor(e,t={},n){this.const=new Set,this.let=new Set;const i=void 0!==n||null===e;this.parent=e,this.allVars=t,this.let=i?this.let:new Set(Object.keys(t)),this.var=i?new Set(Object.keys(t)):this.var,this.globals=null===e?new Set(Object.keys(t)):new Set,this.functionThis=n}get(e,t=!1){if("this"===e&&void 0!==this.functionThis)return new Prop({this:this.functionThis},e,!0,!1,!0);if(reservedWords.has(e))throw new SyntaxError("Unexepected token '"+e+"'");if(null===this.parent||!t||void 0!==this.functionThis){if(this.globals.has(e))return new Prop(this.functionThis,e,!1,!0,!0);if(e in this.allVars&&(!(e in{})||this.allVars.hasOwnProperty(e)))return new Prop(this.allVars,e,this.const.has(e),this.globals.has(e),!0);if(null===this.parent)return new Prop(void 0,e)}return this.parent.get(e,t)}set(e,t){if("this"===e)throw new SyntaxError('"this" cannot be assigned');if(reservedWords.has(e))throw new SyntaxError("Unexepected token '"+e+"'");let n=this.get(e);if(void 0===n.context)throw new ReferenceError(`Variable '${e}' was not declared.`);if(n.isConst)throw new TypeError(`Cannot assign to const variable '${e}'`);if(n.isGlobal)throw new SandboxError(`Cannot override global variable '${e}'`);return n.context[n]=t,n}declare(e,t=null,n,i=!1){if("this"===e)throw new SyntaxError('"this" cannot be declared');if(reservedWords.has(e))throw new SyntaxError("Unexepected token '"+e+"'");if("var"===t&&void 0===this.functionThis&&null!==this.parent)return this.parent.declare(e,t,n,i);if((!this[t].has(e)||"const"===t||this.globals.has(e))&&e in this.allVars)throw new SandboxError(`Identifier '${e}' has already been declared`);return i&&this.globals.add(e),this[t].add(e),this.allVars[e]=n,new Prop(this.allVars,e,this.const.has(e),i)}}class SandboxError extends Error{}function sandboxFunction(e){return function SandboxFunction(...t){let n=parse(t.pop()||"");return createFunction(t,n.tree,{ctx:e,constants:n.constants},void 0,"anonymous")}}const sandboxedFunctions=new WeakSet;function createFunction(e,t,n,i,s){let r=function(...r){const o={};e.forEach(((e,t)=>{e.startsWith("...")?o[e.substring(3)]=r.slice(t):o[e]=r[t]}));return executeTree(n,t,void 0===i?[]:[new Scope(i,o,void 0===s?void 0:this)]).result};return sandboxedFunctions.add(r),r}function createFunctionAsync(e,t,n,i,s){let r=async function(...r){const o={};e.forEach(((e,t)=>{e.startsWith("...")?o[e.substring(3)]=r.slice(t):o[e]=r[t]}));return(await executeTreeAsync(n,t,void 0===i?[]:[new Scope(i,o,void 0===s?void 0:this)])).result};return sandboxedFunctions.add(r),r}function sandboxedEval(e){return function(t){return e(t)()}}function sandboxedSetTimeout(e){return function(t,...n){return"string"!=typeof t?setTimeout(t,...n):setTimeout(e(t),...n)}}function sandboxedSetInterval(e){return function(t,...n){return"string"!=typeof t?setInterval(t,...n):setInterval(e(t),...n)}}function assignCheck(e,t,n="assign"){var i,s,r,o;if(void 0===e.context)throw new ReferenceError(`Cannot ${n} value to undefined.`);if("object"!=typeof e.context&&"function"!=typeof e.context)throw new SyntaxError(`Cannot ${n} value to a primitive.`);if(e.isConst)throw new TypeError(`Cannot set value to const variable '${e.prop}'`);if(e.isGlobal)throw new SandboxError(`Cannot ${n} property '${e.prop}' of a global object`);if("function"==typeof e.context[e.prop]&&!e.context.hasOwnProperty(e.prop))throw new SandboxError(`Override prototype property '${e.prop}' not allowed`);"delete"===n?e.context.hasOwnProperty(e.prop)&&(null===(i=t.ctx.changeSubscriptions.get(e.context))||void 0===i||i.forEach((t=>t({type:"delete",prop:e.prop})))):e.context.hasOwnProperty(e.prop)?null===(r=null===(s=t.ctx.setSubscriptions.get(e.context))||void 0===s?void 0:s.get(e.prop))||void 0===r||r.forEach((e=>e({type:"replace"}))):null===(o=t.ctx.changeSubscriptions.get(e.context))||void 0===o||o.forEach((t=>t({type:"create",prop:e.prop})))}const arrayChange=new Set([[].push,[].pop,[].shift,[].unshift,[].splice,[].reverse,[].sort,[].copyWithin]),literalRegex=/(\$\$)*(\$)?\${(\d+)}/g;let ops2={prop:(e,t,n,i,s,r,o)=>{if(null===n)throw new TypeError(`Cannot get property ${i} of null`);const a=typeof n;if("undefined"===a&&void 0===s){let e=o.get(i);if(void 0===e.context)throw new ReferenceError(i+" is not defined");if(e.context===r.ctx.sandboxGlobal){r.ctx.options.audit&&r.ctx.auditReport.globalsAccess.add(i);const e=r.ctx.globalsWhitelist.has(r.ctx.sandboxGlobal[i])?r.ctx.evals.get(r.ctx.sandboxGlobal[i]):void 0;if(e)return void t(void 0,e)}return e.context&&e.context[i]===globalThis?void t(void 0,r.ctx.globalScope.get("this")):(r.ctx.getSubscriptions.forEach((t=>t(e.context,e.prop))),void t(void 0,e))}if(void 0===n)throw new SandboxError("Cannot get property '"+i+"' of undefined");if("object"!==a)"number"===a?n=new Number(n):"string"===a?n=new String(n):"boolean"===a&&(n=new Boolean(n));else if(void 0===n.hasOwnProperty)return void t(void 0,new Prop(void 0,i));const l="function"===a;let c=l||!(n.hasOwnProperty(i)||"number"==typeof i);if(r.ctx.options.audit&&c&&"string"==typeof i){let e=n.constructor.prototype;do{e.hasOwnProperty(i)&&(r.ctx.auditReport.prototypeAccess[e.constructor.name]||(r.ctx.auditReport.prototypeAccess[e.constructor.name]=new Set),r.ctx.auditReport.prototypeAccess[e.constructor.name].add(i))}while(e=Object.getPrototypeOf(e))}if(c)if(l){if(!["name","length","constructor"].includes(i)&&n.hasOwnProperty(i)){const e=r.ctx.options.prototypeWhitelist.get(n),s=r.ctx.options.prototypeReplacements.get(n);if(s)return void t(void 0,new Prop(s(n,!0),i));if(!e||e.size&&!e.has(i))throw new SandboxError(`Static method or property access not permitted: ${n.name}.${i}`)}}else if("constructor"!==i){let e=n.constructor.prototype;do{if(e.hasOwnProperty(i)){const s=r.ctx.options.prototypeWhitelist.get(e.constructor),o=r.ctx.options.prototypeReplacements.get(e.constuctor);if(o)return void t(void 0,new Prop(o(n,!1),i));if(s&&(!s.size||s.has(i)))break;throw new SandboxError(`Method or property access not permitted: ${e.constructor.name}.${i}`)}}while(e=Object.getPrototypeOf(e))}const p=r.ctx.globalsWhitelist.has(n[i])?r.ctx.evals.get(n[i]):void 0;if(p)return void t(void 0,p);if(n[i]===globalThis)return void t(void 0,r.ctx.globalScope.get("this"));let f=s.isGlobal||l&&!sandboxedFunctions.has(n)||r.ctx.globalsWhitelist.has(n);f||r.ctx.getSubscriptions.forEach((e=>e(n,i))),t(void 0,new Prop(n,i,!1,f))},call:(e,t,n,i,s,r,o)=>{if(r.ctx.options.forbidMethodCalls)throw new SandboxError("Method calls are not allowed");if("function"!=typeof n)throw new TypeError(s.prop+" is not a function");execMany(e,i.map((e=>e instanceof SpreadArray?[...e.item]:[e])).flat(),((e,n)=>{var i;if(e)t(e);else if("function"!=typeof s){if(s.context[s.prop]===JSON.stringify&&r.ctx.getSubscriptions.size){const e=new Set,t=n=>{if(n&&"object"==typeof n&&!e.has(n)){e.add(n);for(let e in n)r.ctx.getSubscriptions.forEach((t=>t(n,e))),t(n[e])}};t(n[0])}if(s.context instanceof Array&&arrayChange.has(s.context[s.prop])&&r.ctx.changeSubscriptions.get(s.context)){let e,t=!1;if("push"===s.prop)e={type:"push",added:n},t=!!n.length;else if("pop"===s.prop)e={type:"pop",removed:s.context.slice(-1)},t=!!e.removed.length;else if("shift"===s.prop)e={type:"shift",removed:s.context.slice(0,1)},t=!!e.removed.length;else if("unshift"===s.prop)e={type:"unshift",added:n},t=!!n.length;else if("splice"===s.prop)e={type:"splice",startIndex:n[0],deleteCount:void 0===n[1]?s.context.length:n[1],added:n.slice(2),removed:s.context.slice(n[0],void 0===n[1]?void 0:n[0]+n[1])},t=!!e.added.length||!!e.removed.length;else if("reverse"===s.prop||"sort"===s.prop)e={type:s.prop},t=!!s.context.length;else if("copyWithin"===s.prop){let i=void 0===n[2]?s.context.length-n[1]:Math.min(s.context.length,n[2]-n[1]);e={type:"copyWithin",startIndex:n[0],endIndex:n[0]+i,added:s.context.slice(n[1],n[1]+i),removed:s.context.slice(n[0],n[0]+i)},t=!!e.added.length||!!e.removed.length}t&&(null===(i=r.ctx.changeSubscriptions.get(s.context))||void 0===i||i.forEach((t=>t(e))))}t(void 0,s.context[s.prop](...n))}else t(void 0,s(...n))}),o,r)},createObject:(e,t,n,i,s,r,o)=>{let a={};for(let e of i)e instanceof SpreadObject?a={...a,...e.item}:a[e.key]=e.val;t(void 0,a)},keyVal:(e,t,n,i)=>t(void 0,new KeyVal(n,i)),createArray:(e,t,n,i,s,r,o)=>{execMany(e,i.map((e=>e instanceof SpreadArray?[...e.item]:[e])).flat(),t,o,r)},group:(e,t,n,i)=>t(void 0,i),string:(e,t,n,i,s,r)=>t(void 0,r.constants.strings[i]),regex:(e,t,n,i,s,r)=>{const o=r.constants.regexes[i];if(!r.ctx.globalsWhitelist.has(RegExp))throw new SandboxError("Regex not permitted");t(void 0,new RegExp(o.regex,o.flags))},literal:(e,t,n,i,s,r,o)=>{let a,l=r.constants.literals[i].a,c=[],p=[];for(;a=literalRegex.exec(l);)a[2]||(c.push(r.constants.literals[i].b[parseInt(a[3],10)]),p.push(a[3]));execMany(e,c,((e,n)=>{const i={};if(e)t(e);else{for(let e in p){const t=p[e];i[t]=n[e]}t(void 0,l.replace(/(\\\\)*(\\)?\${(\d+)}/g,((e,t,n,s)=>{if(n)return e;let r=i[s];return r=r instanceof Prop?r.context[r.prop]:r,(t||"")+""+r})))}}),o,r)},spreadArray:(e,t,n,i,s,r,o)=>{e(i,o,r,((e,n)=>{e?t(e):t(void 0,new SpreadArray(n))}))},spreadObject:(e,t,n,i,s,r,o)=>{e(i,o,r,((e,n)=>{e?t(e):t(void 0,new SpreadObject(n))}))},"!":(e,t,n,i)=>t(void 0,!i),"~":(e,t,n,i)=>t(void 0,~i),"++$":(e,t,n,i,s,r)=>{assignCheck(s,r),t(void 0,++s.context[s.prop])},"$++":(e,t,n,i,s,r)=>{assignCheck(s,r),t(void 0,s.context[s.prop]++)},"--$":(e,t,n,i,s,r)=>{assignCheck(s,r),t(void 0,--s.context[s.prop])},"$--":(e,t,n,i,s,r)=>{assignCheck(s,r),t(void 0,s.context[s.prop]--)},"=":(e,t,n,i,s,r)=>{assignCheck(s,r),s.context[s.prop]=i,t(void 0,new Prop(s.context,s.prop,!1,s.isGlobal))},"+=":(e,t,n,i,s,r)=>{assignCheck(s,r),t(void 0,s.context[s.prop]+=i)},"-=":(e,t,n,i,s,r)=>{assignCheck(s,r),t(void 0,s.context[s.prop]-=i)},"/=":(e,t,n,i,s,r)=>{assignCheck(s,r),t(void 0,s.context[s.prop]/=i)},"*=":(e,t,n,i,s,r)=>{assignCheck(s,r),t(void 0,s.context[s.prop]*=i)},"**=":(e,t,n,i,s,r)=>{assignCheck(s,r),t(void 0,s.context[s.prop]**=i)},"%=":(e,t,n,i,s,r)=>{assignCheck(s,r),t(void 0,s.context[s.prop]%=i)},"^=":(e,t,n,i,s,r)=>{assignCheck(s,r),t(void 0,s.context[s.prop]^=i)},"&=":(e,t,n,i,s,r)=>{assignCheck(s,r),t(void 0,s.context[s.prop]&=i)},"|=":(e,t,n,i,s,r)=>{assignCheck(s,r),t(void 0,s.context[s.prop]|=i)},"<<=":(e,t,n,i,s,r)=>{assignCheck(s,r),t(void 0,s.context[s.prop]<<=i)},">>=":(e,t,n,i,s,r)=>{assignCheck(s,r),t(void 0,s.context[s.prop]>>=i)},">>>=":(e,t,n,i,s,r)=>{assignCheck(s,r),t(void 0,s.context[s.prop]>>=i)},"?":(e,t,n,i)=>{if(!(i instanceof If))throw new SyntaxError("Invalid inline if");t(void 0,n?i.t:i.f)},">":(e,t,n,i)=>t(void 0,n>i),"<":(e,t,n,i)=>t(void 0,n<i),">=":(e,t,n,i)=>t(void 0,n>=i),"<=":(e,t,n,i)=>t(void 0,n<=i),"==":(e,t,n,i)=>t(void 0,n==i),"===":(e,t,n,i)=>t(void 0,n===i),"!=":(e,t,n,i)=>t(void 0,n!=i),"!==":(e,t,n,i)=>t(void 0,n!==i),"&&":(e,t,n,i)=>t(void 0,n&&i),"||":(e,t,n,i)=>t(void 0,n||i),"&":(e,t,n,i)=>t(void 0,n&i),"|":(e,t,n,i)=>t(void 0,n|i),":":(e,t,n,i)=>t(void 0,new If(n,i)),"+":(e,t,n,i)=>t(void 0,n+i),"-":(e,t,n,i)=>t(void 0,n-i),"$+":(e,t,n,i)=>t(void 0,+i),"$-":(e,t,n,i)=>t(void 0,-i),"/":(e,t,n,i)=>t(void 0,n/i),"^":(e,t,n,i)=>t(void 0,n^i),"*":(e,t,n,i)=>t(void 0,n*i),"%":(e,t,n,i)=>t(void 0,n%i),"<<":(e,t,n,i)=>t(void 0,n<<i),">>":(e,t,n,i)=>t(void 0,n>>i),">>>":(e,t,n,i)=>t(void 0,n>>>i),typeof:(e,t,n,i)=>t(void 0,typeof i),instanceof:(e,t,n,i)=>t(void 0,n instanceof i),in:(e,t,n,i)=>t(void 0,n in i),delete:(e,t,n,i,s,r,o,a)=>{void 0!==a.context?(assignCheck(a,r,"delete"),a.isVariable?t(void 0,!1):t(void 0,delete a.context[a.prop])):t(void 0,!0)},return:(e,t,n,i,s,r)=>t(void 0,i),var:(e,t,n,i,s,r,o,a)=>{e(i,o,r,((e,i)=>{e?t(e):t(void 0,o.declare(n,VarType.var,i))}))},let:(e,t,n,i,s,r,o,a)=>{e(i,o,r,((e,i)=>{e?t(e):t(void 0,o.declare(n,VarType.let,i,a&&a.isGlobal))}))},const:(e,t,n,i,s,r,o,a)=>{e(i,o,r,((e,i)=>{e?t(e):t(void 0,o.declare(n,VarType.const,i))}))},arrowFunc:(e,t,n,i,s,r,o)=>{n.shift()?t(void 0,createFunctionAsync(n,i,r,o)):t(void 0,createFunction(n,i,r,o))},function:(e,t,n,i,s,r,o)=>{let a,l=n.shift(),c=n.shift();a=l?createFunctionAsync(n,i,r,o,c):createFunction(n,i,r,o,c),c&&o.declare(c,VarType.var,a),t(void 0,a)},inlineFunction:(e,t,n,i,s,r,o)=>{let a,l=n.shift(),c=n.shift();c&&(o=new Scope(o,{})),a=l?createFunctionAsync(n,i,r,o,c):createFunction(n,i,r,o,c),c&&o.declare(c,VarType.let,a),t(void 0,a)},loop:(e,t,n,i,s,r,o)=>{const[a,l,c,p,f,u]=n;let d=!0;const h=new Scope(o,{}),x=new Scope(h,{});if(e===execAsync)(async()=>{for(await asyncDone((t=>e(c,h,r,t))),await asyncDone((t=>e(l,x,r,t))),a&&(d=(await asyncDone((t=>e(f,x,r,t)))).result);d;){let n={};await asyncDone((t=>e(u,new Scope(x,n),r,t)));let s=await executeTreeAsync(r,i,[new Scope(h,n)],"loop");if(s instanceof ExecReturn&&s.returned)return void t(void 0,s);if(s instanceof ExecReturn&&s.breakLoop)break;await asyncDone((t=>e(p,x,r,t))),d=(await asyncDone((t=>e(f,x,r,t)))).result}t()})().catch(t);else{for(syncDone((t=>e(c,h,r,t))),syncDone((t=>e(l,x,r,t))),a&&(d=syncDone((t=>e(f,x,r,t))).result);d;){let n={};syncDone((t=>e(u,new Scope(x,n),r,t)));let s=executeTree(r,i,[new Scope(h,n)],"loop");if(s instanceof ExecReturn&&s.returned)return void t(void 0,s);if(s instanceof ExecReturn&&s.breakLoop)break;syncDone((t=>e(p,x,r,t))),d=syncDone((t=>e(f,x,r,t))).result}t()}},loopAction:(e,t,n,i,s,r,o)=>{if("switch"===r.inLoopOrSwitch&&"continue"===n||!r.inLoopOrSwitch)throw new SandboxError("Illegal "+n+" statement");t(void 0,new ExecReturn(r.ctx.auditReport,void 0,!1,"break"===n,"continue"===n))},if:(e,t,n,i,s,r,o)=>{if(!(i instanceof If))throw new SyntaxError("Invalid if");e(n,o,r,((n,s)=>{n?t(n):executeTreeWithDone(e,t,r,s?i.t:i.f,[new Scope(o)],r.inLoopOrSwitch)}))},switch:(e,t,n,i,s,r,o)=>{e(n,o,r,((n,s)=>{if(n)t(n);else if(e===execSync){let n,a=!1;for(let l of i)if(a||(a=!l.a||s===valueOrProp(syncDone((t=>e(l.a,o,r,t))).result))){if(!l.b)continue;if(n=executeTree(r,l.b,[o],"switch"),n.breakLoop)break;if(n.returned)return void t(void 0,n);if(!l.a)break}t()}else(async()=>{let n,a=!1;for(let l of i)if(a||(a=!l.a||s===valueOrProp((await asyncDone((t=>e(l.a,o,r,t)))).result))){if(!l.b)continue;if(n=await executeTreeAsync(r,l.b,[o],"switch"),n.breakLoop)break;if(n.returned)return void t(void 0,n);if(!l.a)break}t()})().catch(t)}))},try:(e,t,n,i,s,r,o)=>{const[a,l,c]=i;executeTreeWithDone(e,((n,i)=>{executeTreeWithDone(e,(s=>{s?t(s):n?executeTreeWithDone(e,t,r,l,[new Scope(o)],r.inLoopOrSwitch):t(void 0,i)}),r,c,[new Scope(o,{})])}),r,n,[new Scope(o)],r.inLoopOrSwitch)},void:(e,t,n)=>{t()},new:(e,t,n,i,s,r)=>{if(!r.ctx.globalsWhitelist.has(n)&&!sandboxedFunctions.has(n))throw new SandboxError("Object construction not allowed: "+n.constructor.name);t(void 0,new n(...i))},throw:(e,t,n)=>{t(n)},multi:(e,t,n,i,s,r,o)=>t(void 0,n.pop())},ops=new Map;for(let e in ops2)ops.set(e,ops2[e]);function valueOrProp(e){return e instanceof Prop?e.context[e.prop]:e}function execMany(e,t,n,i,s){let r=[],o=0;if(!t.length)return void n(void 0,[]);const a=(l,c)=>{l?n(l):(r.push(c),++o<t.length?e(t[o],i,s,a):n(void 0,r))};e(t[o],i,s,a)}function asyncDone(e){return new Promise(((t,n)=>{e(((e,i)=>{e?n(e):t({result:i})}))}))}function syncDone(e){let t,n;if(e(((e,i)=>{n=e,t=i})),n)throw n;return{result:t}}async function execAsync(e,t,n,i){let s;try{if(e instanceof Prop)s=e.context[e.prop];else if(Array.isArray(e)){let i=[];for(let s of e){const e=(await asyncDone((e=>execAsync(s,t,n,e)))).result;if(e instanceof ExecReturn){if(i.push(e.result),e.returned||e.breakLoop||e.continueLoop){i=e;break}}else i.push(e)}s=i}else if(e instanceof Lisp)if(["arrowFunc","function","inlineFunction","loop","try","switch","if"].includes(e.op))s=(await asyncDone((i=>ops.get(e.op)(execAsync,i,e.a,e.b,void 0,n,t)))).result;else if("await"===e.op)s=await(await asyncDone((i=>execAsync(e.a,t,n,i)))).result;else{let i=(await asyncDone((i=>execAsync(e.a,t,n,i)))).result,r=i instanceof Prop?i.context?i.context[i.prop]:void 0:i,o=(await asyncDone((i=>execAsync(e.b,t,n,i)))).result,a=o instanceof Prop?o.context?o.context[o.prop]:void 0:o;if(!ops.has(e.op))throw new SyntaxError("Unknown operator: "+e.op);s=(await asyncDone((s=>ops.get(e.op)(execAsync,s,r,a,i,n,t,o)))).result}else s=e;i(void 0,s)}catch(e){i(e)}}function syncDoneExec(e,t,n){let i,s;if(execSync(e,t,n,((e,t)=>{s=e,i=t})),s)throw s;return{result:i}}function syncDoneOp(e,t,n,i,s,r,o){let a,l;if(ops.get(e)(execSync,((e,t)=>{l=e,a=t}),t,n,i,s,r,o),l)throw l;return{result:a}}function execSync(e,t,n,i){let s;if(e instanceof Prop)s=e.context[e.prop];else if(Array.isArray(e)){let i=[];for(let s of e){const e=syncDoneExec(s,t,n).result;if(e instanceof ExecReturn){if(i.push(e.result),e.returned||e.breakLoop||e.continueLoop){i=e;break}}else i.push(e)}s=i}else if(e instanceof Lisp)if(["arrowFunc","function","inlineFunction","loop","try","switch","if"].includes(e.op))s=syncDoneOp(e.op,e.a,e.b,void 0,n,t).result;else{if("await"===e.op)throw new SandboxError("Illegal use of 'await', must be inside async function");{let i=syncDoneExec(e.a,t,n).result,r=i instanceof Prop?i.context?i.context[i.prop]:void 0:i,o=syncDoneExec(e.b,t,n).result,a=o instanceof Prop?o.context?o.context[o.prop]:void 0:o;if(!ops.has(e.op))throw new SyntaxError("Unknown operator: "+e.op);s=syncDoneOp(e.op,r,a,i,n,t,o).result}}else s=e;i(void 0,s)}function executeTree(e,t,n=[],i){return syncDone((s=>executeTreeWithDone(execSync,s,e,t,n,i))).result}async function executeTreeAsync(e,t,n=[],i){return(await asyncDone((s=>executeTreeWithDone(execAsync,s,e,t,n,i)))).result}function executeTreeWithDone(e,t,n,i,s=[],r){if(!i)return void t();if(!(i instanceof Array))throw new SyntaxError("Bad execution tree");let o,a=(n={ctx:n.ctx,constants:n.constants,inLoopOrSwitch:r}).ctx.globalScope;for(;o=s.shift();)"object"==typeof o&&(a=o instanceof Scope?o:new Scope(a,o,null));n.ctx.options.audit&&!n.ctx.auditReport&&(n.ctx.auditReport={globalsAccess:new Set,prototypeAccess:{}});let l=0,c=i[l];const p=(s,r)=>{if(s)t(new s.constructor(s.message));else if(r instanceof ExecReturn)t(void 0,r);else if(c instanceof Lisp&&"return"===c.op)t(void 0,new ExecReturn(n.ctx.auditReport,r,!0));else if(++l<i.length){c=i[l];try{e(c,a,n,p)}catch(e){t(e)}}else t(void 0,new ExecReturn(n.ctx.auditReport,void 0,!1))};try{e(c,a,n,p)}catch(e){t(e)}}class SandboxGlobal{constructor(e){if(e===globalThis)return globalThis;for(let t in e)this[t]=e[t]}}class Sandbox{constructor(options){options=Object.assign({audit:!1,forbidMethodCalls:!1,globals:Sandbox.SAFE_GLOBALS,prototypeWhitelist:Sandbox.SAFE_PROTOTYPES,prototypeReplacements:new Map},options||{});const sandboxGlobal=new SandboxGlobal(options.globals);this.context={sandbox:this,globalsWhitelist:new Set(Object.values(options.globals)),options:options,globalScope:new Scope(null,options.globals,sandboxGlobal),sandboxGlobal:sandboxGlobal,evals:new Map,getSubscriptions:new Set,setSubscriptions:new WeakMap,changeSubscriptions:new WeakMap};const func=sandboxFunction(this.context);this.context.evals.set(Function,func),this.context.evals.set(eval,sandboxedEval(func)),this.context.evals.set(setTimeout,sandboxedSetTimeout(func)),this.context.evals.set(setInterval,sandboxedSetInterval(func))}static get SAFE_GLOBALS(){return{Function:Function,console:{debug:console.debug,error:console.error,info:console.info,log:console.log,table:console.table,warn:console.warn},isFinite:isFinite,isNaN:isNaN,parseFloat:parseFloat,parseInt:parseInt,decodeURI:decodeURI,decodeURIComponent:decodeURIComponent,encodeURI:encodeURI,encodeURIComponent:encodeURIComponent,escape:escape,unescape:unescape,Boolean:Boolean,Number:Number,String:String,Object:Object,Array:Array,Symbol:Symbol,Error:Error,EvalError:EvalError,RangeError:RangeError,ReferenceError:ReferenceError,SyntaxError:SyntaxError,TypeError:TypeError,URIError:URIError,Int8Array:Int8Array,Uint8Array:Uint8Array,Uint8ClampedArray:Uint8ClampedArray,Int16Array:Int16Array,Uint16Array:Uint16Array,Int32Array:Int32Array,Uint32Array:Uint32Array,Float32Array:Float32Array,Float64Array:Float64Array,Map:Map,Set:Set,WeakMap:WeakMap,WeakSet:WeakSet,Promise:Promise,Intl:Intl,JSON:JSON,Math:Math,Date:Date,RegExp:RegExp}}static get SAFE_PROTOTYPES(){let e=[SandboxGlobal,Function,Boolean,Number,String,Date,Error,Array,Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array,Map,Set,WeakMap,WeakSet,Promise,Symbol,Date,RegExp],t=new Map;return e.forEach((e=>{t.set(e,new Set)})),t.set(Object,new Set(["entries","fromEntries","getOwnPropertyNames","is","keys","hasOwnProperty","isPrototypeOf","propertyIsEnumerable","toLocaleString","toString","valueOf","values"])),t}subscribeGet(e){return this.context.getSubscriptions.add(e),{unsubscribe:()=>this.context.getSubscriptions.delete(e)}}subscribeSet(e,t,n){const i=this.context.setSubscriptions.get(e)||new Map;this.context.setSubscriptions.set(e,i);const s=i.get(t)||new Set;let r;return i.set(t,s),s.add(n),e&&e[t]&&"object"==typeof e[t]&&(r=this.context.changeSubscriptions.get(e[t])||new Set,r.add(n),this.context.changeSubscriptions.set(e[t],r)),{unsubscribe:()=>{s.delete(n),r&&r.delete(n)}}}static audit(e,t=[]){const n={};for(let e of Object.getOwnPropertyNames(globalThis))n[e]=globalThis[e];return new Sandbox({globals:n,audit:!0}).executeTree(parse(e),t)}static parse(e){return parse(e)}executeTree(e,t=[]){return executeTree({ctx:this.context,constants:e.constants},e.tree,t)}executeTreeAsync(e,t=[]){return executeTreeAsync({ctx:this.context,constants:e.constants},e.tree,t)}compile(e){const t=parse(e);return(...e)=>this.executeTree(t,e).result}compileAsync(e){const t=parse(e);return async(...e)=>(await this.executeTreeAsync(t,e)).result}}export default Sandbox;export{SandboxGlobal};
//# sourceMappingURL=Sandbox.min.js.map
