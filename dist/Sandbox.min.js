function parseHexToInt(e){return!e.match(/[^a-f0-9]/i)?parseInt(e,16):NaN}function validateAndParseHex(e,t,n){const i=parseHexToInt(e);if(Number.isNaN(i)||void 0!==n&&n!==e.length)throw new SyntaxError(t+": "+e);return i}function parseHexadecimalCode(e){const t=validateAndParseHex(e,"Malformed Hexadecimal",2);return String.fromCharCode(t)}function parseUnicodeCode(e,t){const n=validateAndParseHex(e,"Malformed Unicode",4);if(void 0!==t){const e=validateAndParseHex(t,"Malformed Unicode",4);return String.fromCharCode(n,e)}return String.fromCharCode(n)}function isCurlyBraced(e){return"{"===e.charAt(0)&&"}"===e.charAt(e.length-1)}function parseUnicodeCodePointCode(e){if(!isCurlyBraced(e))throw new SyntaxError("Malformed Unicode: +"+e);const t=validateAndParseHex(e.slice(1,-1),"Malformed Unicode");try{return String.fromCodePoint(t)}catch(e){throw e instanceof RangeError?new SyntaxError("Code Point Limit:"+t):e}}const singleCharacterEscapes=new Map([["b","\b"],["f","\f"],["n","\n"],["r","\r"],["t","\t"],["v","\v"],["0","\0"]]);function parseSingleCharacterCode(e){return singleCharacterEscapes.get(e)||e}const escapeMatch=/\\(?:(\\)|x([\s\S]{0,2})|u(\{[^}]*\}?)|u([\s\S]{4})\\u([^{][\s\S]{0,3})|u([\s\S]{0,4})|([0-3]?[0-7]{1,2})|([\s\S])|$)/g;function unraw(e){return e.replace(escapeMatch,(function(e,t,n,i,r,o,s,a,c){if(void 0!==t)return"\\";if(void 0!==n)return parseHexadecimalCode(n);if(void 0!==i)return parseUnicodeCodePointCode(i);if(void 0!==r)return parseUnicodeCode(r,o);if(void 0!==s)return parseUnicodeCode(s);if("0"===a)return"\0";if(void 0!==a)throw new SyntaxError("Octal Deprecation: "+a);if(void 0!==c)return parseSingleCharacterCode(c);throw new SyntaxError("End of string")}))}let lispTypes=new Map;class ParseError extends Error{constructor(e,t){super(e+": "+t.substring(0,40)),this.code=t}}class Lisp{constructor(e){this.op=e.op,this.a=e.a,this.b=e.b}}class If{constructor(e,t){this.t=e,this.f=t}}class KeyVal{constructor(e,t){this.key=e,this.val=t}}class SpreadObject{constructor(e){this.item=e}}class SpreadArray{constructor(e){this.item=e}}function toLispArray(e){return e.lisp=!0,e}const inlineIfElse=/^:/,space=/^\s/;let expectTypes={splitter:{types:{split:/^(&(?!&)|\|(?!\|)|\+(?!(\+))|\-(?!(\-))|\^|<<|>>(?!>)|>>>|instanceof(?![\w\$])|in(?![\w\$]))(?!\=)/,op:/^(\/|\*\*|\*(?!\*)|\%)(?!\=)/,boolOp:/^(&&|\|\|)/,comparitor:/^(<=|>=|<(?!<)|>(?!>)|!==|!=(?!\=)|===|==)/},next:["modifier","value","prop","incrementerBefore"]},inlineIf:{types:{inlineIf:/^\?/},next:["expEnd"]},assignment:{types:{assignModify:/^(\-=|\+=|\/=|\*\*=|\*=|%=|\^=|\&=|\|=|>>>=|>>=|<<=)/,assign:/^(=)(?!=)/},next:["modifier","value","prop","incrementerBefore"]},incrementerBefore:{types:{incrementerBefore:/^(\+\+|\-\-)/},next:["prop"]},expEdge:{types:{call:/^(\?\.)?[\(]/,incrementerAfter:/^(\+\+|\-\-)/},next:["splitter","expEdge","inlineIf","dot","expEnd"]},modifier:{types:{not:/^!/,inverse:/^~/,negative:/^\-(?!\-)/,positive:/^\+(?!\+)/,typeof:/^typeof(?![\w\$])/,delete:/^delete(?![\w\$])/},next:["modifier","value","prop","incrementerBefore"]},dot:{types:{arrayProp:/^(\?\.)?\[/,dot:/^(\?)?\.(?=\s*[a-zA-Z\$\_])/},next:["splitter","assignment","expEdge","dot","inlineIf","expEnd"]},prop:{types:{prop:/^[a-zA-Z\$\_][a-zA-Z\d\$\_]*/},next:["splitter","assignment","expEdge","dot","inlineIf","expEnd"]},value:{types:{createObject:/^\{/,createArray:/^\[/,number:/^(0x[\da-f]+(_[\da-f]+)*|(\d+(_\d+)*(\.\d+(_\d+)*)?|\.\d+(_\d+)*))(e[\+\-]?\d+(_\d+)*)?(n)?(?!\d)/i,string:/^"(\d+)"/,literal:/^`(\d+)`/,regex:/^\/(\d+)\/r(?![\w\$])/,boolean:/^(true|false)(?![\w\$])/,null:/^null(?![\w\$])/,und:/^undefined(?![\w\$])/,arrowFunctionSingle:/^(async\s+)?([a-zA-Z\$_][a-zA-Z\d\$_]*)\s*=>\s*({)?/,arrowFunction:/^(async\s*)?\(\s*((\.\.\.)?\s*[a-zA-Z\$_][a-zA-Z\d\$_]*(\s*,\s*(\.\.\.)?\s*[a-zA-Z\$_][a-zA-Z\d\$_]*)*)?\s*\)\s*=>\s*({)?/,inlineFunction:/^(async\s+)?function(\s*[a-zA-Z\$_][a-zA-Z\d\$_]*)?\s*\(\s*((\.\.\.)?\s*[a-zA-Z\$_][a-zA-Z\d\$_]*(\s*,\s*(\.\.\.)?\s*[a-zA-Z\$_][a-zA-Z\d\$_]*)*)?\s*\)\s*{/,group:/^\(/,NaN:/^NaN(?![\w\$])/,Infinity:/^Infinity(?![\w\$])/,void:/^void(?![\w\$])\s*/,await:/^await(?![\w\$])\s*/,new:/^new(?![\w\$])\s*/,throw:/^throw(?![\w\$])\s*/},next:["splitter","expEdge","dot","inlineIf","expEnd"]},initialize:{types:{initialize:/^(var|let|const)\s+([a-zA-Z\$_][a-zA-Z\d\$_]*)\s*(=)?/,return:/^return(?![\w\$])/},next:["modifier","value","prop","incrementerBefore","expEnd"]},spreadObject:{types:{spreadObject:/^\.\.\./},next:["value","prop"]},spreadArray:{types:{spreadArray:/^\.\.\./},next:["value","prop"]},expEnd:{types:{},next:[]},expFunction:{types:{function:/^(async\s+)?function(\s*[a-zA-Z\$_][a-zA-Z\d\$_]*)\s*\(\s*((\.\.\.)?\s*[a-zA-Z\$_][a-zA-Z\d\$_]*(\s*,\s*(\.\.\.)?\s*[a-zA-Z\$_][a-zA-Z\d\$_]*)*)?\s*\)\s*{/},next:["expEdge","expEnd"]},expSingle:{types:{for:/^(([a-zA-Z\$\_][\w\$]*)\s*:)?\s*for\s*\(/,do:/^(([a-zA-Z\$\_][\w\$]*)\s*:)?\s*do(?![\w\$])\s*(\{)?/,while:/^(([a-zA-Z\$\_][\w\$]*)\s*:)?\s*while\s*\(/,loopAction:/^(break|continue)(?![\w\$])\s*([a-zA-Z\$\_][\w\$]*)?/,if:/^(([a-zA-Z\$\_][\w\$]*)\s*:)?\s*if\s*\(/,try:/^try\s*{/,block:/^{/,switch:/^(([a-zA-Z\$\_][\w\$]*)\s*:)?\s*switch\s*\(/},next:["expEnd"]}},closings={"(":")","[":"]","{":"}","'":"'",'"':'"',"`":"`"};function testMultiple(e,t){let n;for(let i=0;i<t.length;i++){if(n=t[i].exec(e),n)break}return n}const okFirstChars=/^[\+\-~ !]/,aNumber=expectTypes.value.types.number,wordReg=/^((if|for|while|do|function)(?![\w\$])|[\w\$]+)/;function restOfExp(e,t,n,i,r,o,s={}){s.words=s.words||[];let a=!0;n=n||[];let c,p=!1,l=!1,u="",f=!1;for(c=0;c<t.length&&!l;c++){let d=t[c];if('"'===i||"'"===i||"`"===i){if("`"!==i||"$"!==d||"{"!==t[c+1]||p){if(d===i&&!p)return t.substring(0,c)}else{c+=restOfExp(e,t.substring(c+2),[],"{").length+2}p=!p&&"\\"===d}else if(closings[d]){if(f&&"{"===d&&(f=!1),d===r){l=!0;break}if(c+=restOfExp(e,t.substring(c+1),[],d).length+1,a=!1,o){let e;(e=testMultiple(t.substring(c),o))&&(s.regRes=e,l=!0)}}else if(i){if(d===closings[i])return t.substring(0,c)}else{let e,i,r=t.substring(c);if(o){let e;(e=testMultiple(r,o))&&(s.regRes=e,l=!0)}if(i=aNumber.exec(r))c+=i[0].length-1,r=t.substring(c);else if(u!=d){let t=testMultiple(r,n);t&&(o&&t[1].length&&(c+=t[1].length-1),l=!0),!l&&(e=wordReg.exec(r))&&(f=!0,s.words.push(e[1]),s.lastAnyWord=e[1],e[2]&&(s.lastWord=e[2]),e[0].length>2&&(c+=e[0].length-2))}if(a&&(okFirstChars.test(r)?l=!1:a=!1),l)break}u=d}if(i)throw new ParseError("Unclosed '"+i+"'",i+t.substring(0,Math.min(c,40)));return s&&(s.oneliner=f),t.substring(0,c)}restOfExp.next=["splitter","expEnd","inlineIf"];const startingExecpted=["initialize","expSingle","expFunction","value","modifier","prop","incrementerBefore","expEnd"],setLispType=(e,t)=>{e.forEach((e=>{lispTypes.set(e,t)}))},closingsCreate={createArray:/^\]/,createObject:/^\}/,group:/^\)/,arrayProp:/^\]/,call:/^\)/};setLispType(["createArray","createObject","group","arrayProp","call"],((e,t,n,i,r,o)=>{let s="",a=[],c=!1,p=i[0].length;for(;p<n.length&&!c;)s=restOfExp(e,n.substring(p),[closingsCreate[t],/^,/]),p+=s.length,s&&a.push(s),","!==n[p]?c=!0:p++;const l=["value","modifier","prop","incrementerBefore","expEnd"];let u,f;switch(t){case"group":case"arrayProp":u=lispifyExpr(e,a.join(","));break;case"call":case"createArray":u=toLispArray(a.map((t=>lispify(e,t,[...l,"spreadArray"]))));break;case"createObject":u=toLispArray(a.map((t=>{let n,i;if(t=t.trimStart(),f=expectTypes.expFunction.types.function.exec("function "+t),f)i=f[2].trimStart(),n=lispify(e,"function "+t.replace(i,""));else{let r=restOfExp(e,t,[/^:/]);if(i=lispify(e,r,[...l,"spreadObject"]),i instanceof Lisp&&"prop"===i.op&&(i=i.b),r.length===t.length)return i;n=lispify(e,t.substring(r.length+1))}return new Lisp({op:"keyVal",a:i,b:n})})))}t="arrayProp"===t?i[1]?"?prop":"prop":"call"===t?i[1]?"?call":"call":t,o.lispTree=lispify(e,n.substring(p+1),expectTypes[r].next,new Lisp({op:t,a:o.lispTree,b:u}))})),setLispType(["inverse","not","negative","positive","typeof","delete"],((e,t,n,i,r,o)=>{let s=restOfExp(e,n.substring(i[0].length),[/^[^\s\.\w\$]/]);o.lispTree=lispify(e,n.substring(s.length+i[0].length),restOfExp.next,new Lisp({op:["positive","negative"].includes(t)?"$"+i[0]:i[0],a:o.lispTree,b:lispify(e,s,expectTypes[r].next)}))})),setLispType(["incrementerBefore"],((e,t,n,i,r,o)=>{let s=restOfExp(e,n.substring(2),[/^[^\s\.\w\$]/]);o.lispTree=lispify(e,n.substring(s.length+2),restOfExp.next,new Lisp({op:i[0]+"$",a:lispify(e,s,expectTypes[r].next)}))})),setLispType(["incrementerAfter"],((e,t,n,i,r,o)=>{o.lispTree=lispify(e,n.substring(i[0].length),expectTypes[r].next,new Lisp({op:"$"+i[0],a:o.lispTree}))})),setLispType(["assign","assignModify","boolOp"],((e,t,n,i,r,o)=>{o.lispTree=new Lisp({op:i[0],a:o.lispTree,b:lispify(e,n.substring(i[0].length),expectTypes[r].next)})})),setLispType(["split","comparitor","op"],((e,t,n,i,r,o)=>{const s=[expectTypes.inlineIf.types.inlineIf,inlineIfElse];switch(t){case"op":s.push(expectTypes.splitter.types.op);case"split":s.push(expectTypes.splitter.types.split);case"comparitor":s.push(expectTypes.splitter.types.comparitor),s.push(expectTypes.splitter.types.boolOp)}let a=restOfExp(e,n.substring(i[0].length),s);o.lispTree=lispify(e,n.substring(a.length+i[0].length),restOfExp.next,new Lisp({op:i[0],a:o.lispTree,b:lispify(e,a,expectTypes[r].next)}))})),setLispType(["inlineIf"],((e,t,n,i,r,o)=>{let s=!1,a="",c=1;for(;!s&&a.length<n.length;)a+=restOfExp(e,n.substring(a.length+1),[expectTypes.inlineIf.types.inlineIf,inlineIfElse]),"?"===n[a.length+1]?c++:c--,c?a+=n[a.length+1]:s=!0;o.lispTree=new Lisp({op:"?",a:o.lispTree,b:new Lisp({op:":",a:lispifyExpr(e,a),b:lispifyExpr(e,n.substring(i[0].length+a.length+1))})})})),setLispType(["if"],((e,t,n,i,r,o)=>{let s=restOfExp(e,n.substring(i[0].length),[],"(");const a=/^\s*\{/.exec(n.substring(i[0].length+s.length+1)),c=i[0].length+s.length+1+(a?a[0].length:0);let p=restOfExp(e,n.substring(c),a?[/^\}/]:[/^;/]),l="";if(c+p.length+(a?a[0].length:0)<n.length){const e=n.substring(c+p.length+(a?a[0].length:1)),t=/^;?\s*else(?![\w\$])\s*/.exec(e);t&&(l=e.substring(t[0].length))}s=s.trim(),p=p.trim(),l=l.trim(),"{"===p[0]&&(p=p.slice(1,-1)),"{"===l[0]&&(l=l.slice(1,-1)),o.lispTree=new Lisp({op:"if",a:lispifyExpr(e,s),b:new If(lispifyBlock(p,e),l?lispifyBlock(l,e):void 0)})})),setLispType(["switch"],((e,t,n,i,r,o)=>{const s=restOfExp(e,n.substring(i[0].length),[],"(");let a=n.indexOf("{",i[0].length+s.length+1);if(-1===a)throw new SyntaxError("Invalid switch");let c,p=insertSemicolons(e,restOfExp(e,n.substring(a+1),[],"{"));const l=/^\s*(case\s|default)\s*/;let u=[],f=!1;for(;c=l.exec(p);){if("default"===c[1]){if(f)throw new SyntaxError("Only one default switch case allowed");f=!0}let t=restOfExp(e,p.substring(c[0].length),[/^:/]),n="",i=a=c[0].length+t.length+1,r=/^\s*\{/.exec(p.substring(i)),o=[];if(r)i+=r[0].length,n=restOfExp(e,p.substring(i),[],"{"),i+=n.length+1,o=lispifyBlock(n,e);else{let t=restOfExp(e,p.substring(i),[l]);if(t.trim()){let t=[];for(;(n=restOfExp(e,p.substring(i),[/^;/]))&&(t.push(n),i+=n.length+1,!l.test(p.substring(i))););o=lispifyBlock(t.join(";"),e)}else o=[],i+=t.length}p=p.substring(i),u.push(new Lisp({op:"case",a:"default"===c[1]?void 0:lispifyExpr(e,t),b:toLispArray(o)}))}o.lispTree=new Lisp({op:"switch",a:lispifyExpr(e,s),b:toLispArray(u)})})),setLispType(["dot","prop"],((e,t,n,i,r,o)=>{let s=i[0],a=i[0].length,c="prop";if("dot"===t){i[1]&&(c="?prop");let e=n.substring(i[0].length).match(expectTypes.prop.types.prop);if(!e||!e.length)throw new SyntaxError("Hanging  dot");s=e[0],a=s.length+i[0].length}o.lispTree=lispify(e,n.substring(a),expectTypes[r].next,new Lisp({op:c,a:o.lispTree,b:s}))})),setLispType(["spreadArray","spreadObject"],((e,t,n,i,r,o)=>{o.lispTree=new Lisp({op:t,b:lispify(e,n.substring(i[0].length),expectTypes[r].next)})})),setLispType(["return","throw"],((e,t,n,i,r,o)=>{o.lispTree=new Lisp({op:t,b:lispifyExpr(e,n.substring(i[0].length))})}));const primitives={true:!0,false:!1,null:null,Infinity:1/0,NaN:NaN,und:void 0};setLispType(["number","boolean","null","und","NaN","Infinity"],((e,t,n,i,r,o)=>{o.lispTree=lispify(e,n.substring(i[0].length),expectTypes[r].next,"number"===t?i[10]?BigInt(i[1]):Number(i[0]):primitives["boolean"===t?i[0]:t])})),setLispType(["string","literal","regex"],((e,t,n,i,r,o)=>{o.lispTree=lispify(e,n.substring(i[0].length),expectTypes[r].next,new Lisp({op:t,b:parseInt(JSON.parse(i[1]),10)}))})),setLispType(["initialize"],((e,t,n,i,r,o)=>{i[3]?o.lispTree=new Lisp({op:i[1],a:i[2],b:lispify(e,n.substring(i[0].length),expectTypes[r].next)}):o.lispTree=lispify(e,n.substring(i[0].length),expectTypes[r].next,new Lisp({op:i[1],a:i[2]}))})),setLispType(["function","inlineFunction","arrowFunction","arrowFunctionSingle"],((e,t,n,i,r,o)=>{const s="function"!==t&&"inlineFunction"!==t,a=s&&!i[i.length-1],c=s?2:3,p=!!i[1],l=i[c]?i[c].replace(/\s+/g,"").split(/,/g):[];s||l.unshift((i[2]||"").trimStart());let u=!1;l.forEach((e=>{if(u)throw new SyntaxError("Rest parameter must be last formal parameter");e.startsWith("...")&&(u=!0)})),l.unshift(p);const f=(a?"return ":"")+restOfExp(e,n.substring(i[0].length),a?[/^[,;\)\}\]]/]:[/^}/]);o.lispTree=lispify(e,n.substring(i[0].length+f.length+1),expectTypes[r].next,new Lisp({op:s?"arrowFunc":t,a:toLispArray(l),b:e.eager?lispifyFunction(f,e):f}))}));const iteratorRegex=/^((let|var|const)\s+)?\s*([a-zA-Z\$_][a-zA-Z\d\$_]*)\s+(in|of)(?![\w\$])/;setLispType(["for","do","while"],((e,t,n,i,r,o)=>{let s,a,c,p=0,l=!0,u=toLispArray([]),f=!1,d=!0,h=!0;switch(t){case"while":p=n.indexOf("(")+1;let t=restOfExp(e,n.substring(p),[],"(");a=lispifyExpr(e,t),c=restOfExp(e,n.substring(p+t.length+1)).trim(),"{"===c[0]&&(c=c.slice(1,-1));break;case"for":p=n.indexOf("(")+1;let r,o=[],x="";for(let t=0;t<3&&(x=restOfExp(e,n.substring(p),[/^[;\)]/]),o.push(x.trim()),p+=x.length+1,")"!==n[p-1]);t++);if(1===o.length&&(r=iteratorRegex.exec(o[0])))"of"===r[4]?(s=lispifyExpr(e,o[0].substring(r[0].length)),u=toLispArray([ofStart2,ofStart3]),a=ofCondition,h=ofStep,f=lispify(e,(r[1]||"let ")+r[3]+" = $$next.value",["initialize"])):(s=lispifyExpr(e,o[0].substring(r[0].length)),u=toLispArray([inStart2,inStart3]),h=inStep,a=inCondition,f=lispify(e,(r[1]||"let ")+r[3]+" = $$keys[$$keyIndex]",["initialize"]));else{if(3!==o.length)throw new SyntaxError("Invalid for loop definition");l=lispifyExpr(e,o.shift(),startingExecpted),a=lispifyExpr(e,o.shift()),h=lispifyExpr(e,o.shift())}c=restOfExp(e,n.substring(p)).trim(),"{"===c[0]&&(c=c.slice(1,-1));break;case"do":d=!1;const y=!!i[3];c=restOfExp(e,n.substring(i[0].length),y?[/^\}/]:[/^;/]),a=lispifyExpr(e,restOfExp(e,n.substring(n.indexOf("(",i[0].length+c.length)+1),[],"("))}const x=[d,u,s,l,h,a,f];x.lisp=!0,o.lispTree=new Lisp({op:"loop",a:x,b:lispifyBlock(c,e)})})),setLispType(["block"],((e,t,n,i,r,o)=>{o.lispTree=lispifyBlock(restOfExp(e,n.substring(1),[],"{"),e)})),setLispType(["loopAction"],((e,t,n,i,r,o)=>{o.lispTree=new Lisp({op:"loopAction",a:i[1]})}));const catchReg=/^\s*(catch\s*(\(\s*([a-zA-Z\$_][a-zA-Z\d\$_]*)\s*\))?|finally)\s*\{/;setLispType(["try"],((e,t,n,i,r,o)=>{const s=restOfExp(e,n.substring(i[0].length),[],"{");let a,c,p,l=catchReg.exec(n.substring(i[0].length+s.length+1)),u=0;l[1].startsWith("catch")?(l=catchReg.exec(n.substring(i[0].length+s.length+1)),c=l[2],p=restOfExp(e,n.substring(i[0].length+s.length+1+l[0].length),[],"{"),u=i[0].length+s.length+1+l[0].length+p.length+1,(l=catchReg.exec(n.substring(u)))&&l[1].startsWith("finally")&&(a=restOfExp(e,n.substring(u+l[0].length),[],"{"))):a=restOfExp(e,n.substring(i[0].length+s.length+1+l[0].length),[],"{");const f=[c,lispifyBlock(insertSemicolons(e,p||""),e),lispifyBlock(insertSemicolons(e,a||""),e)];f.lisp=!0,o.lispTree=new Lisp({op:"try",a:lispifyBlock(insertSemicolons(e,s),e),b:f})})),setLispType(["void","await"],((e,t,n,i,r,o)=>{const s=restOfExp(e,n.substring(i[0].length),[/^[^\s\.\w\$]/]);o.lispTree=lispify(e,n.substring(i[0].length+s.length),expectTypes[r].next,new Lisp({op:t,a:lispify(e,s)}))})),setLispType(["new"],((e,t,n,i,r,o)=>{let s=i[0].length;const a=restOfExp(e,n.substring(s),[],void 0,"(");s+=a.length+1;const c=[];if("("===n[s-1]){const t=restOfExp(e,n.substring(s),[],"(");let i;s+=t.length+1;let r=0;for(;i=restOfExp(e,t.substring(r),[/^,/]);)r+=i.length+1,c.push(i.trim())}o.lispTree=lispify(e,n.substring(s),expectTypes.expEdge.next,new Lisp({op:t,a:lispify(e,a,expectTypes.initialize.next),b:toLispArray(c.map((t=>lispify(e,t,expectTypes.initialize.next))))}))}));const ofStart2=lispify(void 0,"let $$iterator = $$obj[Symbol.iterator]()",["initialize"]),ofStart3=lispify(void 0,"let $$next = $$iterator.next()",["initialize"]),ofCondition=lispify(void 0,"return !$$next.done",["initialize"]),ofStep=lispify(void 0,"$$next = $$iterator.next()"),inStart2=lispify(void 0,"let $$keys = Object.keys($$obj)",["initialize"]),inStart3=lispify(void 0,"let $$keyIndex = 0",["initialize"]),inStep=lispify(void 0,"$$keyIndex++"),inCondition=lispify(void 0,"return $$keyIndex < $$keys.length",["initialize"]);var lastType;function lispify(e,t,n,i,r=!1){if(n=n||expectTypes.initialize.next,void 0===t)return i;if(!(t=t.trim()).length&&!n.includes("expEnd"))throw new SyntaxError("Unexpected end of expression");if(!t)return i;let o,s={lispTree:i};for(let i of n)if("expEnd"!==i){for(let n in expectTypes[i].types)if("expEnd"!==n&&(o=expectTypes[i].types[n].exec(t))){lastType=n;try{lispTypes.get(n)(e,n,t,o,i,s)}catch(e){if(r&&e instanceof SyntaxError)throw new ParseError(e.message,t);throw e}break}if(o)break}if(!o&&t.length)throw SyntaxError(`Unexpected token after ${lastType}: ${t[0]}`);return s.lispTree}const startingExpectedWithoutSingle=startingExecpted.filter((e=>"expSingle"!==e));function lispifyExpr(e,t,n){if(!t.trim())return;let i,r=[],o=0;if((n=n||expectTypes.initialize.next).includes("expSingle")&&testMultiple(t,Object.values(expectTypes.expSingle.types)))return lispify(e,t,["expSingle"],void 0,!0);for(n===startingExecpted&&(n=startingExpectedWithoutSingle);i=restOfExp(e,t.substring(o),[/^,/]);)r.push(i.trimStart()),o+=i.length+1;if(1===r.length)return lispify(e,t,n,void 0,!0);if(n.includes("initialize")){let i=expectTypes.initialize.types.initialize.exec(r[0]);if(i)return toLispArray(r.map(((t,n)=>lispify(e,n?i[1]+" "+t:t,["initialize"],void 0,!0))));if(expectTypes.initialize.types.return.exec(r[0]))return lispify(e,t,n,void 0,!0)}const s=toLispArray(r.map(((t,i)=>lispify(e,t,n,void 0,!0))));return new Lisp({op:"multi",a:s})}function lispifyBlock(e,t){if(!(e=insertSemicolons(t,e)).trim())return toLispArray([]);let n,i=[],r=0,o={},s=[];for(;n=restOfExp(t,e.substring(r),[/^;/],void 0,void 0,void 0,o);)o.words.includes("if")&&/^\s*else(?![\w\$])/.test(e.substring(r+n.length+1))||o.words.includes("do")&&/^\s*while(?![\w\$])/.test(e.substring(r+n.length+1))?s.push(n,";"):(i.push(s.join("")+n),s=[]),o={},r+=n.length+1;return s.length&&i.push(s.join("")),toLispArray(i.filter(Boolean).map(((e,n)=>lispifyExpr(t,e.trimStart(),startingExecpted))).flat())}function lispifyFunction(e,t){if(!e.trim())return toLispArray([]);const n=lispifyBlock(e,t);let i=toLispArray([]);return hoist(n,i),toLispArray(i.concat(n))}function hoist(e,t){if(Array.isArray(e)){const n=[];for(let i of e)hoist(i,t)||n.push(i);n.length!==e.length&&(e.length=0,e.push(...n))}else if(e instanceof Lisp)if("try"===e.op||"if"===e.op||"loop"===e.op||"switch"===e.op)hoist(e.a,t),hoist(e.b,t);else if("var"===e.op)t.push(new Lisp({op:"var",a:e.a}));else if("function"===e.op&&e.a[1])return t.push(e),!0;return!1}const closingsNoInsertion=/^(\})\s*(catch|finally|else|while|instanceof)(?![\w\$])/,colonsRegex=/^((([\w\$\]\)]|\+\+|\-\-)\s*\r?\n\s*([\w\$\+\-\!~]))|(\}\s*[\w\$\!~\+\-\{\(]))/;function insertSemicolons(e,t){let n=t,i="",r=[],o={};for(;i=restOfExp(e,n,[],void 0,void 0,[colonsRegex],o);){let e=!1,t=i,s=i.length;if(o.regRes){e=!0;const[,,r,,,a]=o.regRes;if(s="++"===o.regRes[3]||"--"===o.regRes[3]?i.length+1:i.length,t=n.substring(0,s),a){let t=closingsNoInsertion.exec(n.substring(i.length-1));t?e="while"===t[2]&&"do"!==o.lastWord:"function"===o.lastWord&&"}"===o.regRes[5][0]&&"("===o.regRes[5].slice(-1)&&(e=!1)}else r&&("if"!==o.lastWord&&"while"!==o.lastWord||(e=!1))}r.push(t),e&&r.push(";"),n=n.substring(s),o={}}return r.join("")}function checkRegex(e){let t=1,n=!1,i=!1,r=!1;for(;t<e.length&&!i&&!r;)i="/"===e[t]&&!n,n="\\"===e[t]&&!n,r="\n"===e[t],t++;let o=e.substring(t);if(r=r||!i||/^\s*\d/.test(o),r)return null;let s=/^[a-z]*/.exec(o);return/^\s+[\w\$]/.test(e.substring(t+s[0].length))?null:{regex:e.substring(1,t-1),flags:s&&s[0]||"",length:t+(s&&s[0].length||0)}}const notDivide=/(typeof|delete|instanceof|return|in|of|throw|new|void|do|if)$/,possibleDivide=/^([\w\$\]\)]|\+\+|\-\-)[\s\/]/;function extractConstants(e,t,n=""){let i,r,o=[],s=!1,a="",c=-1,p=toLispArray([]),l="";const u=[],f=[];let d;for(var h=0;h<t.length;h++)if(l=t[h],a)l===a&&("*"===a&&"/"===t[h+1]?(a="",h++):"\n"===a&&(a=""));else{if(s){s=!1,o.push(l);continue}if(i)if("`"===i&&"$"===l&&"{"===t[h+1]){let n=extractConstants(e,t.substring(h+2),"{");p.push(n.str),o.push("${",p.length-1,"}"),h+=n.length+2}else i===l?("`"===i?(e.literals.push({op:"literal",a:unraw(o.join("")),b:p}),u.push("`",e.literals.length-1,"`")):(e.strings.push(unraw(o.join(""))),u.push('"',e.strings.length-1,'"')),i=null,o=[]):o.push(l);else{if("'"===l||'"'===l||"`"===l)p=toLispArray([]),i=l;else{if(closings[n]===l&&!f.length)return{str:u.join(""),length:h};closings[l]?(f.push(l),u.push(l)):closings[f[f.length-1]]===l?(f.pop(),u.push(l)):"/"!==l||"*"!==t[h+1]&&"/"!==t[h+1]?"/"===l&&!d&&(r=checkRegex(t.substring(h)))?(e.regexes.push(r),u.push("/",e.regexes.length-1,"/r"),h+=r.length-1):u.push(l):(a="*"===t[h+1]?"*":"\n",c=h)}d&&space.test(l)||(d=possibleDivide.exec(t.substring(h)))&&notDivide.test(t.substring(0,h+d[1].length))&&(d=null)}s=i&&"\\"===l}if(a&&"*"===a)throw new SyntaxError("Unclosed comment '/*': "+t.substring(c));return{str:u.join(""),length:h}}function parse(e,t=!1){if("string"!=typeof e)throw new ParseError("Cannot parse "+e,e);let n=" "+e;const i={strings:[],literals:[],regexes:[],eager:t};n=extractConstants(i,n).str;for(let e of i.literals)e.b=toLispArray(e.b.map((e=>lispifyExpr(i,e))));return{tree:lispifyFunction(n,i),constants:i}}class ExecReturn{constructor(e,t,n,i=!1,r=!1){this.auditReport=e,this.result=t,this.returned=n,this.breakLoop=i,this.continueLoop=r}}class Prop{constructor(e,t,n=!1,i=!1,r=!1){this.context=e,this.prop=t,this.isConst=n,this.isGlobal=i,this.isVariable=r}}const optional=Symbol("optional"),reservedWords=new Set(["instanceof","typeof","return","try","catch","if","finally","else","in","of","var","let","const","for","delete","false","true","while","do","break","continue","new","function","async","await","switch","case"]);var VarType;!function(e){e.let="let",e.const="const",e.var="var"}(VarType||(VarType={}));class Scope{constructor(e,t={},n){this.const={},this.let={};const i=void 0!==n||null===e;this.parent=e,this.allVars=t,this.let=i?this.let:Object.assign({},t),this.var=i?Object.assign({},t):this.var,this.globals=null===e?Object.assign({},t):new Set,this.functionThis=n}get(e,t=!1){if("this"===e&&void 0!==this.functionThis)return new Prop({this:this.functionThis},e,!0,!1,!0);if(reservedWords.has(e))throw new SyntaxError("Unexepected token '"+e+"'");if(null===this.parent||!t||void 0!==this.functionThis){if(this.globals.hasOwnProperty(e))return new Prop(this.functionThis,e,!1,!0,!0);if(e in this.allVars&&(!(e in{})||this.allVars.hasOwnProperty(e)))return new Prop(this.allVars,e,this.const.hasOwnProperty(e),this.globals.hasOwnProperty(e),!0);if(null===this.parent)return new Prop(void 0,e)}return this.parent.get(e,t)}set(e,t){if("this"===e)throw new SyntaxError('"this" cannot be assigned');if(reservedWords.has(e))throw new SyntaxError("Unexepected token '"+e+"'");let n=this.get(e);if(void 0===n.context)throw new ReferenceError(`Variable '${e}' was not declared.`);if(n.isConst)throw new TypeError(`Cannot assign to const variable '${e}'`);if(n.isGlobal)throw new SandboxError(`Cannot override global variable '${e}'`);return n.context[n]=t,n}declare(e,t=null,n,i=!1){if("this"===e)throw new SyntaxError('"this" cannot be declared');if(reservedWords.has(e))throw new SyntaxError("Unexepected token '"+e+"'");if("var"===t&&void 0===this.functionThis&&null!==this.parent)return this.parent.declare(e,t,n,i);if((!this[t].hasOwnProperty(e)||"const"===t||this.globals.hasOwnProperty(e))&&e in this.allVars)throw new SandboxError(`Identifier '${e}' has already been declared`);return i&&(this.globals[e]=!0),this[t][e]=!0,this.allVars[e]=n,new Prop(this.allVars,e,this.const.hasOwnProperty(e),i)}}class SandboxError extends Error{}let currentTicks;function sandboxFunction(e){return function SandboxFunction(...t){let n=parse(t.pop()||"");return createFunction(t,n.tree,currentTicks,{ctx:e,constants:n.constants,tree:n.tree},void 0,"anonymous")}}function generateArgs(e,t){const n={};return e.forEach(((e,i)=>{e.startsWith("...")?n[e.substring(3)]=t.slice(i):n[e]=t[i]})),n}const sandboxedFunctions=new WeakSet;function createFunction(e,t,n,i,r,o){if(i.ctx.options.forbidFunctionCreation)throw new SandboxError("Function creation is forbidden");let s;return s=void 0===o?(...o)=>{const s=generateArgs(e,o);return executeTree(n,i,t,void 0===r?[]:[new Scope(r,s)]).result}:function(...o){const s=generateArgs(e,o);return executeTree(n,i,t,void 0===r?[]:[new Scope(r,s,this)]).result},sandboxedFunctions.add(s),s}function createFunctionAsync(e,t,n,i,r,o){var s;if(i.ctx.options.forbidFunctionCreation)throw new SandboxError("Function creation is forbidden");if(!(null===(s=i.ctx.options.prototypeWhitelist)||void 0===s?void 0:s.has(Promise)))throw new SandboxError("Async/await not permitted");let a;return a=void 0===o?async(...o)=>{const s=generateArgs(e,o);return(await executeTreeAsync(n,i,t,void 0===r?[]:[new Scope(r,s)])).result}:async function(...o){const s=generateArgs(e,o);return(await executeTreeAsync(n,i,t,void 0===r?[]:[new Scope(r,s,this)])).result},sandboxedFunctions.add(a),a}function sandboxedEval(e){return function(t){return e(t)()}}function sandboxedSetTimeout(e){return function(t,...n){return"string"!=typeof t?setTimeout(t,...n):setTimeout(e(t),...n)}}function sandboxedSetInterval(e){return function(t,...n){return"string"!=typeof t?setInterval(t,...n):setInterval(e(t),...n)}}function assignCheck(e,t,n="assign"){var i,r,o,s;if(void 0===e.context)throw new ReferenceError(`Cannot ${n} value to undefined.`);if("object"!=typeof e.context&&"function"!=typeof e.context)throw new SyntaxError(`Cannot ${n} value to a primitive.`);if(e.isConst)throw new TypeError(`Cannot set value to const variable '${e.prop}'`);if(e.isGlobal)throw new SandboxError(`Cannot ${n} property '${e.prop}' of a global object`);if("function"==typeof e.context[e.prop]&&!e.context.hasOwnProperty(e.prop))throw new SandboxError(`Override prototype property '${e.prop}' not allowed`);"delete"===n?e.context.hasOwnProperty(e.prop)&&(null===(i=t.ctx.changeSubscriptions.get(e.context))||void 0===i||i.forEach((t=>t({type:"delete",prop:e.prop})))):e.context.hasOwnProperty(e.prop)?null===(o=null===(r=t.ctx.setSubscriptions.get(e.context))||void 0===r?void 0:r.get(e.prop))||void 0===o||o.forEach((e=>e({type:"replace"}))):null===(s=t.ctx.changeSubscriptions.get(e.context))||void 0===s||s.forEach((t=>t({type:"create",prop:e.prop})))}const arrayChange=new Set([[].push,[].pop,[].shift,[].unshift,[].splice,[].reverse,[].sort,[].copyWithin]),literalRegex=/(\$\$)*(\$)?\${(\d+)}/g;let ops2={prop:(e,t,n,i,r,o,s,a)=>{if(null===i)throw new TypeError(`Cannot get property ${r} of null`);const c=typeof i;if("undefined"===c&&void 0===o){let e=a.get(r);if(void 0===e.context)throw new ReferenceError(r+" is not defined");if(e.context===s.ctx.sandboxGlobal){s.ctx.options.audit&&s.ctx.auditReport.globalsAccess.add(r);const e=s.ctx.globalsWhitelist.has(s.ctx.sandboxGlobal[r])?s.ctx.evals.get(s.ctx.sandboxGlobal[r]):void 0;if(e)return void t(void 0,e)}return e.context&&e.context[r]===globalThis?void t(void 0,s.ctx.globalScope.get("this")):(s.ctx.getSubscriptions.forEach((t=>t(e.context,e.prop))),void t(void 0,e))}if(void 0===i)throw new SandboxError("Cannot get property '"+r+"' of undefined");if("object"!==c)"number"===c?i=new Number(i):"string"===c?i=new String(i):"boolean"===c&&(i=new Boolean(i));else if(void 0===i.hasOwnProperty)return void t(void 0,new Prop(void 0,r));const p="function"===c;let l=p||!(i.hasOwnProperty(r)||"number"==typeof r);if(s.ctx.options.audit&&l&&"string"==typeof r){let e=i.constructor.prototype;do{e.hasOwnProperty(r)&&(s.ctx.auditReport.prototypeAccess[e.constructor.name]||(s.ctx.auditReport.prototypeAccess[e.constructor.name]=new Set),s.ctx.auditReport.prototypeAccess[e.constructor.name].add(r))}while(e=Object.getPrototypeOf(e))}if(l)if(p){if(!["name","length","constructor"].includes(r)&&i.hasOwnProperty(r)){const e=s.ctx.options.prototypeWhitelist.get(i),n=s.ctx.options.prototypeReplacements.get(i);if(n)return void t(void 0,new Prop(n(i,!0),r));if(!e||e.size&&!e.has(r))throw new SandboxError(`Static method or property access not permitted: ${i.name}.${r}`)}}else if("constructor"!==r){let e=i.constructor.prototype;do{if(e.hasOwnProperty(r)){const n=s.ctx.options.prototypeWhitelist.get(e.constructor),o=s.ctx.options.prototypeReplacements.get(e.constuctor);if(o)return void t(void 0,new Prop(o(i,!1),r));if(n&&(!n.size||n.has(r)))break;throw new SandboxError(`Method or property access not permitted: ${e.constructor.name}.${r}`)}}while(e=Object.getPrototypeOf(e))}if(s.ctx.evals.has(i[r]))return void t(void 0,s.ctx.evals.get(i[r]));if(i[r]===globalThis)return void t(void 0,s.ctx.globalScope.get("this"));let u=o.isGlobal||p&&!sandboxedFunctions.has(i)||s.ctx.globalsWhitelist.has(i);u||s.ctx.getSubscriptions.forEach((e=>e(i,r))),t(void 0,new Prop(i,r,!1,u))},call:(e,t,n,i,r,o,s,a)=>{if(s.ctx.options.forbidFunctionCalls)throw new SandboxError("Method calls are not allowed");if("function"!=typeof i)throw new TypeError(o.prop+" is not a function");execMany(n,e,toLispArray(r.map((e=>e instanceof SpreadArray?[...e.item]:[e])).flat()),((e,n)=>{var i;if(e)t(e);else if("function"!=typeof o){if(o.context[o.prop]===JSON.stringify&&s.ctx.getSubscriptions.size){const e=new Set,t=n=>{if(n&&"object"==typeof n&&!e.has(n)){e.add(n);for(let e in n)s.ctx.getSubscriptions.forEach((t=>t(n,e))),t(n[e])}};t(n[0])}if(o.context instanceof Array&&arrayChange.has(o.context[o.prop])&&s.ctx.changeSubscriptions.get(o.context)){let e,t=!1;if("push"===o.prop)e={type:"push",added:n},t=!!n.length;else if("pop"===o.prop)e={type:"pop",removed:o.context.slice(-1)},t=!!e.removed.length;else if("shift"===o.prop)e={type:"shift",removed:o.context.slice(0,1)},t=!!e.removed.length;else if("unshift"===o.prop)e={type:"unshift",added:n},t=!!n.length;else if("splice"===o.prop)e={type:"splice",startIndex:n[0],deleteCount:void 0===n[1]?o.context.length:n[1],added:n.slice(2),removed:o.context.slice(n[0],void 0===n[1]?void 0:n[0]+n[1])},t=!!e.added.length||!!e.removed.length;else if("reverse"===o.prop||"sort"===o.prop)e={type:o.prop},t=!!o.context.length;else if("copyWithin"===o.prop){let i=void 0===n[2]?o.context.length-n[1]:Math.min(o.context.length,n[2]-n[1]);e={type:"copyWithin",startIndex:n[0],endIndex:n[0]+i,added:o.context.slice(n[1],n[1]+i),removed:o.context.slice(n[0],n[0]+i)},t=!!e.added.length||!!e.removed.length}t&&(null===(i=s.ctx.changeSubscriptions.get(o.context))||void 0===i||i.forEach((t=>t(e))))}t(void 0,o.context[o.prop](...n))}else t(void 0,o(...n))}),a,s)},createObject:(e,t,n,i,r,o,s,a)=>{let c={};for(let e of r)e instanceof SpreadObject?c={...c,...e.item}:c[e.key]=e.val;t(void 0,c)},keyVal:(e,t,n,i,r)=>t(void 0,new KeyVal(i,r)),createArray:(e,t,n,i,r,o,s,a)=>{execMany(n,e,toLispArray(r.map((e=>e instanceof SpreadArray?[...e.item]:[e])).flat()),t,a,s)},group:(e,t,n,i,r)=>t(void 0,r),string:(e,t,n,i,r,o,s)=>t(void 0,s.constants.strings[r]),regex:(e,t,n,i,r,o,s)=>{const a=s.constants.regexes[r];if(!s.ctx.globalsWhitelist.has(RegExp))throw new SandboxError("Regex not permitted");t(void 0,new RegExp(a.regex,a.flags))},literal:(e,t,n,i,r,o,s,a)=>{let c,p=s.constants.literals[r].a,l=toLispArray([]),u=[];for(;c=literalRegex.exec(p);)c[2]||(l.push(s.constants.literals[r].b[parseInt(c[3],10)]),u.push(c[3]));execMany(n,e,l,((e,n)=>{const i={};if(e)t(e);else{for(let e in u){const t=u[e];i[t]=n[e]}t(void 0,p.replace(/(\\\\)*(\\)?\${(\d+)}/g,((e,t,n,r)=>{if(n)return e;let o=i[r];return o=o instanceof Prop?o.context[o.prop]:o,(t||"")+""+o})))}}),a,s)},spreadArray:(e,t,n,i,r,o,s,a)=>{e(n,r,a,s,((e,n)=>{e?t(e):t(void 0,new SpreadArray(n))}))},spreadObject:(e,t,n,i,r,o,s,a)=>{e(n,r,a,s,((e,n)=>{e?t(e):t(void 0,new SpreadObject(n))}))},"!":(e,t,n,i,r)=>t(void 0,!r),"~":(e,t,n,i,r)=>t(void 0,~r),"++$":(e,t,n,i,r,o,s)=>{assignCheck(o,s),t(void 0,++o.context[o.prop])},"$++":(e,t,n,i,r,o,s)=>{assignCheck(o,s),t(void 0,o.context[o.prop]++)},"--$":(e,t,n,i,r,o,s)=>{assignCheck(o,s),t(void 0,--o.context[o.prop])},"$--":(e,t,n,i,r,o,s)=>{assignCheck(o,s),t(void 0,o.context[o.prop]--)},"=":(e,t,n,i,r,o,s)=>{assignCheck(o,s),o.context[o.prop]=r,t(void 0,new Prop(o.context,o.prop,!1,o.isGlobal))},"+=":(e,t,n,i,r,o,s)=>{assignCheck(o,s),t(void 0,o.context[o.prop]+=r)},"-=":(e,t,n,i,r,o,s)=>{assignCheck(o,s),t(void 0,o.context[o.prop]-=r)},"/=":(e,t,n,i,r,o,s)=>{assignCheck(o,s),t(void 0,o.context[o.prop]/=r)},"*=":(e,t,n,i,r,o,s)=>{assignCheck(o,s),t(void 0,o.context[o.prop]*=r)},"**=":(e,t,n,i,r,o,s)=>{assignCheck(o,s),t(void 0,o.context[o.prop]**=r)},"%=":(e,t,n,i,r,o,s)=>{assignCheck(o,s),t(void 0,o.context[o.prop]%=r)},"^=":(e,t,n,i,r,o,s)=>{assignCheck(o,s),t(void 0,o.context[o.prop]^=r)},"&=":(e,t,n,i,r,o,s)=>{assignCheck(o,s),t(void 0,o.context[o.prop]&=r)},"|=":(e,t,n,i,r,o,s)=>{assignCheck(o,s),t(void 0,o.context[o.prop]|=r)},"<<=":(e,t,n,i,r,o,s)=>{assignCheck(o,s),t(void 0,o.context[o.prop]<<=r)},">>=":(e,t,n,i,r,o,s)=>{assignCheck(o,s),t(void 0,o.context[o.prop]>>=r)},">>>=":(e,t,n,i,r,o,s)=>{assignCheck(o,s),t(void 0,o.context[o.prop]>>=r)},"?":(e,t,n,i,r)=>{if(!(r instanceof If))throw new SyntaxError("Invalid inline if");t(void 0,i?r.t:r.f)},">":(e,t,n,i,r)=>t(void 0,i>r),"<":(e,t,n,i,r)=>t(void 0,i<r),">=":(e,t,n,i,r)=>t(void 0,i>=r),"<=":(e,t,n,i,r)=>t(void 0,i<=r),"==":(e,t,n,i,r)=>t(void 0,i==r),"===":(e,t,n,i,r)=>t(void 0,i===r),"!=":(e,t,n,i,r)=>t(void 0,i!=r),"!==":(e,t,n,i,r)=>t(void 0,i!==r),"&&":(e,t,n,i,r)=>t(void 0,i&&r),"||":(e,t,n,i,r)=>t(void 0,i||r),"&":(e,t,n,i,r)=>t(void 0,i&r),"|":(e,t,n,i,r)=>t(void 0,i|r),":":(e,t,n,i,r)=>t(void 0,new If(i,r)),"+":(e,t,n,i,r)=>t(void 0,i+r),"-":(e,t,n,i,r)=>t(void 0,i-r),"$+":(e,t,n,i,r)=>t(void 0,+r),"$-":(e,t,n,i,r)=>t(void 0,-r),"/":(e,t,n,i,r)=>t(void 0,i/r),"^":(e,t,n,i,r)=>t(void 0,i^r),"*":(e,t,n,i,r)=>t(void 0,i*r),"%":(e,t,n,i,r)=>t(void 0,i%r),"<<":(e,t,n,i,r)=>t(void 0,i<<r),">>":(e,t,n,i,r)=>t(void 0,i>>r),">>>":(e,t,n,i,r)=>t(void 0,i>>>r),typeof:(e,t,n,i,r)=>t(void 0,typeof r),instanceof:(e,t,n,i,r)=>t(void 0,i instanceof r),in:(e,t,n,i,r)=>t(void 0,i in r),delete:(e,t,n,i,r,o,s,a,c)=>{void 0!==c.context?(assignCheck(c,s,"delete"),c.isVariable?t(void 0,!1):t(void 0,delete c.context[c.prop])):t(void 0,!0)},return:(e,t,n,i,r,o,s)=>t(void 0,r),var:(e,t,n,i,r,o,s,a,c)=>{e(n,r,a,s,((e,n)=>{e?t(e):t(void 0,a.declare(i,VarType.var,n))}))},let:(e,t,n,i,r,o,s,a,c)=>{e(n,r,a,s,((e,n)=>{e?t(e):t(void 0,a.declare(i,VarType.let,n,c&&c.isGlobal))}))},const:(e,t,n,i,r,o,s,a,c)=>{e(n,r,a,s,((e,n)=>{e?t(e):t(void 0,a.declare(i,VarType.const,n))}))},arrowFunc:(e,t,n,i,r,o,s,a)=>{i=[...i],"string"==typeof o.b&&(o.b=r=lispifyFunction(o.b,s.constants)),i.shift()?t(void 0,createFunctionAsync(i,r,n,s,a)):t(void 0,createFunction(i,r,n,s,a))},function:(e,t,n,i,r,o,s,a)=>{"string"==typeof o.b&&(o.b=r=lispifyFunction(o.b,s.constants));let c,p=i.shift(),l=i.shift();c=p?createFunctionAsync(i,r,n,s,a,l):createFunction(i,r,n,s,a,l),l&&a.declare(l,VarType.var,c),t(void 0,c)},inlineFunction:(e,t,n,i,r,o,s,a)=>{"string"==typeof o.b&&(o.b=r=lispifyFunction(o.b,s.constants));let c,p=i.shift(),l=i.shift();l&&(a=new Scope(a,{})),c=p?createFunctionAsync(i,r,n,s,a,l):createFunction(i,r,n,s,a,l),l&&a.declare(l,VarType.let,c),t(void 0,c)},loop:(e,t,n,i,r,o,s,a)=>{const[c,p,l,u,f,d,h]=i;let x=!0;const y=new Scope(a,{});let g={$$obj:void 0};const b=new Scope(y,g);if(e===execAsync)(async()=>{for(await asyncDone((t=>e(n,u,y,s,t))),g.$$obj=(await asyncDone((t=>e(n,l,y,s,t)))).result,await asyncDone((t=>e(n,p,b,s,t))),c&&(x=(await asyncDone((t=>e(n,d,b,s,t)))).result);x;){let i={};await asyncDone((t=>e(n,h,new Scope(b,i),s,t)));let o=await executeTreeAsync(n,s,r,[new Scope(y,i)],"loop");if(o instanceof ExecReturn&&o.returned)return void t(void 0,o);if(o instanceof ExecReturn&&o.breakLoop)break;await asyncDone((t=>e(n,f,b,s,t))),x=(await asyncDone((t=>e(n,d,b,s,t)))).result}t()})().catch(t);else{for(syncDone((t=>e(n,u,y,s,t))),g.$$obj=syncDone((t=>e(n,l,y,s,t))).result,syncDone((t=>e(n,p,b,s,t))),c&&(x=syncDone((t=>e(n,d,b,s,t))).result);x;){let i={};syncDone((t=>e(n,h,new Scope(b,i),s,t)));let o=executeTree(n,s,r,[new Scope(y,i)],"loop");if(o instanceof ExecReturn&&o.returned)return void t(void 0,o);if(o instanceof ExecReturn&&o.breakLoop)break;syncDone((t=>e(n,f,b,s,t))),x=syncDone((t=>e(n,d,b,s,t))).result}t()}},loopAction:(e,t,n,i,r,o,s,a,c,p)=>{if("switch"===p&&"continue"===i||!p)throw new SandboxError("Illegal "+i+" statement");t(void 0,new ExecReturn(s.ctx.auditReport,void 0,!1,"break"===i,"continue"===i))},if:(e,t,n,i,r,o,s,a,c,p)=>{if(!(r instanceof If))throw new SyntaxError("Invalid if");e(n,i,a,s,((i,o)=>{i?t(i):executeTreeWithDone(e,t,n,s,o?r.t:r.f,[new Scope(a)],p)}))},switch:(e,t,n,i,r,o,s,a)=>{e(n,i,a,s,((i,o)=>{if(i)t(i);else if(e===execSync){let i,c=!1;for(let p of r)if(c||(c=!p.a||o===valueOrProp(syncDone((t=>e(n,p.a,a,s,t))).result))){if(!p.b)continue;if(i=executeTree(n,s,p.b,[a],"switch"),i.breakLoop)break;if(i.returned)return void t(void 0,i);if(!p.a)break}t()}else(async()=>{let i,c=!1;for(let p of r)if(c||(c=!p.a||o===valueOrProp((await asyncDone((t=>e(n,p.a,a,s,t)))).result))){if(!p.b)continue;if(i=await executeTreeAsync(n,s,p.b,[a],"switch"),i.breakLoop)break;if(i.returned)return void t(void 0,i);if(!p.a)break}t()})().catch(t)}))},try:(e,t,n,i,r,o,s,a,c,p)=>{const[l,u,f]=r;executeTreeWithDone(e,((i,r)=>{executeTreeWithDone(e,(o=>{o?t(o):i?executeTreeWithDone(e,t,n,s,u,[new Scope(a)],p):t(void 0,r)}),n,s,f,[new Scope(a,{})])}),n,s,i,[new Scope(a)],p)},void:(e,t,n,i)=>{t()},new:(e,t,n,i,r,o,s)=>{if(!s.ctx.globalsWhitelist.has(i)&&!sandboxedFunctions.has(i))throw new SandboxError("Object construction not allowed: "+i.constructor.name);t(void 0,new i(...r))},throw:(e,t,n,i)=>{t(i)},multi:(e,t,n,i)=>t(void 0,i.pop())},ops=new Map;for(let e in ops2)ops.set(e,ops2[e]);function valueOrProp(e){return e instanceof Prop?e.context[e.prop]:e}function execMany(e,t,n,i,r,o,s){t===execSync?_execManySync(e,n,i,r,o,s):_execManyAsync(e,n,i,r,o,s).catch(i)}function _execManySync(e,t,n,i,r,o){let s=[];for(let a=0;a<t.length;a++){let c;try{c=syncDone((n=>execSync(e,t[a],i,r,n,o))).result}catch(e){return void n(e)}if(c instanceof ExecReturn&&(c.returned||c.breakLoop||c.continueLoop))return void n(void 0,c);s.push(c)}n(void 0,s)}async function _execManyAsync(e,t,n,i,r,o){let s=[];for(let a=0;a<t.length;a++){let c;try{c=(await asyncDone((n=>execAsync(e,t[a],i,r,n,o)))).result}catch(e){return void n(e)}if(c instanceof ExecReturn&&(c.returned||c.breakLoop||c.continueLoop))return void n(void 0,c);s.push(c)}n(void 0,s)}function asyncDone(e){return new Promise(((t,n)=>{e(((e,i)=>{e?n(e):t({result:i})}))}))}function syncDone(e){let t,n;if(e(((e,i)=>{n=e,t=i})),n)throw n;return{result:t}}function execAsync(e,t,n,i,r,o){return new Promise(((s,a)=>{execWithDone(e,t,n,i,((e,t)=>{r(e,t),s()}),!0,o)}))}function execSync(e,t,n,i,r,o){execWithDone(e,t,n,i,r,!1,o)}function execWithDone(e,t,n,i,r,o,s){var a;const c=o?execAsync:execSync;if(i.ctx.options.executionQuota<=e.ticks&&("function"!=typeof i.ctx.options.onExecutionQuotaReached||!i.ctx.options.onExecutionQuotaReached(e,n,i,t)))throw new SandboxError("Execution quota exceeded");if(e.ticks++,currentTicks=e,t instanceof Prop)r(void 0,t.context[t.prop]);else if(Array.isArray(t)&&t.lisp)execMany(e,c,t,r,n,i,s);else if(t instanceof Lisp)if(["arrowFunc","function","inlineFunction","loop","try","switch","if"].includes(t.op))try{ops.get(t.op)(c,r,e,t.a,t.b,t,i,n,void 0,s)}catch(e){r(e)}else"await"===t.op?o?(null===(a=i.ctx.options.prototypeWhitelist)||void 0===a?void 0:a.has(Promise))?execAsync(e,t.a,n,i,(async(e,t)=>{e?r(e):r(void 0,await t)}),s).catch(r):r(new SandboxError("Async/await is not permitted")):r(new SandboxError("Illegal use of 'await', must be inside async function")):execWithDone(e,t.a,n,i,((a,p)=>{if(a)return void r(a);let l=p instanceof Prop?p.context?p.context[p.prop]:void 0:p,u=t.op;if("?prop"===u||"?call"===u){if(null==l)return void r(void 0,optional);u=u.slice(1)}if(l===optional){if("prop"===u||"call"===u)return void r(void 0,l);l=void 0}execWithDone(e,t.b,n,i,((t,o)=>{if(t)return void r(t);let a=o instanceof Prop?o.context?o.context[o.prop]:void 0:o;if(a===optional&&(a=void 0),ops.has(u))try{ops.get(u)(c,r,e,l,a,p,i,n,o,s)}catch(e){r(e)}else r(new SyntaxError("Unknown operator: "+u))}),o,s)}),o,s);else r(void 0,t)}function executeTree(e,t,n,i=[],r){return syncDone((o=>executeTreeWithDone(execSync,o,e,t,n,i,r))).result}async function executeTreeAsync(e,t,n,i=[],r){return(await asyncDone((o=>executeTreeWithDone(execAsync,o,e,t,n,i,r)))).result}function executeTreeWithDone(e,t,n,i,r,o=[],s){if(!r)return void t();if(!(r instanceof Array))throw new SyntaxError("Bad execution tree");let a,c=i.ctx.globalScope;for(;a=o.shift();)"object"==typeof a&&(c=a instanceof Scope?a:new Scope(c,a,null));i.ctx.options.audit&&!i.ctx.auditReport&&(i.ctx.auditReport={globalsAccess:new Set,prototypeAccess:{}}),e===execSync?_executeWithDoneSync(t,n,i,r,c,s):_executeWithDoneAsync(t,n,i,r,c,s).catch(t)}function _executeWithDoneSync(e,t,n,i,r,o){if(!(i instanceof Array))throw new SyntaxError("Bad execution tree");let s=0;for(s=0;s<i.length;s++){let a,c;const p=i[s];try{execSync(t,p,r,n,((e,t)=>{c=e,a=t}),o)}catch(e){c=e}if(c)return void e(c);if(a instanceof ExecReturn)return void e(void 0,a);if(p instanceof Lisp&&"return"===p.op)return void e(void 0,new ExecReturn(n.ctx.auditReport,a,!0))}e(void 0,new ExecReturn(n.ctx.auditReport,void 0,!1))}async function _executeWithDoneAsync(e,t,n,i,r,o){if(!(i instanceof Array))throw new SyntaxError("Bad execution tree");let s=0;for(s=0;s<i.length;s++){let a,c;const p=i[s];try{await execAsync(t,p,r,n,((e,t)=>{c=e,a=t}),o)}catch(e){c=e}if(c)return void e(c);if(a instanceof ExecReturn)return void e(void 0,a);if(p instanceof Lisp&&"return"===p.op)return void e(void 0,new ExecReturn(n.ctx.auditReport,a,!0))}e(void 0,new ExecReturn(n.ctx.auditReport,void 0,!1))}const extend=()=>({expectTypes:expectTypes,setLispType:setLispType,executionOps:ops,assignCheck:assignCheck,execMany:execMany,execAsync:execAsync,execSync:execSync,asyncDone:asyncDone,syncDone:syncDone,executeTree:executeTree,executeTreeAsync:executeTreeAsync});class SandboxGlobal{constructor(e){if(e===globalThis)return globalThis;for(let t in e)this[t]=e[t]}}class Sandbox{constructor(options){options=Object.assign({audit:!1,forbidFunctionCalls:!1,forbidFunctionCreation:!1,globals:Sandbox.SAFE_GLOBALS,prototypeWhitelist:Sandbox.SAFE_PROTOTYPES,prototypeReplacements:new Map},options||{});const sandboxGlobal=new SandboxGlobal(options.globals);this.context={sandbox:this,globalsWhitelist:new Set(Object.values(options.globals)),options:options,globalScope:new Scope(null,options.globals,sandboxGlobal),sandboxGlobal:sandboxGlobal,evals:new Map,getSubscriptions:new Set,setSubscriptions:new WeakMap,changeSubscriptions:new WeakMap};const func=sandboxFunction(this.context);this.context.evals.set(Function,func),this.context.evals.set(eval,sandboxedEval(func)),this.context.evals.set(setTimeout,sandboxedSetTimeout(func)),this.context.evals.set(setInterval,sandboxedSetInterval(func))}static get SAFE_GLOBALS(){return{Function:Function,console:{debug:console.debug,error:console.error,info:console.info,log:console.log,table:console.table,warn:console.warn},isFinite:isFinite,isNaN:isNaN,parseFloat:parseFloat,parseInt:parseInt,decodeURI:decodeURI,decodeURIComponent:decodeURIComponent,encodeURI:encodeURI,encodeURIComponent:encodeURIComponent,escape:escape,unescape:unescape,Boolean:Boolean,Number:Number,BigInt:BigInt,String:String,Object:Object,Array:Array,Symbol:Symbol,Error:Error,EvalError:EvalError,RangeError:RangeError,ReferenceError:ReferenceError,SyntaxError:SyntaxError,TypeError:TypeError,URIError:URIError,Int8Array:Int8Array,Uint8Array:Uint8Array,Uint8ClampedArray:Uint8ClampedArray,Int16Array:Int16Array,Uint16Array:Uint16Array,Int32Array:Int32Array,Uint32Array:Uint32Array,Float32Array:Float32Array,Float64Array:Float64Array,Map:Map,Set:Set,WeakMap:WeakMap,WeakSet:WeakSet,Promise:Promise,Intl:Intl,JSON:JSON,Math:Math,Date:Date,RegExp:RegExp}}static get SAFE_PROTOTYPES(){let e=[SandboxGlobal,Function,Boolean,Number,BigInt,String,Date,Error,Array,Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array,Map,Set,WeakMap,WeakSet,Promise,Symbol,Date,RegExp],t=new Map;return e.forEach((e=>{t.set(e,new Set)})),t.set(Object,new Set(["entries","fromEntries","getOwnPropertyNames","is","keys","hasOwnProperty","isPrototypeOf","propertyIsEnumerable","toLocaleString","toString","valueOf","values"])),t}subscribeGet(e){return this.context.getSubscriptions.add(e),{unsubscribe:()=>this.context.getSubscriptions.delete(e)}}subscribeSet(e,t,n){const i=this.context.setSubscriptions.get(e)||new Map;this.context.setSubscriptions.set(e,i);const r=i.get(t)||new Set;let o;return i.set(t,r),r.add(n),e&&e[t]&&"object"==typeof e[t]&&(o=this.context.changeSubscriptions.get(e[t])||new Set,o.add(n),this.context.changeSubscriptions.set(e[t],o)),{unsubscribe:()=>{r.delete(n),o&&o.delete(n)}}}static audit(e,t=[]){const n={};for(let e of Object.getOwnPropertyNames(globalThis))n[e]=globalThis[e];return new Sandbox({globals:n,audit:!0}).executeTree(parse(e),t)}static parse(e){return parse(e)}executeTree(e,t=[]){return executeTree({ticks:BigInt(0)},{ctx:this.context,constants:e.constants,tree:e.tree},e.tree,t)}executeTreeAsync(e,t=[]){return executeTreeAsync({ticks:BigInt(0)},{ctx:this.context,constants:e.constants,tree:e.tree},e.tree,t)}compile(e,t=!1){const n=parse(e,t);return(...e)=>this.executeTree(n,e).result}compileAsync(e,t=!1){const n=parse(e,t);return async(...e)=>(await this.executeTreeAsync(n,e)).result}compileExpression(e,t=!1){const n=parse(e,t);return n.tree.length=1,(...e)=>this.executeTree(n,e).result}compileExpressionAsync(e,t=!1){const n=parse(e,t);return n.tree.length=1,async(...e)=>(await this.executeTreeAsync(n,e)).result}}export default Sandbox;export{SandboxGlobal,extend};
//# sourceMappingURL=Sandbox.min.js.map
