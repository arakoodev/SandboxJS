{"version":3,"file":"SandboxExec.min.js","sources":["../src/utils.ts","../src/executor.ts","../src/SandboxExec.ts"],"sourcesContent":["import { IEvalContext } from \"./eval\";\nimport { Change, Unknown } from \"./executor\";\nimport { IConstants, IExecutionTree, Lisp, LispItem } from \"./parser\";\nimport SandboxExec from \"./SandboxExec\";\n\nexport type replacementCallback = (obj: any, isStaticAccess: boolean) => any\n\nexport interface IOptionParams {\n  audit?: boolean;\n  forbidFunctionCalls?: boolean;\n  forbidFunctionCreation?: boolean;\n  prototypeReplacements?: Map<new () => any, replacementCallback>;\n  prototypeWhitelist?: Map<any, Set<string>>;\n  globals: IGlobals;\n  executionQuota?: bigint;\n  onExecutionQuotaReached?: (ticks: Ticks, scope: Scope, context: IExecutionTree, tree: LispItem) => boolean|void;\n}\n\nexport interface IOptions {\n  audit: boolean;\n  forbidFunctionCalls: boolean;\n  forbidFunctionCreation: boolean;\n  prototypeReplacements: Map<new () => any, replacementCallback>;\n  prototypeWhitelist: Map<any, Set<string>>;\n  globals: IGlobals;\n  executionQuota?: bigint;\n  onExecutionQuotaReached?: (ticks: Ticks, scope: Scope, context: IExecutionTree, tree: LispItem) => boolean|void;\n}\n\nexport interface IContext {\n  sandbox: SandboxExec;\n  globalScope: Scope;\n  sandboxGlobal: ISandboxGlobal;\n  globalsWhitelist: Set<any>;\n  prototypeWhitelist: Map<any, Set<string>>;\n  options: IOptions;\n  auditReport?: IAuditReport;\n}\n\nexport interface IAuditReport {\n  globalsAccess: Set<unknown>;\n  prototypeAccess: {[name: string]: Set<string>}\n}\n\nexport interface Ticks {\n  ticks: bigint;\n}\n\nexport type SubscriptionSubject = object;\n\nexport interface IExecContext extends IExecutionTree {\n  ctx: IContext,\n  getSubscriptions: Set<(obj: SubscriptionSubject, name: string) => void>;\n  setSubscriptions: WeakMap<SubscriptionSubject, Map<string, Set<(modification: Change) => void>>>;\n  changeSubscriptions: WeakMap<SubscriptionSubject, Set<(modification: Change) => void>>;\n  setSubscriptionsGlobal: WeakMap<SubscriptionSubject, Map<string, Set<(modification: Change) => void>>>;\n  changeSubscriptionsGlobal: WeakMap<SubscriptionSubject, Set<(modification: Change) => void>>;\n  registerSandboxFunction: (fn: (...args: any[]) => any) => void;\n  evals: Map<any, any>;\n  allowJit: boolean;\n  evalContext?: IEvalContext\n}\n\nexport interface ISandboxGlobal {[key: string]: unknown}\ninterface SandboxGlobalConstructor {\n  new(globals: IGlobals): ISandboxGlobal;\n}\n\nexport const SandboxGlobal = function SandboxGlobal(this: ISandboxGlobal, globals: IGlobals) {\n  if (globals === (globalThis as any)) return globalThis;\n  for (let i in globals) {\n    this[i] = globals[i];\n  }\n} as any as SandboxGlobalConstructor\n\nexport type IGlobals = ISandboxGlobal \n\nexport class ExecContext implements IExecContext {\n  constructor(\n    public ctx: IContext,\n    public constants: IConstants,\n    public tree: Lisp[],\n    public getSubscriptions: Set<(obj: SubscriptionSubject, name: string) => void>,\n    public setSubscriptions: WeakMap<SubscriptionSubject, Map<string, Set<(modification: Change) => void>>>,\n    public changeSubscriptions: WeakMap<SubscriptionSubject, Set<(modification: Change) => void>>,\n    public setSubscriptionsGlobal: WeakMap<SubscriptionSubject, Map<string, Set<(modification: Change) => void>>>,\n    public changeSubscriptionsGlobal: WeakMap<SubscriptionSubject, Set<(modification: Change) => void>>,\n    public evals: Map<any, any>,\n    public registerSandboxFunction: (fn: (...args: any[]) => any) => void,\n    public allowJit: boolean,\n    public evalContext?: IEvalContext\n  ) {\n\n  }\n}\n\nexport function createContext(sandbox: SandboxExec, options: IOptions, evalContext?: IEvalContext): IContext {\n  const sandboxGlobal = new SandboxGlobal(options.globals);\n  const context = {\n    sandbox: sandbox,\n    globalsWhitelist: new Set(Object.values(options.globals)),\n    prototypeWhitelist: new Map([...options.prototypeWhitelist].map((a) => [a[0].prototype, a[1]])),\n    options,\n    globalScope: new Scope(null, options.globals, sandboxGlobal),\n    sandboxGlobal\n  };\n  context.prototypeWhitelist.set(Object.getPrototypeOf([][Symbol.iterator]()) as Object, new Set());\n  return context;\n}\n\nexport function createExecContext(sandbox: {\n  setSubscriptions: WeakMap<SubscriptionSubject, Map<string, Set<(modification: Change) => void>>>, \n  changeSubscriptions: WeakMap<SubscriptionSubject, Set<(modification: Change) => void>>,\n  sandboxFunctions: WeakMap<(...args: any[]) => any, IExecContext>,\n  context: IContext\n}, executionTree: IExecutionTree, evalContext?: IEvalContext): IExecContext  {\n  const evals = new Map();\n  const execContext: IExecContext = new ExecContext(\n    sandbox.context,\n    executionTree.constants,\n    executionTree.tree,\n    new Set<(obj: SubscriptionSubject, name: string) => void>(),\n    new WeakMap<SubscriptionSubject, Map<string, Set<(modification: Change) => void>>>(),\n    new WeakMap<SubscriptionSubject, Set<(modification: Change) => void>>(),\n    sandbox.setSubscriptions,\n    sandbox.changeSubscriptions,\n    evals,\n    (fn) => sandbox.sandboxFunctions.set(fn, execContext),\n    !!evalContext,\n    evalContext\n  );\n  if (evalContext) {\n    const func = evalContext.sandboxFunction(execContext);\n    evals.set(Function, func);\n    evals.set(eval, evalContext.sandboxedEval(func));\n    evals.set(setTimeout, evalContext.sandboxedSetTimeout(func));\n    evals.set(setInterval, evalContext.sandboxedSetInterval(func));\n  }\n  return execContext;\n}\n\nexport class CodeString {\n  \n  start: number;\n  end: number;\n  ref: {str: string};\n  constructor(str: string|CodeString) {\n    this.ref = {str: \"\"};\n    if (str instanceof CodeString) {\n      this.ref = str.ref;\n      this.start = str.start\n      this.end = str.end;\n    } else {\n      this.ref.str = str;\n      this.start = 0;\n      this.end = str.length;\n    }\n  }\n\n  substring(start: number, end?: number): CodeString {\n    if (!this.length) return this;\n    start = this.start + start;\n    if (start < 0) {\n      start = 0;\n    }\n    if (start > this.end) {\n      start = this.end;\n    }\n    end = end === undefined ? this.end : this.start + end;\n    if (end < 0) {\n      end = 0;\n    }\n    if (end > this.end) {\n      end = this.end;\n    }\n    const code = new CodeString(this);\n    code.start = start;\n    code.end = end;\n    return code;\n  }\n\n  get length () {\n    const len = this.end - this.start;\n    return len < 0 ? 0 : len;\n  }\n\n  char(i: number) {\n    if (this.start === this.end) return undefined;\n    return this.ref.str[this.start + i];\n  }\n\n  toString() {\n    return this.ref.str.substring(this.start, this.end);\n  }\n\n  trimStart() {\n    const found = /^\\s+/.exec(this.toString());\n    const code = new CodeString(this);\n    if (found) {\n      code.start += found[0].length;\n    }\n    return code;\n  }\n\n  slice(start: number, end?: number) {\n    if (start < 0) {\n      start = this.end - this.start + start;\n    }\n    if (start < 0) {\n      start = 0;\n    }\n    if (end === undefined) {\n      end = this.end - this.start;\n    }\n\n    if (end < 0) {\n      end = this.end - this.start + end;\n    }\n    if (end < 0) {\n      end = 0;\n    }\n    return this.substring(start, end);\n  }\n\n  trim() {\n    const code = this.trimStart();\n    const found = /\\s+$/.exec(code.toString());\n    if (found) {\n      code.end -= found[0].length;\n    }\n    return code;\n  }\n\n  valueOf() {\n    return this.toString();\n  }\n}\n\nfunction keysOnly(obj: unknown): Record<string, true> {\n  const ret: Record<string, true> = Object.assign({}, obj);\n  for (let key in ret) {\n    ret[key] = true;\n  }\n  return ret;\n}\n\nconst reservedWords = new Set([\n  'instanceof',\n  'typeof',\n  'return',\n  'try',\n  'catch',\n  'if',\n  'finally',\n  'else',\n  'in',\n  'of',\n  'var',\n  'let',\n  'const',\n  'for',\n  'delete',\n  'false',\n  'true',\n  'while',\n  'do',\n  'break',\n  'continue',\n  'new',\n  'function',\n  'async',\n  'await',\n  'switch',\n  'case'\n]);\n\nexport const enum VarType {\n  let = \"let\",\n  const = \"const\",\n  var = \"var\"\n}\n\nexport class Scope {\n  parent: Scope|null;\n  const: {[key: string]: true} = {};\n  let: {[key: string]: true} = {};\n  var: {[key: string]: true} = {};\n  globals: {[key: string]: true};\n  allVars: {[key:string]: unknown} & Object;\n  functionThis?: Unknown;\n  constructor(parent: Scope|null, vars = {}, functionThis?: Unknown) {\n    const isFuncScope = functionThis !== undefined || parent === null;\n    this.parent = parent;\n    this.allVars = vars;\n    this.let = isFuncScope ? this.let : keysOnly(vars);\n    this.var = isFuncScope ? keysOnly(vars) : this.var;\n    this.globals = parent === null ? keysOnly(vars) : {};\n    this.functionThis = functionThis;\n  }\n\n  get(key: string, functionScope = false): Prop {\n    const functionThis = this.functionThis;\n    if (key === 'this' && functionThis !== undefined) {\n      return new Prop({this: functionThis}, key, true, false, true);\n    }\n    if (reservedWords.has(key)) throw new SyntaxError(\"Unexepected token '\" + key + \"'\");\n    if (this.parent === null || !functionScope || functionThis !== undefined) {\n      if (this.globals.hasOwnProperty(key)) {\n        return new Prop(functionThis, key, false, true, true);\n      }\n      if (key in this.allVars && (!(key in {}) || this.allVars.hasOwnProperty(key))) {\n        return new Prop(this.allVars, key, this.const.hasOwnProperty(key), this.globals.hasOwnProperty(key), true);\n      }\n      if (this.parent === null) {\n        return new Prop(undefined, key);\n      }\n    }\n    return this.parent.get(key, functionScope)\n  }\n\n  set(key: string, val: unknown) {\n    if (key === 'this') throw new SyntaxError('\"this\" cannot be assigned')\n    if (reservedWords.has(key)) throw new SyntaxError(\"Unexepected token '\" + key + \"'\");\n    let prop = this.get(key);\n    if(prop.context === undefined) {\n      throw new ReferenceError(`Variable '${key}' was not declared.`);\n    }\n    if (prop.isConst) {\n      throw new TypeError(`Cannot assign to const variable '${key}'`);\n    }\n    if (prop.isGlobal) {\n      throw new SandboxError(`Cannot override global variable '${key}'`);\n    }\n    if (!(prop.context instanceof Object)) throw new SandboxError('Scope is not an object');\n    prop.context[prop.prop] = val;\n    return prop;\n  }\n\n  declare(key: string, type: VarType, value: unknown = undefined, isGlobal = false): Prop {\n    if (key === 'this') throw new SyntaxError('\"this\" cannot be declared');\n    if (reservedWords.has(key)) throw new SyntaxError(\"Unexepected token '\" + key + \"'\");\n    if (type === 'var' && this.functionThis === undefined && this.parent !== null) {\n      return this.parent.declare(key, type, value, isGlobal)\n    } else if ((this[type].hasOwnProperty(key) && type !== 'const' && !this.globals.hasOwnProperty(key)) || !(key in this.allVars)) {\n      if (isGlobal) {\n        this.globals[key] = true;\n      }\n      this[type][key] = true;\n      this.allVars[key] = value;\n    } else {\n      throw new SandboxError(`Identifier '${key}' has already been declared`);\n    }\n    return new Prop(this.allVars, key, this.const.hasOwnProperty(key), isGlobal);\n  }\n}\n\nexport interface IScope {\n  [key: string]: any;\n}\n\nexport class FunctionScope implements IScope {}\n\nexport class LocalScope implements IScope {}\n\nexport class SandboxError extends Error {}\n\nexport function isLisp<Type extends Lisp = Lisp>(item: LispItem|LispItem): item is Type {\n  return Array.isArray(item) && typeof item[0] === 'number' && item[0] !== LispType.None && item[0] !== LispType.True;\n}\n\nexport const enum LispType {\n  None,\n  Prop,\n  StringIndex,\n  Let,\n  Const,\n  Call,\n  KeyVal,\n  Number,\n  Return,\n  Assign,\n  InlineFunction,\n  ArrowFunction,\n  CreateArray,\n  If,\n  IfCase,\n  InlineIf,\n  InlineIfCase,\n  SpreadObject,\n  SpreadArray,\n  ArrayProp,\n  PropOptional,\n  CallOptional,\n  CreateObject,\n  Group,\n  Not,\n  IncrementBefore,\n  IncrementAfter,\n  DecrementBefore,\n  DecrementAfter,\n  And,\n  Or,\n  StrictNotEqual,\n  StrictEqual,\n  Plus,\n  Var,\n  GlobalSymbol,\n  Literal,\n  Function,\n  Loop,\n  Try,\n  Switch,\n  SwitchCase,\n  Block,\n  Expression,\n  Await,\n  New,\n  Throw,\n  Minus,\n  Divide,\n  Power,\n  Multiply,\n  Modulus,\n  Equal,\n  NotEqual,\n  SmallerEqualThan,\n  LargerEqualThan,\n  SmallerThan,\n  LargerThan,\n  Negative,\n  Positive,\n  Typeof,\n  Delete,\n  Instanceof,\n  In,\n  Inverse,\n  SubractEquals,\n  AddEquals,\n  DivideEquals,\n  PowerEquals,\n  MultiplyEquals,\n  ModulusEquals,\n  BitNegateEquals,\n  BitAndEquals,\n  BitOrEquals,\n  UnsignedShiftRightEquals,\n  ShiftRightEquals,\n  ShiftLeftEquals,\n  BitAnd,\n  BitOr,\n  BitNegate,\n  BitShiftLeft,\n  BitShiftRight,\n  BitUnsignedShiftRight,\n  BigInt,\n  LiteralIndex,\n  RegexIndex,\n  LoopAction,\n  Void,\n  True,\n\n  LispEnumSize\n}\n\nexport class Prop {\n  constructor(public context: Unknown, public prop: string, public isConst = false, public isGlobal = false, public isVariable = false) {\n  }\n\n  get<T = unknown>(context: IExecContext): T {\n    const ctx = this.context;\n    if (ctx === undefined) throw new ReferenceError(`${this.prop} is not defined`);\n    if (ctx === null) throw new TypeError(`Cannot read properties of null, (reading '${this.prop}')`);\n    context.getSubscriptions.forEach((cb) => cb(ctx, this.prop))\n    return (ctx as any)[this.prop] as T;\n  }\n}","import { LispItem, Lisp, IRegEx, LispFamily, ExtractLispOp, SwitchCase } from \"./parser.js\";\nimport { CodeString, IAuditReport, IExecContext, IScope, isLisp, LispType, LocalScope, Prop, SandboxError, Scope, Ticks, VarType } from \"./utils.js\";\n\nexport type Done<T = any> = (err?: any, res?: T|typeof optional) => void;\n\nexport class ExecReturn<T> {\n  constructor(public auditReport: IAuditReport|undefined, public result: T, public returned: boolean, public breakLoop = false, public continueLoop = false) {}\n}\n\nexport type Unknown = undefined|null|Record<string|number, unknown>;\n\n\nexport interface IChange {\n  type: string;\n}\n\nexport interface ICreate extends IChange {\n  type: \"create\";\n  prop: number|string;\n}\n\nexport interface IReplace extends IChange {\n  type: \"replace\";\n}\n\nexport interface IDelete extends IChange {\n  type: \"delete\";\n  prop: number|string;\n}\n\nexport interface IReverse extends IChange {\n  type: \"reverse\";\n}\n\nexport interface ISort extends IChange {\n  type: \"sort\";\n}\n\nexport interface IPush extends IChange {\n  type: \"push\";\n  added: unknown[];\n}\n\nexport interface IPop extends IChange {\n  type: \"pop\";\n  removed: unknown[];\n}\n\nexport interface IShift extends IChange {\n  type: \"shift\";\n  removed: unknown[];\n}\n\nexport interface IUnShift extends IChange {\n  type: \"unshift\";\n  added: unknown[];\n}\n\nexport interface ISplice extends IChange {\n  type: \"splice\";\n  startIndex: number;\n  deleteCount: number; \n  added: unknown[];\n  removed: unknown[];\n\n}\n\nexport interface ICopyWithin extends IChange {\n  type: \"copyWithin\";\n  startIndex: number;\n  endIndex: number;\n  added: unknown[];\n  removed: unknown[];\n}\n\nexport type Change = ICreate | IReplace | IDelete | IReverse | ISort | IPush | IPop | IUnShift | IShift | ISplice | ICopyWithin\n\nconst optional = {};\n\n\nfunction generateArgs(argNames: string[], args: unknown[]) {\n  const vars: Record<string, unknown> = {};\n  argNames.forEach((arg, i) => {\n    if (arg.startsWith('...')) {\n      vars[arg.substring(3)] = args.slice(i);\n    } else {\n      vars[arg] = args[i];\n    }\n  });\n  return vars;\n}\n\nexport const sandboxedFunctions = new WeakSet();\nexport function createFunction(argNames: string[], parsed: Lisp[], ticks: Ticks, context: IExecContext, scope?: Scope, name?: string) {\n  if (context.ctx.options.forbidFunctionCreation) {\n    throw new SandboxError(\"Function creation is forbidden\");\n  }\n  let func;\n  if (name === undefined) {\n    func = (...args: unknown[]) => {\n      const vars = generateArgs(argNames, args);\n      const res = executeTree(ticks, context, parsed, scope === undefined ? [] : [new Scope(scope, vars)])\n      return res.result;\n    }\n  } else {\n    func = function sandboxedObject(this: Unknown, ...args: unknown[]) {\n      const vars = generateArgs(argNames, args);\n      const res = executeTree(ticks, context, parsed, scope === undefined ? [] : [new Scope(scope, vars, this)])\n      return res.result;\n    }\n  }\n  context.registerSandboxFunction(func);\n  sandboxedFunctions.add(func);\n  return func;\n}\n\nexport function createFunctionAsync(argNames: string[], parsed: Lisp[], ticks: Ticks, context: IExecContext, scope?: Scope, name?: string) {\n  if (context.ctx.options.forbidFunctionCreation) {\n    throw new SandboxError(\"Function creation is forbidden\");\n  }\n  if (!context.ctx.prototypeWhitelist?.has(Promise.prototype)) {\n    throw new SandboxError(\"Async/await not permitted\");\n  }\n  let func;\n  if (name === undefined) {\n    func = async (...args: unknown[]) => {\n      const vars = generateArgs(argNames, args);\n      const res = await executeTreeAsync(ticks, context, parsed, scope === undefined ? [] : [new Scope(scope, vars)])\n      return res.result;\n    }\n  } else {\n    func = async function sandboxedObject(this: Unknown, ...args: unknown[]) {\n      const vars = generateArgs(argNames, args);\n      const res = await executeTreeAsync(ticks, context, parsed, scope === undefined ? [] : [new Scope(scope, vars, this)])\n      return res.result;\n    }\n  }\n  context.registerSandboxFunction(func);\n  sandboxedFunctions.add(func);\n  return func;\n}\n\nexport function assignCheck(obj: Prop, context: IExecContext, op = 'assign') {\n  if(obj.context === undefined) {\n    throw new ReferenceError(`Cannot ${op} value to undefined.`)\n  }\n  if(typeof obj.context !== 'object' && typeof obj.context !== 'function') {\n    throw new SyntaxError(`Cannot ${op} value to a primitive.`)\n  }\n  if (obj.isConst) {\n    throw new TypeError(`Cannot set value to const variable '${obj.prop}'`);\n  }\n  if (obj.isGlobal) {\n    throw new SandboxError(`Cannot ${op} property '${obj.prop}' of a global object`);\n  }\n  if (obj.context === null) {\n    throw new TypeError('Cannot set properties of null');\n  }\n  if (typeof obj.context[obj.prop] === 'function' && !obj.context.hasOwnProperty(obj.prop)) {\n    throw new SandboxError(`Override prototype property '${obj.prop}' not allowed`);\n  }\n  if (op === \"delete\") {\n    if (obj.context.hasOwnProperty(obj.prop)) {\n      context.changeSubscriptions.get(obj.context)?.forEach((cb) => cb({type: \"delete\", prop: obj.prop}));\n      context.changeSubscriptionsGlobal.get(obj.context)?.forEach((cb) => cb({type: \"delete\", prop: obj.prop}));\n    }\n  } else if (obj.context.hasOwnProperty(obj.prop)) {\n    context.setSubscriptions.get(obj.context)?.get(obj.prop)?.forEach((cb) => cb({\n      type: \"replace\"\n    }));\n    context.setSubscriptionsGlobal.get(obj.context)?.get(obj.prop)?.forEach((cb) => cb({\n      type: \"replace\"\n    }));\n  } else {\n    context.changeSubscriptions.get(obj.context)?.forEach((cb) => cb({type: \"create\", prop: obj.prop}));\n    context.changeSubscriptionsGlobal.get(obj.context)?.forEach((cb) => cb({type: \"create\", prop: obj.prop}));\n  }\n}\nconst arrayChange = new Set([\n  [].push,\n  [].pop,\n  [].shift,\n  [].unshift,\n  [].splice,\n  [].reverse,\n  [].sort,\n  [].copyWithin\n]);\n\nexport class KeyVal {\n  constructor(public key: string|SpreadObject, public val: unknown) {}\n}\n\nexport class SpreadObject {\n  constructor(public item: {[key: string]: unknown}) {}\n}\n\nexport class SpreadArray {\n  constructor(public item: unknown[]) {}\n}\n\nexport class If {\n  constructor(public t: Lisp, public f: Lisp) {}\n}\n\nconst literalRegex = /(\\$\\$)*(\\$)?\\${(\\d+)}/g;\ntype OpCallback = (exec: Execution, done: Done, ticks: Ticks, a: any, b: any, obj: any, context: IExecContext, scope: Scope, bobj?: any, inLoopOrSwitch?: string) => void;\n\nexport const ops = new Map<LispType, OpCallback>();\nexport function addOps<Type extends LispFamily>(type: ExtractLispOp<Type>, cb: OpCallback) {\n  ops.set(type, cb);\n}\n\naddOps(LispType.Prop, (exec, done, ticks, a, b: string, obj, context, scope) => {\n    if(a === null) {\n      throw new TypeError(`Cannot get property ${b} of null`);\n    }\n    const type = typeof a;\n    if (type === 'undefined' && obj === undefined) {\n      let prop = scope.get(b);\n      if (prop.context === context.ctx.sandboxGlobal) {\n        if (context.ctx.options.audit) {\n          context.ctx.auditReport?.globalsAccess.add(b);\n        }\n        const rep = context.ctx.globalsWhitelist.has(context.ctx.sandboxGlobal[b]) ? context.evals.get(context.ctx.sandboxGlobal[b]) : undefined;\n        if (rep) {\n          done(undefined, rep);\n          return;\n        }\n      }\n      if (prop.context && prop.context[b] === globalThis) {\n        done(undefined, context.ctx.globalScope.get('this'));\n        return;\n      }\n\n      done(undefined, prop);\n      return;\n    } else if (a === undefined) {\n      throw new SandboxError(\"Cannot get property '\" + b + \"' of undefined\")\n    }\n\n    if (type !== 'object') {\n      if(type === 'number') {\n        a = new Number(a);\n      } else if(type === 'string') {\n        a = new String(a);\n      } else if(type === 'boolean') {\n        a = new Boolean(a);\n      }\n    } else if (typeof a.hasOwnProperty === 'undefined') {\n      done(undefined, new Prop(undefined, b));\n      return;\n    }\n\n    const isFunction = type === 'function';\n    let prototypeAccess = isFunction || !(a.hasOwnProperty(b) || typeof b === 'number');\n\n    if (context.ctx.options.audit && prototypeAccess) {\n      if (typeof b === 'string') {\n        let prot = Object.getPrototypeOf(a);\n        do {\n          if (prot.hasOwnProperty(b)) {\n            if(context.ctx.auditReport && !context.ctx.auditReport.prototypeAccess[prot.constructor.name]) {\n              context.ctx.auditReport.prototypeAccess[prot.constructor.name] = new Set();\n            }\n            context.ctx.auditReport?.prototypeAccess[prot.constructor.name].add(b);\n          }\n        } while(prot = Object.getPrototypeOf(prot))\n      }\n    }\n\n    if (prototypeAccess) {\n      if (isFunction) {\n        if (!['name', 'length', 'constructor'].includes(b) && a.hasOwnProperty(b)) {\n          const whitelist = context.ctx.prototypeWhitelist.get(a.prototype);\n          const replace = context.ctx.options.prototypeReplacements.get(a);\n          if (replace) {\n            done(undefined, new Prop(replace(a, true), b));\n            return;\n          }\n          if (whitelist && (!whitelist.size || whitelist.has(b))) {\n          } else {\n            throw new SandboxError(`Static method or property access not permitted: ${a.name}.${b}`);\n          }\n        }\n      } else if (b !== 'constructor') {\n        let prot = a;\n        while(prot = Object.getPrototypeOf(prot)) {\n          if (prot.hasOwnProperty(b)) {\n            const whitelist = context.ctx.prototypeWhitelist.get(prot);\n            const replace = context.ctx.options.prototypeReplacements.get(prot.constuctor);\n            if (replace) {\n              done(undefined, new Prop(replace(a, false), b));\n              return;\n            }\n            if (whitelist && (!whitelist.size || whitelist.has(b))) {\n              break;\n            }\n            throw new SandboxError(`Method or property access not permitted: ${prot.constructor.name}.${b}`);\n          }\n        };\n      }\n    }\n\n    if (context.evals.has(a[b])) {\n      done(undefined, context.evals.get(a[b]));\n      return;\n    }\n    if (a[b] === globalThis) {\n      done(undefined, context.ctx.globalScope.get('this'));\n      return;\n    }\n\n    let g = obj.isGlobal || (isFunction && !sandboxedFunctions.has(a)) || context.ctx.globalsWhitelist.has(a);\n\n    done(undefined, new Prop(a, b, false, g));\n  });\n\naddOps(LispType.Call, (exec, done, ticks, a, b: Lisp[], obj, context, scope) => {\n  if (context.ctx.options.forbidFunctionCalls) throw new SandboxError(\"Function invocations are not allowed\");\n  if (typeof a !== 'function') {\n    throw new TypeError(`${typeof obj.prop === 'symbol' ? 'Symbol' : obj.prop} is not a function`);\n  }\n  const vals = b.map((item) => {\n    if (item instanceof SpreadArray) {\n      return [...item.item];\n    } else {\n      return [item];\n    }\n  }).flat().map((item) => valueOrProp(item, context));\n\n  if (typeof obj === 'function') {\n    done(undefined, obj(...vals));\n    return;\n  }\n  if (obj.context[obj.prop] === JSON.stringify && context.getSubscriptions.size) {\n    const cache = new Set<any>();\n    const recurse = (x: unknown) => {\n      if (!x || !(typeof x === 'object') || cache.has(x)) return;\n      cache.add(x);\n      for (let y of Object.keys(x) as (keyof typeof x)[]) {\n        context.getSubscriptions.forEach((cb) => cb(x, y));\n        recurse(x[y]);\n      }\n    };\n    recurse(vals[0]);\n  }\n\n  if (obj.context instanceof Array && arrayChange.has(obj.context[obj.prop]) && (context.changeSubscriptions.get(obj.context) || context.changeSubscriptionsGlobal.get(obj.context))) {\n    let change: Change;\n    let changed = false;\n    if (obj.prop === \"push\") {\n      change = {\n        type: \"push\",\n        added: vals\n      }\n      changed = !!vals.length;\n    } else if (obj.prop === \"pop\") {\n      change = {\n        type: \"pop\",\n        removed: obj.context.slice(-1)\n      }\n      changed = !!change.removed.length;\n    }  else if (obj.prop === \"shift\") {\n      change = {\n        type: \"shift\",\n        removed: obj.context.slice(0, 1)\n      }\n      changed = !!change.removed.length;\n    } else if (obj.prop === \"unshift\") {\n      change = {\n        type: \"unshift\",\n        added: vals\n      }\n      changed = !!vals.length;\n    } else if (obj.prop === \"splice\") {\n      change = {\n        type: \"splice\",\n        startIndex: vals[0],\n        deleteCount: vals[1] === undefined ? obj.context.length : vals[1],\n        added: vals.slice(2),\n        removed: obj.context.slice(vals[0], vals[1] === undefined ? undefined : vals[0] + vals[1])\n      }\n      changed = !!change.added.length || !!change.removed.length;\n    } else if (obj.prop === \"reverse\" || obj.prop === \"sort\") {\n      change = {type: obj.prop}\n      changed = !!obj.context.length;\n    } else if (obj.prop === \"copyWithin\") {\n      let len = vals[2] === undefined ? obj.context.length - vals[1] : Math.min(obj.context.length, vals[2] - vals[1]);\n      change = {\n        type: \"copyWithin\",\n        startIndex: vals[0],\n        endIndex: vals[0] + len,\n        added: obj.context.slice(vals[1], vals[1] + len),\n        removed: obj.context.slice(vals[0], vals[0] + len)\n      }\n      changed = !!change.added.length || !!change.removed.length;\n    }\n    if (changed) {\n      context.changeSubscriptions.get(obj.context)?.forEach((cb) => cb(change));\n      context.changeSubscriptionsGlobal.get(obj.context)?.forEach((cb) => cb(change));\n    }\n  }\n  obj.get(context);\n  done(undefined, obj.context[obj.prop](...vals));\n});\n\naddOps(LispType.CreateObject, (exec, done, ticks, a, b: KeyVal[], obj, context, scope) => {\n  let res = {} as any;\n  for (let item of b) {\n    if (item.key instanceof SpreadObject) {\n      res = {...res, ...item.key.item};\n    } else {\n      res[item.key] = item.val;\n    }\n  }\n  done(undefined, res);\n});\n\naddOps(LispType.KeyVal, (exec, done, ticks, a: string, b: LispItem) => done(undefined, new KeyVal(a, b)));\n\naddOps(LispType.CreateArray, (exec, done, ticks, a, b: Lisp[], obj, context, scope) => {\n  const items = b.map((item) => {\n    if (item instanceof SpreadArray) {\n      return [...item.item];\n    } else {\n      return [item];\n    }\n  }).flat().map((item) => valueOrProp(item, context))\n  done(undefined, items)\n});\n\naddOps(LispType.Group, (exec, done, ticks, a, b) => done(undefined, b));\n\naddOps(LispType.GlobalSymbol, (exec, done, ticks, a, b: string) => {\n  switch (b) {\n    case 'true': return done(undefined, true);\n    case 'false': return done(undefined, false);\n    case 'null': return done(undefined, null);\n    case 'undefined': return done(undefined, undefined);\n    case 'NaN': return done(undefined, NaN);\n    case 'Infinity': return done(undefined, Infinity);\n  }\n  done(new Error('Unknown symbol: ' + b))\n})\n\naddOps(LispType.Number, (exec, done, ticks, a, b) => done(undefined, Number(b)));\naddOps(LispType.BigInt, (exec, done, ticks, a, b) => done(undefined, BigInt(b)));\naddOps(LispType.StringIndex, (exec, done, ticks, a, b: string, obj, context) => done(undefined, context.constants.strings[parseInt(b)]));\n\naddOps(LispType.RegexIndex, (exec, done, ticks, a, b: string, obj, context) => {\n  const reg: IRegEx = context.constants.regexes[parseInt(b)];\n  if (!context.ctx.globalsWhitelist.has(RegExp)) {\n    throw new SandboxError(\"Regex not permitted\");\n  } else {\n    done(undefined, new RegExp(reg.regex, reg.flags));\n  }\n});\n\naddOps(LispType.LiteralIndex, (exec, done, ticks, a, b: string, obj, context, scope) => {\n  let item = context.constants.literals[parseInt(b)];\n  const [,name,js] = item;\n  let found: Lisp[] = [];\n  let f: RegExpExecArray|null;\n  let resnums: string[] = [];\n  while(f = literalRegex.exec(name)) {\n    if (!f[2]) {\n      found.push(js[parseInt(f[3], 10)]);\n      resnums.push(f[3]);\n    }\n  }\n\n  exec<unknown[]>(ticks, found, scope, context, (err, processed) => {\n    const reses: Record<string, unknown> = {};\n    if(err) {\n      done(err);\n      return;\n    }\n    for (let i of Object.keys(processed!) as (keyof typeof processed)[]) {\n      const num = resnums[i];\n      reses[num] = processed![i];\n    }\n    done(undefined, name.replace(/(\\\\\\\\)*(\\\\)?\\${(\\d+)}/g, (match, $$, $, num) => {\n      if ($) return match;\n      let res = reses[num];\n      return ($$ ? $$ : '') + `${valueOrProp(res, context)}`;\n    }));\n  })\n});\n\naddOps(LispType.SpreadArray, (exec, done, ticks, a, b, obj, context, scope) => {\n  done(undefined, new SpreadArray(b));\n});\n\naddOps(LispType.SpreadObject, (exec, done, ticks, a, b, obj, context, scope) => {\n  done(undefined, new SpreadObject(b));\n});\n\naddOps(LispType.Not, (exec, done, ticks, a, b) => done(undefined, !b));\naddOps(LispType.Inverse, (exec, done, ticks, a, b) => done(undefined, ~b));\n\naddOps(LispType.IncrementBefore, (exec, done, ticks, a, b, obj, context) => {\n  assignCheck(obj, context);\n  done(undefined, ++obj.context[obj.prop]);\n});\n\naddOps(LispType.IncrementAfter, (exec, done, ticks, a, b, obj, context) => {\n  assignCheck(obj, context);\n  done(undefined, obj.context[obj.prop]++);\n});\n\naddOps(LispType.DecrementBefore, (exec, done, ticks, a, b, obj, context) => {\n  assignCheck(obj, context);\n  done(undefined, --obj.context[obj.prop]);\n});\n\naddOps(LispType.DecrementAfter, (exec, done, ticks, a, b, obj, context) => {\n  assignCheck(obj, context);\n  done(undefined, obj.context[obj.prop]--);\n});\n\naddOps(LispType.Assign, (exec, done, ticks, a, b, obj, context) => {\n  assignCheck(obj, context);\n  done(undefined, obj.context[obj.prop] = b);\n});\n\naddOps(LispType.AddEquals, (exec, done, ticks, a, b, obj, context) => {\n  assignCheck(obj, context);\n  done(undefined, obj.context[obj.prop] += b);\n});\n\naddOps(LispType.SubractEquals, (exec, done, ticks, a, b: number, obj, context) => {\n  assignCheck(obj, context);\n  done(undefined, obj.context[obj.prop] -= b);\n});\n\naddOps(LispType.DivideEquals, (exec, done, ticks, a, b: number, obj, context) => {\n  assignCheck(obj, context);\n  done(undefined, obj.context[obj.prop] /= b);\n});\n\naddOps(LispType.MultiplyEquals, (exec, done, ticks, a, b: number, obj, context) => {\n  assignCheck(obj, context);\n  done(undefined, obj.context[obj.prop] *= b);\n});\n\naddOps(LispType.PowerEquals, (exec, done, ticks, a, b: number, obj, context) => {\n  assignCheck(obj, context);\n  done(undefined, obj.context[obj.prop] **= b);\n});\n\naddOps(LispType.ModulusEquals, (exec, done, ticks, a, b: number, obj, context) => {\n  assignCheck(obj, context);\n  done(undefined, obj.context[obj.prop] %= b);\n});\n\naddOps(LispType.BitNegateEquals, (exec, done, ticks, a, b: number, obj, context) => {\n  assignCheck(obj, context);\n  done(undefined, obj.context[obj.prop] ^= b);\n});\n\naddOps(LispType.BitAndEquals, (exec, done, ticks, a, b: number, obj, context) => {\n  assignCheck(obj, context);\n  done(undefined, obj.context[obj.prop] &= b);\n});\n\naddOps(LispType.BitOrEquals, (exec, done, ticks, a, b: number, obj, context) => {\n  assignCheck(obj, context);\n  done(undefined, obj.context[obj.prop] |= b);\n});\n\naddOps(LispType.ShiftLeftEquals, (exec, done, ticks, a, b: number, obj, context) => {\n  assignCheck(obj, context);\n  done(undefined, obj.context[obj.prop] <<= b);\n});\n\naddOps(LispType.ShiftRightEquals, (exec, done, ticks, a, b: number, obj, context) => {\n  assignCheck(obj, context);\n  done(undefined, obj.context[obj.prop] >>= b);\n});\n\naddOps(LispType.UnsignedShiftRightEquals, (exec, done, ticks, a, b: number, obj, context) => {\n  assignCheck(obj, context);\n  done(undefined, obj.context[obj.prop] >>= b);\n});\n\naddOps(LispType.LargerThan, (exec, done, ticks, a, b) => done(undefined, a > b));\naddOps(LispType.SmallerThan, (exec, done, ticks, a, b) => done(undefined, a < b));\naddOps(LispType.LargerEqualThan, (exec, done, ticks, a, b) => done(undefined, a >= b));\naddOps(LispType.SmallerEqualThan, (exec, done, ticks, a, b) => done(undefined, a <= b));\naddOps(LispType.Equal, (exec, done, ticks, a, b) => done(undefined, a == b));\naddOps(LispType.StrictEqual, (exec, done, ticks, a, b) => done(undefined, a === b));\naddOps(LispType.NotEqual, (exec, done, ticks, a, b) => done(undefined, a != b));\naddOps(LispType.StrictNotEqual, (exec, done, ticks, a, b) => done(undefined, a !== b));\naddOps(LispType.And, (exec, done, ticks, a, b) => done(undefined, a && b));\naddOps(LispType.Or, (exec, done, ticks, a, b) => done(undefined, a || b));\naddOps(LispType.BitAnd, (exec, done, ticks, a: number, b: number) => done(undefined, a & b));\naddOps(LispType.BitOr, (exec, done, ticks, a: number, b: number) => done(undefined, a | b));\naddOps(LispType.Plus, (exec, done, ticks, a: number, b: number) => done(undefined, a + b));\naddOps(LispType.Minus, (exec, done, ticks, a: number, b: number) => done(undefined, a - b));\naddOps(LispType.Positive, (exec, done, ticks, a, b) => done(undefined, +b));\naddOps(LispType.Negative, (exec, done, ticks, a, b) => done(undefined, -b));\naddOps(LispType.Divide, (exec, done, ticks, a: number, b: number) => done(undefined, a / b));\naddOps(LispType.BitNegate, (exec, done, ticks, a: number, b: number) => done(undefined, a ^ b));\naddOps(LispType.Multiply, (exec, done, ticks, a: number, b: number) => done(undefined, a * b));\naddOps(LispType.Modulus, (exec, done, ticks, a: number, b: number) => done(undefined, a % b));\naddOps(LispType.BitShiftLeft, (exec, done, ticks, a: number, b: number) => done(undefined, a << b));\naddOps(LispType.BitShiftRight, (exec, done, ticks, a: number, b: number) => done(undefined, a >> b));\naddOps(LispType.BitUnsignedShiftRight, (exec, done, ticks, a: number, b: number) => done(undefined, a >>> b));\naddOps(LispType.Typeof, (exec, done, ticks, a, b: LispItem, obj, context, scope) => {\n    exec(ticks, b, scope, context, (e, prop) => {\n      done(undefined, typeof valueOrProp(prop, context));\n    });\n  });\n\naddOps(LispType.Instanceof, (exec, done, ticks, a, b:  { new(): unknown }) => done(undefined, a instanceof b));\naddOps(LispType.In, (exec, done, ticks, a: string, b) => done(undefined, a in b));\n\naddOps(LispType.Delete, (exec, done, ticks, a, b, obj, context, scope, bobj: Prop) => {\n  if (bobj.context === undefined) {\n    done(undefined, true);\n    return;\n  }\n  assignCheck(bobj, context, 'delete');\n  if (bobj.isVariable) {\n    done(undefined, false);\n    return;\n  }\n  done(undefined, delete bobj.context?.[bobj.prop]);\n});\n\naddOps(LispType.Return, (exec, done, ticks, a, b, obj, context) => done(undefined, b));\n\naddOps(LispType.Var, (exec, done, ticks, a: string, b: LispItem, obj, context, scope, bobj) => {\n  done(undefined, scope.declare(a, VarType.var, b));\n});\n\naddOps(LispType.Let, (exec, done, ticks, a: string, b: LispItem, obj, context, scope, bobj) => {\n  done(undefined, scope.declare(a, VarType.let, b, bobj && bobj.isGlobal));\n});\n\naddOps(LispType.Const, (exec, done, ticks, a: string, b: LispItem, obj, context, scope, bobj) => {\n  done(undefined, scope.declare(a, VarType.const, b));\n});\n\naddOps(LispType.ArrowFunction, (exec, done, ticks, a: string[], b: Lisp[], obj: Lisp, context, scope) => {\n  a = [...a];\n    if (typeof obj[2] === \"string\" || obj[2] instanceof CodeString) {\n      if (context.allowJit && context.evalContext) {\n        obj[2] = b = context.evalContext.lispifyFunction(new CodeString(obj[2]), context.constants);\n      } else {\n        throw new SandboxError('Unevaluated code detected, JIT not allowed')\n      }\n    }\n    if (a.shift()) {\n      done(undefined, createFunctionAsync(a, b, ticks, context, scope));\n    } else {\n      done(undefined, createFunction(a, b, ticks, context, scope));\n    }\n});\n\naddOps(LispType.Function, (exec, done, ticks, a: (string|LispType)[], b: Lisp[], obj: Lisp, context, scope) => {   \n  if (typeof obj[2] === \"string\" || obj[2] instanceof CodeString) {\n    if (context.allowJit && context.evalContext) {\n      obj[2] = b = context.evalContext.lispifyFunction(new CodeString(obj[2]), context.constants);\n    } else {\n      throw new SandboxError('Unevaluated code detected, JIT not allowed')\n    }\n  }\n  let isAsync = a.shift();\n  let name = a.shift() as string;\n  let func;\n  if (isAsync === LispType.True) {\n    func = createFunctionAsync(a as string[], b, ticks, context, scope, name);\n  } else {\n    func = createFunction(a as string[], b, ticks, context, scope, name);\n  }\n  if (name) {\n    scope.declare(name, VarType.var, func);\n  }\n  done(undefined, func);\n});\n\naddOps(LispType.InlineFunction, (exec, done, ticks, a: (string|LispType)[], b: Lisp[], obj: Lisp, context, scope) => {\n  if (typeof obj[2] === \"string\" || obj[2] instanceof CodeString) {\n    if (context.allowJit && context.evalContext) {\n      obj[2] = b = context.evalContext.lispifyFunction(new CodeString(obj[2]), context.constants);\n    } else {\n      throw new SandboxError('Unevaluated code detected, JIT not allowed')\n    }\n  }\n  let isAsync = a.shift();\n  let name = a.shift() as string;\n  if (name) {\n    scope = new Scope(scope, {})\n  }\n  let func;\n  if (isAsync === LispType.True) {\n    func = createFunctionAsync(a as string[], b, ticks, context, scope, name);\n  } else {\n    func = createFunction(a as string[], b, ticks, context, scope, name);\n  }\n  if (name) {\n    scope.declare(name, VarType.let, func);\n  }\n  done(undefined, func);\n});\n\naddOps(LispType.Loop, (exec, done, ticks, a: Lisp[], b: Lisp[], obj, context, scope) => {\n  const [checkFirst, startInternal, getIterator, startStep, step, condition, beforeStep] = a;\n  let loop = true;\n  const loopScope = new Scope(scope, {});\n  let internalVars = {\n    '$$obj': undefined\n  };\n  const interalScope = new Scope(loopScope, internalVars);\n  if (exec === execAsync) {\n    (async() => {\n      let ad: AsyncDoneRet;\n      ad = asyncDone((d) => exec(ticks, startStep, loopScope, context, d));\n      internalVars['$$obj'] = (ad = asyncDone((d) => exec(ticks, getIterator, loopScope, context, d))).isInstant === true ? ad.instant : (await ad.p).result;\n      ad = asyncDone((d) => exec(ticks, startInternal, interalScope, context, d));\n      if (checkFirst) loop = (ad = asyncDone((d) => exec(ticks, condition, interalScope, context, d))).isInstant === true ? ad.instant : (await ad.p).result;\n      while (loop) {\n        let innerLoopVars = {};\n        ad = asyncDone((d) => exec(ticks, beforeStep, new Scope(interalScope, innerLoopVars), context, d));\n        ad.isInstant === true ? ad.instant : (await ad.p).result;\n        let res = await executeTreeAsync(ticks, context, b, [new Scope(loopScope, innerLoopVars)], \"loop\");\n        if (res instanceof ExecReturn && res.returned) {\n          done(undefined, res);\n          return;\n        }\n        if (res instanceof ExecReturn && res.breakLoop) {\n          break;\n        }\n        ad = asyncDone((d) => exec(ticks, step, interalScope, context, d));\n        loop = (ad = asyncDone((d) => exec(ticks, condition, interalScope, context, d))).isInstant === true ? ad.instant : (await ad.p).result;\n      }\n      done();\n    })().catch(done);\n  } else {\n    syncDone((d) => exec(ticks, startStep, loopScope, context, d));\n    internalVars['$$obj'] = syncDone((d) => exec(ticks, getIterator, loopScope, context, d)).result;\n    syncDone((d) => exec(ticks, startInternal, interalScope, context, d));\n    if (checkFirst) loop = (syncDone((d) => exec(ticks, condition, interalScope, context, d))).result;\n    while (loop) {\n      let innerLoopVars = {};\n      syncDone((d) => exec(ticks, beforeStep, new Scope(interalScope, innerLoopVars), context, d));\n      let res = executeTree(ticks, context, b, [new Scope(loopScope, innerLoopVars)], \"loop\");\n      if (res instanceof ExecReturn && res.returned) {\n        done(undefined, res);\n        return;\n      }\n      if (res instanceof ExecReturn && res.breakLoop) {\n        break;\n      }\n      syncDone((d) => exec(ticks, step, interalScope, context, d));\n      loop = (syncDone((d) => exec(ticks, condition, interalScope, context, d))).result;\n    }\n    done();\n  }\n});\n\naddOps(LispType.LoopAction, (exec, done, ticks, a: LispItem, b: LispItem, obj, context, scope, bobj, inLoopOrSwitch) => {\n  if ((inLoopOrSwitch === \"switch\" && a === \"continue\") || !inLoopOrSwitch) {\n    throw new SandboxError(\"Illegal \" + a + \" statement\");\n  }\n  done(undefined, new ExecReturn(context.ctx.auditReport, undefined, false, a === \"break\", a === \"continue\"));\n});\n\naddOps(LispType.If, (exec, done, ticks, a: LispItem, b:If, obj, context, scope, bobj, inLoopOrSwitch) => {\n  exec(ticks, valueOrProp(a, context) ? b.t : b.f, scope, context, done);\n});\n\naddOps(LispType.InlineIf, (exec, done, ticks, a: LispItem, b: If, obj, context, scope) => {\n  exec(ticks, valueOrProp(a, context) ? b.t : b.f, scope, context, done);\n});\naddOps(LispType.InlineIfCase, (exec, done, ticks, a, b) => done(undefined, new If(a, b)));\naddOps(LispType.IfCase, (exec, done, ticks, a, b) => done(undefined, new If(a, b)));\n\naddOps(LispType.Switch, (exec, done, ticks, a: LispItem, b: SwitchCase[], obj, context, scope) => {\n  exec(ticks, a, scope, context, (err, toTest) => {\n    if (err) {\n      done(err);\n      return;\n    }\n    toTest = valueOrProp(toTest, context);\n    if (exec === execSync) {\n      let res: ExecReturn<unknown>;\n      let isTrue = false;\n      for (let caseItem of b) {\n        if (isTrue || (isTrue = !caseItem[1] || toTest === valueOrProp((syncDone((d) => exec(ticks, caseItem[1], scope, context, d))).result, context))) {\n          if (!caseItem[2]) continue;\n          res = executeTree(ticks, context, caseItem[2], [scope], \"switch\");\n          if (res.breakLoop) break;\n          if (res.returned) {\n            done(undefined, res);\n            return;\n          }\n          if (!caseItem[1]) { // default case\n            break;\n          }\n        }\n      }\n      done();\n    } else {\n      (async () => {\n        let res: ExecReturn<unknown>;\n        let isTrue = false;\n        for (let caseItem of b) {\n          let ad: AsyncDoneRet;\n          if (isTrue || (isTrue = !caseItem[1] || toTest === valueOrProp((ad = asyncDone((d) => exec(ticks, caseItem[1], scope, context, d))).isInstant === true ? ad.instant : (await ad.p).result, context))) {\n            if (!caseItem[2]) continue;\n            res = await executeTreeAsync(ticks, context, caseItem[2], [scope], \"switch\");\n            if (res.breakLoop) break;\n            if (res.returned) {\n              done(undefined, res);\n              return;\n            }\n            if (!caseItem[1]) { // default case\n              break;\n            }\n          }\n        }\n        done();\n      })().catch(done)\n    }\n  });\n});\n\naddOps(LispType.Try, (exec, done, ticks, a: Lisp[], b: [string, Lisp[], Lisp[]], obj, context, scope, bobj, inLoopOrSwitch) => {\n  const [exception, catchBody, finallyBody] = b;\n  executeTreeWithDone(exec, (err, res) => {\n    executeTreeWithDone(exec, (e) => {\n      if (e) done(e);\n      else  if (err) {\n        let sc: Record<string, unknown> = {};\n        if (exception) sc[exception] = err;\n        executeTreeWithDone(exec, done, ticks, context, catchBody, [new Scope(scope)], inLoopOrSwitch);\n      } else {\n        done(undefined, res);\n      }\n    }, ticks, context, finallyBody, [new Scope(scope, {})]);\n  }, ticks, context, a, [new Scope(scope)], inLoopOrSwitch);\n});\n\naddOps(LispType.Void, (exec, done, ticks, a) => {done()});\naddOps(LispType.New, (exec, done, ticks, a: new (...args: unknown[]) => unknown, b: unknown[], obj, context) => {\n  if (!context.ctx.globalsWhitelist.has(a) && !sandboxedFunctions.has(a)) {\n    throw new SandboxError(`Object construction not allowed: ${a.constructor.name}`)\n  }\n  done(undefined, new a(...b))\n});\n\naddOps(LispType.Throw, (exec, done, ticks, a, b) => { done(b) });\naddOps(LispType.Expression, (exec, done, ticks, a: unknown[]) => done(undefined, a.pop()));\naddOps(LispType.None, (exec, done, ticks, a: unknown[]) => done());\n\nfunction valueOrProp(a: unknown, context: IExecContext): any {\n  if (a instanceof Prop) return a.get(context);\n  if (a === optional) return undefined;\n  return a;\n}\n\nexport function execMany(ticks: Ticks, exec: Execution, tree: Lisp[], done: Done, scope: Scope, context: IExecContext, inLoopOrSwitch?: string) {\n  if (exec === execSync) {\n    _execManySync(ticks, tree, done, scope, context, inLoopOrSwitch);\n  } else {\n    _execManyAsync(ticks, tree, done, scope, context, inLoopOrSwitch).catch(done);\n  }\n}\n\nfunction _execManySync(ticks: Ticks, tree: Lisp[], done: Done, scope: Scope, context: IExecContext, inLoopOrSwitch?: string) {\n  let ret = [];\n  for (let i = 0; i < tree.length; i++) {\n    let res;\n    try {\n      res = syncDone((d) => execSync(ticks, tree[i], scope, context, d, inLoopOrSwitch)).result;\n    } catch(e) {\n      done(e);\n      return;\n    }\n    if (res instanceof ExecReturn && (res.returned || res.breakLoop || res.continueLoop)) {\n      done(undefined, res);\n      return;\n    }\n    if (isLisp(tree[i]) && tree[i][0] === LispType.Return) {\n      done(undefined, new ExecReturn(context.ctx.auditReport, res, true))\n      return;\n    }\n    ret.push(res);\n  }\n  done(undefined, ret);\n}\n\nasync function _execManyAsync(ticks: Ticks, tree: Lisp[], done: Done, scope: Scope, context: IExecContext, inLoopOrSwitch?: string) {\n  let ret = [];\n  for (let i = 0; i < tree.length; i++) {\n    let res;\n    try {\n      let ad: AsyncDoneRet;\n      res = (ad = asyncDone((d) => execAsync(ticks, tree[i], scope, context, d, inLoopOrSwitch))).isInstant === true ? ad.instant : (await ad.p).result;\n    } catch(e) {\n      done(e);\n      return;\n    }\n    if (res instanceof ExecReturn && (res.returned || res.breakLoop || res.continueLoop)) {\n      done(undefined, res);\n      return;\n    }\n    if (isLisp(tree[i]) && tree[i][0] === LispType.Return) {\n      done(undefined, new ExecReturn(context.ctx.auditReport, res, true))\n      return;\n    }\n    ret.push(res);\n  }\n  done(undefined, ret);\n}\n\ntype Execution = <T = any>(ticks: Ticks, tree: LispItem, scope: Scope, context: IExecContext, done: Done<T>, inLoopOrSwitch?: string) => void\n\nexport interface AsyncDoneRet {\n  isInstant: boolean,\n  instant: any,\n  p: Promise<{result: any}>\n}\n\nexport function asyncDone(callback: (done: Done) => void): AsyncDoneRet {\n  let isInstant = false;\n  let instant: unknown;\n  const p = new Promise<any>((resolve, reject) => {\n    callback((err, result) => {\n      if (err) reject(err);\n      else {\n        isInstant = true;\n        instant = result;\n        resolve({result})\n      };\n    });\n  });\n  return {\n    isInstant,\n    instant,\n    p\n  }\n}\n\nexport function syncDone(callback: (done: Done) => void): {result: any} {\n  let result;\n  let err;\n  callback((e, r) => {\n    err = e;\n    result = r;\n  });\n  if (err) throw err;\n  return {result};\n}\n\nexport async function execAsync<T = any>(ticks: Ticks, tree: LispItem, scope: Scope, context: IExecContext, doneOriginal: Done<T>, inLoopOrSwitch?: string): Promise<void> {\n  let done: Done<T> = doneOriginal;\n  const p = new Promise<void>((resolve) => {\n    done = (e, r?) => {\n      doneOriginal(e, r);\n      resolve();\n    }\n  });\n  if(_execNoneRecurse(ticks, tree, scope, context, done, true, inLoopOrSwitch)) {\n  } else if (isLisp(tree)) {\n    let op = tree[0];\n    let obj;\n    try {\n      let ad: AsyncDoneRet;\n      obj = (ad = asyncDone((d) => execAsync(ticks, tree[1], scope, context, d, inLoopOrSwitch))).isInstant === true ? ad.instant : (await ad.p).result;\n    } catch (e) {\n      done(e);\n      return;\n    }\n    let a = obj;\n    try {\n      a = obj instanceof Prop ? obj.get(context) : obj;\n    } catch (e) {\n      done(e);\n      return;\n    }\n    if (op === LispType.PropOptional || op === LispType.CallOptional) {\n      if (a === undefined || a === null) {\n        done(undefined, optional);\n        return;\n      }\n      op = op === LispType.PropOptional ? LispType.Prop : LispType.Call;\n    }\n    if (a === optional) {\n      if (op === LispType.Prop || op === LispType.Call) {\n        done(undefined, a);\n        return;\n      } else {\n        a = undefined;\n      }\n    }\n    let bobj;\n    try {\n      let ad: AsyncDoneRet;\n      bobj = (ad = asyncDone((d) => execAsync(ticks, tree[2], scope, context, d, inLoopOrSwitch))).isInstant === true ? ad.instant : (await ad.p).result;\n    } catch (e) {\n      done(e);\n      return;\n    }\n    let b = bobj;\n    try {\n      b = bobj instanceof Prop ? bobj.get(context) : bobj;\n    } catch (e) {\n      done(e);\n      return;\n    }\n    if (b === optional) {\n      b = undefined;\n    }\n    if (ops.has(op)) {\n      try {\n        ops.get(op)?.(execAsync, done, ticks, a, b, obj, context, scope, bobj, inLoopOrSwitch);\n      } catch (err) {\n        done(err);\n      }\n    } else {\n      done(new SyntaxError('Unknown operator: ' + op));\n    }\n  }\n  await p;\n}\n\n\nexport function execSync<T = any>(ticks: Ticks, tree: LispItem, scope: Scope, context: IExecContext, done: Done<T>, inLoopOrSwitch?: string) {\n  if(_execNoneRecurse(ticks, tree, scope, context, done, false, inLoopOrSwitch)) {\n  } else if (isLisp(tree)) {\n    let op = tree[0];\n    let obj;\n    try {\n      obj = syncDone((d) => execSync(ticks, tree[1], scope, context, d, inLoopOrSwitch)).result;\n    } catch (e) {\n      done(e);\n      return;\n    }\n    let a = obj;\n    try {\n      a = obj instanceof Prop ? obj.get(context) : obj;\n    } catch (e) {\n      done(e);\n      return;\n    }\n    if (op === LispType.PropOptional || op === LispType.CallOptional) {\n      if (a === undefined || a === null) {\n        done(undefined, optional);\n        return;\n      }\n      op = op === LispType.PropOptional ? LispType.Prop : LispType.Call;\n    }\n    if (a === optional) {\n      if (op === LispType.Prop || op === LispType.Call) {\n        done(undefined, a);\n        return;\n      } else {\n        a = undefined;\n      }\n    }\n    let bobj;\n    try {\n      bobj = syncDone((d) => execSync(ticks, tree[2], scope, context, d, inLoopOrSwitch)).result;\n    } catch (e) {\n      done(e);\n      return;\n    }\n    let b = bobj;\n    try {\n      b = bobj instanceof Prop ? bobj.get(context) : bobj;\n    } catch (e) {\n      done(e);\n      return;\n    }\n    if (b === optional) {\n      b = undefined;\n    }\n    if (ops.has(op)) {\n      try {\n        ops.get(op)?.(execSync, done, ticks, a, b, obj, context, scope, bobj, inLoopOrSwitch);\n      } catch (err) {\n        done(err);\n      }\n    } else {\n      done(new SyntaxError('Unknown operator: ' + op));\n    }\n  }\n}\n\nconst unexecTypes = new Set([\n  LispType.ArrowFunction,\n  LispType.Function,\n  LispType.InlineFunction,\n  LispType.Loop,\n  LispType.Try,\n  LispType.Switch,\n  LispType.IfCase,\n  LispType.InlineIfCase,\n  LispType.Typeof\n]);\n\nexport const currentTicks = { current: { ticks: BigInt(0) } as Ticks };\n\nfunction _execNoneRecurse<T = any>(ticks: Ticks, tree: LispItem, scope: Scope, context: IExecContext, done: Done<T>, isAsync: boolean, inLoopOrSwitch?: string): boolean {\n  const exec = isAsync ? execAsync : execSync;\n  if (context.ctx.options.executionQuota && context.ctx.options.executionQuota <= ticks.ticks) {\n    if (typeof context.ctx.options.onExecutionQuotaReached === 'function' && context.ctx.options.onExecutionQuotaReached(ticks, scope, context, tree)) {\n    } else {\n      done(new SandboxError(\"Execution quota exceeded\"));\n      return true;\n    }\n  }\n  ticks.ticks++;\n  currentTicks.current = ticks;\n  if (tree instanceof Prop) {\n    try {\n      done(undefined, tree.get(context));\n    } catch (err) {\n      done(err);\n    }\n  } else if (tree === optional) {\n    done();\n  } else if (Array.isArray(tree) && !isLisp(tree)) {\n    if (tree[0] === LispType.None) {\n      done();\n    } else {\n      execMany(ticks, exec, tree as Lisp[], done, scope, context, inLoopOrSwitch);\n    }\n  } else if (!isLisp(tree)) {\n    done(undefined, tree);\n  } else if (tree[0] === LispType.Block) {\n    execMany(ticks, exec, tree[1] as Lisp[], done, scope, context, inLoopOrSwitch);\n  } else if (tree[0] === LispType.Await) {\n    if (!isAsync) {\n      done(new SandboxError(\"Illegal use of 'await', must be inside async function\"));\n    } else if (context.ctx.prototypeWhitelist?.has(Promise.prototype)) {\n      execAsync(ticks, tree[1], scope, context, async (e, r) => {\n        if (e) done(e);\n        else try {\n          done(undefined, await valueOrProp(r, context));\n        } catch(err) {\n          done(err);\n        }\n      }, inLoopOrSwitch).catch(done);\n    } else {\n      done(new SandboxError('Async/await is not permitted'))\n    }\n  } else if (unexecTypes.has(tree[0])) {\n    try {\n      ops.get(tree[0])?.(exec, done, ticks, tree[1], tree[2], tree, context, scope, undefined, inLoopOrSwitch);\n    } catch (err) {\n      done(err);\n    }\n  } else {\n    return false;\n  }\n  return true;\n}\nexport function executeTree<T>(ticks: Ticks, context: IExecContext, executionTree: Lisp[], scopes: (IScope)[] = [], inLoopOrSwitch?: string): ExecReturn<T> {\n  return syncDone((done) => executeTreeWithDone(execSync, done, ticks, context, executionTree, scopes, inLoopOrSwitch)).result;\n}\n\nexport async function executeTreeAsync<T>(ticks: Ticks, context: IExecContext, executionTree: Lisp[], scopes: (IScope)[] = [], inLoopOrSwitch?: string): Promise<ExecReturn<T>> {\n  let ad: AsyncDoneRet;\n  return (ad = asyncDone((done) => executeTreeWithDone(execAsync, done, ticks, context, executionTree, scopes, inLoopOrSwitch))).isInstant === true ? ad.instant : (await ad.p).result;\n}\n\nfunction executeTreeWithDone(exec: Execution, done: Done, ticks: Ticks, context: IExecContext, executionTree: Lisp[], scopes: (IScope)[] = [], inLoopOrSwitch?: string) {\n  if (!executionTree)  {\n    done();\n    return;\n  }\n  if (!(executionTree instanceof Array)) {\n    throw new SyntaxError('Bad execution tree');\n  }\n  let scope = context.ctx.globalScope;\n  let s;\n  while (s = scopes.shift()) {\n    if (typeof s !== \"object\") continue;\n    if (s instanceof Scope) {\n      scope = s;\n    } else {\n      scope = new Scope(scope, s, s instanceof LocalScope ? undefined : null);\n    }\n  }\n  if (context.ctx.options.audit && !context.ctx.auditReport) {\n    context.ctx.auditReport = {\n      globalsAccess: new Set(),\n      prototypeAccess: {},\n    }\n  }\n  if (exec === execSync) {\n    _executeWithDoneSync(done, ticks, context, executionTree, scope, inLoopOrSwitch);\n  } else {\n    _executeWithDoneAsync(done, ticks, context, executionTree, scope, inLoopOrSwitch).catch(done);\n  }\n}\n\nfunction _executeWithDoneSync(done: Done, ticks: Ticks, context: IExecContext, executionTree: Lisp[], scope: Scope, inLoopOrSwitch?: string) {\n  if (!(executionTree instanceof Array)) throw new SyntaxError('Bad execution tree');\n  let i = 0;\n  for (i = 0; i < executionTree.length; i++) {\n    let res: unknown;\n    let err: unknown;\n    const current = executionTree[i];\n    try {\n      execSync(ticks, current, scope, context, (e, r) => {\n        err = e;\n        res = r;\n      }, inLoopOrSwitch);\n    } catch (e) {\n      err = e;\n    }\n    if (err) {\n      done(err);\n      return;\n    }\n    if (res instanceof ExecReturn) {\n      done(undefined, res);\n      return;\n    }\n    if (isLisp(current) && current[0] === LispType.Return) {\n      done(undefined, new ExecReturn(context.ctx.auditReport, res, true))\n      return;\n    }\n  }\n  done(undefined, new ExecReturn(context.ctx.auditReport, undefined, false));\n}\n\nasync function _executeWithDoneAsync(done: Done, ticks: Ticks, context: IExecContext, executionTree: Lisp[], scope: Scope, inLoopOrSwitch?: string) {\n  if (!(executionTree instanceof Array)) throw new SyntaxError('Bad execution tree');\n  let i = 0;\n  for (i = 0; i < executionTree.length; i++) {\n    let res: unknown;\n    let err: unknown;\n    const current = executionTree[i];\n    try {\n      await execAsync(ticks, current, scope, context, (e, r) => {\n        err = e;\n        res = r;\n      }, inLoopOrSwitch);\n    } catch (e) {\n      err = e;\n    }\n    if (err) {\n      done(err);\n      return;\n    }\n    if (res instanceof ExecReturn) {\n      done(undefined, res);\n      return;\n    }\n    if (isLisp(current) && current[0] === LispType.Return) {\n      done(undefined, new ExecReturn(context.ctx.auditReport, res, true))\n      return;\n    }\n  }\n  done(undefined, new ExecReturn(context.ctx.auditReport, undefined, false));\n}\n","import { IEvalContext } from \"./eval.js\";\nimport { \n  Change, \n  ExecReturn,\n  executeTree,\n  executeTreeAsync,\n} from \"./executor.js\";\nimport { createContext, IContext, IExecContext, IGlobals, IOptionParams, IOptions, IScope, replacementCallback, SandboxGlobal, SubscriptionSubject } from \"./utils.js\";\n\nfunction subscribeSet(obj: unknown, name: string, callback: (modification: Change) => void, context: {\n  setSubscriptions: WeakMap<SubscriptionSubject, Map<string, Set<(modification: Change) => void>>>, \n  changeSubscriptions: WeakMap<SubscriptionSubject, Set<(modification: Change) => void>>\n}): {unsubscribe: () => void} {\n  if (!(obj instanceof Object)) throw new Error('Invalid subscription object, got ' + (typeof obj === 'object' ? 'null' : typeof obj))\n  const names = context.setSubscriptions.get(obj) || new Map<string, Set<(modification: Change) => void>>();\n  context.setSubscriptions.set(obj, names);\n  const callbacks = names.get(name) || new Set();\n  names.set(name, callbacks);\n  callbacks.add(callback);\n  let changeCbs: Set<(modification: Change) => void>;\n  const val = (obj as any)[name] as unknown;\n  if (val instanceof Object) {\n    changeCbs = context.changeSubscriptions.get(val) || new Set();\n    changeCbs.add(callback);\n    context.changeSubscriptions.set(val, changeCbs);\n  }\n  return {\n    unsubscribe: () => {\n      callbacks.delete(callback);\n      changeCbs?.delete(callback);\n    }\n  }\n}\n\nexport default class SandboxExec {\n  context: IContext;\n  setSubscriptions: WeakMap<SubscriptionSubject, Map<string, Set<(modification: Change) => void>>> = new WeakMap();\n  changeSubscriptions: WeakMap<SubscriptionSubject, Set<(modification: Change) => void>> = new WeakMap();\n  sandboxFunctions: WeakMap<(...args: any[]) => any, IExecContext> = new WeakMap();\n  constructor(options?: IOptionParams, public evalContext?: IEvalContext) {\n    const opt: IOptions = Object.assign({\n      audit: false,\n      forbidFunctionCalls: false,\n      forbidFunctionCreation: false,\n      globals: SandboxExec.SAFE_GLOBALS,\n      prototypeWhitelist: SandboxExec.SAFE_PROTOTYPES, \n      prototypeReplacements: new Map<new() => any, replacementCallback>(),\n    }, options || {});\n    this.context = createContext(this, opt, evalContext)\n  }\n\n  static get SAFE_GLOBALS(): IGlobals {\n    return {\n      Function,\n      console: {\n        debug: console.debug, \n        error: console.error, \n        info: console.info, \n        log: console.log, \n        table: console.table, \n        warn: console.warn\n      },\n      isFinite,\n      isNaN,\n      parseFloat,\n      parseInt,\n      decodeURI,\n      decodeURIComponent,\n      encodeURI,\n      encodeURIComponent,\n      escape,\n      unescape,\n      Boolean,\n      Number,\n      BigInt,\n      String,\n      Object,\n      Array,\n      Symbol,\n      Error,\n      EvalError,\n      RangeError,\n      ReferenceError,\n      SyntaxError,\n      TypeError,\n      URIError,\n      Int8Array,\n      Uint8Array,\n      Uint8ClampedArray,\n      Int16Array,\n      Uint16Array,\n      Int32Array,\n      Uint32Array,\n      Float32Array,\n      Float64Array,\n      Map,\n      Set,\n      WeakMap,\n      WeakSet,\n      Promise,\n      Intl,\n      JSON,\n      Math,\n      Date,\n      RegExp\n    }\n  }\n\n  \n  static get SAFE_PROTOTYPES(): Map<any, Set<string>> {\n    let protos = [\n      SandboxGlobal,\n      Function,\n      Boolean,\n      Number,\n      BigInt,\n      String,\n      Date,\n      Error,\n      Array,\n      Int8Array,\n      Uint8Array,\n      Uint8ClampedArray,\n      Int16Array,\n      Uint16Array,\n      Int32Array,\n      Uint32Array,\n      Float32Array,\n      Float64Array,\n      Map,\n      Set,\n      WeakMap,\n      WeakSet,\n      Promise,\n      Symbol,\n      Date,\n      RegExp\n    ]\n    let map = new Map<any, Set<string>>();\n    protos.forEach((proto) => {\n      map.set(proto, new Set());\n    });\n    map.set(Object, new Set([\n      'entries',\n      'fromEntries',\n      'getOwnPropertyNames',\n      'is',\n      'keys',\n      'hasOwnProperty',\n      'isPrototypeOf',\n      'propertyIsEnumerable',\n      'toLocaleString',\n      'toString',\n      'valueOf',\n      'values'\n    ]));\n    return map;\n  }\n\n  subscribeGet(callback: (obj: SubscriptionSubject, name: string) => void, context: IExecContext): {unsubscribe: () => void} {\n    context.getSubscriptions.add(callback);\n    return {unsubscribe: () => context.getSubscriptions.delete(callback)}\n  }\n\n  subscribeSet(obj: object, name: string, callback: (modification: Change) => void, context: SandboxExec|IExecContext): {unsubscribe: () => void} {\n    return subscribeSet(obj, name, callback, context);\n  }\n\n  subscribeSetGlobal(obj: SubscriptionSubject, name: string, callback: (modification: Change) => void): {unsubscribe: () => void} {\n    return subscribeSet(obj, name, callback, this);\n  }\n\n  getContext(fn: (...args: any[]) => any) {\n    return this.sandboxFunctions.get(fn);\n  }\n\n  executeTree<T>(context: IExecContext, scopes: (IScope)[] = []): ExecReturn<T> {\n    return executeTree({\n      ticks: BigInt(0),\n    }, context, context.tree, scopes);\n  }\n\n  executeTreeAsync<T>(context: IExecContext, scopes: (IScope)[] = []): Promise<ExecReturn<T>> {\n    return executeTreeAsync({\n      ticks: BigInt(0),\n    }, context, context.tree, scopes);\n  }\n}\n"],"names":["SandboxGlobal","globals","globalThis","i","this","CodeString","constructor","str","ref","start","end","length","substring","undefined","code","len","char","toString","trimStart","found","exec","slice","trim","valueOf","keysOnly","obj","ret","Object","assign","key","reservedWords","Set","Scope","parent","vars","functionThis","const","let","var","isFuncScope","allVars","get","functionScope","Prop","has","SyntaxError","hasOwnProperty","set","val","prop","context","ReferenceError","isConst","TypeError","isGlobal","SandboxError","declare","type","value","LocalScope","Error","isLisp","item","Array","isArray","isVariable","ctx","getSubscriptions","forEach","cb","ExecReturn","auditReport","result","returned","breakLoop","continueLoop","optional","generateArgs","argNames","args","arg","startsWith","sandboxedFunctions","WeakSet","createFunction","parsed","ticks","scope","name","options","forbidFunctionCreation","func","executeTree","registerSandboxFunction","add","createFunctionAsync","prototypeWhitelist","Promise","prototype","async","executeTreeAsync","assignCheck","op","changeSubscriptions","changeSubscriptionsGlobal","setSubscriptions","setSubscriptionsGlobal","arrayChange","push","pop","shift","unshift","splice","reverse","sort","copyWithin","KeyVal","SpreadObject","SpreadArray","If","t","f","literalRegex","ops","Map","addOps","valueOrProp","a","execMany","tree","done","inLoopOrSwitch","execSync","res","syncDone","d","e","_execManySync","ad","asyncDone","execAsync","isInstant","instant","p","_execManyAsync","catch","callback","resolve","reject","err","r","doneOriginal","_execNoneRecurse","bobj","b","sandboxGlobal","audit","globalsAccess","rep","globalsWhitelist","evals","globalScope","Number","String","Boolean","isFunction","prototypeAccess","prot","getPrototypeOf","includes","whitelist","replace","prototypeReplacements","size","constuctor","g","forbidFunctionCalls","vals","map","flat","JSON","stringify","cache","recurse","x","y","keys","change","changed","added","removed","startIndex","deleteCount","Math","min","endIndex","NaN","Infinity","BigInt","constants","strings","parseInt","reg","regexes","RegExp","regex","flags","literals","js","resnums","processed","reses","num","match","$$","$","allowJit","evalContext","lispifyFunction","isAsync","checkFirst","startInternal","getIterator","startStep","step","condition","beforeStep","loop","loopScope","internalVars","$$obj","interalScope","innerLoopVars","toTest","isTrue","caseItem","exception","catchBody","finallyBody","executeTreeWithDone","unexecTypes","executionQuota","onExecutionQuotaReached","executionTree","scopes","s","current","_executeWithDoneSync","_executeWithDoneAsync","subscribeSet","names","callbacks","changeCbs","unsubscribe","delete","SandboxExec","WeakMap","sandboxFunctions","opt","SAFE_GLOBALS","SAFE_PROTOTYPES","sandbox","values","Symbol","iterator","createContext","Function","console","debug","error","info","log","table","warn","isFinite","isNaN","parseFloat","decodeURI","decodeURIComponent","encodeURI","encodeURIComponent","escape","unescape","EvalError","RangeError","URIError","Int8Array","Uint8Array","Uint8ClampedArray","Int16Array","Uint16Array","Int32Array","Uint32Array","Float32Array","Float64Array","Intl","Date","protos","proto","subscribeGet","subscribeSetGlobal","getContext","fn"],"mappings":"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"}