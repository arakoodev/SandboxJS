class Prop{constructor(e,t,r=!1,n=!1){this.context=e,this.prop=t,this.isConst=r,this.isGlobal=n}}class Lisp{constructor(e){this.op=e.op,this.a=e.a,this.b=e.b}}class If{constructor(e,t){this.t=e,this.f=t}}class KeyVal{constructor(e,t){this.key=e,this.val=t}}class ObjectFunc{constructor(e,t,r){this.key=e,this.args=t,this.tree=r}}class SpreadObject{constructor(e){this.item=e}}class SpreadArray{constructor(e){this.item=e}}class Scope{constructor(e,t={},r){this.const={},this.var={},this.globals={},this.parent=e,this.let=e?t:{},this.globals=e?{}:t,this.functionThis=r||!e,r&&this.declare("this","var",r)}get(e,t=!1){if(!this.parent||!t||this.functionThis){if(this.const.hasOwnProperty(e))return new Prop(this.const,e,!0,e in this.globals);if(this.var.hasOwnProperty(e))return new Prop(this.var,e,!1,e in this.globals);if(this.let.hasOwnProperty(e))return new Prop(this.let,e,!1,e in this.globals);if(!this.parent&&this.globals.hasOwnProperty(e))return new Prop(this.functionThis,e,!1,!0);if(!this.parent)return new Prop(void 0,e)}return this.parent.get(e,t)}set(e,t){if("this"===e)throw new SyntaxError('"this" cannot be a variable');let r=this.get(e);if(void 0===r.context)throw new ReferenceError(`Variable '${e}' was not declared.`);if(r.isConst)throw new TypeError(`Cannot assign to const variable '${e}'`);if(r.isGlobal)throw new SandboxError(`Cannot override global variable '${e}'`);return r.context[r]=t,r}declare(e,t=null,r,n=!1){if("var"===t&&!this.functionThis&&this.parent)this.parent.declare(e,t,r,n);else{if(e in this.var&&e in this.let&&e in this.const&&e in this.globals)throw Error(`Variable '${e}' already declared`);n&&(this.globals[e]=r),this[t][e]=r}}}class ParseError extends Error{constructor(e,t){super(e),this.code=t}}class SandboxError extends Error{}class SandboxGlobal{constructor(e){if(e===globalThis)return globalThis;for(let t in e)this[t]=e[t]}}function sandboxFunction(e){return function SandboxFunction(...t){let r=t.pop(),n=Sandbox.parse(r);return function(...r){const s={};for(let e of t)s[e]=r.shift();const o=e.sandbox.executeTree(n);if(e.options.audit){for(let t in o.auditReport.globalsAccess){let r=o.auditReport.globalsAccess[t];e.auditReport.globalsAccess[t]=e.auditReport.globalsAccess[t]||new Set,r.forEach(r=>{e.auditReport.globalsAccess[t].add(r)})}for(let t in o.auditReport.prototypeAccess){let r=o.auditReport.prototypeAccess[t];e.auditReport.prototypeAccess[t]=e.auditReport.prototypeAccess[t]||new Set,r.forEach(r=>{e.auditReport.prototypeAccess[t].add(r)})}}return o.result}}}function sandboxedEval(e){return function(t){return e(t)()}}function sandboxedSetTimeout(e){return function(t,...r){return"string"!=typeof t?setTimeout(t,...r):setTimeout(e(t),r[0])}}function sandboxedSetInterval(e){return function(t,...r){return"string"!=typeof t?setInterval(t,...r):setTimeout(e(t),r[0])}}let expectTypes={op:{types:{op:/^(\/|\*\*(?!\=)|\*(?!\=)|\%(?!\=))/},next:["value","prop","exp","modifier","incrementerBefore"],firstChar:new Set([..."/*%"])},splitter:{types:{split:/^(&&|&|\|\||\||<=|>=|<|>|!==|!=|===|==| instanceof | in |\+(?!\+)|\-(?!\-))(?!\=)/},next:["value","prop","exp","modifier","incrementerBefore"],firstChar:new Set([..."&|<>!= +-"])},if:{types:{if:/^\?/,else:/^:/},next:["expEnd"],firstChar:new Set([..."?:"])},assignment:{types:{assignModify:/^(\-=|\+=|\/=|\*\*=|\*=|%=|\^=|\&=|\|=)/,assign:/^(=)/},next:["value","function","prop","exp","modifier","incrementerBefore"],firstChar:new Set([..."+-=*%^&|/"])},incrementerBefore:{types:{incrementerBefore:/^(\+\+|\-\-)/},next:["prop"],firstChar:new Set([..."+-"])},incrementerAfter:{types:{incrementerAfter:/^(\+\+|\-\-)/},next:["splitter","op","expEnd"],firstChar:new Set([..."+-"])},expEdge:{types:{arrayProp:/^[\[]/,call:/^[\(]/},next:["splitter","op","expEdge","if","dot","expEnd"],firstChar:new Set([..."[("])},modifier:{types:{not:/^!/,inverse:/^~/,negative:/^\-(?!\-)/,positive:/^\+(?!\+)/,typeof:/^ typeof /},next:["exp","modifier","value","prop","incrementerBefore"],firstChar:new Set([..."!~-+ "])},exp:{types:{createObject:/^\{/,createArray:/^\[/,group:/^\(/},next:["splitter","op","expEdge","if","dot","expEnd"],firstChar:new Set([..."{[("])},dot:{types:{dot:/^\.(?!\.)/},next:["splitter","incrementerAfter","assignment","op","expEdge","if","dot","expEnd"],firstChar:new Set([..."."])},prop:{types:{prop:/^[a-zA-Z\$_][a-zA-Z\d\$_]*/},next:["splitter","incrementerAfter","assignment","op","expEdge","if","dot","expEnd"],firstChar:new Set([..."abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYX$_"])},value:{types:{number:/^\-?\d+(\.\d+)?/,string:/^"(\d+)"/,literal:/^`(\d+)`/,boolean:/^(true|false)(?![\w$_])/,null:/^null(?![\w$_])/,und:/^undefined(?![\w$_])/,NaN:/^NaN(?![\w$_])/,Infinity:/^Infinity(?![\w$_])/},next:["splitter","op","if","dot","expEnd"],firstChar:new Set([...'-"`tfunNI0123456789'])},function:{types:{arrowFunc:/^\(?(([a-zA-Z\$_][a-zA-Z\d\$_]*,?)*)(\))?=>({)?/},next:["expEnd"],firstChar:new Set([..."(abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYX$_"])},initialize:{types:{initialize:/^ (var|let|const) [a-zA-Z\$_][a-zA-Z\d\$_]*/},next:["value","function","prop","exp","modifier","incrementerBefore","expEnd"],firstChar:new Set([..." "])},spreadObject:{types:{spreadObject:/^\.\.\./},next:["value","exp","prop"],firstChar:new Set([..."."])},spreadArray:{types:{spreadArray:/^\.\.\./},next:["value","exp","prop"],firstChar:new Set([..."."])},expEnd:{types:{},next:[],firstChar:new Set},expStart:{types:{return:/^ return /},next:["value","function","prop","exp","modifier","incrementerBefore","expEnd"],firstChar:new Set([..." "])}},closings={"(":")","[":"]","{":"}","'":"'",'"':'"',"`":"`"},closingsRegex={"(":/^\)/,"[":/^\]/,"{":/^\}/,"'":/^\'/,'"':/^\"/,"`":/^\`/};const restOfExp=(e,t,r)=>{let n=/^[\+\-~ !]/,s=!0;t=t||[expectTypes.op.types.op,expectTypes.splitter.types.split,expectTypes.if.types.if,expectTypes.if.types.else];let o,i=!1,p=!1;for(o=0;o<e.length&&!p;o++){let a=e[o];if('"'===r||"'"===r||"`"===r){if("`"!==r||"$"!==a||"{"!==e[o+1]||i){if(a===r&&!i)return e.substring(0,o)}else{o+=restOfExp(e.substring(o+2),[/^}/]).length+2}i="\\"===a}else if(closings[a]){o+=restOfExp(e.substring(o+1),[closingsRegex[r]],a).length+1,s=!1}else if(r){if(a===closings[r])return e.substring(0,o)}else{let r=e.substring(o);for(let e of t)if(p=e.test(r),p)break;if(s&&(n.test(r)?p=!1:s=!1),p)break}}return e.substring(0,o)};function assignCheck(e){if(void 0===e.context)throw new ReferenceError("Cannot assign value to undefined.");if("object"!=typeof e.context&&"function"!=typeof e.context)throw new SyntaxError("Cannot assign value to a primitive.");if(e.isConst)throw new TypeError(`Cannot set value to const variable '${e.prop}'`);if(e.isGlobal)throw new SandboxError(`Cannot assign property '${e.prop}' of a global object`);if("function"==typeof e.context[e.prop]&&!e.context.hasOwnProperty(e.prop))throw new SandboxError(`Override prototype property '${e.prop}' not allowed`)}restOfExp.next=["splitter","op","expEnd"];let ops2={prop:(e,t,r,n,s)=>{if(null===e)throw new TypeError(`Cannot get property ${t} of null`);if(void 0===e){let e=s.get(t);if(void 0===e.context)throw new ReferenceError(`${t} is not defined`);if(e.context===n.sandboxGlobal){n.options.audit&&n.auditReport.globalsAccess.add(t);const e=n.replacements.get(n.sandboxGlobal[t]);if(e)return e}return e.context&&e.context[t]===globalThis?n.globalScope.get("this"):e}let o=!1;if("number"==typeof e&&(e=new Number(e)),"string"==typeof e&&(e=new String(e)),"boolean"==typeof e&&(e=new Boolean(e)),void 0===e.hasOwnProperty)return new Prop(void 0,t);if(o="function"!=typeof e&&(e.hasOwnProperty(t)||"number"==typeof t),!o&&n.options.audit&&(o=!0,"string"==typeof t)){let r=e.constructor.prototype;do{r.hasOwnProperty(t)&&(n.auditReport.prototypeAccess[r.constructor.name]||(n.auditReport.prototypeAccess[r.constructor.name]=new Set),n.auditReport.prototypeAccess[r.constructor.name].add(t))}while(r=Object.getPrototypeOf(r))}if(!o)if("function"==typeof e){if(!["name","length","constructor"].includes(t)&&e.hasOwnProperty(t)){const r=n.prototypeWhitelist.get(e);if(!r||r.size&&!r.has(t))throw new SandboxError(`Static method or property access not permitted: ${e.name}.${t}`)}}else if("constructor"!==t){let r=e.constructor.prototype;do{if(r.hasOwnProperty(t)){const e=n.prototypeWhitelist.get(r.constructor);if(e&&(!e.size||e.has(t)))break;throw new SandboxError(`Method or property access not permitted: ${r.constructor.name}.${t}`)}}while(r=Object.getPrototypeOf(r))}const i=n.replacements.get(e[t]);if(i)return i;if(e[t]===globalThis)return n.globalScope.get("this");let p=r.isGlobal||"function"==typeof e&&"sandboxArrowFunction"!==e.name||n.globalsWhitelist.has(e);return new Prop(e,t,!1,p)},call:(e,t,r,n,s)=>{if(n.options.forbidMethodCalls)throw new SandboxError("Method calls are not allowed");if("function"!=typeof e)throw new TypeError(`${r.prop} is not a function`);return"function"==typeof r?r(...t.map(e=>exec(e,s,n))):r.context[r.prop](...t.map(e=>exec(e,s,n)))},createObject:(e,t,r,n,s)=>{let o={};for(let e of t)if(e instanceof SpreadObject)o={...o,...e.item};else if(e instanceof ObjectFunc){let t=e;o[t.key]=function(...e){const r={};return t.args.forEach((t,n)=>{r[t]=e[n]}),n.sandbox.executeTree({tree:t.tree,strings:n.strings,literals:n.literals},[new Scope(s,r,this)]).result}}else o[e.key]=e.val;return o},keyVal:(e,t)=>new KeyVal(e,t),createArray:(e,t,r,n,s)=>{let o=[],i=[];return t.forEach(e=>{e instanceof SpreadArray?(i.length&&(o.push(i),i=[]),o.push(e.item)):i.push(exec(e,s,n))}),i.length&&o.push(i),o.flat()},group:(e,t)=>t,string:(e,t,r,n)=>n.strings[t],literal:(e,t,r,n,s)=>n.literals[t].a.replace(/(\$\$)*(\$)?\${(\d+)}/g,(e,r,o,i)=>{if(o)return e;let p=exec(n.literals[t].b[parseInt(i,10)],s,n);return p=p instanceof Prop?p.context[p.prop]:p,(r||"")+`${p}`.replace(/\$/g,"$$")}).replace(/\$\$/g,"$"),spreadArray:(e,t,r,n,s)=>new SpreadArray(exec(t,s,n)),spreadObject:(e,t,r,n,s)=>new SpreadObject(exec(t,s,n)),"!":(e,t)=>!t,"~":(e,t)=>~t,"++$":(e,t,r)=>++r.context[r.prop],"$++":(e,t,r)=>r.context[r.prop]++,"--$":(e,t,r)=>--r.context[r.prop],"$--":(e,t,r)=>r.context[r.prop]--,"=":(e,t,r,n,s,o)=>(assignCheck(r),r.context[r.prop]=t,new Prop(r.context,r.prop,!1,r.isGlobal)),"+=":(e,t,r)=>(assignCheck(r),r.context[r.prop]+=t),"-=":(e,t,r)=>(assignCheck(r),r.context[r.prop]-=t),"/=":(e,t,r)=>(assignCheck(r),r.context[r.prop]/=t),"*=":(e,t,r)=>(assignCheck(r),r.context[r.prop]*=t),"**=":(e,t,r)=>(assignCheck(r),r.context[r.prop]**=t),"%=":(e,t,r)=>(assignCheck(r),r.context[r.prop]%=t),"^=":(e,t,r)=>(assignCheck(r),r.context[r.prop]^=t),"&=":(e,t,r)=>(assignCheck(r),r.context[r.prop]&=t),"|=":(e,t,r)=>(assignCheck(r),r.context[r.prop]|=t),"?":(e,t)=>{if(!(t instanceof If))throw new SyntaxError("Invalid inline if");return e?t.t:t.f},">":(e,t)=>e>t,"<":(e,t)=>e<t,">=":(e,t)=>e>=t,"<=":(e,t)=>e<=t,"==":(e,t)=>e==t,"===":(e,t)=>e===t,"!=":(e,t)=>e!=t,"!==":(e,t)=>e!==t,"&&":(e,t)=>e&&t,"||":(e,t)=>e||t,"&":(e,t)=>e&t,"|":(e,t)=>e|t,":":(e,t)=>new If(e,t),"+":(e,t)=>e+t,"-":(e,t)=>e-t,"$+":(e,t)=>+t,"$-":(e,t)=>-t,"/":(e,t)=>e/t,"*":(e,t)=>e*t,"%":(e,t)=>e%t," typeof ":(e,t)=>typeof t," instanceof ":(e,t)=>e instanceof t," in ":(e,t)=>e in t,return:(e,t)=>t,var:(e,t,r,n,s,o)=>(s.declare(e,"var",exec(t,s,n)),new Prop(s.var,e,!1,o&&o.isGlobal)),let:(e,t,r,n,s,o)=>(s.declare(e,"let",exec(t,s,n),o&&o.isGlobal),new Prop(s.let,e,!1,o&&o.isGlobal)),const:(e,t,r,n,s,o)=>(s.declare(e,"const",exec(t,s,n)),new Prop(s.const,e,!1,o&&o.isGlobal)),arrowFunc:(e,t,r,n,s)=>(...r)=>{const o={};return e.forEach((e,t)=>{o[e]=r[t]}),n.sandbox.executeTree({tree:t,strings:n.strings,literals:n.literals},[new Scope(s,o)]).result}},ops=new Map;for(let e in ops2)ops.set(e,ops2[e]);let lispTypes=new Map,setLispType=(e,t)=>{e.forEach(e=>{lispTypes.set(e,t)})},lastType;function lispify(e,t,r){if(t=t||["initialize","expStart","value","function","prop","exp","modifier","incrementerBefore","expEnd"],void 0===e)return r;if(!e.length&&!t.includes("expEnd"))throw new SyntaxError("Unexpected end of expression");let n,s={lispTree:r};for(let r of t)if("expEnd"!==r){if(expectTypes[r].firstChar.has(e[0])&&!n)for(let t in expectTypes[r].types)if("expEnd"!==t&&(n=expectTypes[r].types[t].exec(e))){lastType=t,lispTypes.get(t)(t,e,n,r,s);break}if(n)break}if(!n&&e.length)throw Error(`Unexpected token (${lastType}): ${e}`);return s.lispTree}function exec(e,t,r){if(e instanceof Prop)return e.context[e.prop];if(Array.isArray(e))return e.map(e=>exec(e,t,r));if(!(e instanceof Lisp))return e;if("arrowFunc"===e.op)return ops.get(e.op)(e.a,e.b,void 0,r,t);let n=exec(e.a,t,r),s=n instanceof Prop?n.context?n.context[n.prop]:void 0:n,o=exec(e.b,t,r),i=o instanceof Prop?o.context?o.context[o.prop]:void 0:o;if(ops.has(e.op)){return ops.get(e.op)(s,i,n,r,t,o)}throw new SyntaxError("Unknown operator: "+e.op)}setLispType(["createArray","createObject","group","arrayProp","call"],(e,t,r,n,s)=>{let o="",i={createArray:"]",createObject:"}",group:")",arrayProp:"]",call:")"},p=[],a=!1,l=1;for(;l<t.length&&!a;)o=restOfExp(t.substring(l),[new RegExp("^\\"+i[e]),/^,/]),l+=o.length,o&&p.push(o),","!==t[l]?a=!0:l++;const c=["value","function","prop","exp","modifier","incrementerBefore"];let f,u;const y=/^([a-zA-Z\$_][a-zA-Z\d\$_]*)\((([a-zA-Z\$_][a-zA-Z\d\$_]*,?)*)\)?{/;switch(e){case"group":case"arrayProp":f=lispify(p.pop());break;case"call":case"createArray":f=p.map(e=>lispify(e,[...c,"spreadArray"]));break;case"createObject":f=p.map(e=>{let t,r;if(u=y.exec(e),u){let t=u[2]?u[2].split(","):[];const r=restOfExp(e.substring(u.index+u[0].length),[/^}/]);return new ObjectFunc(u[1],t,Sandbox.parse(r,null).tree)}{let n=restOfExp(e,[/^:/]);if(r=lispify(n,[...c,"spreadObject"]),r instanceof Lisp&&"prop"===r.op&&(r=r.b),n.length===e.length)return r;t=lispify(e.substring(n.length+1))}return new Lisp({op:"keyVal",a:r,b:t})})}e="arrayProp"===e?"prop":e,s.lispTree=lispify(t.substring(l+1),expectTypes[n].next,new Lisp({op:e,a:s.lispTree,b:f}))}),setLispType(["op"],(e,t,r,n,s)=>{let o=restOfExp(t.substring(r[0].length));s.lispTree=new Lisp({op:r[0],a:s.lispTree,b:lispify(o)}),s.lispTree=lispify(t.substring(o.length+r[0].length),restOfExp.next,s.lispTree)}),setLispType(["inverse","not","negative","positive","typeof"],(e,t,r,n,s)=>{let o=restOfExp(t.substring(r[0].length));s.lispTree=new Lisp({op:["positive","negative"].includes(e)?"$"+r[0]:r[0],a:s.lispTree,b:lispify(o,expectTypes[n].next)}),s.lispTree=lispify(t.substring(o.length+r[0].length),restOfExp.next,s.lispTree)}),setLispType(["incrementerBefore"],(e,t,r,n,s)=>{let o=restOfExp(t.substring(2));s.lispTree=lispify(t.substring(o.length+2),restOfExp.next,new Lisp({op:r[0]+"$",a:lispify(o,expectTypes[n].next)}))}),setLispType(["incrementerAfter"],(e,t,r,n,s)=>{s.lispTree=lispify(t.substring(r[0].length),expectTypes[n].next,new Lisp({op:"$"+r[0],a:s.lispTree}))}),setLispType(["assign","assignModify"],(e,t,r,n,s)=>{s.lispTree=new Lisp({op:r[0],a:s.lispTree,b:lispify(t.substring(r[0].length),expectTypes[n].next)})}),setLispType(["split"],(e,t,r,n,s)=>{let o=restOfExp(t.substring(r[0].length),[expectTypes.splitter.types.split,expectTypes.if.types.if,expectTypes.if.types.else]);s.lispTree=new Lisp({op:r[0],a:s.lispTree,b:lispify(o,expectTypes[n].next)}),s.lispTree=lispify(t.substring(o.length+r[0].length),restOfExp.next,s.lispTree)}),setLispType(["if"],(e,t,r,n,s)=>{let o=!1,i="",p=1;for(;!o&&i.length<t.length;)i+=restOfExp(t.substring(i.length+1),[expectTypes.if.types.if,expectTypes.if.types.else]),"?"===t[i.length+1]?p++:p--,p?i+=t[i.length+1]:o=!0;s.lispTree=new Lisp({op:"?",a:s.lispTree,b:new Lisp({op:":",a:lispify(i),b:lispify(t.substring(r[0].length+i.length+1))})})}),setLispType(["dot","prop"],(e,t,r,n,s)=>{let o=r[0],i=r[0].length;if("."===r[0]){let e=t.substring(r[0].length).match(expectTypes.prop.types.prop);if(!e.length)throw Error("Hanging  dot:"+t);o=e[0],i=o.length+r[0].length}s.lispTree=lispify(t.substring(i),expectTypes[n].next,new Lisp({op:"prop",a:s.lispTree,b:o}))}),setLispType(["spreadArray","spreadObject"],(e,t,r,n,s)=>{s.lispTree=new Lisp({op:e,b:lispify(t.substring(r[0].length),expectTypes[n].next)})}),setLispType(["number","boolean","null"],(e,t,r,n,s)=>{s.lispTree=lispify(t.substring(r[0].length),expectTypes[n].next,JSON.parse(r[0]))}),setLispType(["und"],(e,t,r,n,s)=>{s.lispTree=lispify(t.substring(r[0].length),expectTypes[n].next,void 0)}),setLispType(["NaN"],(e,t,r,n,s)=>{s.lispTree=lispify(t.substring(r[0].length),expectTypes[n].next,NaN)}),setLispType(["Infinity"],(e,t,r,n,s)=>{s.lispTree=lispify(t.substring(r[0].length),expectTypes[n].next,1/0)}),setLispType(["string","literal"],(e,t,r,n,s)=>{s.lispTree=lispify(t.substring(r[0].length),expectTypes[n].next,new Lisp({op:e,b:parseInt(JSON.parse(r[1]),10)}))}),setLispType(["return"],(e,t,r,n,s)=>{s.lispTree=new Lisp({op:"return",b:lispify(t.substring(r[0].length),expectTypes[n].next)})}),setLispType(["initialize"],(e,t,r,n,s)=>{const o=r[0].split(/ /g);t.length===r[0].length?s.lispTree=lispify(t.substring(r[0].length),expectTypes[n].next,new Lisp({op:o[1],a:o[2]})):s.lispTree=new Lisp({op:o[1],a:o[2],b:lispify(t.substring(r[0].length+1),expectTypes[n].next)})}),setLispType(["arrowFunc"],(e,t,r,n,s)=>{let o=r[1]?r[1].split(","):[];if(r[3]){if("("!==r[0][0])throw new SyntaxError("Unstarted inline function brackets: "+r[0])}else o.length&&(o=[o.pop()]);const i=(r[4]?"":" return ")+restOfExp(t.substring(r[0].length),r[4]?[/^}/]:[/^[,;\)\}\]]/]);s.lispTree=lispify(t.substring(r[0].length+i.length+1),expectTypes[n].next,new Lisp({op:"arrowFunc",a:o,b:Sandbox.parse(i,null).tree}))});let optimizeTypes={},setOptimizeType=(e,t)=>{e.forEach(e=>{optimizeTypes[e]=t})};function optimize(e,t,r){if(!(e instanceof Lisp)){if(Array.isArray(e)){for(let n=0;n<e.length;n++)e[n]=optimize(e[n],t,r);return e}return e}return e.a=optimize(e.a,t,r),e.b=optimize(e.b,t,r),e.a instanceof Lisp||e.b instanceof Lisp||!optimizeTypes[e.op]?e:optimizeTypes[e.op](e,t,r)}setOptimizeType([">","<",">=","<=","==","===","!=","!==","&&","||","&","|","+","-","/","*","**","%","$+","$-","!","~","group"],e=>ops.get(e.op)(e.a,e.b)),setOptimizeType(["createArray"],e=>e.b.find(e=>e instanceof Lisp)?e:ops.get(e.op)(e.a,e.b)),setOptimizeType(["prop"],e=>"number"==typeof e.b&&e.b%1==0?e.a[e.b]:e);export default class Sandbox{constructor(globals=Sandbox.SAFE_GLOBALS,prototypeWhitelist=Sandbox.SAFE_PROTOTYPES,options={audit:!1}){const sandboxGlobal=new SandboxGlobal(globals);this.context={sandbox:this,globals:globals,prototypeWhitelist:prototypeWhitelist,globalsWhitelist:new Set(Object.values(globals)),options:options,globalScope:new Scope(null,globals,sandboxGlobal),sandboxGlobal:sandboxGlobal,replacements:new Map,auditReport:{prototypeAccess:{},globalsAccess:new Set}};const func=sandboxFunction(this.context);this.context.replacements.set(Function,func),this.context.replacements.set(eval,sandboxedEval(func)),this.context.replacements.set(setTimeout,sandboxedSetTimeout(func)),this.context.replacements.set(setInterval,sandboxedSetInterval(func))}static get SAFE_GLOBALS(){return{Function:Function,console:console,isFinite:isFinite,isNaN:isNaN,parseFloat:parseFloat,parseInt:parseInt,decodeURI:decodeURI,decodeURIComponent:decodeURIComponent,encodeURI:encodeURI,encodeURIComponent:encodeURIComponent,escape:escape,unescape:unescape,Boolean:Boolean,Number:Number,String:String,Object:Object,Array:Array,Symbol:Symbol,Error:Error,EvalError:EvalError,RangeError:RangeError,ReferenceError:ReferenceError,SyntaxError:SyntaxError,TypeError:TypeError,URIError:URIError,Int8Array:Int8Array,Uint8Array:Uint8Array,Uint8ClampedArray:Uint8ClampedArray,Int16Array:Int16Array,Uint16Array:Uint16Array,Int32Array:Int32Array,Uint32Array:Uint32Array,Float32Array:Float32Array,Float64Array:Float64Array,Map:Map,Set:Set,WeakMap:WeakMap,WeakSet:WeakSet,Promise:Promise,Intl:Intl,JSON:JSON,Math:Math}}static get SAFE_PROTOTYPES(){let e=[SandboxGlobal,Function,Boolean,Number,String,Date,RegExp,Error,Array,Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array,Map,Set,WeakMap,WeakSet,Promise],t=new Map;return e.forEach(e=>{t.set(e,new Set)}),t.set(Object,new Set(["entries","fromEntries","getOwnPropertyNames","is","keys","hasOwnProperty","isPrototypeOf","propertyIsEnumerable","toLocaleString","toString","valueOf","values"])),t}static audit(e,t=[]){let r=new Map;return new Sandbox(globalThis,r,{audit:!0}).executeTree(Sandbox.parse(e),t)}static parse(e,t=[],r=[]){if("string"!=typeof e)throw new ParseError(`Cannot parse ${e}`,e);let n,s=e,o="",i=!1,p=[],a=[];if(t){let e=0;for(let l=0;l<s.length;l++){let c=s[l];if(i)if("$"===c&&"`"===n)e--,c="$$";else if("u"===c){let e,t=/^[a-fA-F\d]{2,4}/.exec(s.substring(l+1));e=t?Array.from(t):Array.from(/^{[a-fA-F\d]+}/.exec(s.substring(l+1))||[""]),c=JSON.parse(`"\\u${e[0]}"`),s=s.substring(0,l-1)+c+s.substring(l+(1+e[0].length)),l-=1}else"`"!=c&&(c=JSON.parse(`"\\${c}"`));else"$"===c&&"`"===n&&"{"!==s[l+1]&&(e--,c="$$");if("`"===n&&"$"===c&&"{"===s[l+1]){let t=restOfExp(s.substring(l+2),[/^}/]);a.push(t),e+=t.length+3,o+=`\${${a.length-1}}`,l+=t.length+2}else if(n||"'"!==c&&'"'!==c&&"`"!==c||i)if(n!==c||i)n&&(i||"\\"!==c)&&(e+=i?1+c.length:c.length,o+=c);else{let i;"`"===n?(r.push({op:"literal",a:o,b:a}),p.push(a),s=s.substring(0,l-e-1)+`\`${r.length-1}\``+s.substring(l+1),i=(r.length-1).toString().length):(t.push(o),s=s.substring(0,l-o.length-1)+`"${t.length-1}"`+s.substring(l+1),i=(t.length-1).toString().length),n=null,l-=o.length-i,o=""}else a=[],e=0,n=c;i=n&&!i&&"\\"===c}s=s.replace(/([^\w_$]|^)((var|let|const|typeof|return|instanceof|in)(?=[^\w_$]|$))/g,(e,t,r)=>{if(r.length!==r.trim().length)throw new Error(r);return`${t}#${r}#`}).replace(/\s/g,"").replace(/#/g," "),p.forEach(e=>{const n=e.map(e=>this.parse(e,t,r).tree[0]);e.length=0,e.push(...n)})}let l,c=[],f=0;for(;l=restOfExp(s.substring(f),[/^;/]);)c.push(l),f+=l.length+1;return c=c.filter(Boolean),{tree:c.filter(e=>e.length).map(e=>{try{return lispify(e)}catch(t){throw new ParseError(t.message,e)}}).map(e=>optimize(e,t,r)),strings:t,literals:r}}executeTree(e,t=[]){const r=e.tree,n={...this.context,strings:e.strings,literals:e.literals};let s,o=this.context.globalScope;for(;s=t.shift();)"object"==typeof s&&(o=s instanceof Scope?s:new Scope(o,s));let i=Object.assign({},n);n.options.audit&&(i.auditReport={globalsAccess:new Set,prototypeAccess:{}});let p,a=!1;if(!(r instanceof Array))throw new SyntaxError("Bad execution tree");return r.map(e=>{if(!a){let t;try{t=exec(e,o,i)}catch(e){throw new e.constructor(e.message)}e instanceof Lisp&&"return"===e.op&&(a=!0,p=t)}return null}),p=p instanceof Prop?p.context[p.prop]:p,{auditReport:i.auditReport,result:p}}compile(e){const t=Sandbox.parse(e);return(...e)=>this.executeTree(t,e).result}}