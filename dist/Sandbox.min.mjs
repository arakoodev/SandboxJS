class Prop{constructor(e,t,r=!1,s=!1,n=!1){this.context=e,this.prop=t,this.isConst=r,this.isGlobal=s,this.isVariable=n}}class Lisp{constructor(e){this.op=e.op,this.a=e.a,this.b=e.b}}class If{constructor(e,t){this.t=e,this.f=t}}class KeyVal{constructor(e,t){this.key=e,this.val=t}}class ObjectFunc{constructor(e,t,r){this.key=e,this.args=t,this.tree=r}}class SpreadObject{constructor(e){this.item=e}}class SpreadArray{constructor(e){this.item=e}}var VarType;!function(e){e.let="let",e.const="const",e.var="var"}(VarType||(VarType={}));class Scope{constructor(e,t={},r){this.const=new Set,this.let=new Set,this.parent=e,this.allVars=t,this.var=new Set(Object.keys(t)),this.globals=e?new Set:new Set(Object.keys(t)),this.functionThis=r||!e,r&&this.declare("this",VarType.var,r)}get(e,t=!1){if(!this.parent||!t||this.functionThis){if(this.globals.has(e))return new Prop(this.functionThis,e,!1,!0,!0);if(this.const.has(e))return new Prop(this.allVars,e,!0,this.globals.has(e),!0);if(this.var.has(e))return new Prop(this.allVars,e,!1,this.globals.has(e),!0);if(this.let.has(e))return new Prop(this.allVars,e,!1,this.globals.has(e),!0);if(!this.parent)return new Prop(void 0,e)}return this.parent.get(e,t)}set(e,t){if("this"===e)throw new SyntaxError('"this" cannot be a variable');let r=this.get(e);if(void 0===r.context)throw new ReferenceError(`Variable '${e}' was not declared.`);if(r.isConst)throw new TypeError(`Cannot assign to const variable '${e}'`);if(r.isGlobal)throw new SandboxError(`Cannot override global variable '${e}'`);return r.context[r]=t,r}declare(e,t=null,r,s=!1){if("var"===t&&!this.functionThis&&this.parent)return this.parent.declare(e,t,r,s);if(this.var.has(e)&&this.let.has(e)&&this.const.has(e)&&this.globals.has(e))throw Error(`Variable '${e}' already declared`);return s&&this.globals.add(e),this[t].add(e),this.allVars[e]=r,new Prop(this.allVars,e,this.const.has(e),s)}}class ParseError extends Error{constructor(e,t){super(e),this.code=t}}class SandboxError extends Error{}class SandboxGlobal{constructor(e){if(e===globalThis)return globalThis;for(let t in e)this[t]=e[t]}}function sandboxFunction(e){return function SandboxFunction(...t){let r=t.pop(),s=Sandbox.parse(r);return function(...r){const n={};for(let e of t)n[e]=r.shift();const o=e.sandbox.executeTree(s);if(e.options.audit){for(let t in o.auditReport.globalsAccess){let r=o.auditReport.globalsAccess[t];e.auditReport.globalsAccess[t]=e.auditReport.globalsAccess[t]||new Set,r.forEach(r=>{e.auditReport.globalsAccess[t].add(r)})}for(let t in o.auditReport.prototypeAccess){let r=o.auditReport.prototypeAccess[t];e.auditReport.prototypeAccess[t]=e.auditReport.prototypeAccess[t]||new Set,r.forEach(r=>{e.auditReport.prototypeAccess[t].add(r)})}}return o.result}}}function sandboxedEval(e){return function(t){return e(t)()}}function sandboxedSetTimeout(e){return function(t,...r){return"string"!=typeof t?setTimeout(t,...r):setTimeout(e(t),r[0])}}function sandboxedSetInterval(e){return function(t,...r){return"string"!=typeof t?setInterval(t,...r):setTimeout(e(t),r[0])}}let expectTypes={op:{types:{op:/^(\/|\*\*(?!\=)|\*(?!\=)|\%(?!\=))/},next:["value","prop","exp","modifier","incrementerBefore"]},splitter:{types:{split:/^(&&|&|\|\||\||<=|>=|<|>|!==|!=|===|==| instanceof | in |\+(?!\+)|\-(?!\-))(?!\=)/},next:["value","prop","exp","modifier","incrementerBefore"]},if:{types:{if:/^\?/,else:/^:/},next:["expEnd"]},assignment:{types:{assignModify:/^(\-=|\+=|\/=|\*\*=|\*=|%=|\^=|\&=|\|=)/,assign:/^(=)/},next:["value","function","prop","exp","modifier","incrementerBefore"]},incrementerBefore:{types:{incrementerBefore:/^(\+\+|\-\-)/},next:["prop"]},incrementerAfter:{types:{incrementerAfter:/^(\+\+|\-\-)/},next:["splitter","op","expEnd"]},expEdge:{types:{arrayProp:/^[\[]/,call:/^[\(]/},next:["splitter","op","expEdge","if","dot","expEnd"]},modifier:{types:{not:/^!/,inverse:/^~/,negative:/^\-(?!\-)/,positive:/^\+(?!\+)/,typeof:/^ typeof /,delete:/^ delete /},next:["exp","modifier","value","prop","incrementerBefore"]},exp:{types:{createObject:/^\{/,createArray:/^\[/,group:/^\(/},next:["splitter","op","expEdge","if","dot","expEnd"]},dot:{types:{dot:/^\.(?!\.)/},next:["splitter","incrementerAfter","assignment","op","expEdge","if","dot","expEnd"]},prop:{types:{prop:/^[a-zA-Z\$_][a-zA-Z\d\$_]*/},next:["splitter","incrementerAfter","assignment","op","expEdge","if","dot","expEnd"]},value:{types:{number:/^\-?\d+(\.\d+)?/,string:/^"(\d+)"/,literal:/^`(\d+)`/,boolean:/^(true|false)(?![\w$_])/,null:/^null(?![\w$_])/,und:/^undefined(?![\w$_])/,NaN:/^NaN(?![\w$_])/,Infinity:/^Infinity(?![\w$_])/},next:["splitter","op","if","dot","expEnd"]},function:{types:{arrowFunc:/^\(?(((\.\.\.)?[a-zA-Z\$_][a-zA-Z\d\$_]*,?)*)(\))?=>({)?/},next:["expEnd"]},initialize:{types:{initialize:/^ (var|let|const) [a-zA-Z\$_][a-zA-Z\d\$_]*/},next:["value","function","prop","exp","modifier","incrementerBefore","expEnd"]},spreadObject:{types:{spreadObject:/^\.\.\./},next:["value","exp","prop"]},spreadArray:{types:{spreadArray:/^\.\.\./},next:["value","exp","prop"]},expEnd:{types:{},next:[]},expStart:{types:{return:/^ return /},next:["value","function","prop","exp","modifier","incrementerBefore","expEnd"]}},closings={"(":")","[":"]","{":"}","'":"'",'"':'"',"`":"`"},closingsRegex={"(":/^\)/,"[":/^\]/,"{":/^\}/,"'":/^\'/,'"':/^\"/,"`":/^\`/};const okFirstChars=/^[\+\-~ !]/,restOfExp=(e,t,r)=>{let s=!0;t=t||[expectTypes.op.types.op,expectTypes.splitter.types.split,expectTypes.if.types.if,expectTypes.if.types.else];let n,o=!1,i=!1;for(n=0;n<e.length&&!i;n++){let p=e[n];if('"'===r||"'"===r||"`"===r){if("`"!==r||"$"!==p||"{"!==e[n+1]||o){if(p===r&&!o)return e.substring(0,n)}else{n+=restOfExp(e.substring(n+2),[closingsRegex["{"]]).length+2}o="\\"===p}else if(closings[p]){n+=restOfExp(e.substring(n+1),[closingsRegex[r]],p).length+1,s=!1}else if(r){if(p===closings[r])return e.substring(0,n)}else{let r=e.substring(n);for(let e of t)if(i=e.test(r),i)break;if(s&&(okFirstChars.test(r)?i=!1:s=!1),i)break}}return e.substring(0,n)};function assignCheck(e,t,r="assign"){if(void 0===e.context)throw new ReferenceError(`Cannot ${r} value to undefined.`);if("object"!=typeof e.context&&"function"!=typeof e.context)throw new SyntaxError(`Cannot ${r} value to a primitive.`);if(e.isConst)throw new TypeError(`Cannot set value to const variable '${e.prop}'`);if(e.isGlobal)throw new SandboxError(`Cannot ${r} property '${e.prop}' of a global object`);if("function"==typeof e.context[e.prop]&&!e.context.hasOwnProperty(e.prop))throw new SandboxError(`Override prototype property '${e.prop}' not allowed`);setTimeout(()=>{var r,s;null===(s=null===(r=t.setSubscriptions.get(e.context))||void 0===r?void 0:r.get(e.prop))||void 0===s||s.forEach(e=>e())})}restOfExp.next=["splitter","op","expEnd","if"];let ops2={prop:(e,t,r,s,n)=>{if(null===e)throw new TypeError(`Cannot get property ${t} of null`);const o=typeof e;if("undefined"===o){let e=n.get(t);if(void 0===e.context)throw new ReferenceError(t+" is not defined");if(e.context===s.sandboxGlobal){s.options.audit&&s.auditReport.globalsAccess.add(t);const e=s.evals.get(s.sandboxGlobal[t]);if(e)return e}return e.context&&e.context[t]===globalThis?s.globalScope.get("this"):(s.getSubscriptions.forEach(t=>t(e.context,e.prop)),e)}if("object"!==o)"number"===o?e=new Number(e):"string"===o?e=new String(e):"boolean"===o&&(e=new Boolean(e));else if(void 0===e.hasOwnProperty)return new Prop(void 0,t);const i="function"===o;let p=i||!(e.hasOwnProperty(t)||"number"==typeof t);if(s.options.audit&&p&&"string"==typeof t){let r=e.constructor.prototype;do{r.hasOwnProperty(t)&&(s.auditReport.prototypeAccess[r.constructor.name]||(s.auditReport.prototypeAccess[r.constructor.name]=new Set),s.auditReport.prototypeAccess[r.constructor.name].add(t))}while(r=Object.getPrototypeOf(r))}if(p)if(i){if(!["name","length","constructor"].includes(t)&&e.hasOwnProperty(t)){const r=s.prototypeWhitelist.get(e),n=s.prototypeReplacements.get(e);if(n)return new Prop(n(e,!0),t);if(!r||r.size&&!r.has(t))throw new SandboxError(`Static method or property access not permitted: ${e.name}.${t}`)}}else if("constructor"!==t){let r=e.constructor.prototype;do{if(r.hasOwnProperty(t)){const n=s.prototypeWhitelist.get(r.constructor),o=s.prototypeReplacements.get(r.constuctor);if(o)return new Prop(o(e,!1),t);if(n&&(!n.size||n.has(t)))break;throw new SandboxError(`Method or property access not permitted: ${r.constructor.name}.${t}`)}}while(r=Object.getPrototypeOf(r))}const a=s.evals.get(e[t]);if(a)return a;if(e[t]===globalThis)return s.globalScope.get("this");let l=r.isGlobal||i&&"sandboxArrowFunction"!==e.name||s.globalsWhitelist.has(e);return l||s.getSubscriptions.forEach(r=>r(e,t)),new Prop(e,t,!1,l)},call:(e,t,r,s,n)=>{if(s.options.forbidMethodCalls)throw new SandboxError("Method calls are not allowed");if("function"!=typeof e)throw new TypeError(r.prop+" is not a function");const o=t.map(e=>e instanceof SpreadArray?[...e.item]:[e]).flat();return"function"==typeof r?r(...o.map(e=>exec(e,n,s))):r.context[r.prop](...o.map(e=>exec(e,n,s)))},createObject:(e,t,r,s,n)=>{let o={};for(let e of t)if(e instanceof SpreadObject)o={...o,...e.item};else if(e instanceof ObjectFunc){let t=e;o[t.key]=function(...e){const r={};return t.args.forEach((t,s)=>{r[t]=e[s]}),s.sandbox.executeTree({tree:t.tree,strings:s.strings,literals:s.literals},[new Scope(n,r,this)]).result}}else o[e.key]=e.val;return o},keyVal:(e,t)=>new KeyVal(e,t),createArray:(e,t,r,s,n)=>t.map(e=>e instanceof SpreadArray?[...e.item]:[e]).flat().map(e=>exec(e,n,s)),group:(e,t)=>t,string:(e,t,r,s)=>s.strings[t],literal:(e,t,r,s,n)=>s.literals[t].a.replace(/(\$\$)*(\$)?\${(\d+)}/g,(e,r,o,i)=>{if(o)return e;let p=exec(s.literals[t].b[parseInt(i,10)],n,s);return p=p instanceof Prop?p.context[p.prop]:p,(r||"")+(""+p).replace(/\$/g,"$$")}).replace(/\$\$/g,"$"),spreadArray:(e,t,r,s,n)=>new SpreadArray(exec(t,n,s)),spreadObject:(e,t,r,s,n)=>new SpreadObject(exec(t,n,s)),"!":(e,t)=>!t,"~":(e,t)=>~t,"++$":(e,t,r,s)=>(assignCheck(r,s),++r.context[r.prop]),"$++":(e,t,r,s)=>(assignCheck(r,s),r.context[r.prop]++),"--$":(e,t,r,s)=>(assignCheck(r,s),--r.context[r.prop]),"$--":(e,t,r,s)=>(assignCheck(r,s),r.context[r.prop]--),"=":(e,t,r,s)=>(assignCheck(r,s),r.context[r.prop]=t,new Prop(r.context,r.prop,!1,r.isGlobal)),"+=":(e,t,r,s)=>(assignCheck(r,s),r.context[r.prop]+=t),"-=":(e,t,r,s)=>(assignCheck(r,s),r.context[r.prop]-=t),"/=":(e,t,r,s)=>(assignCheck(r,s),r.context[r.prop]/=t),"*=":(e,t,r,s)=>(assignCheck(r,s),r.context[r.prop]*=t),"**=":(e,t,r,s)=>(assignCheck(r,s),r.context[r.prop]**=t),"%=":(e,t,r,s)=>(assignCheck(r,s),r.context[r.prop]%=t),"^=":(e,t,r,s)=>(assignCheck(r,s),r.context[r.prop]^=t),"&=":(e,t,r,s)=>(assignCheck(r,s),r.context[r.prop]&=t),"|=":(e,t,r,s)=>(assignCheck(r,s),r.context[r.prop]|=t),"?":(e,t)=>{if(!(t instanceof If))throw new SyntaxError("Invalid inline if");return e?t.t:t.f},">":(e,t)=>e>t,"<":(e,t)=>e<t,">=":(e,t)=>e>=t,"<=":(e,t)=>e<=t,"==":(e,t)=>e==t,"===":(e,t)=>e===t,"!=":(e,t)=>e!=t,"!==":(e,t)=>e!==t,"&&":(e,t)=>e&&t,"||":(e,t)=>e||t,"&":(e,t)=>e&t,"|":(e,t)=>e|t,":":(e,t)=>new If(e,t),"+":(e,t)=>e+t,"-":(e,t)=>e-t,"$+":(e,t)=>+t,"$-":(e,t)=>-t,"/":(e,t)=>e/t,"*":(e,t)=>e*t,"%":(e,t)=>e%t," typeof ":(e,t)=>typeof t," instanceof ":(e,t)=>e instanceof t," in ":(e,t)=>e in t," delete ":(e,t,r,s,n,o)=>void 0===o.context||(assignCheck(o,s,"delete"),!o.isVariable&&delete o.context[o.prop]),return:(e,t)=>t,var:(e,t,r,s,n,o)=>n.declare(e,VarType.var,exec(t,n,s)),let:(e,t,r,s,n,o)=>n.declare(e,VarType.let,exec(t,n,s),o&&o.isGlobal),const:(e,t,r,s,n,o)=>n.declare(e,VarType.const,exec(t,n,s)),arrowFunc:(e,t,r,s,n)=>(...r)=>{const o={};return e.forEach((e,t)=>{e.startsWith("...")?o[e.substring(3)]=r.slice(t):o[e]=r[t]}),s.sandbox.executeTree({tree:t,strings:s.strings,literals:s.literals},[new Scope(n,o)]).result}},ops=new Map;for(let e in ops2)ops.set(e,ops2[e]);let lispTypes=new Map;const setLispType=(e,t)=>{e.forEach(e=>{lispTypes.set(e,t)})},closingsCreate={createArray:/^\]/,createObject:/^\}/,group:/^\)/,arrayProp:/^\]/,call:/^\)/};setLispType(["createArray","createObject","group","arrayProp","call"],(e,t,r,s,n)=>{let o="",i=[],p=!1,a=1;for(;a<t.length&&!p;)o=restOfExp(t.substring(a),[closingsCreate[e],/^,/]),a+=o.length,o&&i.push(o),","!==t[a]?p=!0:a++;const l=["value","function","prop","exp","modifier","incrementerBefore"];let c,f;const u=/^([a-zA-Z\$_][a-zA-Z\d\$_]*)\((([a-zA-Z\$_][a-zA-Z\d\$_]*,?)*)\)?{/;switch(e){case"group":case"arrayProp":c=lispify(i.pop());break;case"call":case"createArray":c=i.map(e=>lispify(e,[...l,"spreadArray"]));break;case"createObject":c=i.map(e=>{let t,r;if(f=u.exec(e),f){let t=f[2]?f[2].split(","):[];const r=restOfExp(e.substring(f.index+f[0].length),[/^}/]);return new ObjectFunc(f[1],t,Sandbox.parse(r,null).tree)}{let s=restOfExp(e,[/^:/]);if(r=lispify(s,[...l,"spreadObject"]),r instanceof Lisp&&"prop"===r.op&&(r=r.b),s.length===e.length)return r;t=lispify(e.substring(s.length+1))}return new Lisp({op:"keyVal",a:r,b:t})})}e="arrayProp"===e?"prop":e,n.lispTree=lispify(t.substring(a+1),expectTypes[s].next,new Lisp({op:e,a:n.lispTree,b:c}))}),setLispType(["inverse","not","negative","positive","typeof","delete","op"],(e,t,r,s,n)=>{let o=restOfExp(t.substring(r[0].length));n.lispTree=lispify(t.substring(o.length+r[0].length),restOfExp.next,new Lisp({op:["positive","negative"].includes(e)?"$"+r[0]:r[0],a:n.lispTree,b:lispify(o,expectTypes[s].next)}))}),setLispType(["incrementerBefore"],(e,t,r,s,n)=>{let o=restOfExp(t.substring(2));n.lispTree=lispify(t.substring(o.length+2),restOfExp.next,new Lisp({op:r[0]+"$",a:lispify(o,expectTypes[s].next)}))}),setLispType(["incrementerAfter"],(e,t,r,s,n)=>{n.lispTree=lispify(t.substring(r[0].length),expectTypes[s].next,new Lisp({op:"$"+r[0],a:n.lispTree}))}),setLispType(["assign","assignModify"],(e,t,r,s,n)=>{n.lispTree=new Lisp({op:r[0],a:n.lispTree,b:lispify(t.substring(r[0].length),expectTypes[s].next)})}),setLispType(["split"],(e,t,r,s,n)=>{let o=restOfExp(t.substring(r[0].length),[expectTypes.splitter.types.split,expectTypes.if.types.if,expectTypes.if.types.else]);n.lispTree=lispify(t.substring(o.length+r[0].length),restOfExp.next,new Lisp({op:r[0],a:n.lispTree,b:lispify(o,expectTypes[s].next)}))}),setLispType(["if"],(e,t,r,s,n)=>{let o=!1,i="",p=1;for(;!o&&i.length<t.length;)i+=restOfExp(t.substring(i.length+1),[expectTypes.if.types.if,expectTypes.if.types.else]),"?"===t[i.length+1]?p++:p--,p?i+=t[i.length+1]:o=!0;n.lispTree=new Lisp({op:"?",a:n.lispTree,b:new Lisp({op:":",a:lispify(i),b:lispify(t.substring(r[0].length+i.length+1))})})}),setLispType(["dot","prop"],(e,t,r,s,n)=>{let o=r[0],i=r[0].length;if("."===r[0]){let e=t.substring(r[0].length).match(expectTypes.prop.types.prop);if(!e.length)throw Error("Hanging  dot:"+t);o=e[0],i=o.length+r[0].length}n.lispTree=lispify(t.substring(i),expectTypes[s].next,new Lisp({op:"prop",a:n.lispTree,b:o}))}),setLispType(["spreadArray","spreadObject","return"],(e,t,r,s,n)=>{n.lispTree=new Lisp({op:e,b:lispify(t.substring(r[0].length),expectTypes[s].next)})}),setLispType(["number","boolean","null"],(e,t,r,s,n)=>{n.lispTree=lispify(t.substring(r[0].length),expectTypes[s].next,JSON.parse(r[0]))});const constants={NaN:NaN,Infinity:1/0};let lastType;function lispify(e,t,r){if(t=t||["initialize","expStart","value","function","prop","exp","modifier","incrementerBefore","expEnd"],void 0===e)return r;if(!e.length&&!t.includes("expEnd"))throw new SyntaxError("Unexpected end of expression");let s,n={lispTree:r};for(let r of t)if("expEnd"!==r){for(let t in expectTypes[r].types)if("expEnd"!==t&&(s=expectTypes[r].types[t].exec(e))){lastType=t,lispTypes.get(t)(t,e,s,r,n);break}if(s)break}if(!s&&e.length)throw Error(`Unexpected token (${lastType}): ${e}`);return n.lispTree}function exec(e,t,r){if(e instanceof Prop)return e.context[e.prop];if(Array.isArray(e))return e.map(e=>exec(e,t,r));if(!(e instanceof Lisp))return e;if("arrowFunc"===e.op)return ops.get(e.op)(e.a,e.b,void 0,r,t);let s=exec(e.a,t,r),n=s instanceof Prop?s.context?s.context[s.prop]:void 0:s,o=exec(e.b,t,r),i=o instanceof Prop?o.context?o.context[o.prop]:void 0:o;if(ops.has(e.op)){return ops.get(e.op)(n,i,s,r,t,o)}throw new SyntaxError("Unknown operator: "+e.op)}setLispType(["und","NaN","Infinity"],(e,t,r,s,n)=>{n.lispTree=lispify(t.substring(r[0].length),expectTypes[s].next,constants[e])}),setLispType(["string","literal"],(e,t,r,s,n)=>{n.lispTree=lispify(t.substring(r[0].length),expectTypes[s].next,new Lisp({op:e,b:parseInt(JSON.parse(r[1]),10)}))}),setLispType(["initialize"],(e,t,r,s,n)=>{const o=r[0].split(/ /g);t.length===r[0].length?n.lispTree=lispify(t.substring(r[0].length),expectTypes[s].next,new Lisp({op:o[1],a:o[2]})):n.lispTree=new Lisp({op:o[1],a:o[2],b:lispify(t.substring(r[0].length+1),expectTypes[s].next)})}),setLispType(["arrowFunc"],(e,t,r,s,n)=>{let o=r[1]?r[1].split(","):[];if(r[4]){if("("!==r[0][0])throw new SyntaxError("Unstarted inline function brackets: "+r[0])}else o.length&&(o=[o.pop()]);let i=!1;o.forEach(e=>{if(i)throw new SyntaxError("Rest parameter must be last formal parameter");e.startsWith("...")&&(i=!0)});const p=(r[5]?"":" return ")+restOfExp(t.substring(r[0].length),r[5]?[/^}/]:[/^[,;\)\}\]]/]);n.lispTree=lispify(t.substring(r[0].length+p.length+1),expectTypes[s].next,new Lisp({op:"arrowFunc",a:o,b:Sandbox.parse(p,null).tree}))});export default class Sandbox{constructor(globals=Sandbox.SAFE_GLOBALS,prototypeWhitelist=Sandbox.SAFE_PROTOTYPES,prototypeReplacements=new Map,options={audit:!1}){const sandboxGlobal=new SandboxGlobal(globals);this.context={sandbox:this,globals:globals,prototypeWhitelist:prototypeWhitelist,prototypeReplacements:prototypeReplacements,globalsWhitelist:new Set(Object.values(globals)),options:options,globalScope:new Scope(null,globals,sandboxGlobal),sandboxGlobal:sandboxGlobal,evals:new Map,getSubscriptions:new Set,setSubscriptions:new WeakMap};const func=sandboxFunction(this.context);this.context.evals.set(Function,func),this.context.evals.set(eval,sandboxedEval(func)),this.context.evals.set(setTimeout,sandboxedSetTimeout(func)),this.context.evals.set(setInterval,sandboxedSetInterval(func))}static get SAFE_GLOBALS(){return{Function:Function,console:console,isFinite:isFinite,isNaN:isNaN,parseFloat:parseFloat,parseInt:parseInt,decodeURI:decodeURI,decodeURIComponent:decodeURIComponent,encodeURI:encodeURI,encodeURIComponent:encodeURIComponent,escape:escape,unescape:unescape,Boolean:Boolean,Number:Number,String:String,Object:Object,Array:Array,Symbol:Symbol,Error:Error,EvalError:EvalError,RangeError:RangeError,ReferenceError:ReferenceError,SyntaxError:SyntaxError,TypeError:TypeError,URIError:URIError,Int8Array:Int8Array,Uint8Array:Uint8Array,Uint8ClampedArray:Uint8ClampedArray,Int16Array:Int16Array,Uint16Array:Uint16Array,Int32Array:Int32Array,Uint32Array:Uint32Array,Float32Array:Float32Array,Float64Array:Float64Array,Map:Map,Set:Set,WeakMap:WeakMap,WeakSet:WeakSet,Promise:Promise,Intl:Intl,JSON:JSON,Math:Math}}static get SAFE_PROTOTYPES(){let e=[SandboxGlobal,Function,Boolean,Number,String,Date,RegExp,Error,Array,Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array,Map,Set,WeakMap,WeakSet,Promise],t=new Map;return e.forEach(e=>{t.set(e,new Set)}),t.set(Object,new Set(["entries","fromEntries","getOwnPropertyNames","is","keys","hasOwnProperty","isPrototypeOf","propertyIsEnumerable","toLocaleString","toString","valueOf","values"])),t}subscribeGet(e){return this.context.getSubscriptions.add(e),{unsubscribe:()=>this.context.getSubscriptions.delete(e)}}subscribeSet(e,t,r){const s=this.context.setSubscriptions.get(e)||new Map;this.context.setSubscriptions.set(e,s);const n=s.get(t)||new Set;return s.set(t,n),n.add(r),{unsubscribe:()=>n.delete(r)}}static audit(e,t=[]){return new Sandbox(globalThis,new Map,new Map,{audit:!0}).executeTree(Sandbox.parse(e),t)}static parse(e,t=[],r=[]){if("string"!=typeof e)throw new ParseError("Cannot parse "+e,e);let s,n=e,o="",i=!1,p=[],a=[];if(t){let e=0;for(let l=0;l<n.length;l++){let c=n[l];if(i)if("$"===c&&"`"===s)e--,c="$$";else if("u"===c){let e,t=/^[a-fA-F\d]{2,4}/.exec(n.substring(l+1));e=t?Array.from(t):Array.from(/^{[a-fA-F\d]+}/.exec(n.substring(l+1))||[""]),c=JSON.parse(`"\\u${e[0]}"`),n=n.substring(0,l-1)+c+n.substring(l+(1+e[0].length)),l-=1}else"`"!=c&&(c=JSON.parse(`"\\${c}"`));else"$"===c&&"`"===s&&"{"!==n[l+1]&&(e--,c="$$");if("`"===s&&"$"===c&&"{"===n[l+1]){let t=restOfExp(n.substring(l+2),[/^}/]);a.push(t),e+=t.length+3,o+=`\${${a.length-1}}`,l+=t.length+2}else if(s||"'"!==c&&'"'!==c&&"`"!==c||i)if(s!==c||i)s&&(i||"\\"!==c)&&(e+=i?1+c.length:c.length,o+=c);else{let i;"`"===s?(r.push({op:"literal",a:o,b:a}),p.push(a),n=n.substring(0,l-e-1)+`\`${r.length-1}\``+n.substring(l+1),i=(r.length-1).toString().length):(t.push(o),n=n.substring(0,l-o.length-1)+`"${t.length-1}"`+n.substring(l+1),i=(t.length-1).toString().length),s=null,l-=o.length-i,o=""}else a=[],e=0,s=c;i=s&&!i&&"\\"===c}n=n.replace(/([^\w_$]|^)((var|let|const|typeof|return|instanceof|in|delete)(?=[^\w_$]|$))/g,(e,t,r)=>{if(r.length!==r.trim().length)throw new Error(r);return`${t}#${r}#`}).replace(/\s/g,"").replace(/#/g," "),p.forEach(e=>{const s=e.map(e=>this.parse(e,t,r).tree[0]);e.length=0,e.push(...s)})}let l,c=[],f=0;for(;l=restOfExp(n.substring(f),[/^;/]);)c.push(l),f+=l.length+1;c=c.filter(Boolean);return{tree:c.filter(e=>e.length).map(e=>{let t,r=[],s=0;for(;t=restOfExp(e.substring(s),[/^,/]);)r.push(t),s+=t.length+1;try{const e=r.map(e=>lispify(e));if(e.length>1&&e[0]instanceof Lisp&&"return"===e[0].op){const t=e.pop();return[e.shift().b,...e,new Lisp({op:"return",b:t})]}return e}catch(t){throw new ParseError(t.message+": "+e,e)}}).flat(),strings:t,literals:r}}executeTree(e,t=[]){const r=e.tree,s={...this.context,strings:e.strings,literals:e.literals};let n,o=this.context.globalScope;for(;n=t.shift();)"object"==typeof n&&(o=n instanceof Scope?n:new Scope(o,n));let i=Object.assign({},s);s.options.audit&&(i.auditReport={globalsAccess:new Set,prototypeAccess:{}});let p,a=!1;if(!(r instanceof Array))throw new SyntaxError("Bad execution tree");return r.map(e=>{if(!a){let t;try{t=exec(e,o,i)}catch(e){throw new e.constructor(e.message)}e instanceof Lisp&&"return"===e.op&&(a=!0,p=t)}return null}),p=p instanceof Prop?p.context[p.prop]:p,{auditReport:i.auditReport,result:p}}compile(e){const t=Sandbox.parse(e);return(...e)=>this.executeTree(t,e).result}}