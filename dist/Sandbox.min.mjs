export class ExecReturn{constructor(e,t,r,n=!1,s=!1){this.auditReport=e,this.result=t,this.returned=r,this.breakLoop=n,this.continueLoop=s}}class Prop{constructor(e,t,r=!1,n=!1,s=!1){this.context=e,this.prop=t,this.isConst=r,this.isGlobal=n,this.isVariable=s}}class Lisp{constructor(e){this.op=e.op,this.a=e.a,this.b=e.b}}class If{constructor(e,t){this.t=e,this.f=t}}class KeyVal{constructor(e,t){this.key=e,this.val=t}}class SpreadObject{constructor(e){this.item=e}}class SpreadArray{constructor(e){this.item=e}}const reservedWords=new Set(["instanceof","typeof","return","try","catch","if","else","in","of","var","let","const","for","delete","false","true","while","do","break","continue","new","function"]);var VarType;!function(e){e.let="let",e.const="const",e.var="var"}(VarType||(VarType={}));class Scope{constructor(e,t={},r){this.const=new Set,this.let=new Set;const n=void 0!==r||null===e;this.parent=e,this.allVars=t,this.let=n?this.let:new Set(Object.keys(t)),this.var=n?new Set(Object.keys(t)):this.var,this.globals=null===e?new Set(Object.keys(t)):new Set,this.functionThis=r,n&&void 0===this.allVars.this&&(this.var.add("this"),this.allVars.this=r)}get(e,t=!1){if(reservedWords.has(e))throw new SyntaxError("Unexepected token '"+e+"'");if(null===this.parent||!t||void 0!==this.functionThis){if(this.globals.has(e))return new Prop(this.functionThis,e,!1,!0,!0);if(e in this.allVars&&(!(e in{})||this.allVars.hasOwnProperty(e)))return new Prop(this.allVars,e,this.const.has(e),this.globals.has(e),!0);if(null===this.parent)return new Prop(void 0,e)}return this.parent.get(e,t)}set(e,t){if("this"===e)throw new SyntaxError('"this" cannot be assigned');if(reservedWords.has(e))throw new SyntaxError("Unexepected token '"+e+"'");let r=this.get(e);if(void 0===r.context)throw new ReferenceError(`Variable '${e}' was not declared.`);if(r.isConst)throw new TypeError(`Cannot assign to const variable '${e}'`);if(r.isGlobal)throw new SandboxError(`Cannot override global variable '${e}'`);return r.context[r]=t,r}declare(e,t=null,r,n=!1){if("this"===e)throw new SyntaxError('"this" cannot be declared');if(reservedWords.has(e))throw new SyntaxError("Unexepected token '"+e+"'");if("var"===t&&void 0===this.functionThis&&null!==this.parent)return this.parent.declare(e,t,r,n);if((!this[t].has(e)||"const"===t||this.globals.has(e))&&e in this.allVars)throw Error(`Identifier '${e}' has already been declared`);return n&&this.globals.add(e),this[t].add(e),this.allVars[e]=r,new Prop(this.allVars,e,this.const.has(e),n)}}class ParseError extends Error{constructor(e,t){super(e),this.code=t}}class SandboxError extends Error{}class SandboxGlobal{constructor(e){if(e===globalThis)return globalThis;for(let t in e)this[t]=e[t]}}function sandboxFunction(e){return function SandboxFunction(...t){let r=parse(t.pop()||"");return createFunction(t,r,e,void 0,"anonymous")}}const sandboxedFunctions=new WeakSet;function createFunction(e,t,r,n,s){let o=function(...o){const i={};e.forEach((e,t)=>{e.startsWith("...")?i[e.substring(3)]=o.slice(t):i[e]=o[t]});return r.sandbox.executeTree(t,void 0===n?[]:[new Scope(n,i,void 0===s?void 0:this)]).result};return void 0!==s&&Object.defineProperty(o,"name",{value:s,writable:!1}),sandboxedFunctions.add(o),o}function sandboxedEval(e){return function(t){return e(t)()}}function sandboxedSetTimeout(e){return function(t,...r){return"string"!=typeof t?setTimeout(t,...r):setTimeout(e(t),r[0])}}function sandboxedSetInterval(e){return function(t,...r){return"string"!=typeof t?setInterval(t,...r):setTimeout(e(t),r[0])}}let expectTypes={op:{types:{op:/^(\/|\*\*(?!\=)|\*(?!\=)|\%(?!\=))/},next:["void","value","prop","modifier","incrementerBefore"]},splitter:{types:{split:/^(&&|&|\|\||\||<=|>=|<|>|!==|!=|===|==|instanceof(?![\w$_])|in(?![\w$_])|\+(?!\+)|\-(?!\-))(?!\=)/},next:["void","value","prop","modifier","incrementerBefore"]},inlineIf:{types:{inlineIf:/^\?/,else:/^:/},next:["expEnd"]},assignment:{types:{assignModify:/^(\-=|\+=|\/=|\*\*=|\*=|%=|\^=|\&=|\|=)/,assign:/^(=)/},next:["void","value","prop","modifier","incrementerBefore"]},incrementerBefore:{types:{incrementerBefore:/^(\+\+|\-\-)/},next:["prop"]},incrementerAfter:{types:{incrementerAfter:/^(\+\+|\-\-)/},next:["splitter","op","expEnd"]},expEdge:{types:{call:/^[\(]/},next:["splitter","op","expEdge","inlineIf","dot","expEnd"]},modifier:{types:{not:/^!/,inverse:/^~/,negative:/^\-(?!\-)/,positive:/^\+(?!\+)/,typeof:/^typeof(?![\w$_])/,delete:/^delete(?![\w$_])/},next:["modifier","void","value","prop","incrementerBefore"]},dot:{types:{arrayProp:/^[\[]/,dot:/^\.(?!\.)/},next:["splitter","incrementerAfter","assignment","op","expEdge","inlineIf","dot","expEnd"]},prop:{types:{prop:/^[a-zA-Z\$_][a-zA-Z\d\$_]*/},next:["splitter","incrementerAfter","assignment","op","expEdge","inlineIf","dot","expEnd"]},value:{types:{createObject:/^\{/,createArray:/^\[/,number:/^\-?\d+(\.\d+)?/,string:/^"(\d+)"/,literal:/^`(\d+)`/,boolean:/^(true|false)(?![\w$_])/,null:/^null(?![\w$_])/,und:/^undefined(?![\w$_])/,arrowFunctionSingle:/^([a-zA-Z\$_][a-zA-Z\d\$_]*)\s*=>\s*({)?/,arrowFunction:/^\(\s*((\.\.\.)?\s*[a-zA-Z\$_][a-zA-Z\d\$_]*(\s*,\s*(\.\.\.)?\s*[a-zA-Z\$_][a-zA-Z\d\$_]*)*)?\s*\)\s*=>\s*({)?/,inlineFunction:/^function(\s*[a-zA-Z\$_][a-zA-Z\d\$_]*)?\s*\(\s*((\.\.\.)?\s*[a-zA-Z\$_][a-zA-Z\d\$_]*(\s*,\s*(\.\.\.)?\s*[a-zA-Z\$_][a-zA-Z\d\$_]*)*)?\s*\)\s*{/,group:/^\(/,NaN:/^NaN(?![\w$_])/,Infinity:/^Infinity(?![\w$_])/},next:["splitter","op","expEdge","inlineIf","dot","expEnd"]},void:{types:{void:/^void(?![\w$_])/},next:["splitter","op","expEdge","inlineIf","dot","expEnd"]},initialize:{types:{initialize:/^(var|let|const)\s+([a-zA-Z\$_][a-zA-Z\d\$_]*)\s*(=)?/},next:["void","value","modifier","prop","incrementerBefore","expEnd"]},spreadObject:{types:{spreadObject:/^\.\.\./},next:["void","value","prop"]},spreadArray:{types:{spreadArray:/^\.\.\./},next:["void","value","prop"]},expEnd:{types:{},next:[]},expStart:{types:{return:/^return(?![\w$_])/,for:/^for\s*\(/,do:/^do\s*\{/,while:/^while\s*\(/,loopAction:/^(break|continue)(?![\w$_])/,if:/^if\s*\(/,try:/^try\s*{/,function:/^function(\s*[a-zA-Z\$_][a-zA-Z\d\$_]*)\s*\(\s*((\.\.\.)?\s*[a-zA-Z\$_][a-zA-Z\d\$_]*(\s*,\s*(\.\.\.)?\s*[a-zA-Z\$_][a-zA-Z\d\$_]*)*)?\s*\)\s*{/},next:["void","value","modifier","prop","incrementerBefore","expEnd"]}},closings={"(":")","[":"]","{":"}","'":"'",'"':'"',"`":"`"},closingsRegex={"(":/^\)/,"[":/^\]/,"{":/^\}/,"'":/^\'/,'"':/^\"/,"`":/^\`/};const okFirstChars=/^[\+\-~ !]/,restOfExp=(e,t,r)=>{let n=!0;t=t||[expectTypes.op.types.op,expectTypes.splitter.types.split,expectTypes.inlineIf.types.inlineIf,expectTypes.inlineIf.types.else];let s,o=!1,i=!1;for(s=0;s<e.length&&!i;s++){let p=e[s];if('"'===r||"'"===r||"`"===r){if("`"!==r||"$"!==p||"{"!==e[s+1]||o){if(p===r&&!o)return e.substring(0,s)}else{s+=restOfExp(e.substring(s+2),[closingsRegex["{"]]).length+2}o="\\"===p}else if(closings[p]){s+=restOfExp(e.substring(s+1),[closingsRegex[r]],p).length+1,n=!1}else if(r){if(p===closings[r])return e.substring(0,s)}else{let r=e.substring(s);for(let e of t)if(i=e.test(r),i)break;if(n&&(okFirstChars.test(r)?i=!1:n=!1),i)break}}return e.substring(0,s)};function assignCheck(e,t,r="assign"){var n,s,o,i;if(void 0===e.context)throw new ReferenceError(`Cannot ${r} value to undefined.`);if("object"!=typeof e.context&&"function"!=typeof e.context)throw new SyntaxError(`Cannot ${r} value to a primitive.`);if(e.isConst)throw new TypeError(`Cannot set value to const variable '${e.prop}'`);if(e.isGlobal)throw new SandboxError(`Cannot ${r} property '${e.prop}' of a global object`);if("function"==typeof e.context[e.prop]&&!e.context.hasOwnProperty(e.prop))throw new SandboxError(`Override prototype property '${e.prop}' not allowed`);"delete"===r?e.context.hasOwnProperty(e.prop)&&(null===(n=t.changeSubscriptions.get(e.context))||void 0===n||n.forEach(t=>t({type:"delete",prop:e.prop}))):e.context.hasOwnProperty(e.prop)?null===(o=null===(s=t.setSubscriptions.get(e.context))||void 0===s?void 0:s.get(e.prop))||void 0===o||o.forEach(e=>e({type:"replace"})):null===(i=t.changeSubscriptions.get(e.context))||void 0===i||i.forEach(t=>t({type:"create",prop:e.prop}))}restOfExp.next=["splitter","op","expEnd","inlineIf"];const arrayChange=new Set([[].push,[].pop,[].shift,[].unshift,[].splice,[].reverse,[].sort,[].copyWithin]);let ops2={prop:(e,t,r,n,s)=>{if(null===e)throw new TypeError(`Cannot get property ${t} of null`);const o=typeof e;if("undefined"===o&&void 0===r){let e=s.get(t);if(void 0===e.context)throw new ReferenceError(t+" is not defined");if(e.context===n.sandboxGlobal){n.options.audit&&n.auditReport.globalsAccess.add(t);const e=n.evals.get(n.sandboxGlobal[t]);if(e)return e}return e.context&&e.context[t]===globalThis?n.globalScope.get("this"):(n.getSubscriptions.forEach(t=>t(e.context,e.prop)),e)}if(void 0===e)throw new Error("Cannot get property '"+t+"' of undefined");if("object"!==o)"number"===o?e=new Number(e):"string"===o?e=new String(e):"boolean"===o&&(e=new Boolean(e));else if(void 0===e.hasOwnProperty)return new Prop(void 0,t);const i="function"===o;let p=i||!(e.hasOwnProperty(t)||"number"==typeof t);if(n.options.audit&&p&&"string"==typeof t){let r=e.constructor.prototype;do{r.hasOwnProperty(t)&&(n.auditReport.prototypeAccess[r.constructor.name]||(n.auditReport.prototypeAccess[r.constructor.name]=new Set),n.auditReport.prototypeAccess[r.constructor.name].add(t))}while(r=Object.getPrototypeOf(r))}if(p)if(i){if(!["name","length","constructor"].includes(t)&&e.hasOwnProperty(t)){const r=n.prototypeWhitelist.get(e),s=n.prototypeReplacements.get(e);if(s)return new Prop(s(e,!0),t);if(!r||r.size&&!r.has(t))throw new SandboxError(`Static method or property access not permitted: ${e.name}.${t}`)}}else if("constructor"!==t){let r=e.constructor.prototype;do{if(r.hasOwnProperty(t)){const s=n.prototypeWhitelist.get(r.constructor),o=n.prototypeReplacements.get(r.constuctor);if(o)return new Prop(o(e,!1),t);if(s&&(!s.size||s.has(t)))break;throw new SandboxError(`Method or property access not permitted: ${r.constructor.name}.${t}`)}}while(r=Object.getPrototypeOf(r))}const a=n.evals.get(e[t]);if(a)return a;if(e[t]===globalThis)return n.globalScope.get("this");let l=r.isGlobal||i&&!sandboxedFunctions.has(e)||n.globalsWhitelist.has(e);return l||n.getSubscriptions.forEach(r=>r(e,t)),new Prop(e,t,!1,l)},call:(e,t,r,n,s)=>{var o;if(n.options.forbidMethodCalls)throw new SandboxError("Method calls are not allowed");if("function"!=typeof e)throw new TypeError(r.prop+" is not a function");const i=t.map(e=>e instanceof SpreadArray?[...e.item]:[e]).flat();if("function"==typeof r)return r(...i.map(e=>exec(e,s,n)));const p=i.map(e=>exec(e,s,n));if(r.context[r.prop]===JSON.stringify&&n.getSubscriptions.size){const e=new Set,t=r=>{if(r&&"object"==typeof r&&!e.has(r)){e.add(r);for(let e in r)n.getSubscriptions.forEach(t=>t(r,e)),t(r[e])}};t(p[0])}if(r.context instanceof Array&&arrayChange.has(r.context[r.prop])&&n.changeSubscriptions.get(r.context)){let e,t=!1;if("push"===r.prop)e={type:"push",added:p},t=!!p.length;else if("pop"===r.prop)e={type:"pop",removed:r.context.slice(-1)},t=!!e.removed.length;else if("shift"===r.prop)e={type:"shift",removed:r.context.slice(0,1)},t=!!e.removed.length;else if("unshift"===r.prop)e={type:"unshift",added:p},t=!!p.length;else if("splice"===r.prop)e={type:"splice",startIndex:p[0],deleteCount:void 0===p[1]?r.context.length:p[1],added:p.slice(2),removed:r.context.slice(p[0],void 0===p[1]?void 0:p[0]+p[1])},t=!!e.added.length||!!e.removed.length;else if("reverse"===r.prop||"sort"===r.prop)e={type:r.prop},t=!!r.context.length;else if("copyWithin"===r.prop){let n=void 0===p[2]?r.context.length-p[1]:Math.min(r.context.length,p[2]-p[1]);e={type:"copyWithin",startIndex:p[0],endIndex:p[0]+n,added:r.context.slice(p[1],p[1]+n),removed:r.context.slice(p[0],p[0]+n)},t=!!e.added.length||!!e.removed.length}return t&&(null===(o=n.changeSubscriptions.get(r.context))||void 0===o||o.forEach(t=>t(e))),r.context[r.prop](...p)}return r.context[r.prop](...i.map(e=>exec(e,s,n)))},createObject:(e,t,r,n,s)=>{let o={};for(let e of t)e instanceof SpreadObject?o={...o,...e.item}:o[e.key]=e.val;return o},keyVal:(e,t)=>new KeyVal(e,t),createArray:(e,t,r,n,s)=>t.map(e=>e instanceof SpreadArray?[...e.item]:[e]).flat().map(e=>exec(e,s,n)),group:(e,t)=>t,string:(e,t,r,n)=>n.strings[t],literal:(e,t,r,n,s)=>n.literals[t].a.replace(/(\$\$)*(\$)?\${(\d+)}/g,(e,r,o,i)=>{if(o)return e;let p=exec(n.literals[t].b[parseInt(i,10)],s,n);return p=p instanceof Prop?p.context[p.prop]:p,(r||"")+(""+p).replace(/\$/g,"$$")}).replace(/\$\$/g,"$"),spreadArray:(e,t,r,n,s)=>new SpreadArray(exec(t,s,n)),spreadObject:(e,t,r,n,s)=>new SpreadObject(exec(t,s,n)),"!":(e,t)=>!t,"~":(e,t)=>~t,"++$":(e,t,r,n)=>(assignCheck(r,n),++r.context[r.prop]),"$++":(e,t,r,n)=>(assignCheck(r,n),r.context[r.prop]++),"--$":(e,t,r,n)=>(assignCheck(r,n),--r.context[r.prop]),"$--":(e,t,r,n)=>(assignCheck(r,n),r.context[r.prop]--),"=":(e,t,r,n)=>(assignCheck(r,n),r.context[r.prop]=t,new Prop(r.context,r.prop,!1,r.isGlobal)),"+=":(e,t,r,n)=>(assignCheck(r,n),r.context[r.prop]+=t),"-=":(e,t,r,n)=>(assignCheck(r,n),r.context[r.prop]-=t),"/=":(e,t,r,n)=>(assignCheck(r,n),r.context[r.prop]/=t),"*=":(e,t,r,n)=>(assignCheck(r,n),r.context[r.prop]*=t),"**=":(e,t,r,n)=>(assignCheck(r,n),r.context[r.prop]**=t),"%=":(e,t,r,n)=>(assignCheck(r,n),r.context[r.prop]%=t),"^=":(e,t,r,n)=>(assignCheck(r,n),r.context[r.prop]^=t),"&=":(e,t,r,n)=>(assignCheck(r,n),r.context[r.prop]&=t),"|=":(e,t,r,n)=>(assignCheck(r,n),r.context[r.prop]|=t),"?":(e,t)=>{if(!(t instanceof If))throw new SyntaxError("Invalid inline if");return e?t.t:t.f},">":(e,t)=>e>t,"<":(e,t)=>e<t,">=":(e,t)=>e>=t,"<=":(e,t)=>e<=t,"==":(e,t)=>e==t,"===":(e,t)=>e===t,"!=":(e,t)=>e!=t,"!==":(e,t)=>e!==t,"&&":(e,t)=>e&&t,"||":(e,t)=>e||t,"&":(e,t)=>e&t,"|":(e,t)=>e|t,":":(e,t)=>new If(e,t),"+":(e,t)=>e+t,"-":(e,t)=>e-t,"$+":(e,t)=>+t,"$-":(e,t)=>-t,"/":(e,t)=>e/t,"*":(e,t)=>e*t,"%":(e,t)=>e%t,typeof:(e,t)=>typeof t,instanceof:(e,t)=>e instanceof t,in:(e,t)=>e in t,delete:(e,t,r,n,s,o)=>void 0===o.context||(assignCheck(o,n,"delete"),!o.isVariable&&delete o.context[o.prop]),return:(e,t,r,n)=>t,var:(e,t,r,n,s,o)=>s.declare(e,VarType.var,exec(t,s,n)),let:(e,t,r,n,s,o)=>s.declare(e,VarType.let,exec(t,s,n),o&&o.isGlobal),const:(e,t,r,n,s,o)=>s.declare(e,VarType.const,exec(t,s,n)),arrowFunc:(e,t,r,n,s)=>createFunction(e,t,n,s),function:(e,t,r,n,s)=>{let o=e.shift(),i=createFunction(e,t,n,s,o);return o&&s.declare(o,VarType.var,i),i},inlineFunction:(e,t,r,n,s)=>{let o=e.shift();o&&(s=new Scope(s,{}));const i=createFunction(e,t,n,s,o);return o&&s.declare(o,VarType.let,i),i},loop:(e,t,r,n,s)=>{const[o,i,p,a,l]=e;let c=!0;const f=new Scope(s,{});for(exec(i,f,n),o&&(c=exec(a,f,n));c;){exec(l,f,n);let e=n.sandbox.executeTree(t,[new Scope(f,{})],!0);if(e.returned)return e;if(e.breakLoop)break;exec(p,f,n),c=exec(a,f,n)}},loopAction:(e,t,r,n,s)=>{if(!n.inLoop)throw new Error("Illegal "+e+" statement");return new ExecReturn(n.auditReport,void 0,!1,"break"===e,"continue"===e)},if:(e,t,r,n,s)=>{if(!(t instanceof If))throw new SyntaxError("Invalid inline if");return exec(e,s,n)?n.sandbox.executeTree(t.t,[new Scope(s)]):n.sandbox.executeTree(t.f,[new Scope(s)])},try:(e,t,r,n,s)=>{const[o,i]=t;try{return n.sandbox.executeTree(e,[new Scope(s)],n.inLoop)}catch(e){let t={};return o&&(t[o]=e),n.sandbox.executeTree(i,[new Scope(s,t)],n.inLoop)}},void:e=>{}},ops=new Map;for(let e in ops2)ops.set(e,ops2[e]);let lispTypes=new Map;const setLispType=(e,t)=>{e.forEach(e=>{lispTypes.set(e,t)})},closingsCreate={createArray:/^\]/,createObject:/^\}/,group:/^\)/,arrayProp:/^\]/,call:/^\)/};setLispType(["createArray","createObject","group","arrayProp","call"],(e,t,r,n,s,o)=>{let i="",p=[],a=!1,l=1;for(;l<r.length&&!a;)i=restOfExp(r.substring(l),[closingsCreate[t],/^,/]),l+=i.length,i&&p.push(i),","!==r[l]?a=!0:l++;const c=["void","value","prop","modifier","incrementerBefore"];let f,u;switch(t){case"group":case"arrayProp":f=lispify(e,p.pop());break;case"call":case"createArray":f=p.map(t=>lispify(e,t,[...c,"spreadArray"]));break;case"createObject":f=p.map(t=>{let r,n;if(t=t.trimStart(),u=expectTypes.expStart.types.function.exec("function "+t),u)n=u[1].trimStart(),r=lispify(e,"function "+t.replace(n,""));else{let s=restOfExp(t,[/^:/]);if(n=lispify(e,s,[...c,"spreadObject"]),n instanceof Lisp&&"prop"===n.op&&(n=n.b),s.length===t.length)return n;r=lispify(e,t.substring(s.length+1))}return new Lisp({op:"keyVal",a:n,b:r})})}t="arrayProp"===t?"prop":t,o.lispTree=lispify(e,r.substring(l+1),expectTypes[s].next,new Lisp({op:t,a:o.lispTree,b:f}))}),setLispType(["inverse","not","negative","positive","typeof","delete","op"],(e,t,r,n,s,o)=>{let i=restOfExp(r.substring(n[0].length));o.lispTree=lispify(e,r.substring(i.length+n[0].length),restOfExp.next,new Lisp({op:["positive","negative"].includes(t)?"$"+n[0]:n[0],a:o.lispTree,b:lispify(e,i,expectTypes[s].next)}))}),setLispType(["incrementerBefore"],(e,t,r,n,s,o)=>{let i=restOfExp(r.substring(2));o.lispTree=lispify(e,r.substring(i.length+2),restOfExp.next,new Lisp({op:n[0]+"$",a:lispify(e,i,expectTypes[s].next)}))}),setLispType(["incrementerAfter"],(e,t,r,n,s,o)=>{o.lispTree=lispify(e,r.substring(n[0].length),expectTypes[s].next,new Lisp({op:"$"+n[0],a:o.lispTree}))}),setLispType(["assign","assignModify"],(e,t,r,n,s,o)=>{o.lispTree=new Lisp({op:n[0],a:o.lispTree,b:lispify(e,r.substring(n[0].length),expectTypes[s].next)})}),setLispType(["split"],(e,t,r,n,s,o)=>{let i=restOfExp(r.substring(n[0].length),[expectTypes.splitter.types.split,expectTypes.inlineIf.types.inlineIf,expectTypes.inlineIf.types.else]);o.lispTree=lispify(e,r.substring(i.length+n[0].length),restOfExp.next,new Lisp({op:n[0],a:o.lispTree,b:lispify(e,i,expectTypes[s].next)}))}),setLispType(["inlineIf"],(e,t,r,n,s,o)=>{let i=!1,p="",a=1;for(;!i&&p.length<r.length;)p+=restOfExp(r.substring(p.length+1),[expectTypes.inlineIf.types.inlineIf,expectTypes.inlineIf.types.else]),"?"===r[p.length+1]?a++:a--,a?p+=r[p.length+1]:i=!0;o.lispTree=new Lisp({op:"?",a:o.lispTree,b:new Lisp({op:":",a:lispify(e,p),b:lispify(e,r.substring(n[0].length+p.length+1))})})}),setLispType(["if"],(e,t,r,n,s,o)=>{let i=restOfExp(r.substring(n[0].length),[/^\)/]),p=restOfExp(r.substring(n[0].length+i.length+1),[/^else(?!=\w\$)/]),a=r.substring(n[0].length+i.length+p.length+1+4);i=i.trim(),p=p.trim(),a=a.trim(),"{"===p[0]&&(p=p.slice(1,-1)),"{"===a[0]&&(p=a.slice(1,-1)),o.lispTree=new Lisp({op:"if",a:lispify(e,i),b:new Lisp({op:":",a:parse(p,e.strings,e.literals,!0),b:parse(a,e.strings,e.literals,!0)})})}),setLispType(["dot","prop"],(e,t,r,n,s,o)=>{let i=n[0],p=n[0].length;if("."===n[0]){let e=r.substring(n[0].length).match(expectTypes.prop.types.prop);if(!e.length)throw Error("Hanging  dot:"+r);i=e[0],p=i.length+n[0].length}o.lispTree=lispify(e,r.substring(p),expectTypes[s].next,new Lisp({op:"prop",a:o.lispTree,b:i}))}),setLispType(["spreadArray","spreadObject","return"],(e,t,r,n,s,o)=>{o.lispTree=new Lisp({op:t,b:lispify(e,r.substring(n[0].length),expectTypes[s].next)})}),setLispType(["number","boolean","null"],(e,t,r,n,s,o)=>{o.lispTree=lispify(e,r.substring(n[0].length),expectTypes[s].next,JSON.parse(n[0]))});const constants={NaN:NaN,Infinity:1/0};setLispType(["und","NaN","Infinity"],(e,t,r,n,s,o)=>{o.lispTree=lispify(e,r.substring(n[0].length),expectTypes[s].next,constants[t])}),setLispType(["string","literal"],(e,t,r,n,s,o)=>{o.lispTree=lispify(e,r.substring(n[0].length),expectTypes[s].next,new Lisp({op:t,b:parseInt(JSON.parse(n[1]),10)}))}),setLispType(["initialize"],(e,t,r,n,s,o)=>{n[3]?o.lispTree=new Lisp({op:n[1],a:n[2],b:lispify(e,r.substring(n[0].length+1),expectTypes[s].next)}):o.lispTree=lispify(e,r.substring(n[0].length),expectTypes[s].next,new Lisp({op:n[1],a:n[2]}))}),setLispType(["function","inlineFunction","arrowFunction","arrowFunctionSingle"],(e,t,r,n,s,o)=>{const i="function"!==t&&"inlineFunction"!==t,p=i&&!n[n.length-1],a=i?1:2,l=n[a]?n[a].replace(/\s+/g,"").split(/,/g):[];i||l.unshift((n[1]||"").trimStart());let c=!1;l.forEach(e=>{if(c)throw new SyntaxError("Rest parameter must be last formal parameter");e.startsWith("...")&&(c=!0)});const f=(p?"return ":"")+restOfExp(r.substring(n[0].length),p?[/^[,;\)\}\]]/]:[/^}/]);o.lispTree=lispify(e,r.substring(n[0].length+f.length+1),expectTypes[s].next,new Lisp({op:i?"arrowFunc":t,a:l,b:parse(f,e.strings,e.literals,!0)}))});const iteratorRegex=/^((let|var|const)\s+[a-zA-Z\$_][a-zA-Z\d\$_]*)\s+(in|of)\s+/;let lastType;function lispify(e,t,r,n){if(r=r||["initialize","expStart","void","value","prop","modifier","incrementerBefore","expEnd"],void 0===t)return n;if(!t.length&&!r.includes("expEnd"))throw new SyntaxError("Unexpected end of expression");t=t.trimStart();let s,o={lispTree:n};for(let n of r)if("expEnd"!==n){for(let r in expectTypes[n].types)if("expEnd"!==r&&(s=expectTypes[n].types[r].exec(t))){lastType=r,lispTypes.get(r)(e,r,t,s,n,o);break}if(s)break}if(!s&&t.length)throw SyntaxError(`Unexpected token (${lastType}): ${t}`);return o.lispTree}function exec(e,t,r){if(e instanceof Prop)return e.context[e.prop];if(Array.isArray(e)){let n=[];for(let s of e){const e=exec(s,t,r);if(e instanceof ExecReturn){if(n.push(e.result),e.returned||e.breakLoop||e.continueLoop){n=e;break}}else n.push(e)}return n}if(!(e instanceof Lisp))return e;if("arrowFunc"===e.op||"function"===e.op||"loop"===e.op||"try"===e.op)return ops.get(e.op)(e.a,e.b,void 0,r,t);if("if"===e.op)return ops.get(e.op)(e.a,exec(e.b,t,r),void 0,r,t);let n=exec(e.a,t,r),s=n instanceof Prop?n.context?n.context[n.prop]:void 0:n,o=exec(e.b,t,r),i=o instanceof Prop?o.context?o.context[o.prop]:void 0:o;if(ops.has(e.op)){return ops.get(e.op)(s,i,n,r,t,o)}throw new SyntaxError("Unknown operator: "+e.op)}function parse(e,t=[],r=[],n=!1){if("string"!=typeof e)throw new ParseError("Cannot parse "+e,e);let s,o=e,i="",p=!1,a=[],l=[];if(!n){let e=0;for(let n=0;n<o.length;n++){let c=o[n];if(p)if("$"===c&&"`"===s)e--,c="$$";else if("u"===c){let e,t=/^[a-fA-F\d]{2,4}/.exec(o.substring(n+1));e=t?Array.from(t):Array.from(/^{[a-fA-F\d]+}/.exec(o.substring(n+1))||[""]),c=JSON.parse(`"\\u${e[0]}"`),o=o.substring(0,n-1)+c+o.substring(n+(1+e[0].length)),n-=1}else"`"!=c&&(c=JSON.parse(`"\\${c}"`));else"$"===c&&"`"===s&&"{"!==o[n+1]&&(e--,c="$$");if("`"===s&&"$"===c&&"{"===o[n+1]){let t=restOfExp(o.substring(n+2),[/^}/]);l.push(t),e+=t.length+3,i+=`\${${l.length-1}}`,n+=t.length+2}else if(s||"'"!==c&&'"'!==c&&"`"!==c||p)if(s!==c||p)s&&(p||"\\"!==c)&&(e+=p?1+c.length:c.length,i+=c);else{let p;"`"===s?(r.push({op:"literal",a:i,b:l}),a.push(l),o=o.substring(0,n-e-1)+`\`${r.length-1}\``+o.substring(n+1),p=(r.length-1).toString().length):(t.push(i),o=o.substring(0,n-i.length-1)+`"${t.length-1}"`+o.substring(n+1),p=(t.length-1).toString().length),s=null,n-=i.length-p,i=""}else l=[],e=0,s=c;p=s&&!p&&"\\"===c}a.forEach(e=>{const n=e.map(e=>parse(e,t,r).tree[0]);e.length=0,e.push(...n)})}let c,f=[],u=0;for(;c=restOfExp(o.substring(u),[/^;/]);)f.push(c),u+=c.length+1;f=f.filter(Boolean);return{tree:f.filter(e=>e.length).map(e=>{let n,s=[],o=0;for(;n=restOfExp(e.substring(o),[/^,/]);)s.push(n),o+=n.length+1;try{const e=s.map(e=>lispify({strings:t,literals:r},e));if(e.length>1&&e[0]instanceof Lisp&&"return"===e[0].op){const t=e.pop();return[e.shift().b,...e,new Lisp({op:"return",b:t})]}return e}catch(t){throw new ParseError(t.message+": "+e,e)}}).flat(),strings:t,literals:r}}setLispType(["for","do","while"],(e,t,r,n,s,o)=>{let i,p,a=r.indexOf("(")+1,l=!0,c=!1,f=!0,u=!0;switch(t){case"while":let t=restOfExp(r.substring(a),[/^\)/]);i=lispify(e,t),p=restOfExp(r.substring(a+t.length+1)).trim(),"{"===p[0]&&(p=p.slice(1,-1));break;case"for":let n,s=[],o="";for(let e=0;e<3&&(o=restOfExp(r.substring(a),[/^[;\)]/]),s.push(o.trim()),a+=o.length+1,")"!==r[a-1]);e++);if(1===s.length&&(n=iteratorRegex.exec(s[0])))"of"===n[3]?(l=[lispify(e,"let $$obj = "+s[0].substring(n[0].length)),lispify(e,"let $$iterator = $$obj[Symbol.iterator]()"),lispify(e,"let $$next = $$iterator.next()")],i=lispify(e,"return !$$next.done"),u=lispify(e,"$$next = $$iterator.next()"),c=lispify(e,n[1]+" = $$next.value")):(l=[lispify(e,"let $$obj = "+s[0].substring(n[0].length)),lispify(e,"let $$keys = Object.keys($$obj)"),lispify(e,"let $$keyIndex = 0")],u=lispify(e,"$$keyIndex++"),i=lispify(e,"return $$keyIndex < $$keys.length"),c=lispify(e,n[1]+" = $$keys[$$keyIndex]"));else{if(3!==s.length)throw new SyntaxError("Invalid for loop definition");l=lispify(e,s.shift()),i=lispify(e,"return "+s.shift()),u=lispify(e,s.shift())}p=restOfExp(r.substring(a)).trim(),"{"===p[0]&&(p=p.slice(1,-1));break;case"do":f=!1;const d=r.indexOf("{")+1;let h=restOfExp(r.substring(d),[/^}/]);p=h,i=lispify(e,restOfExp(r.substring(r.indexOf("(",d+h.length)+1),[/^\)/]))}o.lispTree=new Lisp({op:"loop",a:[f,l,u,i,c],b:parse(p,e.strings,e.literals,!0)}),setLispType(["block"],(e,t,r,n,s,o)=>{o.lispTree=parse(restOfExp(r.substring(1),[/^}/]),e.strings,e.literals,!0)}),setLispType(["loopAction"],(e,t,r,n,s,o)=>{o.lispTree=new Lisp({op:"loopAction",a:n[1]})});const d=/^\s*catch\s*(\(\s*([a-zA-Z\$_][a-zA-Z\d\$_]*)\s*\))?\s*\{/;setLispType(["try"],(e,t,r,n,s,o)=>{const i=restOfExp(r.substring(n[0].length),[/^}/]),p=d.exec(r.substring(n[0].length+i.length+1)),a=p[2],l=restOfExp(r.substring(n[0].length+i.length+1+p[0].length),[/^}/]);o.lispTree=new Lisp({op:"try",a:parse(i,e.strings,e.literals,!0),b:[a,parse(l,e.strings,e.literals,!0)]})}),setLispType(["void"],(e,t,r,n,s,o)=>{const i=restOfExp(r.substring(n[0].length),expectTypes[s].next.map(e=>Object.values(expectTypes[e].types)).flat());o.lispTree=lispify(e,r.substring(n[0].length+i.length),expectTypes[s].next,new Lisp({op:"void",a:lispify(e,i)}))})});export default class Sandbox{constructor(globals=Sandbox.SAFE_GLOBALS,prototypeWhitelist=Sandbox.SAFE_PROTOTYPES,prototypeReplacements=new Map,options={audit:!1}){const sandboxGlobal=new SandboxGlobal(globals);this.context={sandbox:this,globals:globals,prototypeWhitelist:prototypeWhitelist,prototypeReplacements:prototypeReplacements,globalsWhitelist:new Set(Object.values(globals)),options:options,globalScope:new Scope(null,globals,sandboxGlobal),sandboxGlobal:sandboxGlobal,evals:new Map,getSubscriptions:new Set,setSubscriptions:new WeakMap,changeSubscriptions:new WeakMap,inLoop:!1};const func=sandboxFunction(this.context);this.context.evals.set(Function,func),this.context.evals.set(eval,sandboxedEval(func)),this.context.evals.set(setTimeout,sandboxedSetTimeout(func)),this.context.evals.set(setInterval,sandboxedSetInterval(func))}static get SAFE_GLOBALS(){return{Function:Function,console:{debug:console.debug,error:console.error,info:console.info,log:console.log,table:console.table,warn:console.warn},isFinite:isFinite,isNaN:isNaN,parseFloat:parseFloat,parseInt:parseInt,decodeURI:decodeURI,decodeURIComponent:decodeURIComponent,encodeURI:encodeURI,encodeURIComponent:encodeURIComponent,escape:escape,unescape:unescape,Boolean:Boolean,Number:Number,String:String,Object:Object,Array:Array,Symbol:Symbol,Error:Error,EvalError:EvalError,RangeError:RangeError,ReferenceError:ReferenceError,SyntaxError:SyntaxError,TypeError:TypeError,URIError:URIError,Int8Array:Int8Array,Uint8Array:Uint8Array,Uint8ClampedArray:Uint8ClampedArray,Int16Array:Int16Array,Uint16Array:Uint16Array,Int32Array:Int32Array,Uint32Array:Uint32Array,Float32Array:Float32Array,Float64Array:Float64Array,Map:Map,Set:Set,WeakMap:WeakMap,WeakSet:WeakSet,Promise:Promise,Intl:Intl,JSON:JSON,Math:Math}}static get SAFE_PROTOTYPES(){let e=[SandboxGlobal,Function,Boolean,Number,String,Date,RegExp,Error,Array,Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array,Map,Set,WeakMap,WeakSet,Promise,Symbol],t=new Map;return e.forEach(e=>{t.set(e,new Set)}),t.set(Object,new Set(["entries","fromEntries","getOwnPropertyNames","is","keys","hasOwnProperty","isPrototypeOf","propertyIsEnumerable","toLocaleString","toString","valueOf","values"])),t}subscribeGet(e){return this.context.getSubscriptions.add(e),{unsubscribe:()=>this.context.getSubscriptions.delete(e)}}subscribeSet(e,t,r){const n=this.context.setSubscriptions.get(e)||new Map;this.context.setSubscriptions.set(e,n);const s=n.get(t)||new Set;let o;return n.set(t,s),s.add(r),e&&e[t]&&"object"==typeof e[t]&&(o=this.context.changeSubscriptions.get(e[t])||new Set,o.add(r),this.context.changeSubscriptions.set(e[t],o)),{unsubscribe:()=>{s.delete(r),o&&o.delete(r)}}}static audit(e,t=[]){return new Sandbox(globalThis,new Map,new Map,{audit:!0}).executeTree(parse(e),t)}static parse(e){return parse(e)}executeTree(e,t=[],r=!1){const n=e.tree,s={...this.context,strings:e.strings,literals:e.literals,inLoop:r};let o,i=this.context.globalScope;for(;o=t.shift();)"object"==typeof o&&(i=o instanceof Scope?o:new Scope(i,o,null));let p=Object.assign({},s);s.options.audit&&(p.auditReport={globalsAccess:new Set,prototypeAccess:{}});let a,l=!1;if(!(n instanceof Array))throw new SyntaxError("Bad execution tree");for(let e of n){let t;try{if(t=exec(e,i,p),t instanceof ExecReturn){a=t;break}}catch(e){throw new e.constructor(e.message)}e instanceof Lisp&&"return"===e.op&&(l=!0,a=t)}return a=a instanceof Prop?a.context[a.prop]:a,a instanceof ExecReturn?a:new ExecReturn(p.auditReport,a,l,!1,!1)}compile(e){const t=parse(e);return(...e)=>this.executeTree(t,e).result}}