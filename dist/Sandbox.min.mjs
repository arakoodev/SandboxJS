class Prop{constructor(e,t,r=!1,n=!1){this.context=e,this.prop=t,this.isConst=r,this.isGlobal=n}}class Lisp{constructor(e){this.op=e.op,this.a=e.a,this.b=e.b}}class If{constructor(e,t){this.t=e,this.f=t}}class KeyVal{constructor(e,t){this.key=e,this.val=t}}class ObjectFunc{constructor(e,t,r){this.key=e,this.args=t,this.tree=r}}class SpreadObject{constructor(e){this.item=e}}class SpreadArray{constructor(e){this.item=e}}class Scope{constructor(e,t={},r){this.const={},this.var={},this.globals={},this.parent=e,this.let=e?t:{},this.globals=e?{}:t,this.functionThis=r||!e,r&&this.declare("this","var",r)}get(e,t=!1){if(!this.parent||!t||this.functionThis){if(e in this.const)return new Prop(this.const,e,!0,e in this.globals);if(e in this.var)return new Prop(this.var,e,!1,e in this.globals);if(e in this.let)return new Prop(this.let,e,!1,e in this.globals);if(!this.parent&&e in this.globals)return new Prop(this.functionThis,e,!1,!0);if(!this.parent)return new Prop(void 0,e)}return this.parent.get(e,t)}set(e,t){if("this"===e)throw new Error('"this" cannot be a variable');let r=this.get(e);if(void 0===r.context)throw new Error(`Variable '${e}' was not declared.`);if(r.isConst)throw Error(`Cannot assign to const variable '${e}'`);if(r.isGlobal)throw Error(`Cannot override global variable '${e}'`);return r.context[r]=t,r}declare(e,t=null,r,n=!1){if("var"===t&&!this.functionThis&&this.parent)this.parent.declare(e,t,r,n);else{if(e in this.var&&e in this.let&&e in this.const&&e in this.globals)throw Error(`Variable '${e}' already declared`);n&&(this.globals[e]=r),this[t][e]=r}}}class SandboxGlobal{constructor(e){if(e===globalThis)return globalThis;for(let t in e)this[t]=e[t]}}function sandboxFunction(e){return function SandboxFunction(...t){let r=t.pop(),n=Sandbox.parse(r);return function(...r){const s={};for(let e of t)s[e]=r.shift();const i=e.sandbox.executeTree(n);if(e.options.audit){for(let t in i.auditReport.globalsAccess){let r=i.auditReport.globalsAccess[t];e.auditReport.globalsAccess[t]=e.auditReport.globalsAccess[t]||new Set,r.forEach(r=>{e.auditReport.globalsAccess[t].add(r)})}for(let t in i.auditReport.prototypeAccess){let r=i.auditReport.prototypeAccess[t];e.auditReport.prototypeAccess[t]=e.auditReport.prototypeAccess[t]||new Set,r.forEach(r=>{e.auditReport.prototypeAccess[t].add(r)})}}return i.result}}}function sandboxedEval(e){return function(t){return e(t)()}}let expectTypes={op:{types:{op:/^(\/|\*\*(?!\=)|\*(?!\=)|\%(?!\=))/},next:["value","prop","exp","modifier","incrementerBefore"]},splitter:{types:{split:/^(&&|&|\|\||\||<=|>=|<|>|!==|!=|===|==| instanceof | in |\+(?!\+)|\-(?!\-))(?!\=)/},next:["value","prop","exp","modifier","incrementerBefore"]},if:{types:{if:/^\?/,else:/^:/},next:["expEnd"]},assignment:{types:{assignModify:/^(\-=|\+=|\/=|\*\*=|\*=|%=|\^=|\&=|\|=)/,assign:/^(=)/},next:["value","prop","function","exp","modifier","incrementerBefore"]},incrementerBefore:{types:{incrementerBefore:/^(\+\+|\-\-)/},next:["prop"]},incrementerAfter:{types:{incrementerAfter:/^(\+\+|\-\-)/},next:["splitter","op","expEnd"]},expEdge:{types:{arrayProp:/^[\[]/,call:/^[\(]/},next:["splitter","op","expEdge","if","dot","expEnd"]},modifier:{types:{not:/^!/,inverse:/^~/,negative:/^\-(?!\-)/,positive:/^\+(?!\+)/,typeof:/^ typeof /},next:["exp","modifier","value","prop","incrementerBefore"]},exp:{types:{createObject:/^\{/,createArray:/^\[/,group:/^\(/},next:["splitter","op","expEdge","if","dot","expEnd"]},dot:{types:{dot:/^\.(?!\.)/},next:["splitter","incrementerAfter","assignment","op","expEdge","if","dot","expEnd"]},prop:{types:{prop:/^[a-zA-Z\$_][a-zA-Z\d\$_]*/},next:["splitter","incrementerAfter","assignment","op","expEdge","if","dot","expEnd"]},value:{types:{number:/^\-?\d+(\.\d+)?/,string:/^"(\d+)"/,literal:/^`(\d+)`/,boolean:/^(true|false)(?![\w$_])/,null:/^null(?![\w$_])/,und:/^undefined(?![\w$_])/,NaN:/^NaN(?![\w$_])/,Infinity:/^Infinity(?![\w$_])/},next:["splitter","op","if","dot","expEnd"]},function:{types:{arrowFunc:/^\(?([a-zA-Z\$_][a-zA-Z\d\$_]*,?)*(\))?=>({)?/},next:["expEnd"]},initialize:{types:{initialize:/^ (var|let|const) [a-zA-Z\$_][a-zA-Z\d\$_]*/},next:["value","prop","function","exp","modifier","incrementerBefore","expEnd"]},spreadObject:{types:{spreadObject:/^\.\.\./},next:["value","exp","prop"]},spreadArray:{types:{spreadArray:/^\.\.\./},next:["value","exp","prop"]},expEnd:{types:{},next:[]},expStart:{types:{return:/^ return /},next:["value","prop","exp","modifier","incrementerBefore","expEnd"]}},closings={"(":")","[":"]","{":"}","'":"'",'"':'"',"`":"`"};const restOfExp=(e,t,r)=>{let n=/^[\+\-~ !]/,s=!0;t=t||[expectTypes.op.types.op,expectTypes.splitter.types.split,expectTypes.if.types.if,expectTypes.if.types.else];let i,o=!1,p=!1;for(i=0;i<e.length&&!p;i++){let a=e[i];if('"'===r||"'"===r||"`"===r){if("`"!==r||"$"!==a||"{"!==e[i+1]||o){if(a===r&&!o)return e.substring(0,i)}else{i+=restOfExp(e.substring(i+2),[/^}/]).length+2}o="\\"===a}else if(closings[a]){i+=restOfExp(e.substring(i+1),[new RegExp("^\\"+closings[r])],a).length+1,s=!1}else if(r){if(a===closings[r])return e.substring(0,i)}else{let r=e.substring(i);if(t.forEach(e=>{p=p||e.test(r)}),s&&(n.test(r)?p=!1:s=!1),p)break}}return e.substring(0,i)};function assignCheck(e){if(void 0===e.context)throw new Error("Cannot assign value to undefined.");if("object"!=typeof e.context)throw new Error("Cannot assign value to a premitive.");if(e.isConst)throw new Error(`Cannot set value to const variable '${e.prop}'`);if(e.isGlobal)throw Error(`Cannot override property of global variable '${e.prop}'`);if("function"==typeof e.context[e.prop]&&!e.context.hasOwnProperty(e.prop))throw Error(`Cannot override prototype property '${e.prop}'`)}restOfExp.next=["splitter","op","expEnd"];let ops2={prop:(e,t,r,n,s)=>{if(void 0===e||void 0===e.hasOwnProperty){let e=s.get(t);if(void 0===e.context)throw new Error(`${t} is not defined`);if(e.context===n.sandboxGlobal){if(n.options.audit&&n.auditReport.globalsAccess.add(t),n.sandboxGlobal[t]===Function)return n.Function;if(n.sandboxGlobal[t]===eval)return n.eval;const e=n.sandboxGlobal[t];if(setTimeout===e||e===setInterval)return}return e.context&&e.context[t]===globalThis?n.globalScope.get("this"):e}let i=!1;if(null===e)throw new Error("Cannot get propety of null");if("number"==typeof e&&(e=new Number(e)),"string"==typeof e&&(e=new String(e)),"boolean"==typeof e&&(e=new Boolean(e)),i=e.hasOwnProperty(t)||parseInt(t,10)+""==t+"",!i&&n.options.audit&&(i=!0,"string"==typeof t&&(n.auditReport.prototypeAccess[e.constructor.name]||(n.auditReport.prototypeAccess[e.constructor.name]=new Set),n.auditReport.prototypeAccess[e.constructor.name].add(t))),!i&&n.prototypeWhitelist.has(e.constructor)){let r=n.prototypeWhitelist.get(e.constructor)||[];i=!r.length||r.includes(t)}else i||n.prototypeWhitelist.forEach((r,n)=>{!i&&e instanceof n&&(i=i||t in n.prototype,i=i&&(!r||!r.length||r.includes(t)))});if(i){if(e[t]===Function)return n.Function;if(e[t]===globalThis)return n.globalScope.get("this");let s=r.isGlobal||e.constructor===Function;return new Prop(e,t,!1,s)}throw Error(`Method or property access prevented: ${e.constructor.name}.${t}`)},call:(e,t,r,n,s)=>{if(n.options.forbidMethodCalls)throw new Error("Method calls are not allowed");if("function"!=typeof e)throw new Error(`${r.prop} is not a function`);return"function"==typeof r?r(...t.map(e=>exec(e,s,n))):r.context[r.prop](...t.map(e=>exec(e,s,n)))},createObject:(e,t,r,n,s)=>{let i={};for(let e of t)if(e instanceof SpreadObject)i={...i,...e.item};else if(e instanceof ObjectFunc){let t=e;i[t.key]=function(...e){const r={};return t.args.forEach((t,n)=>{r[t]=e[n]}),n.sandbox.executeTree({tree:t.tree,strings:n.strings,literals:n.literals},[new Scope(s,r,this)]).result}}else i[e.key]=e.val;return i},keyVal:(e,t)=>new KeyVal(e,t),createArray:(e,t,r,n,s)=>{let i=[],o=[];return t.forEach(e=>{e instanceof SpreadArray?(o.length&&(i.push(o),o=[]),i.push(e.item)):o.push(exec(e,s,n))}),o.length&&i.push(o),i.flat()},group:(e,t)=>t,string:(e,t,r,n)=>n.strings[t],literal:(e,t,r,n,s)=>n.literals[t].a.replace(/(\$\$)*(\$)?\${(\d+)}/g,(e,r,i,o)=>{if(i)return e;let p=exec(n.literals[t].b[parseInt(o,10)],s,n);return p=p instanceof Prop?p.context[p.prop]:p,(r||"")+`${p}`.replace(/\$/g,"$$")}).replace(/\$\$/g,"$"),spreadArray:(e,t,r,n,s)=>new SpreadArray(exec(t,s,n)),spreadObject:(e,t,r,n,s)=>new SpreadObject(exec(t,s,n)),"!":(e,t)=>!t,"~":(e,t)=>~t,"++$":(e,t,r)=>++r.context[r.prop],"$++":(e,t,r)=>r.context[r.prop]++,"--$":(e,t,r)=>--r.context[r.prop],"$--":(e,t,r)=>r.context[r.prop]--,"=":(e,t,r,n,s,i)=>(assignCheck(r),r.context[r.prop]=t,new Prop(r.context,r.prop,!1,r.isGlobal)),"+=":(e,t,r)=>(assignCheck(r),r.context[r.prop]+=t),"-=":(e,t,r)=>(assignCheck(r),r.context[r.prop]-=t),"/=":(e,t,r)=>(assignCheck(r),r.context[r.prop]/=t),"*=":(e,t,r)=>(assignCheck(r),r.context[r.prop]*=t),"**=":(e,t,r)=>(assignCheck(r),r.context[r.prop]**=t),"%=":(e,t,r)=>(assignCheck(r),r.context[r.prop]%=t),"^=":(e,t,r)=>(assignCheck(r),r.context[r.prop]^=t),"&=":(e,t,r)=>(assignCheck(r),r.context[r.prop]&=t),"|=":(e,t,r)=>(assignCheck(r),r.context[r.prop]|=t),"?":(e,t)=>{if(!(t instanceof If))throw new Error("Invalid inline if");return e?t.t:t.f},">":(e,t)=>e>t,"<":(e,t)=>e<t,">=":(e,t)=>e>=t,"<=":(e,t)=>e<=t,"==":(e,t)=>e==t,"===":(e,t)=>e===t,"!=":(e,t)=>e!=t,"!==":(e,t)=>e!==t,"&&":(e,t)=>e&&t,"||":(e,t)=>e||t,"&":(e,t)=>e&t,"|":(e,t)=>e|t,":":(e,t)=>new If(e,t),"+":(e,t)=>e+t,"-":(e,t)=>e-t,"$+":(e,t)=>+t,"$-":(e,t)=>-t,"/":(e,t)=>e/t,"*":(e,t)=>e*t,"%":(e,t)=>e%t," typeof ":(e,t)=>typeof t," instanceof ":(e,t)=>e instanceof t," in ":(e,t)=>e in t,return:(e,t)=>t,var:(e,t,r,n,s,i)=>(s.declare(e,"var",exec(t,s,n)),new Prop(s.var,e,!1,i&&i.isGlobal)),let:(e,t,r,n,s,i)=>(s.declare(e,"let",exec(t,s,n),i&&i.isGlobal),new Prop(s.let,e,!1,i&&i.isGlobal)),const:(e,t,r,n,s,i)=>(s.declare(e,"const",exec(t,s,n)),new Prop(s.const,e,!1,i&&i.isGlobal)),arrowFunc:(e,t,r,n,s)=>(...r)=>{const i={};return e.forEach((e,t)=>{i[e]=r[t]}),n.sandbox.executeTree({tree:t,strings:n.strings,literals:n.literals},[new Scope(s,i)]).result}},ops=new Map;for(let e in ops2)ops.set(e,ops2[e]);let lispTypes={},setLispType=(e,t)=>{e.forEach(e=>{lispTypes[e]=t})};function lispify(e,t,r){if(t=t||["initialize","expStart","value","function","prop","exp","modifier","incrementerBefore","expEnd"],void 0===e)return r;if(!e.length&&!t.includes("expEnd"))throw new Error("Unexpected end of expression");let n,s={lispTree:r};if(t.forEach(r=>{if("expEnd"!==r)for(let i in expectTypes[r].types){if(n)break;"expEnd"!==i&&((n=expectTypes[r].types[i].exec(e))&&(lispTypes[i](i,e,n,r,s),t=expectTypes[r].next))}}),!n&&e.length)throw Error("Unexpected token: "+e);return s.lispTree}function exec(e,t,r){if(e instanceof Prop)return e.context[e.prop];if(Array.isArray(e))return e.map(e=>exec(e,t,r));if(!(e instanceof Lisp))return e;if("arrowFunc"===e.op)return ops.get(e.op)(e.a,e.b,void 0,r,t);let n=exec(e.a,t,r),s=n instanceof Prop?n.context?n.context[n.prop]:void 0:n,i=exec(e.b,t,r),o=i instanceof Prop?i.context?i.context[i.prop]:void 0:i;if(ops.has(e.op)){return ops.get(e.op)(s,o,n,r,t,i)}throw new Error("Unknown operator: "+e.op)}setLispType(["createArray","createObject","group","arrayProp","call"],(e,t,r,n,s)=>{let i="",o={createArray:"]",createObject:"}",group:")",arrayProp:"]",call:")"},p=[],a=!1,l=1;for(;l<t.length&&!a;)i=restOfExp(t.substring(l),[new RegExp("^\\"+o[e]),/^,/]),l+=i.length,i&&p.push(i),","!==t[l]?a=!0:l++;const c=["value","prop","function","exp","modifier","incrementerBefore"];let f,u;const y=/^([a-zA-Z\$_][a-zA-Z\d\$_]*)\((([a-zA-Z\$_][a-zA-Z\d\$_]*,?)*)\)?{/;switch(e){case"group":case"arrayProp":f=lispify(p.pop());break;case"call":case"createArray":f=p.map(e=>lispify(e,[...c,"spreadArray"]));break;case"createObject":f=p.map(e=>{let t,r;if(u=y.exec(e),u){let t=u[2]?u[2].split(","):[];const r=restOfExp(e.substring(u.index+u[0].length),[/^}/]);return new ObjectFunc(u[1],t,Sandbox.parse(r,null).tree)}{let n=restOfExp(e,[/^:/]);if(r=lispify(n,[...c,"spreadObject"]),r instanceof Lisp&&"prop"===r.op&&(r=r.b),n.length===e.length)return r;t=lispify(e.substring(n.length+1))}return new Lisp({op:"keyVal",a:r,b:t})})}e="arrayProp"===e?"prop":e,s.lispTree=lispify(t.substring(l+1),expectTypes[n].next,new Lisp({op:e,a:s.lispTree,b:f}))}),setLispType(["op"],(e,t,r,n,s)=>{let i=restOfExp(t.substring(r[0].length));s.lispTree=new Lisp({op:r[0],a:s.lispTree,b:lispify(i)}),s.lispTree=lispify(t.substring(i.length+r[0].length),restOfExp.next,s.lispTree)}),setLispType(["inverse","not","negative","positive","typeof"],(e,t,r,n,s)=>{let i=restOfExp(t.substring(r[0].length));s.lispTree=new Lisp({op:["positive","negative"].includes(e)?"$"+r[0]:r[0],a:s.lispTree,b:lispify(i,expectTypes[n].next)}),s.lispTree=lispify(t.substring(i.length+r[0].length),restOfExp.next,s.lispTree)}),setLispType(["incrementerBefore"],(e,t,r,n,s)=>{let i=restOfExp(t.substring(2));s.lispTree=lispify(t.substring(i.length+2),restOfExp.next,new Lisp({op:r[0]+"$",a:lispify(i,expectTypes[n].next)}))}),setLispType(["incrementerAfter"],(e,t,r,n,s)=>{s.lispTree=lispify(t.substring(r[0].length),expectTypes[n].next,new Lisp({op:"$"+r[0],a:s.lispTree}))}),setLispType(["assign","assignModify"],(e,t,r,n,s)=>{s.lispTree=new Lisp({op:r[0],a:s.lispTree,b:lispify(t.substring(r[0].length),expectTypes[n].next)})}),setLispType(["split"],(e,t,r,n,s)=>{let i=restOfExp(t.substring(r[0].length),[expectTypes.splitter.types.split,expectTypes.if.types.if,expectTypes.if.types.else]);s.lispTree=new Lisp({op:r[0],a:s.lispTree,b:lispify(i,expectTypes[n].next)}),s.lispTree=lispify(t.substring(i.length+r[0].length),restOfExp.next,s.lispTree)}),setLispType(["if"],(e,t,r,n,s)=>{let i=!1,o="",p=1;for(;!i&&o.length<t.length;)o+=restOfExp(t.substring(o.length+1),[expectTypes.if.types.if,expectTypes.if.types.else]),"?"===t[o.length+1]?p++:p--,p?o+=t[o.length+1]:i=!0;s.lispTree=new Lisp({op:"?",a:s.lispTree,b:new Lisp({op:":",a:lispify(o),b:lispify(t.substring(r[0].length+o.length+1))})})}),setLispType(["dot","prop"],(e,t,r,n,s)=>{let i=r[0],o=r[0].length;if("."===r[0]){let e=t.substring(r[0].length).match(expectTypes.prop.types.prop);if(!e.length)throw Error("Hanging  dot:"+t);i=e[0],o=i.length+r[0].length}s.lispTree=lispify(t.substring(o),expectTypes[n].next,new Lisp({op:"prop",a:s.lispTree,b:i}))}),setLispType(["spreadArray","spreadObject"],(e,t,r,n,s)=>{s.lispTree=new Lisp({op:e,b:lispify(t.substring(r[0].length),expectTypes[n].next)})}),setLispType(["number","boolean","null"],(e,t,r,n,s)=>{s.lispTree=lispify(t.substring(r[0].length),expectTypes[n].next,JSON.parse(r[0]))}),setLispType(["und"],(e,t,r,n,s)=>{s.lispTree=lispify(t.substring(r[0].length),expectTypes[n].next,void 0)}),setLispType(["NaN"],(e,t,r,n,s)=>{s.lispTree=lispify(t.substring(r[0].length),expectTypes[n].next,NaN)}),setLispType(["Infinity"],(e,t,r,n,s)=>{s.lispTree=lispify(t.substring(r[0].length),expectTypes[n].next,1/0)}),setLispType(["string","literal"],(e,t,r,n,s)=>{s.lispTree=lispify(t.substring(r[0].length),expectTypes[n].next,new Lisp({op:e,b:parseInt(JSON.parse(r[1]),10)}))}),setLispType(["return"],(e,t,r,n,s)=>{s.lispTree=new Lisp({op:"return",b:lispify(t.substring(r[0].length),expectTypes[n].next)})}),setLispType(["initialize"],(e,t,r,n,s)=>{const i=r[0].split(/ /g);t.length===r[0].length?s.lispTree=lispify(t.substring(r[0].length),expectTypes[n].next,new Lisp({op:i[1],a:i[2]})):s.lispTree=new Lisp({op:i[1],a:i[2],b:lispify(t.substring(r[0].length+1),expectTypes[n].next)})}),setLispType(["arrowFunc"],(e,t,r,n,s)=>{let i=r[1]?r[1].split(","):[];if(r[2]){if("("!==r[0][0])throw new Error("Unstarted inline function brackets: "+r[0])}else i.length&&(i=[i.pop()]);const o=(r[3]?"":" return ")+restOfExp(t.substring(r[0].length),r[3]?[/^}/]:[/^[,;\)\}\]]/]);s.lispTree=lispify(t.substring(r[0].length+o.length+1),expectTypes[n].next,new Lisp({op:"arrowFunc",a:i,b:Sandbox.parse(o,null).tree}))});let optimizeTypes={},setOptimizeType=(e,t)=>{e.forEach(e=>{optimizeTypes[e]=t})};function optimize(e,t,r){if(!(e instanceof Lisp)){if(Array.isArray(e)){for(let n=0;n<e.length;n++)e[n]=optimize(e[n],t,r);return e}return e}return e.a=optimize(e.a,t,r),e.b=optimize(e.b,t,r),e.a instanceof Lisp||e.b instanceof Lisp||!optimizeTypes[e.op]?e:optimizeTypes[e.op](e,t,r)}setOptimizeType([">","<",">=","<=","==","===","!=","!==","&&","||","&","|","+","-","/","*","**","%","$+","$-","!","~","group"],e=>ops.get(e.op)(e.a,e.b)),setOptimizeType(["createArray"],e=>e.b.find(e=>e instanceof Lisp)?e:ops.get(e.op)(e.a,e.b)),setOptimizeType(["prop"],e=>"number"==typeof e.b&&e.b%1==0?e.a[e.b]:e);export default class Sandbox{constructor(e={},t=new Map,r={audit:!1}){const n=new SandboxGlobal(e);this.context={sandbox:this,globals:e,prototypeWhitelist:t,options:r,globalScope:new Scope(null,e,n),sandboxGlobal:n,Function:()=>()=>{},eval:()=>{},auditReport:{prototypeAccess:{},globalsAccess:new Set}},this.context.Function=sandboxFunction(this.context),this.context.eval=sandboxedEval(this.context.Function)}static get SAFE_GLOBALS(){return{Function:Function,console:console,isFinite:isFinite,isNaN:isNaN,parseFloat:parseFloat,parseInt:parseInt,decodeURI:decodeURI,decodeURIComponent:decodeURIComponent,encodeURI:encodeURI,encodeURIComponent:encodeURIComponent,escape:escape,unescape:unescape,Boolean:Boolean,Number:Number,String:String,Object:Object,Array:Array,Symbol:Symbol,Error:Error,EvalError:EvalError,RangeError:RangeError,ReferenceError:ReferenceError,SyntaxError:SyntaxError,TypeError:TypeError,URIError:URIError,Int8Array:Int8Array,Uint8Array:Uint8Array,Uint8ClampedArray:Uint8ClampedArray,Int16Array:Int16Array,Uint16Array:Uint16Array,Int32Array:Int32Array,Uint32Array:Uint32Array,Float32Array:Float32Array,Float64Array:Float64Array,Map:Map,Set:Set,WeakMap:WeakMap,WeakSet:WeakSet,Promise:Promise,Intl:Intl,JSON:JSON,Math:Math}}static get SAFE_PROTOTYPES(){let e=[SandboxGlobal,Function,Boolean,Object,Number,String,Date,RegExp,Error,Array,Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array,Map,Set,WeakMap,WeakSet,Promise],t=new Map;return e.forEach(e=>{t.set(e,[])}),t}static audit(e,t=[]){let r=new Map;return new Sandbox(globalThis,r,{audit:!0}).executeTree(Sandbox.parse(e),t)}static parse(e,t=[],r=[]){let n,s=e,i="",o=!1,p=[],a=[];if(t){let e=0;for(let l=0;l<s.length;l++){let c=s[l];if(o)if("$"===c&&"`"===n)e--,c="$$";else if("u"===c){let e,t=/^[a-fA-F\d]{2,4}/.exec(s.substring(l+1));e=t?Array.from(t):Array.from(/^{[a-fA-F\d]+}/.exec(s.substring(l+1))||[""]),c=JSON.parse(`"\\u${e[0]}"`),s=s.substring(0,l-1)+c+s.substring(l+(1+e[0].length)),l-=1}else"`"!=c&&(c=JSON.parse(`"\\${c}"`));else"$"===c&&"`"===n&&"{"!==s[l+1]&&(e--,c="$$");if("`"===n&&"$"===c&&"{"===s[l+1]){let t=restOfExp(s.substring(l+2),[/^}/]);a.push(t),e+=t.length+3,i+=`\${${a.length-1}}`,l+=t.length+2}else if(n||"'"!==c&&'"'!==c&&"`"!==c||o)if(n!==c||o)n&&(o||"\\"!==c)&&(e+=o?1+c.length:c.length,i+=c);else{let o;"`"===n?(r.push({op:"literal",a:i,b:a}),p.push(a),s=s.substring(0,l-e-1)+`\`${r.length-1}\``+s.substring(l+1),o=(r.length-1).toString().length):(t.push(i),s=s.substring(0,l-i.length-1)+`"${t.length-1}"`+s.substring(l+1),o=(t.length-1).toString().length),n=null,l-=i.length-o,i=""}else a=[],e=0,n=c;o=n&&!o&&"\\"===c}s=s.replace(/(?<=(^|[^\w_$]))(var|let|const|typeof|return|instanceof|in)(?=([^\w_$]|$))/g,e=>`#${e}#`).replace(/\s/g,"").replace(/#/g," ")}p.forEach(e=>{const n=e.map(e=>this.parse(e,t,r).tree[0]);e.length=0,e.push(...n)});let l,c=[],f=0;for(;l=restOfExp(s.substring(f),[/^;/]);)c.push(l),f+=l.length+1;return c=c.filter(Boolean),{tree:c.filter(e=>e.length).map(e=>lispify(e)).map(e=>optimize(e,t,r)),strings:t,literals:r}}executeTree(e,t=[]){const r=e.tree,n={...this.context,strings:e.strings,literals:e.literals};let s,i=this.context.globalScope;for(;s=t.shift();)"object"==typeof s&&(i=s instanceof Scope?s:new Scope(i,s));let o=Object.assign({},n);n.options.audit&&(o.auditReport={globalsAccess:new Set,prototypeAccess:{}});let p,a=!1;if(!(r instanceof Array))throw new Error("Bad execution tree");return r.map(e=>{if(!a){const t=exec(e,i,o);e instanceof Lisp&&"return"===e.op&&(a=!0,p=t)}return null}),p=p instanceof Prop?p.context[p.prop]:p,{auditReport:o.auditReport,result:p}}compile(e){const t=Sandbox.parse(e);return(...e)=>this.executeTree(t,e).result}}