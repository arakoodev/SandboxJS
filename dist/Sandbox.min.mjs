class Prop{constructor(e,t,r=!1,n=!1,s=!1){this.context=e,this.prop=t,this.isConst=r,this.isGlobal=n,this.isVariable=s}}class Lisp{constructor(e){this.op=e.op,this.a=e.a,this.b=e.b}}class If{constructor(e,t){this.t=e,this.f=t}}class KeyVal{constructor(e,t){this.key=e,this.val=t}}class ObjectFunc{constructor(e,t,r){this.key=e,this.args=t,this.tree=r}}class SpreadObject{constructor(e){this.item=e}}class SpreadArray{constructor(e){this.item=e}}var VarType;!function(e){e.let="let",e.const="const",e.var="var"}(VarType||(VarType={}));class Scope{constructor(e,t={},r){this.const=new Set,this.let=new Set,this.parent=e,this.allVars=t,this.var=new Set(Object.keys(t)),this.globals=e?new Set:new Set(Object.keys(t)),this.functionThis=r||!e,r&&this.declare("this",VarType.var,r)}get(e,t=!1){if(!this.parent||!t||this.functionThis){if(this.globals.has(e))return new Prop(this.functionThis,e,!1,!0,!0);if(e in this.allVars&&(!(e in{})||this.allVars.hasOwnProperty(e)))return new Prop(this.allVars,e,this.const.has(e),this.globals.has(e),!0);if(!this.parent)return new Prop(void 0,e)}return this.parent.get(e,t)}set(e,t){if("this"===e)throw new SyntaxError('"this" cannot be a variable');let r=this.get(e);if(void 0===r.context)throw new ReferenceError(`Variable '${e}' was not declared.`);if(r.isConst)throw new TypeError(`Cannot assign to const variable '${e}'`);if(r.isGlobal)throw new SandboxError(`Cannot override global variable '${e}'`);return r.context[r]=t,r}declare(e,t=null,r,n=!1){if("var"===t&&!this.functionThis&&this.parent)return this.parent.declare(e,t,r,n);if(this.var.has(e)&&this.let.has(e)&&this.const.has(e)&&this.globals.has(e))throw Error(`Variable '${e}' already declared`);return n&&this.globals.add(e),this[t].add(e),this.allVars[e]=r,new Prop(this.allVars,e,this.const.has(e),n)}}class ParseError extends Error{constructor(e,t){super(e),this.code=t}}class SandboxError extends Error{}class SandboxGlobal{constructor(e){if(e===globalThis)return globalThis;for(let t in e)this[t]=e[t]}}function sandboxFunction(e){return function SandboxFunction(...t){let r=t.pop(),n=Sandbox.parse(r);return function(...r){const s={};for(let e of t)s[e]=r.shift();const o=e.sandbox.executeTree(n);if(e.options.audit){for(let t in o.auditReport.globalsAccess){let r=o.auditReport.globalsAccess[t];e.auditReport.globalsAccess[t]=e.auditReport.globalsAccess[t]||new Set,r.forEach(r=>{e.auditReport.globalsAccess[t].add(r)})}for(let t in o.auditReport.prototypeAccess){let r=o.auditReport.prototypeAccess[t];e.auditReport.prototypeAccess[t]=e.auditReport.prototypeAccess[t]||new Set,r.forEach(r=>{e.auditReport.prototypeAccess[t].add(r)})}}return o.result}}}function sandboxedEval(e){return function(t){return e(t)()}}function sandboxedSetTimeout(e){return function(t,...r){return"string"!=typeof t?setTimeout(t,...r):setTimeout(e(t),r[0])}}function sandboxedSetInterval(e){return function(t,...r){return"string"!=typeof t?setInterval(t,...r):setTimeout(e(t),r[0])}}let expectTypes={op:{types:{op:/^(\/|\*\*(?!\=)|\*(?!\=)|\%(?!\=))/},next:["value","prop","exp","modifier","incrementerBefore"]},splitter:{types:{split:/^(&&|&|\|\||\||<=|>=|<|>|!==|!=|===|==| instanceof | in |\+(?!\+)|\-(?!\-))(?!\=)/},next:["value","prop","exp","modifier","incrementerBefore"]},if:{types:{if:/^\?/,else:/^:/},next:["expEnd"]},assignment:{types:{assignModify:/^(\-=|\+=|\/=|\*\*=|\*=|%=|\^=|\&=|\|=)/,assign:/^(=)/},next:["value","function","prop","exp","modifier","incrementerBefore"]},incrementerBefore:{types:{incrementerBefore:/^(\+\+|\-\-)/},next:["prop"]},incrementerAfter:{types:{incrementerAfter:/^(\+\+|\-\-)/},next:["splitter","op","expEnd"]},expEdge:{types:{call:/^[\(]/},next:["splitter","op","expEdge","if","dot","expEnd"]},modifier:{types:{not:/^!/,inverse:/^~/,negative:/^\-(?!\-)/,positive:/^\+(?!\+)/,typeof:/^ typeof /,delete:/^ delete /},next:["exp","modifier","value","prop","incrementerBefore"]},exp:{types:{createObject:/^\{/,createArray:/^\[/,group:/^\(/},next:["splitter","op","expEdge","if","dot","expEnd"]},dot:{types:{arrayProp:/^[\[]/,dot:/^\.(?!\.)/},next:["splitter","incrementerAfter","assignment","op","expEdge","if","dot","expEnd"]},prop:{types:{prop:/^[a-zA-Z\$_][a-zA-Z\d\$_]*/},next:["splitter","incrementerAfter","assignment","op","expEdge","if","dot","expEnd"]},value:{types:{number:/^\-?\d+(\.\d+)?/,string:/^"(\d+)"/,literal:/^`(\d+)`/,boolean:/^(true|false)(?![\w$_])/,null:/^null(?![\w$_])/,und:/^undefined(?![\w$_])/,NaN:/^NaN(?![\w$_])/,Infinity:/^Infinity(?![\w$_])/},next:["splitter","op","if","dot","expEnd"]},function:{types:{arrowFunc:/^\(?(((\.\.\.)?[a-zA-Z\$_][a-zA-Z\d\$_]*,?)*)(\))?=>({)?/},next:["expEnd"]},initialize:{types:{initialize:/^ (var|let|const) [a-zA-Z\$_][a-zA-Z\d\$_]*/},next:["value","function","prop","exp","modifier","incrementerBefore","expEnd"]},spreadObject:{types:{spreadObject:/^\.\.\./},next:["value","exp","prop"]},spreadArray:{types:{spreadArray:/^\.\.\./},next:["value","exp","prop"]},expEnd:{types:{},next:[]},expStart:{types:{return:/^ return /},next:["value","function","prop","exp","modifier","incrementerBefore","expEnd"]}},closings={"(":")","[":"]","{":"}","'":"'",'"':'"',"`":"`"},closingsRegex={"(":/^\)/,"[":/^\]/,"{":/^\}/,"'":/^\'/,'"':/^\"/,"`":/^\`/};const okFirstChars=/^[\+\-~ !]/,restOfExp=(e,t,r)=>{let n=!0;t=t||[expectTypes.op.types.op,expectTypes.splitter.types.split,expectTypes.if.types.if,expectTypes.if.types.else];let s,o=!1,i=!1;for(s=0;s<e.length&&!i;s++){let p=e[s];if('"'===r||"'"===r||"`"===r){if("`"!==r||"$"!==p||"{"!==e[s+1]||o){if(p===r&&!o)return e.substring(0,s)}else{s+=restOfExp(e.substring(s+2),[closingsRegex["{"]]).length+2}o="\\"===p}else if(closings[p]){s+=restOfExp(e.substring(s+1),[closingsRegex[r]],p).length+1,n=!1}else if(r){if(p===closings[r])return e.substring(0,s)}else{let r=e.substring(s);for(let e of t)if(i=e.test(r),i)break;if(n&&(okFirstChars.test(r)?i=!1:n=!1),i)break}}return e.substring(0,s)};function assignCheck(e,t,r="assign"){var n,s,o,i;if(void 0===e.context)throw new ReferenceError(`Cannot ${r} value to undefined.`);if("object"!=typeof e.context&&"function"!=typeof e.context)throw new SyntaxError(`Cannot ${r} value to a primitive.`);if(e.isConst)throw new TypeError(`Cannot set value to const variable '${e.prop}'`);if(e.isGlobal)throw new SandboxError(`Cannot ${r} property '${e.prop}' of a global object`);if("function"==typeof e.context[e.prop]&&!e.context.hasOwnProperty(e.prop))throw new SandboxError(`Override prototype property '${e.prop}' not allowed`);"delete"===r?e.context.hasOwnProperty(e.prop)&&(null===(n=t.changeSubscriptions.get(e.context))||void 0===n||n.forEach(t=>t({type:"delete",prop:e.prop}))):e.context.hasOwnProperty(e.prop)?null===(o=null===(s=t.setSubscriptions.get(e.context))||void 0===s?void 0:s.get(e.prop))||void 0===o||o.forEach(e=>e({type:"replace"})):null===(i=t.changeSubscriptions.get(e.context))||void 0===i||i.forEach(t=>t({type:"create",prop:e.prop}))}restOfExp.next=["splitter","op","expEnd","if"];const arrayChange=new Set([[].push,[].pop,[].shift,[].unshift,[].splice,[].reverse,[].sort,[].copyWithin]);let ops2={prop:(e,t,r,n,s)=>{if(null===e)throw new TypeError(`Cannot get property ${t} of null`);const o=typeof e;if("undefined"===o){let e=s.get(t);if(void 0===e.context)throw new ReferenceError(t+" is not defined");if(e.context===n.sandboxGlobal){n.options.audit&&n.auditReport.globalsAccess.add(t);const e=n.evals.get(n.sandboxGlobal[t]);if(e)return e}return e.context&&e.context[t]===globalThis?n.globalScope.get("this"):(n.getSubscriptions.forEach(t=>t(e.context,e.prop)),e)}if("object"!==o)"number"===o?e=new Number(e):"string"===o?e=new String(e):"boolean"===o&&(e=new Boolean(e));else if(void 0===e.hasOwnProperty)return new Prop(void 0,t);const i="function"===o;let p=i||!(e.hasOwnProperty(t)||"number"==typeof t);if(n.options.audit&&p&&"string"==typeof t){let r=e.constructor.prototype;do{r.hasOwnProperty(t)&&(n.auditReport.prototypeAccess[r.constructor.name]||(n.auditReport.prototypeAccess[r.constructor.name]=new Set),n.auditReport.prototypeAccess[r.constructor.name].add(t))}while(r=Object.getPrototypeOf(r))}if(p)if(i){if(!["name","length","constructor"].includes(t)&&e.hasOwnProperty(t)){const r=n.prototypeWhitelist.get(e),s=n.prototypeReplacements.get(e);if(s)return new Prop(s(e,!0),t);if(!r||r.size&&!r.has(t))throw new SandboxError(`Static method or property access not permitted: ${e.name}.${t}`)}}else if("constructor"!==t){let r=e.constructor.prototype;do{if(r.hasOwnProperty(t)){const s=n.prototypeWhitelist.get(r.constructor),o=n.prototypeReplacements.get(r.constuctor);if(o)return new Prop(o(e,!1),t);if(s&&(!s.size||s.has(t)))break;throw new SandboxError(`Method or property access not permitted: ${r.constructor.name}.${t}`)}}while(r=Object.getPrototypeOf(r))}const a=n.evals.get(e[t]);if(a)return a;if(e[t]===globalThis)return n.globalScope.get("this");let l=r.isGlobal||i&&"sandboxArrowFunction"!==e.name||n.globalsWhitelist.has(e);return l||n.getSubscriptions.forEach(r=>r(e,t)),new Prop(e,t,!1,l)},call:(e,t,r,n,s)=>{var o;if(n.options.forbidMethodCalls)throw new SandboxError("Method calls are not allowed");if("function"!=typeof e)throw new TypeError(r.prop+" is not a function");const i=t.map(e=>e instanceof SpreadArray?[...e.item]:[e]).flat();if("function"==typeof r)return r(...i.map(e=>exec(e,s,n)));const p=i.map(e=>exec(e,s,n));if(r.context[r.prop]===JSON.stringify&&n.getSubscriptions.size){const e=new Set,t=r=>{if(r&&"object"==typeof r&&!e.has(r)){e.add(r);for(let e in r)n.getSubscriptions.forEach(t=>t(r,e)),t(r[e])}};t(p[0])}if(r.context instanceof Array&&arrayChange.has(r.context[r.prop])&&n.changeSubscriptions.get(r.context)){let e,t=!1;if("push"===r.prop)e={type:"push",added:p},t=!!p.length;else if("pop"===r.prop)e={type:"pop",removed:r.context.slice(-1)},t=!!e.removed.length;else if("shift"===r.prop)e={type:"shift",removed:r.context.slice(0,1)},t=!!e.removed.length;else if("unshift"===r.prop)e={type:"unshift",added:p},t=!!p.length;else if("splice"===r.prop)e={type:"splice",startIndex:p[0],deleteCount:void 0===p[1]?r.context.length:p[1],added:p.slice(2),removed:r.context.slice(p[0],void 0===p[1]?void 0:p[0]+p[1])},t=!!e.added.length||!!e.removed.length;else if("reverse"===r.prop||"sort"===r.prop)e={type:r.prop},t=!!r.context.length;else if("copyWithin"===r.prop){let n=void 0===p[2]?r.context.length-p[1]:Math.min(r.context.length,p[2]-p[1]);e={type:"copyWithin",startIndex:p[0],endIndex:p[0]+n,added:r.context.slice(p[1],p[1]+n),removed:r.context.slice(p[0],p[0]+n)},t=!!e.added.length||!!e.removed.length}return t&&(null===(o=n.changeSubscriptions.get(r.context))||void 0===o||o.forEach(t=>t(e))),r.context[r.prop](...p)}return r.context[r.prop](...i.map(e=>exec(e,s,n)))},createObject:(e,t,r,n,s)=>{let o={};for(let e of t)if(e instanceof SpreadObject)o={...o,...e.item};else if(e instanceof ObjectFunc){let t=e;o[t.key]=function(...e){const r={};return t.args.forEach((t,n)=>{r[t]=e[n]}),n.sandbox.executeTree({tree:t.tree,strings:n.strings,literals:n.literals},[new Scope(s,r,this)]).result}}else o[e.key]=e.val;return o},keyVal:(e,t)=>new KeyVal(e,t),createArray:(e,t,r,n,s)=>t.map(e=>e instanceof SpreadArray?[...e.item]:[e]).flat().map(e=>exec(e,s,n)),group:(e,t)=>t,string:(e,t,r,n)=>n.strings[t],literal:(e,t,r,n,s)=>n.literals[t].a.replace(/(\$\$)*(\$)?\${(\d+)}/g,(e,r,o,i)=>{if(o)return e;let p=exec(n.literals[t].b[parseInt(i,10)],s,n);return p=p instanceof Prop?p.context[p.prop]:p,(r||"")+(""+p).replace(/\$/g,"$$")}).replace(/\$\$/g,"$"),spreadArray:(e,t,r,n,s)=>new SpreadArray(exec(t,s,n)),spreadObject:(e,t,r,n,s)=>new SpreadObject(exec(t,s,n)),"!":(e,t)=>!t,"~":(e,t)=>~t,"++$":(e,t,r,n)=>(assignCheck(r,n),++r.context[r.prop]),"$++":(e,t,r,n)=>(assignCheck(r,n),r.context[r.prop]++),"--$":(e,t,r,n)=>(assignCheck(r,n),--r.context[r.prop]),"$--":(e,t,r,n)=>(assignCheck(r,n),r.context[r.prop]--),"=":(e,t,r,n)=>(assignCheck(r,n),r.context[r.prop]=t,new Prop(r.context,r.prop,!1,r.isGlobal)),"+=":(e,t,r,n)=>(assignCheck(r,n),r.context[r.prop]+=t),"-=":(e,t,r,n)=>(assignCheck(r,n),r.context[r.prop]-=t),"/=":(e,t,r,n)=>(assignCheck(r,n),r.context[r.prop]/=t),"*=":(e,t,r,n)=>(assignCheck(r,n),r.context[r.prop]*=t),"**=":(e,t,r,n)=>(assignCheck(r,n),r.context[r.prop]**=t),"%=":(e,t,r,n)=>(assignCheck(r,n),r.context[r.prop]%=t),"^=":(e,t,r,n)=>(assignCheck(r,n),r.context[r.prop]^=t),"&=":(e,t,r,n)=>(assignCheck(r,n),r.context[r.prop]&=t),"|=":(e,t,r,n)=>(assignCheck(r,n),r.context[r.prop]|=t),"?":(e,t)=>{if(!(t instanceof If))throw new SyntaxError("Invalid inline if");return e?t.t:t.f},">":(e,t)=>e>t,"<":(e,t)=>e<t,">=":(e,t)=>e>=t,"<=":(e,t)=>e<=t,"==":(e,t)=>e==t,"===":(e,t)=>e===t,"!=":(e,t)=>e!=t,"!==":(e,t)=>e!==t,"&&":(e,t)=>e&&t,"||":(e,t)=>e||t,"&":(e,t)=>e&t,"|":(e,t)=>e|t,":":(e,t)=>new If(e,t),"+":(e,t)=>e+t,"-":(e,t)=>e-t,"$+":(e,t)=>+t,"$-":(e,t)=>-t,"/":(e,t)=>e/t,"*":(e,t)=>e*t,"%":(e,t)=>e%t," typeof ":(e,t)=>typeof t," instanceof ":(e,t)=>e instanceof t," in ":(e,t)=>e in t," delete ":(e,t,r,n,s,o)=>void 0===o.context||(assignCheck(o,n,"delete"),!o.isVariable&&delete o.context[o.prop]),return:(e,t)=>t,var:(e,t,r,n,s,o)=>s.declare(e,VarType.var,exec(t,s,n)),let:(e,t,r,n,s,o)=>s.declare(e,VarType.let,exec(t,s,n),o&&o.isGlobal),const:(e,t,r,n,s,o)=>s.declare(e,VarType.const,exec(t,s,n)),arrowFunc:(e,t,r,n,s)=>(...r)=>{const o={};return e.forEach((e,t)=>{e.startsWith("...")?o[e.substring(3)]=r.slice(t):o[e]=r[t]}),n.sandbox.executeTree({tree:t,strings:n.strings,literals:n.literals},[new Scope(s,o)]).result}},ops=new Map;for(let e in ops2)ops.set(e,ops2[e]);let lispTypes=new Map;const setLispType=(e,t)=>{e.forEach(e=>{lispTypes.set(e,t)})},closingsCreate={createArray:/^\]/,createObject:/^\}/,group:/^\)/,arrayProp:/^\]/,call:/^\)/};setLispType(["createArray","createObject","group","arrayProp","call"],(e,t,r,n,s)=>{let o="",i=[],p=!1,a=1;for(;a<t.length&&!p;)o=restOfExp(t.substring(a),[closingsCreate[e],/^,/]),a+=o.length,o&&i.push(o),","!==t[a]?p=!0:a++;const l=["value","function","prop","exp","modifier","incrementerBefore"];let c,f;const u=/^([a-zA-Z\$_][a-zA-Z\d\$_]*)\((([a-zA-Z\$_][a-zA-Z\d\$_]*,?)*)\)?{/;switch(e){case"group":case"arrayProp":c=lispify(i.pop());break;case"call":case"createArray":c=i.map(e=>lispify(e,[...l,"spreadArray"]));break;case"createObject":c=i.map(e=>{let t,r;if(f=u.exec(e),f){let t=f[2]?f[2].split(","):[];const r=restOfExp(e.substring(f.index+f[0].length),[/^}/]);return new ObjectFunc(f[1],t,Sandbox.parse(r,null).tree)}{let n=restOfExp(e,[/^:/]);if(r=lispify(n,[...l,"spreadObject"]),r instanceof Lisp&&"prop"===r.op&&(r=r.b),n.length===e.length)return r;t=lispify(e.substring(n.length+1))}return new Lisp({op:"keyVal",a:r,b:t})})}e="arrayProp"===e?"prop":e,s.lispTree=lispify(t.substring(a+1),expectTypes[n].next,new Lisp({op:e,a:s.lispTree,b:c}))}),setLispType(["inverse","not","negative","positive","typeof","delete","op"],(e,t,r,n,s)=>{let o=restOfExp(t.substring(r[0].length));s.lispTree=lispify(t.substring(o.length+r[0].length),restOfExp.next,new Lisp({op:["positive","negative"].includes(e)?"$"+r[0]:r[0],a:s.lispTree,b:lispify(o,expectTypes[n].next)}))}),setLispType(["incrementerBefore"],(e,t,r,n,s)=>{let o=restOfExp(t.substring(2));s.lispTree=lispify(t.substring(o.length+2),restOfExp.next,new Lisp({op:r[0]+"$",a:lispify(o,expectTypes[n].next)}))}),setLispType(["incrementerAfter"],(e,t,r,n,s)=>{s.lispTree=lispify(t.substring(r[0].length),expectTypes[n].next,new Lisp({op:"$"+r[0],a:s.lispTree}))}),setLispType(["assign","assignModify"],(e,t,r,n,s)=>{s.lispTree=new Lisp({op:r[0],a:s.lispTree,b:lispify(t.substring(r[0].length),expectTypes[n].next)})}),setLispType(["split"],(e,t,r,n,s)=>{let o=restOfExp(t.substring(r[0].length),[expectTypes.splitter.types.split,expectTypes.if.types.if,expectTypes.if.types.else]);s.lispTree=lispify(t.substring(o.length+r[0].length),restOfExp.next,new Lisp({op:r[0],a:s.lispTree,b:lispify(o,expectTypes[n].next)}))}),setLispType(["if"],(e,t,r,n,s)=>{let o=!1,i="",p=1;for(;!o&&i.length<t.length;)i+=restOfExp(t.substring(i.length+1),[expectTypes.if.types.if,expectTypes.if.types.else]),"?"===t[i.length+1]?p++:p--,p?i+=t[i.length+1]:o=!0;s.lispTree=new Lisp({op:"?",a:s.lispTree,b:new Lisp({op:":",a:lispify(i),b:lispify(t.substring(r[0].length+i.length+1))})})}),setLispType(["dot","prop"],(e,t,r,n,s)=>{let o=r[0],i=r[0].length;if("."===r[0]){let e=t.substring(r[0].length).match(expectTypes.prop.types.prop);if(!e.length)throw Error("Hanging  dot:"+t);o=e[0],i=o.length+r[0].length}s.lispTree=lispify(t.substring(i),expectTypes[n].next,new Lisp({op:"prop",a:s.lispTree,b:o}))}),setLispType(["spreadArray","spreadObject","return"],(e,t,r,n,s)=>{s.lispTree=new Lisp({op:e,b:lispify(t.substring(r[0].length),expectTypes[n].next)})}),setLispType(["number","boolean","null"],(e,t,r,n,s)=>{s.lispTree=lispify(t.substring(r[0].length),expectTypes[n].next,JSON.parse(r[0]))});const constants={NaN:NaN,Infinity:1/0};let lastType;function lispify(e,t,r){if(t=t||["initialize","expStart","value","function","prop","exp","modifier","incrementerBefore","expEnd"],void 0===e)return r;if(!e.length&&!t.includes("expEnd"))throw new SyntaxError("Unexpected end of expression");let n,s={lispTree:r};for(let r of t)if("expEnd"!==r){for(let t in expectTypes[r].types)if("expEnd"!==t&&(n=expectTypes[r].types[t].exec(e))){lastType=t,lispTypes.get(t)(t,e,n,r,s);break}if(n)break}if(!n&&e.length)throw Error(`Unexpected token (${lastType}): ${e}`);return s.lispTree}function exec(e,t,r){if(e instanceof Prop)return e.context[e.prop];if(Array.isArray(e))return e.map(e=>exec(e,t,r));if(!(e instanceof Lisp))return e;if("arrowFunc"===e.op)return ops.get(e.op)(e.a,e.b,void 0,r,t);let n=exec(e.a,t,r),s=n instanceof Prop?n.context?n.context[n.prop]:void 0:n,o=exec(e.b,t,r),i=o instanceof Prop?o.context?o.context[o.prop]:void 0:o;if(ops.has(e.op)){return ops.get(e.op)(s,i,n,r,t,o)}throw new SyntaxError("Unknown operator: "+e.op)}setLispType(["und","NaN","Infinity"],(e,t,r,n,s)=>{s.lispTree=lispify(t.substring(r[0].length),expectTypes[n].next,constants[e])}),setLispType(["string","literal"],(e,t,r,n,s)=>{s.lispTree=lispify(t.substring(r[0].length),expectTypes[n].next,new Lisp({op:e,b:parseInt(JSON.parse(r[1]),10)}))}),setLispType(["initialize"],(e,t,r,n,s)=>{const o=r[0].split(/ /g);t.length===r[0].length?s.lispTree=lispify(t.substring(r[0].length),expectTypes[n].next,new Lisp({op:o[1],a:o[2]})):s.lispTree=new Lisp({op:o[1],a:o[2],b:lispify(t.substring(r[0].length+1),expectTypes[n].next)})}),setLispType(["arrowFunc"],(e,t,r,n,s)=>{let o=r[1]?r[1].split(","):[];if(r[4]){if("("!==r[0][0])throw new SyntaxError("Unstarted inline function brackets: "+r[0])}else o.length&&(o=[o.pop()]);let i=!1;o.forEach(e=>{if(i)throw new SyntaxError("Rest parameter must be last formal parameter");e.startsWith("...")&&(i=!0)});const p=(r[5]?"":" return ")+restOfExp(t.substring(r[0].length),r[5]?[/^}/]:[/^[,;\)\}\]]/]);s.lispTree=lispify(t.substring(r[0].length+p.length+1),expectTypes[n].next,new Lisp({op:"arrowFunc",a:o,b:Sandbox.parse(p,null).tree}))});export default class Sandbox{constructor(globals=Sandbox.SAFE_GLOBALS,prototypeWhitelist=Sandbox.SAFE_PROTOTYPES,prototypeReplacements=new Map,options={audit:!1}){const sandboxGlobal=new SandboxGlobal(globals);this.context={sandbox:this,globals:globals,prototypeWhitelist:prototypeWhitelist,prototypeReplacements:prototypeReplacements,globalsWhitelist:new Set(Object.values(globals)),options:options,globalScope:new Scope(null,globals,sandboxGlobal),sandboxGlobal:sandboxGlobal,evals:new Map,getSubscriptions:new Set,setSubscriptions:new WeakMap,changeSubscriptions:new WeakMap};const func=sandboxFunction(this.context);this.context.evals.set(Function,func),this.context.evals.set(eval,sandboxedEval(func)),this.context.evals.set(setTimeout,sandboxedSetTimeout(func)),this.context.evals.set(setInterval,sandboxedSetInterval(func))}static get SAFE_GLOBALS(){return{Function:Function,console:{debug:console.debug,error:console.error,info:console.info,log:console.log,table:console.table,warn:console.warn},isFinite:isFinite,isNaN:isNaN,parseFloat:parseFloat,parseInt:parseInt,decodeURI:decodeURI,decodeURIComponent:decodeURIComponent,encodeURI:encodeURI,encodeURIComponent:encodeURIComponent,escape:escape,unescape:unescape,Boolean:Boolean,Number:Number,String:String,Object:Object,Array:Array,Symbol:Symbol,Error:Error,EvalError:EvalError,RangeError:RangeError,ReferenceError:ReferenceError,SyntaxError:SyntaxError,TypeError:TypeError,URIError:URIError,Int8Array:Int8Array,Uint8Array:Uint8Array,Uint8ClampedArray:Uint8ClampedArray,Int16Array:Int16Array,Uint16Array:Uint16Array,Int32Array:Int32Array,Uint32Array:Uint32Array,Float32Array:Float32Array,Float64Array:Float64Array,Map:Map,Set:Set,WeakMap:WeakMap,WeakSet:WeakSet,Promise:Promise,Intl:Intl,JSON:JSON,Math:Math}}static get SAFE_PROTOTYPES(){let e=[SandboxGlobal,Function,Boolean,Number,String,Date,RegExp,Error,Array,Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array,Map,Set,WeakMap,WeakSet,Promise],t=new Map;return e.forEach(e=>{t.set(e,new Set)}),t.set(Object,new Set(["entries","fromEntries","getOwnPropertyNames","is","keys","hasOwnProperty","isPrototypeOf","propertyIsEnumerable","toLocaleString","toString","valueOf","values"])),t}subscribeGet(e){return this.context.getSubscriptions.add(e),{unsubscribe:()=>this.context.getSubscriptions.delete(e)}}subscribeSet(e,t,r){const n=this.context.setSubscriptions.get(e)||new Map;this.context.setSubscriptions.set(e,n);const s=n.get(t)||new Set;let o;return n.set(t,s),s.add(r),e&&e[t]&&"object"==typeof e[t]&&(o=this.context.changeSubscriptions.get(e[t])||new Set,o.add(r),this.context.changeSubscriptions.set(e[t],o)),{unsubscribe:()=>{s.delete(r),o&&o.delete(r)}}}static audit(e,t=[]){return new Sandbox(globalThis,new Map,new Map,{audit:!0}).executeTree(Sandbox.parse(e),t)}static parse(e,t=[],r=[]){if("string"!=typeof e)throw new ParseError("Cannot parse "+e,e);let n,s=e,o="",i=!1,p=[],a=[];if(t){let e=0;for(let l=0;l<s.length;l++){let c=s[l];if(i)if("$"===c&&"`"===n)e--,c="$$";else if("u"===c){let e,t=/^[a-fA-F\d]{2,4}/.exec(s.substring(l+1));e=t?Array.from(t):Array.from(/^{[a-fA-F\d]+}/.exec(s.substring(l+1))||[""]),c=JSON.parse(`"\\u${e[0]}"`),s=s.substring(0,l-1)+c+s.substring(l+(1+e[0].length)),l-=1}else"`"!=c&&(c=JSON.parse(`"\\${c}"`));else"$"===c&&"`"===n&&"{"!==s[l+1]&&(e--,c="$$");if("`"===n&&"$"===c&&"{"===s[l+1]){let t=restOfExp(s.substring(l+2),[/^}/]);a.push(t),e+=t.length+3,o+=`\${${a.length-1}}`,l+=t.length+2}else if(n||"'"!==c&&'"'!==c&&"`"!==c||i)if(n!==c||i)n&&(i||"\\"!==c)&&(e+=i?1+c.length:c.length,o+=c);else{let i;"`"===n?(r.push({op:"literal",a:o,b:a}),p.push(a),s=s.substring(0,l-e-1)+`\`${r.length-1}\``+s.substring(l+1),i=(r.length-1).toString().length):(t.push(o),s=s.substring(0,l-o.length-1)+`"${t.length-1}"`+s.substring(l+1),i=(t.length-1).toString().length),n=null,l-=o.length-i,o=""}else a=[],e=0,n=c;i=n&&!i&&"\\"===c}s=s.replace(/([^\w_$]|^)((var|let|const|typeof|return|instanceof|in|delete)(?=[^\w_$]|$))/g,(e,t,r)=>{if(r.length!==r.trim().length)throw new Error(r);return`${t}#${r}#`}).replace(/\s/g,"").replace(/#/g," "),p.forEach(e=>{const n=e.map(e=>this.parse(e,t,r).tree[0]);e.length=0,e.push(...n)})}let l,c=[],f=0;for(;l=restOfExp(s.substring(f),[/^;/]);)c.push(l),f+=l.length+1;c=c.filter(Boolean);return{tree:c.filter(e=>e.length).map(e=>{let t,r=[],n=0;for(;t=restOfExp(e.substring(n),[/^,/]);)r.push(t),n+=t.length+1;try{const e=r.map(e=>lispify(e));if(e.length>1&&e[0]instanceof Lisp&&"return"===e[0].op){const t=e.pop();return[e.shift().b,...e,new Lisp({op:"return",b:t})]}return e}catch(t){throw new ParseError(t.message+": "+e,e)}}).flat(),strings:t,literals:r}}executeTree(e,t=[]){const r=e.tree,n={...this.context,strings:e.strings,literals:e.literals};let s,o=this.context.globalScope;for(;s=t.shift();)"object"==typeof s&&(o=s instanceof Scope?s:new Scope(o,s));let i=Object.assign({},n);n.options.audit&&(i.auditReport={globalsAccess:new Set,prototypeAccess:{}});let p,a=!1;if(!(r instanceof Array))throw new SyntaxError("Bad execution tree");return r.map(e=>{if(!a){let t;try{t=exec(e,o,i)}catch(e){throw new e.constructor(e.message)}e instanceof Lisp&&"return"===e.op&&(a=!0,p=t)}return null}),p=p instanceof Prop?p.context[p.prop]:p,{auditReport:i.auditReport,result:p}}compile(e){const t=Sandbox.parse(e);return(...e)=>this.executeTree(t,e).result}}