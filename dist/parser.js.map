{"version":3,"file":"parser.js","sources":["../src/unraw.ts","../src/parser.ts"],"sourcesContent":["/**\n * Parse a string as a base-16 number. This is more strict than `parseInt` as it\n * will not allow any other characters, including (for example) \"+\", \"-\", and\n * \".\".\n * @param hex A string containing a hexadecimal number.\n * @returns The parsed integer, or `NaN` if the string is not a valid hex\n * number.\n */\nfunction parseHexToInt(hex: string): number {\n  const isOnlyHexChars = !hex.match(/[^a-f0-9]/i);\n  return isOnlyHexChars ? parseInt(hex, 16) : NaN;\n}\n\n/**\n * Check the validity and length of a hexadecimal code and optionally enforces\n * a specific number of hex digits.\n * @param hex The string to validate and parse.\n * @param errorName The name of the error message to throw a `SyntaxError` with\n * if `hex` is invalid. This is used to index `errorMessages`.\n * @param enforcedLength If provided, will throw an error if `hex` is not\n * exactly this many characters.\n * @returns The parsed hex number as a normal number.\n * @throws {SyntaxError} If the code is not valid.\n */\nfunction validateAndParseHex(\n  hex: string,\n  errorName: string,\n  enforcedLength?: number\n): number {\n  const parsedHex = parseHexToInt(hex);\n  if (\n    Number.isNaN(parsedHex) ||\n    (enforcedLength !== undefined && enforcedLength !== hex.length)\n  ) {\n    throw new SyntaxError(errorName + ': ' + hex);\n  }\n  return parsedHex;\n}\n\n/**\n * Parse a two-digit hexadecimal character escape code.\n * @param code The two-digit hexadecimal number that represents the character to\n * output.\n * @returns The single character represented by the code.\n * @throws {SyntaxError} If the code is not valid hex or is not the right\n * length.\n */\nfunction parseHexadecimalCode(code: string): string {\n  const parsedCode = validateAndParseHex(\n    code,\n    'Malformed Hexadecimal',\n    2\n  );\n  return String.fromCharCode(parsedCode);\n}\n\n/**\n * Parse a four-digit Unicode character escape code.\n * @param code The four-digit unicode number that represents the character to\n * output.\n * @param surrogateCode Optional four-digit unicode surrogate that represents\n * the other half of the character to output.\n * @returns The single character represented by the code.\n * @throws {SyntaxError} If the codes are not valid hex or are not the right\n * length.\n */\nfunction parseUnicodeCode(code: string, surrogateCode?: string): string {\n  const parsedCode = validateAndParseHex(code, 'Malformed Unicode', 4);\n\n  if (surrogateCode !== undefined) {\n    const parsedSurrogateCode = validateAndParseHex(\n      surrogateCode,\n      'Malformed Unicode',\n      4\n    );\n    return String.fromCharCode(parsedCode, parsedSurrogateCode);\n  }\n\n  return String.fromCharCode(parsedCode);\n}\n\n/**\n * Test if the text is surrounded by curly braces (`{}`).\n * @param text Text to check.\n * @returns `true` if the text is in the form `{*}`.\n */\nfunction isCurlyBraced(text: string): boolean {\n  return text.charAt(0) === \"{\" && text.charAt(text.length - 1) === \"}\";\n}\n\n/**\n * Parse a Unicode code point character escape code.\n * @param codePoint A unicode escape code point, including the surrounding curly\n * braces.\n * @returns The single character represented by the code.\n * @throws {SyntaxError} If the code is not valid hex or does not have the\n * surrounding curly braces.\n */\nfunction parseUnicodeCodePointCode(codePoint: string): string {\n  if (!isCurlyBraced(codePoint)) {\n    throw new SyntaxError('Malformed Unicode: +' + codePoint);\n  }\n  const withoutBraces = codePoint.slice(1, -1);\n  const parsedCode = validateAndParseHex(\n    withoutBraces,\n    'Malformed Unicode'\n  );\n\n  try {\n    return String.fromCodePoint(parsedCode);\n  } catch (err) {\n    throw err instanceof RangeError\n      ? new SyntaxError('Code Point Limit:' + parsedCode)\n      : err;\n  }\n}\n\n/**\n * Map of unescaped letters to their corresponding special JS escape characters.\n * Intentionally does not include characters that map to themselves like \"\\'\".\n */\nconst singleCharacterEscapes = new Map<string, string>([\n  [\"b\", \"\\b\"],\n  [\"f\", \"\\f\"],\n  [\"n\", \"\\n\"],\n  [\"r\", \"\\r\"],\n  [\"t\", \"\\t\"],\n  [\"v\", \"\\v\"],\n  [\"0\", \"\\0\"]\n]);\n\n/**\n * Parse a single character escape sequence and return the matching character.\n * If none is matched, defaults to `code`.\n * @param code A single character code.\n */\nfunction parseSingleCharacterCode(code: string): string {\n  return singleCharacterEscapes.get(code) || code;\n}\n\n/**\n * Matches every escape sequence possible, including invalid ones.\n *\n * All capture groups (described below) are unique (only one will match), except\n * for 4, which can only potentially match if 3 does.\n *\n * **Capture Groups:**\n * 0. A single backslash\n * 1. Hexadecimal code\n * 2. Unicode code point code with surrounding curly braces\n * 3. Unicode escape code with surrogate\n * 4. Surrogate code\n * 5. Unicode escape code without surrogate\n * 6. Octal code _NOTE: includes \"0\"._\n * 7. A single character (will never be \\, x, u, or 0-3)\n */\nconst escapeMatch = /\\\\(?:(\\\\)|x([\\s\\S]{0,2})|u(\\{[^}]*\\}?)|u([\\s\\S]{4})\\\\u([^{][\\s\\S]{0,3})|u([\\s\\S]{0,4})|([0-3]?[0-7]{1,2})|([\\s\\S])|$)/g;\n\n/**\n * Replace raw escape character strings with their escape characters.\n * @param raw A string where escape characters are represented as raw string\n * values like `\\'` rather than `'`.\n * @param allowOctals If `true`, will process the now-deprecated octal escape\n * sequences (ie, `\\111`).\n * @returns The processed string, with escape characters replaced by their\n * respective actual Unicode characters.\n */\nexport function unraw(raw: string): string {\n  return raw.replace(escapeMatch, function(\n    _,\n    backslash?: string,\n    hex?: string,\n    codePoint?: string,\n    unicodeWithSurrogate?: string,\n    surrogate?: string,\n    unicode?: string,\n    octal?: string,\n    singleCharacter?: string\n  ): string {\n    // Compare groups to undefined because empty strings mean different errors\n    // Otherwise, `\\u` would fail the same as `\\` which is wrong.\n    if (backslash !== undefined) {\n      return \"\\\\\";\n    }\n    if (hex !== undefined) {\n      return parseHexadecimalCode(hex);\n    }\n    if (codePoint !== undefined) {\n      return parseUnicodeCodePointCode(codePoint);\n    }\n    if (unicodeWithSurrogate !== undefined) {\n      return parseUnicodeCode(unicodeWithSurrogate, surrogate);\n    }\n    if (unicode !== undefined) {\n      return parseUnicodeCode(unicode);\n    }\n    if (octal === \"0\") {\n      return \"\\0\";\n    }\n    if (octal !== undefined) {\n      throw new SyntaxError('Octal Deprecation: ' + octal);\n    }\n    if (singleCharacter !== undefined) {\n      return parseSingleCharacterCode(singleCharacter);\n    }\n    throw new SyntaxError('End of string');\n  });\n}\nexport default unraw;","import unraw from \"./unraw.js\";\nimport { CodeString, isLisp, LispType } from \"./utils.js\";\n\nexport type DefineLisp<op extends LispType, a extends LispItem|LispItem, b extends LispItem|LispItem> = [op, a, b];\n\nexport type ExtractLispOp<L> = L extends DefineLisp<infer i, any, any> ? i : never;\nexport type ExtractLispA<L> = L extends DefineLisp<any, infer i, any> ? i : never;\nexport type ExtractLispB<L> = L extends DefineLisp<any, any, infer i> ? i : never;\n\nexport type LispItemSingle = LispType.None|LispType.True|string|Lisp;\nexport type LispItem = LispItemSingle|LispItemSingle[];\nexport type Lisp = [LispType, LispItem, LispItem];\n\nfunction createLisp<L extends Lisp>(obj: {op: ExtractLispOp<L>, a: ExtractLispA<L>, b: ExtractLispB<L>}) {\n  return [obj.op, obj.a, obj.b] as L;\n}\n\nconst NullLisp = createLisp<None>({op: LispType.None, a: LispType.None, b: LispType.None});\n\nexport type Literal = DefineLisp<LispType.Literal, string, Lisp[]> & {tempJsStrings?: string[]}\nexport type If = DefineLisp<LispType.If, Lisp, IfCase>\nexport type InlineIf = DefineLisp<LispType.InlineIf, Lisp, InlineIfCase>\nexport type IfCase = DefineLisp<LispType.IfCase, Lisp[], Lisp[]>\nexport type InlineIfCase = DefineLisp<LispType.InlineIfCase, Lisp, Lisp>\nexport type KeyVal = DefineLisp<LispType.KeyVal, string|Lisp, Lisp>\nexport type SpreadObject = DefineLisp<LispType.SpreadObject, LispType.None, Lisp>;\nexport type SpreadArray = DefineLisp<LispType.SpreadArray, LispType.None, Lisp>;\nexport type ArrayProp = DefineLisp<LispType.ArrayProp, Lisp, Lisp>;\nexport type Prop = DefineLisp<LispType.Prop, Lisp, string|Lisp>;\nexport type PropOptional = DefineLisp<LispType.PropOptional, Lisp, Lisp[]>;\nexport type Call = DefineLisp<LispType.Call, Lisp, Lisp[]>;\nexport type CallOptional = DefineLisp<LispType.CallOptional, Lisp, Lisp[]>;\nexport type CreateArray = DefineLisp<LispType.CreateArray, Lisp, Lisp[]>;\nexport type CreateObject = DefineLisp<LispType.CreateObject, Lisp, Lisp[]>;\nexport type Group = DefineLisp<LispType.Group, Lisp, Lisp[]>;\nexport type Inverse = DefineLisp<LispType.Inverse, Lisp, Lisp>;\nexport type Not = DefineLisp<LispType.Not, Lisp, Lisp>;\nexport type Negative = DefineLisp<LispType.Negative, Lisp, Lisp>;\nexport type Positive = DefineLisp<LispType.Positive, Lisp, Lisp>;\nexport type Typeof = DefineLisp<LispType.Typeof, Lisp, Lisp>;\nexport type Delete = DefineLisp<LispType.Delete, Lisp, Lisp>;\nexport type IncrementBefore = DefineLisp<LispType.IncrementBefore, Lisp, LispType.None>;\nexport type IncrementAfter = DefineLisp<LispType.IncrementAfter, Lisp, LispType.None>;\nexport type DecrementBefore = DefineLisp<LispType.DecrementBefore, Lisp, LispType.None>;\nexport type DecrementAfter = DefineLisp<LispType.DecrementAfter, Lisp, LispType.None>;\n\nexport type And = DefineLisp<LispType.And, Lisp, Lisp>;\nexport type Or = DefineLisp<LispType.Or, Lisp, Lisp>;\nexport type Instanceof = DefineLisp<LispType.Instanceof, Lisp, Lisp>;\nexport type In = DefineLisp<LispType.In, Lisp, Lisp>;\nexport type Assigns = DefineLisp<LispType.Assign, Lisp, Lisp>;\nexport type SubractEquals = DefineLisp<LispType.SubractEquals, Lisp, Lisp>;\nexport type AddEquals = DefineLisp<LispType.AddEquals, Lisp, Lisp>;\nexport type DivideEquals = DefineLisp<LispType.DivideEquals, Lisp, Lisp>;\nexport type PowerEquals = DefineLisp<LispType.PowerEquals, Lisp, Lisp>;\nexport type MultiplyEquals = DefineLisp<LispType.MultiplyEquals, Lisp, Lisp>;\nexport type ModulusEquals = DefineLisp<LispType.ModulusEquals, Lisp, Lisp>;\nexport type BitNegateEquals = DefineLisp<LispType.BitNegateEquals, Lisp, Lisp>;\nexport type BitAndEquals = DefineLisp<LispType.BitAndEquals, Lisp, Lisp>;\nexport type BitOrEquals = DefineLisp<LispType.BitOrEquals, Lisp, Lisp>;\nexport type UnsignedShiftRightEquals = DefineLisp<LispType.UnsignedShiftRightEquals, Lisp, Lisp>;\nexport type ShiftLeftEquals = DefineLisp<LispType.ShiftLeftEquals, Lisp, Lisp>;\nexport type ShiftRightEquals = DefineLisp<LispType.ShiftRightEquals, Lisp, Lisp>;\n\nexport type BitAnd = DefineLisp<LispType.BitAnd, Lisp, Lisp>;\nexport type BitOr = DefineLisp<LispType.BitOr, Lisp, Lisp>;\nexport type BitNegate = DefineLisp<LispType.BitNegate, Lisp, Lisp>;\nexport type BitShiftLeft = DefineLisp<LispType.BitShiftLeft, Lisp, Lisp>;\nexport type BitShiftRight = DefineLisp<LispType.BitShiftRight, Lisp, Lisp>;\nexport type BitUnsignedShiftRight = DefineLisp<LispType.BitUnsignedShiftRight, Lisp, Lisp>;\nexport type SmallerEqualThan = DefineLisp<LispType.SmallerEqualThan, Lisp, Lisp>;\nexport type LargerEqualThan = DefineLisp<LispType.LargerEqualThan, Lisp, Lisp>;\nexport type SmallerThan = DefineLisp<LispType.SmallerThan, Lisp, Lisp>;\nexport type LargerThan = DefineLisp<LispType.LargerThan, Lisp, Lisp>;\nexport type StrictNotEqual = DefineLisp<LispType.StrictNotEqual, Lisp, Lisp>;\nexport type NotEqual = DefineLisp<LispType.NotEqual, Lisp, Lisp>;\nexport type StrictEqual = DefineLisp<LispType.StrictEqual, Lisp, Lisp>;\nexport type Equal = DefineLisp<LispType.Equal, Lisp, Lisp>;\nexport type Plus = DefineLisp<LispType.Plus, Lisp, Lisp>;\nexport type Minus = DefineLisp<LispType.Minus, Lisp, Lisp>;\nexport type Divide = DefineLisp<LispType.Divide, Lisp, Lisp>;\nexport type Power = DefineLisp<LispType.Power, Lisp, Lisp>;\nexport type Multiply = DefineLisp<LispType.Multiply, Lisp, Lisp>;\nexport type Modulus = DefineLisp<LispType.Modulus, Lisp, Lisp>;\n\nexport type Block = DefineLisp<LispType.Block, Lisp[], LispType.None>;\nexport type Expression = DefineLisp<LispType.Expression, Lisp[], LispType.None>;\nexport type Return = DefineLisp<LispType.Return, LispType.None, Lisp>;\nexport type Throw = DefineLisp<LispType.Throw, LispType.None, Lisp>;\nexport type Switch = DefineLisp<LispType.Switch, Lisp, SwitchCase[]>;\nexport type SwitchCase = DefineLisp<LispType.SwitchCase, LispType.None|Lisp, Lisp[]>;\nexport type Var = DefineLisp<LispType.Var, string, Lisp|LispType.None>;\nexport type Let = DefineLisp<LispType.Let, string, Lisp|LispType.None>;\nexport type Const = DefineLisp<LispType.Const, string, Lisp|LispType.None>;\n\nexport type Number = DefineLisp<LispType.Number, LispType.None, string>;\nexport type BigInt = DefineLisp<LispType.BigInt, LispType.None, string>;\nexport type GlobalSymbol = DefineLisp<LispType.GlobalSymbol, LispType.None, string>;\nexport type LiteralIndex = DefineLisp<LispType.LiteralIndex, LispType.None, string>;\nexport type StringIndex = DefineLisp<LispType.StringIndex, LispType.None, string>;\nexport type RegexIndex = DefineLisp<LispType.RegexIndex, LispType.None, string>;\n\nexport type Function = DefineLisp<LispType.Function, (string|LispType.None|LispType.True)[], string|Lisp[]>;\nexport type InlineFunction = DefineLisp<LispType.InlineFunction, string[], string|Lisp[]>;\nexport type ArrowFunction = DefineLisp<LispType.ArrowFunction, string[], string|Lisp[]>;\nexport type Loop = DefineLisp<LispType.Loop, LispItem, Lisp[]>;\nexport type LoopAction = DefineLisp<LispType.LoopAction, string, LispType.None>;\nexport type Try = DefineLisp<LispType.Try, Lisp[], LispItem>;\n\nexport type Void = DefineLisp<LispType.Void, Lisp, LispType.None>;\nexport type Await = DefineLisp<LispType.Await, Lisp, LispType.None>;\nexport type New = DefineLisp<LispType.New, Lisp, Lisp[]>;\nexport type None = DefineLisp<LispType.None, LispType.None, LispType.None>;\n\nexport type LispFamily = \n  Literal\n  |If\n  |InlineIf\n  |IfCase\n  |InlineIfCase\n  |KeyVal\n  |SpreadObject\n  |SpreadArray\n  |ArrayProp\n  |Prop\n  |PropOptional\n  |Call\n  |CallOptional\n  |CreateArray\n  |CreateObject\n  |Group\n  |Inverse\n  |Not\n  |Negative\n  |Positive\n  |Typeof\n  |Delete\n  |IncrementBefore\n  |IncrementAfter\n  |DecrementBefore\n  |DecrementAfter\n  |And\n  |Or\n  |Instanceof\n  |In\n  |Assigns\n  |SubractEquals\n  |AddEquals\n  |DivideEquals\n  |PowerEquals\n  |MultiplyEquals\n  |ModulusEquals\n  |BitNegateEquals\n  |BitAndEquals\n  |BitOrEquals\n  |UnsignedShiftRightEquals\n  |ShiftLeftEquals\n  |ShiftRightEquals\n  |BitAnd\n  |BitOr\n  |BitNegate\n  |BitShiftLeft\n  |BitShiftRight\n  |BitUnsignedShiftRight\n  |SmallerEqualThan\n  |LargerEqualThan\n  |SmallerThan\n  |LargerThan\n  |StrictNotEqual\n  |NotEqual\n  |StrictEqual\n  |Equal\n  |Plus\n  |Minus\n  |Divide\n  |Power\n  |Multiply\n  |Modulus\n  |Block\n  |Expression\n  |Return\n  |Throw\n  |Switch\n  |SwitchCase\n  |Var\n  |Let\n  |Const\n  |Number\n  |BigInt\n  |GlobalSymbol\n  |LiteralIndex\n  |StringIndex\n  |RegexIndex\n  |Function\n  |InlineFunction\n  |ArrowFunction\n  |Loop\n  |LoopAction\n  |Try\n  |Void\n  |Await\n  |New\n  |None;\n\nexport interface IRegEx {\n  regex: string,\n  flags: string,\n  length: number\n}\n\nexport interface IConstants {\n  strings: string[];\n  literals: Literal[];\n  regexes: IRegEx[];\n  eager: boolean;\n}\n\nexport interface IExecutionTree {\n  tree: Lisp[], \n  constants: IConstants\n}\n\ntype LispCallback<T> = (strings: IConstants, type: T, part: CodeString, res: string[], expect: string, ctx: {lispTree: Lisp}) => any\nlet lispTypes: Map<string, LispCallback<string>> = new Map();\n\nexport class ParseError extends Error {\n  constructor(message: string, public code: string) {\n    super(message + \": \" + code.substring(0, 40));\n  }\n}\n\nconst inlineIfElse =  /^:/;\nconst elseIf = /^else(?![\\w\\$])/\nconst ifElse = /^if(?![\\w\\$])/\nconst space = /^\\s/;\n\nexport const expectTypes = {\n  splitter: {\n    types: {\n      opHigh: /^(\\/|\\*\\*|\\*(?!\\*)|\\%)(?!\\=)/,\n      op: /^(\\+(?!(\\+))|\\-(?!(\\-)))(?!\\=)/,\n      comparitor: /^(<=|>=|<(?!<)|>(?!>)|!==|!=(?!\\=)|===|==)/,\n      boolOp: /^(&&|\\|\\||instanceof(?![\\w\\$])|in(?![\\w\\$]))/,\n      bitwise: /^(&(?!&)|\\|(?!\\|)|\\^|<<|>>(?!>)|>>>)(?!\\=)/,\n    },\n    next: [\n      'modifier',\n      'value', \n      'prop', \n      'incrementerBefore',\n    ]\n  },\n  inlineIf: {\n    types: {\n      inlineIf: /^\\?(?!\\.(?!\\d))/,\n    },\n    next: [\n      'expEnd'\n    ]\n  },\n  assignment: {\n    types: {\n      assignModify: /^(\\-=|\\+=|\\/=|\\*\\*=|\\*=|%=|\\^=|\\&=|\\|=|>>>=|>>=|<<=)/,\n      assign: /^(=)(?!=)/\n    },\n    next: [\n      'modifier',\n      'value', \n      'prop', \n      'incrementerBefore',\n    ]\n  },\n  incrementerBefore: {\n    types: {incrementerBefore: /^(\\+\\+|\\-\\-)/},\n    next: [\n      'prop',\n    ]\n  },\n  expEdge: {\n    types: {\n      call: /^(\\?\\.)?[\\(]/,\n      incrementerAfter: /^(\\+\\+|\\-\\-)/\n    },\n    next: [\n      'splitter',\n      'expEdge',\n      'dot',\n      'inlineIf',\n      'expEnd'\n    ]\n  },\n  modifier: {\n    types: {\n      not: /^!/,\n      inverse: /^~/,\n      negative: /^\\-(?!\\-)/,\n      positive: /^\\+(?!\\+)/,\n      typeof: /^typeof(?![\\w\\$])/,\n      delete: /^delete(?![\\w\\$])/,\n    },\n    next: [\n      'modifier', \n      'value',\n      'prop',\n      'incrementerBefore',\n    ]\n  },\n  dot: {\n    types: {\n      arrayProp: /^(\\?\\.)?\\[/,\n      dot: /^(\\?)?\\.(?=\\s*[a-zA-Z\\$\\_])/,\n    },\n    next: [\n      'splitter',\n      'assignment',\n      'expEdge',\n      'dot',\n      'inlineIf',\n      'expEnd'\n    ]\n  },\n  prop: {\n    types: {\n      prop: /^[a-zA-Z\\$\\_][a-zA-Z\\d\\$\\_]*/,\n    },\n    next: [\n      'splitter',\n      'assignment',\n      'expEdge',\n      'dot',\n      'inlineIf',\n      'expEnd'\n    ]\n  },\n  value: {\n    types: {\n      createObject: /^\\{/,\n      createArray: /^\\[/,\n      number: /^(0x[\\da-f]+(_[\\da-f]+)*|(\\d+(_\\d+)*(\\.\\d+(_\\d+)*)?|\\.\\d+(_\\d+)*))(e[\\+\\-]?\\d+(_\\d+)*)?(n)?(?!\\d)/i,\n      string: /^\"(\\d+)\"/,\n      literal: /^`(\\d+)`/,\n      regex: /^\\/(\\d+)\\/r(?![\\w\\$])/,\n      boolean: /^(true|false)(?![\\w\\$])/,\n      null: /^null(?![\\w\\$])/,\n      und: /^undefined(?![\\w\\$])/,\n      arrowFunctionSingle: /^(async\\s+)?([a-zA-Z\\$_][a-zA-Z\\d\\$_]*)\\s*=>\\s*({)?/,\n      arrowFunction: /^(async\\s*)?\\(\\s*((\\.\\.\\.)?\\s*[a-zA-Z\\$_][a-zA-Z\\d\\$_]*(\\s*,\\s*(\\.\\.\\.)?\\s*[a-zA-Z\\$_][a-zA-Z\\d\\$_]*)*)?\\s*\\)\\s*=>\\s*({)?/,\n      inlineFunction: /^(async\\s+)?function(\\s*[a-zA-Z\\$_][a-zA-Z\\d\\$_]*)?\\s*\\(\\s*((\\.\\.\\.)?\\s*[a-zA-Z\\$_][a-zA-Z\\d\\$_]*(\\s*,\\s*(\\.\\.\\.)?\\s*[a-zA-Z\\$_][a-zA-Z\\d\\$_]*)*)?\\s*\\)\\s*{/,\n      group: /^\\(/,\n      NaN: /^NaN(?![\\w\\$])/,\n      Infinity: /^Infinity(?![\\w\\$])/,\n      void: /^void(?![\\w\\$])\\s*/,\n      await: /^await(?![\\w\\$])\\s*/,\n      new: /^new(?![\\w\\$])\\s*/,\n    },\n    next: [\n      'splitter',\n      'expEdge',\n      'dot',\n      'inlineIf',\n      'expEnd'\n    ]\n  },\n  initialize: {\n    types: {\n      initialize: /^(var|let|const)\\s+([a-zA-Z\\$_][a-zA-Z\\d\\$_]*)\\s*(=)?/,\n      return: /^return(?![\\w\\$])/,\n      throw: /^throw(?![\\w\\$])\\s*/\n    },\n    next: [\n      'modifier',\n      'value', \n      'prop', \n      'incrementerBefore',\n      'expEnd'\n    ]\n  },\n  spreadObject: {\n    types: {\n      spreadObject: /^\\.\\.\\./\n    },\n    next: [\n      'value',\n      'prop', \n    ]\n  },\n  spreadArray: {\n    types: {\n      spreadArray: /^\\.\\.\\./\n    },\n    next: [\n      'value', \n      'prop', \n    ]\n  },\n  expEnd: {types: {}, next: []},\n  expFunction: {\n    types: {\n      function: /^(async\\s+)?function(\\s*[a-zA-Z\\$_][a-zA-Z\\d\\$_]*)\\s*\\(\\s*((\\.\\.\\.)?\\s*[a-zA-Z\\$_][a-zA-Z\\d\\$_]*(\\s*,\\s*(\\.\\.\\.)?\\s*[a-zA-Z\\$_][a-zA-Z\\d\\$_]*)*)?\\s*\\)\\s*{/,\n    },\n    next: [\n      'expEdge',\n      'expEnd'\n    ]\n  },\n  expSingle: {\n    types: {\n      for: /^(([a-zA-Z\\$\\_][\\w\\$]*)\\s*:)?\\s*for\\s*\\(/,\n      do: /^(([a-zA-Z\\$\\_][\\w\\$]*)\\s*:)?\\s*do(?![\\w\\$])\\s*(\\{)?/,\n      while: /^(([a-zA-Z\\$\\_][\\w\\$]*)\\s*:)?\\s*while\\s*\\(/,\n      loopAction: /^(break|continue)(?![\\w\\$])\\s*([a-zA-Z\\$\\_][\\w\\$]*)?/,\n      if: /^((([a-zA-Z\\$\\_][\\w\\$]*)\\s*:)?\\s*)if\\s*\\(/,\n      try: /^try\\s*{/,\n      block: /^{/,\n      switch: /^(([a-zA-Z\\$\\_][\\w\\$]*)\\s*:)?\\s*switch\\s*\\(/,\n    },\n    next: [\n      'expEnd'\n    ]\n  }\n} as Record<string, {types: Record<string, RegExp>, next: string[]}>;\n\nlet closings = {\n  \"(\": \")\",\n  \"[\": \"]\",\n  \"{\": \"}\",\n  \"'\": \"'\",\n  '\"': '\"',\n  \"`\": \"`\"\n} as Record<string, string>;\n\nexport function testMultiple(str: string, tests: RegExp[]) {\n  let found: RegExpExecArray|null = null;\n  for (let i = 0; i < tests.length; i++) {\n    const test = tests[i];\n    found = test.exec(str);\n    if (found) break;\n  }\n  return found;\n}\n\n\nconst emptyString = new CodeString(\"\")\n\nconst okFirstChars = /^[\\+\\-~ !]/;\nconst aChar = /^[\\w\\$]/\nconst aNumber = expectTypes.value.types.number;\nconst wordReg = /^((if|for|else|while|do|function)(?![\\w\\$])|[\\w\\$]+)/;\nconst semiColon = /^;/\nconst insertedSemicolons: WeakMap<{str: string}, Array<number>> = new WeakMap();\nconst quoteCache: WeakMap<{str: string}, Map<number, number>> = new WeakMap();\nexport interface restDetails {oneliner?: boolean, words?: string[], lastWord?: string, lastAnyWord?: string, regRes?: RegExpExecArray}\nexport function restOfExp(constants: IConstants, \n                          part: CodeString, \n                          tests?: RegExp[], \n                          quote?: string, \n                          firstOpening?: string, \n                          closingsTests?: RegExp[], \n                          details: restDetails = {}): CodeString {\n  if (!part.length) {\n    return part;\n  }\n  details.words = details.words || [];\n  let isStart = true;\n  tests = tests || [];\n  const hasSemiTest = tests.includes(semiColon);\n  if (hasSemiTest) {\n    tests = tests.filter((a) => a !== semiColon);\n  }\n  const insertedSemis = insertedSemicolons.get(part.ref) || [];\n  const cache = quoteCache.get(part.ref) || new Map<number, number>();\n  quoteCache.set(part.ref, cache);\n  if (quote && cache.has(part.start - 1)) {\n    return part.substring(0, cache.get(part.start - 1)! - part.start);\n  }\n  let escape = false;\n  let done = false;\n  let lastChar = \"\";\n  let isOneLiner = false;\n  let i;\n  let lastInertedSemi = false;\n  for (i = 0; i < part.length && !done; i++) {\n    let char = part.char(i)!;\n    if (quote === '\"' || quote === \"'\" || quote === \"`\") {\n      if (quote === \"`\" && char === \"$\" && part.char(i+1) === \"{\" && !escape) {\n        let skip = restOfExp(constants, part.substring(i+2), [], \"{\");\n        i += skip.length + 2;\n      } else if (char === quote && !escape) {\n        return part.substring(0, i);\n      }\n      escape = !escape && char === \"\\\\\";\n    } else if (closings[char]) {\n      if (!lastInertedSemi && insertedSemis[i + part.start]) {\n        lastInertedSemi = true\n        if (hasSemiTest) {\n          break;\n        }\n        i--;\n        lastChar = ';';\n        continue;\n      }\n      if (isOneLiner && char === \"{\") {\n        isOneLiner = false;\n      }\n      if (char === firstOpening) {\n        done = true;\n        break;\n      } else {\n        let skip = restOfExp(constants, part.substring(i+1), [], char);\n        cache.set(skip.start - 1, skip.end);\n        i += skip.length + 1;\n        isStart = false;\n        if (closingsTests) {\n          let sub = part.substring(i);\n          let found: RegExpExecArray|null;\n          if (found = testMultiple(sub.toString(), closingsTests)) {\n            details.regRes = found;\n            done = true;\n          }\n        }\n      }\n    } else if (!quote) {\n      let sub = part.substring(i).toString();\n      let foundWord: RegExpExecArray|null;\n      let foundNumber: RegExpExecArray|null;\n      if (closingsTests) {\n        let found: RegExpExecArray|null;\n        if (found = testMultiple(sub, closingsTests)) {\n          details.regRes = found;\n          i++;\n          done = true;\n          break;\n        }\n      }\n      if (foundNumber = aNumber.exec(sub)) {\n        i += foundNumber[0].length - 1;\n        sub = part.substring(i).toString();\n      } else if (lastChar != char) {\n        let found: [string]|RegExpExecArray|null = null;\n        if (char === ';' || (insertedSemis[i + part.start] && !isStart && !lastInertedSemi)) {\n          if (hasSemiTest) {\n            found = [\";\"];\n          } else if (insertedSemis[i + part.start]) {\n            lastInertedSemi = true\n            i--;\n            lastChar = ';';\n            continue;\n          }\n          char = sub = ';';\n        } else {\n          lastInertedSemi = false;\n        }\n        if (!found) {\n          found = testMultiple(sub, tests);\n        }\n        if (found) {\n          done = true;\n        }\n        if (!done && (foundWord = wordReg.exec(sub))) {\n          isOneLiner = true;\n          if (foundWord[0].length > 1) {\n            details.words.push(foundWord[1]);\n            details.lastAnyWord = foundWord[1];\n            if (foundWord[2]) {\n              details.lastWord = foundWord[2];\n            }\n          }\n          if(foundWord[0].length > 2) {\n            i += foundWord[0].length - 2;\n          }\n        }\n      }\n      if (isStart) {\n        if (okFirstChars.test(sub)) {\n          done = false;\n        } else {\n          isStart = false;\n        }\n      }\n      if (done) break;\n    } else if(char === closings[quote]) {\n      return part.substring(0, i);\n    }\n    lastChar = char;\n  }\n  if (quote) {\n    throw new SyntaxError(\"Unclosed '\" + quote + \"'\");\n  }\n  if (details) {\n    details.oneliner = isOneLiner;\n  }\n  return part.substring(0, i);\n}\nrestOfExp.next = [\n  'splitter',\n  'expEnd',\n  'inlineIf'\n];\n\nconst startingExecpted = ['initialize', 'expSingle', 'expFunction', 'value', 'modifier', 'prop', 'incrementerBefore', 'expEnd'];\n\nexport const setLispType = <T extends readonly string[]>(types: T, fn: LispCallback<T[number]>) => {\n  types.forEach((type) => {\n    lispTypes.set(type, fn);\n  })\n}\n\nconst closingsCreate: {[type:string]: RegExp} = {\n  'createArray': /^\\]/,\n  'createObject': /^\\}/,\n  'group': /^\\)/,\n  'arrayProp': /^\\]/,\n  'call': /^\\)/\n}\n\nconst typesCreate = {\n  'createArray': LispType.CreateArray,\n  'createObject': LispType.CreateObject,\n  'group': LispType.Group,\n  'arrayProp': LispType.ArrayProp,\n  'call': LispType.Call,\n  'prop': LispType.Prop,\n  '?prop': LispType.PropOptional,\n  '?call': LispType.CallOptional,\n} as any\n\nsetLispType(['createArray', 'createObject', 'group', 'arrayProp','call'] as const, (constants, type, part, res, expect, ctx) => {\n  let extract = emptyString;\n  let arg: CodeString[] = [];\n  let end = false;\n  let i = res[0].length;\n  const start = i;\n  while (i < part.length && !end) {\n    extract = restOfExp(constants, part.substring(i), [\n      closingsCreate[type],\n      /^,/\n    ]);\n    i += extract.length;\n    if (extract.trim().length) {\n      arg.push(extract);\n    }\n    if (part.char(i) !== ',') {\n      end = true;\n    } else {\n      i++;\n    }\n  }\n  const next = ['value', 'modifier', 'prop', 'incrementerBefore', 'expEnd'];\n  let l: Lisp|Lisp[];\n\n  let funcFound: RegExpExecArray|null;\n  switch(type) {\n    case 'group':\n    case 'arrayProp':\n      l = lispifyExpr(constants, part.substring(start, i));\n      break;\n    case 'call':\n    case 'createArray':\n      // @TODO: support 'empty' values\n      l = arg.map((e) => lispify(constants, e, [...next, 'spreadArray']));\n      break;\n    case 'createObject':\n      l = arg.map((str) => {\n        str = str.trimStart();\n        let value: Lisp;\n        let key: string|Lisp = '';\n        funcFound = expectTypes.expFunction.types.function.exec('function ' + str);\n        if (funcFound) {\n          key = funcFound[2].trimStart();\n          value = lispify(constants, new CodeString('function ' + str.toString().replace(key, \"\")));\n        } else {\n          let extract = restOfExp(constants, str, [/^:/]);\n          key = lispify(constants, extract, [...next, 'spreadObject']) as Prop;\n          if (key[0] === LispType.Prop) {\n            key = (key as Prop)[2];\n          }\n          value = lispify(constants, str.substring(extract.length + 1));\n        }\n        return createLisp<KeyVal>({\n          op: LispType.KeyVal,\n          a: key,\n          b: value\n        });\n      });\n      break;\n  }\n  let lisptype = (type === 'arrayProp' ? (res[1] ? LispType.PropOptional : LispType.Prop) : (type === 'call' ? (res[1] ? LispType.CallOptional : LispType.Call) : typesCreate[type])) as (typeof typesCreate)[keyof typeof typesCreate];\n  ctx.lispTree = lispify(constants, part.substring(i + 1), expectTypes[expect].next, createLisp<ArrayProp|Prop|Call|CreateObject|CreateArray|Group|PropOptional|CallOptional>({\n    op: lisptype, \n    a: ctx.lispTree, \n    b: l,\n  }));\n});\n\nconst modifierTypes = {\n  'inverse': LispType.Inverse,\n  'not': LispType.Not,\n  'positive': LispType.Positive,\n  'negative': LispType.Negative,\n  'typeof': LispType.Typeof,  \n  'delete': LispType.Delete\n} as const\n\nsetLispType(['inverse', 'not', 'negative', 'positive', 'typeof', 'delete'] as const, (constants, type, part, res, expect, ctx) => {\n  let extract = restOfExp(constants, part.substring(res[0].length), [/^([^\\s\\.\\?\\w\\$]|\\?[^\\.])/]);\n  ctx.lispTree = lispify(constants, part.substring(extract.length + res[0].length), restOfExp.next, createLisp<Inverse|Not|Negative|Positive|Typeof|Delete>({\n    op: modifierTypes[type],\n    a: ctx.lispTree, \n    b: lispify(constants, extract, expectTypes[expect].next), \n  }));\n});\n\nconst incrementTypes = {\n  '++$': LispType.IncrementBefore,\n  '--$': LispType.DecrementBefore,\n  '$++': LispType.IncrementAfter,\n  '$--': LispType.DecrementAfter\n} as any\n\nsetLispType(['incrementerBefore'] as const, (constants, type, part, res, expect, ctx) => {\n  let extract = restOfExp(constants, part.substring(2), [/^[^\\s\\.\\w\\$]/]);\n  ctx.lispTree = lispify(constants, part.substring(extract.length + 2), restOfExp.next, createLisp<IncrementBefore|DecrementBefore>({\n    op: incrementTypes[res[0] + \"$\"], \n    a: lispify(constants, extract, expectTypes[expect].next),\n    b: LispType.None\n  }));\n});\n\nsetLispType(['incrementerAfter'] as const, (constants, type, part, res, expect, ctx) => {\n  ctx.lispTree = lispify(constants, part.substring(res[0].length), expectTypes[expect].next, createLisp<IncrementAfter|DecrementAfter>({\n    op: incrementTypes[\"$\"  + res[0]], \n    a: ctx.lispTree, \n    b: LispType.None\n  }));\n});\n\nconst adderTypes = {\n  '&&': LispType.And,\n  '||': LispType.Or,\n  'instanceof': LispType.Instanceof,\n  'in': LispType.In,\n  '=': LispType.Assign,\n  '-=': LispType.SubractEquals,\n  '+=': LispType.AddEquals,\n  '/=': LispType.DivideEquals,\n  '**=': LispType.PowerEquals,\n  '*=': LispType.MultiplyEquals,\n  '%=': LispType.ModulusEquals,\n  '^=': LispType.BitNegateEquals,\n  '&=': LispType.BitAndEquals,\n  '|=': LispType.BitOrEquals,\n  '>>>=': LispType.UnsignedShiftRightEquals,\n  '<<=': LispType.ShiftLeftEquals,\n  '>>=': LispType.ShiftRightEquals,\n} as any;\n\nsetLispType(['assign', 'assignModify', 'boolOp'] as const, (constants, type, part, res, expect, ctx) => {\n  ctx.lispTree = createLisp<And|Or|Instanceof|In|Assigns|SubractEquals|AddEquals|DivideEquals|PowerEquals|MultiplyEquals|ModulusEquals|BitNegateEquals|BitAndEquals|BitOrEquals|UnsignedShiftRightEquals|ShiftLeftEquals|ShiftRightEquals>({\n    op: adderTypes[res[0]], \n    a: ctx.lispTree,\n    b: lispify(constants, part.substring(res[0].length), expectTypes[expect].next)\n  });\n});\n\nconst opTypes = {\n  '&': LispType.BitAnd,\n  '|': LispType.BitOr,\n  '^': LispType.BitNegate,\n  '<<': LispType.BitShiftLeft,\n  '>>': LispType.BitShiftRight,\n  '>>>': LispType.BitUnsignedShiftRight,\n  '<=': LispType.SmallerEqualThan,\n  '>=': LispType.LargerEqualThan,\n  '<': LispType.SmallerThan,\n  '>': LispType.LargerThan,\n  '!==': LispType.StrictNotEqual,\n  '!=': LispType.NotEqual,\n  '===': LispType.StrictEqual,\n  '==': LispType.Equal,\n  '+': LispType.Plus,\n  '-': LispType.Minus,\n  '/': LispType.Divide,\n  '**': LispType.Power,\n  '*': LispType.Multiply,\n  '%': LispType.Modulus,\n} as any\n\nsetLispType(['opHigh', 'op', 'comparitor', 'bitwise'] as const, (constants, type, part, res, expect, ctx) => {\n  const next = [\n    expectTypes.inlineIf.types.inlineIf,\n    inlineIfElse\n  ];\n  switch (type) {\n    case 'opHigh':\n      next.push(expectTypes.splitter.types.opHigh);\n    case 'op':\n      next.push(expectTypes.splitter.types.op);\n    case 'comparitor':\n      next.push(expectTypes.splitter.types.comparitor);\n    case 'bitwise':\n      next.push(expectTypes.splitter.types.bitwise);\n      next.push(expectTypes.splitter.types.boolOp);\n  }\n  let extract = restOfExp(constants, part.substring(res[0].length), next);\n  ctx.lispTree = lispify(constants, part.substring(extract.length + res[0].length), restOfExp.next, createLisp<BitAnd|BitOr|BitNegate|BitShiftLeft|BitShiftRight|BitUnsignedShiftRight|SmallerEqualThan|LargerEqualThan|SmallerThan|LargerThan|StrictNotEqual|NotEqual|StrictEqual|Equal|Plus|Minus|Divide|Power|Multiply|Modulus>  ({\n    op: opTypes[res[0]],\n    a: ctx.lispTree, \n    b: lispify(constants, extract, expectTypes[expect].next), \n  }));\n});\n\nsetLispType(['inlineIf'] as const, (constants, type, part, res, expect, ctx) => {\n  let found = false;\n  let extract = part.substring(0, 0);\n  let quoteCount = 1;\n  while(!found && extract.length < part.length) {\n    extract.end = restOfExp(constants, part.substring(extract.length + 1), [\n      expectTypes.inlineIf.types.inlineIf,\n      inlineIfElse\n    ]).end;\n    if (part.char(extract.length) === '?') {\n      quoteCount++\n    } else {\n      quoteCount--\n    }\n    if (!quoteCount) {\n      found = true;\n    }\n  }\n  extract.start = part.start + 1;\n  ctx.lispTree = createLisp<InlineIf>({\n    op: LispType.InlineIf,\n    a: ctx.lispTree, \n    b: createLisp<InlineIfCase>({\n      op: LispType.InlineIfCase,\n      a: lispifyExpr(constants, extract),\n      b: lispifyExpr(constants, part.substring(res[0].length + extract.length + 1))\n    })\n  });\n});\n\n\nfunction extractIfElse(constants: IConstants, part: CodeString) {\n  let count = 0;\n  let found = part.substring(0, 0);\n  let foundElse = emptyString;\n  let foundTrue: CodeString|undefined;\n  let first = true;\n  let elseReg: RegExpExecArray|null;\n  let details: restDetails = {}\n  while((found = restOfExp(constants, part.substring(found.end - part.start), [elseIf, ifElse, semiColon], undefined, undefined , undefined, details)).length || first) {\n    first = false;\n    const f = part.substring(found.end - part.start).toString();\n    \n    if (f.startsWith(\"if\")) {\n      found.end++;\n      count++;\n    } else if (f.startsWith('else')) {\n      foundTrue = part.substring(0, found.end - part.start);\n      found.end++;\n      count--;\n      if (!count) {\n        found.end--;\n      }\n    } else if (elseReg = /^;?\\s*else(?![\\w\\$])/.exec(f)) {\n      foundTrue = part.substring(0, found.end - part.start);\n      found.end += elseReg[0].length - 1;\n      count--;\n      if (!count) {\n        found.end -= elseReg[0].length - 1;\n      }\n    } else {\n      foundTrue = foundElse.length ? foundTrue : part.substring(0, found.end - part.start);\n      break;\n    }\n    if (!count) {\n      let ie = extractIfElse(constants, part.substring(found.end - part.start + (/^;?\\s*else(?![\\w\\$])/.exec(f)?.[0].length || 0)));\n      foundElse = ie.all;\n      break;\n    }\n    details = {};\n  }\n  foundTrue = foundTrue || part.substring(0, found.end - part.start);\n  return {all: part.substring(0, Math.max(foundTrue.end, foundElse.end) - part.start), true: foundTrue, false: foundElse};\n}\n\nsetLispType(['if'] as const, (constants, type, part, res, expect, ctx) => {\n  let condition = restOfExp(constants, part.substring(res[0].length), [], \"(\");\n  const ie = extractIfElse(constants, part.substring(res[1].length));\n  const isBlock = /^\\s*\\{/.exec(part.substring(res[0].length + condition.length + 1).toString());\n  const startTrue = res[0].length - res[1].length + condition.length + 1;\n  \n  let trueBlock = ie.true.substring(startTrue);\n  let elseBlock = ie.false;\n  \n  condition = condition.trim();\n  trueBlock = trueBlock.trim();\n  elseBlock = elseBlock.trim();\n\n  if (trueBlock.char(0) === \"{\") trueBlock = trueBlock.slice(1, -1);\n  if (elseBlock.char(0) === \"{\") elseBlock = elseBlock.slice(1, -1);\n  ctx.lispTree = createLisp<If>({\n    op: LispType.If,\n    a: lispifyExpr(constants, condition), \n    b: createLisp<IfCase>({\n      op: LispType.IfCase,\n      a: lispifyBlock(trueBlock, constants),\n      b: lispifyBlock(elseBlock, constants)\n    })\n  });\n});\n\nsetLispType(['switch'] as const, (constants, type, part, res, expect, ctx) => {\n  const test = restOfExp(constants, part.substring(res[0].length), [], \"(\");\n  let start = part.toString().indexOf(\"{\", res[0].length + test.length + 1);\n  if (start === -1) throw new SyntaxError(\"Invalid switch\");\n  let statement = insertSemicolons(constants, restOfExp(constants, part.substring(start + 1), [], \"{\"));\n  let caseFound: RegExpExecArray|null;\n  const caseTest = /^\\s*(case\\s|default)\\s*/;\n  let cases: SwitchCase[] = [];\n  let defaultFound = false;\n  while(caseFound = caseTest.exec(statement.toString())) {\n    if (caseFound[1] === 'default') {\n      if (defaultFound) throw new SyntaxError(\"Only one default switch case allowed\");\n      defaultFound = true;\n    }\n    let cond = restOfExp(constants, statement.substring(caseFound[0].length), [/^:/]);\n    let found = emptyString;\n    let i = start = caseFound[0].length + cond.length + 1;\n    let bracketFound = /^\\s*\\{/.exec(statement.substring(i).toString());\n    let exprs: Lisp[] = [];\n    if (bracketFound) {\n      i += bracketFound[0].length;\n      found = restOfExp(constants, statement.substring(i), [], \"{\");\n      i += found.length + 1;\n      exprs = lispifyBlock(found, constants);\n    } else {\n      let notEmpty = restOfExp(constants, statement.substring(i), [caseTest]);\n      if (!notEmpty.trim().length) {\n        exprs = [];\n        i += notEmpty.length;\n      } else {\n        while((found = restOfExp(constants, statement.substring(i), [semiColon])).length) {\n          i += found.length + (statement.char(i + found.length) === ';' ? 1 : 0);\n          if (caseTest.test(statement.substring(i).toString())) {\n            break;\n          }\n        }\n        exprs = lispifyBlock(statement.substring(start, found.end - statement.start), constants);\n      }\n    }\n    statement = statement.substring(i);\n    cases.push(createLisp<SwitchCase>({\n      op: LispType.SwitchCase,\n      a: caseFound[1] === \"default\" ? LispType.None : lispifyExpr(constants, cond),\n      b: exprs\n    }));\n  }\n  ctx.lispTree = createLisp<Switch>({\n    op: LispType.Switch,\n    a: lispifyExpr(constants, test),\n    b: cases\n  });\n});\n\nsetLispType(['dot', 'prop'] as const, (constants, type, part, res, expect, ctx) => {\n  let prop = res[0];\n  let index = res[0].length;\n  let op = 'prop';\n  if (type === 'dot') {\n    if (res[1]) {\n      op = '?prop';\n    }\n    let matches = part.substring(res[0].length).toString().match(expectTypes.prop.types.prop);\n    if (matches && matches.length) {\n      prop = matches[0];\n      index = prop.length + res[0].length\n    } else {\n      throw new SyntaxError('Hanging  dot');\n    }\n  }\n  ctx.lispTree = lispify(constants, part.substring(index), expectTypes[expect].next, createLisp<Prop|PropOptional>({\n    op: typesCreate[op], \n    a: ctx.lispTree, \n    b: prop\n  }));\n});\n\nsetLispType(['spreadArray', 'spreadObject'] as const, (constants, type, part, res, expect, ctx) => {\n  ctx.lispTree = createLisp<SpreadArray|SpreadObject>({\n    op: type === 'spreadArray' ? LispType.SpreadArray : LispType.SpreadObject,\n    a: LispType.None,\n    b: lispify(constants, part.substring(res[0].length), expectTypes[expect].next)\n  });\n});\n\nsetLispType(['return', 'throw'] as const, (constants, type, part, res, expect, ctx) => {\n  ctx.lispTree = createLisp<Return|Throw>({\n    op: type === 'return' ? LispType.Return : LispType.Throw,\n    a: LispType.None,\n    b: lispifyExpr(constants, part.substring(res[0].length))\n  });\n});\n\nsetLispType(['number', 'boolean', 'null', 'und', 'NaN', 'Infinity'] as const, (constants, type, part, res, expect, ctx) => {\n  ctx.lispTree = lispify(constants, part.substring(res[0].length), expectTypes[expect].next, createLisp<Number|BigInt|GlobalSymbol>({\n    op: type === \"number\" ? res[10] ? LispType.BigInt : LispType.Number : LispType.GlobalSymbol,\n    a: LispType.None,\n    b: res[10] ? res[1] : res[0]\n  }));\n});\n\nsetLispType(['string', 'literal', 'regex'] as const, (constants, type, part, res, expect, ctx) => {\n  ctx.lispTree = lispify(constants, part.substring(res[0].length), expectTypes[expect].next, createLisp<StringIndex|LiteralIndex|RegexIndex>({\n    op: type === 'string' ? LispType.StringIndex : type === 'literal' ? LispType.LiteralIndex : LispType.RegexIndex,\n    a: LispType.None,\n    b: res[1],\n  }));\n});\n\nsetLispType(['initialize'] as const, (constants, type, part, res, expect, ctx) => {\n  const lt = res[1] === 'var' ? LispType.Var : res[1] === 'let' ? LispType.Let : LispType.Const;\n  if (!res[3]) {\n    ctx.lispTree = lispify(constants, part.substring(res[0].length), expectTypes[expect].next, createLisp<Var|Let|Const>({\n      op: lt,\n      a: res[2],\n      b: LispType.None\n    }));\n  } else {\n    ctx.lispTree = createLisp<Var|Let|Const>({\n      op: lt,\n      a: res[2],\n      b: lispify(constants, part.substring(res[0].length), expectTypes[expect].next)\n    });\n  }\n});\n\nsetLispType(['function', 'inlineFunction', 'arrowFunction', 'arrowFunctionSingle'] as const, (constants, type, part, res, expect, ctx) => {\n  const isArrow = type !== 'function' && type !== 'inlineFunction';\n  const isReturn = isArrow && !res[res.length - 1];\n  const argPos = isArrow ? 2 : 3;\n  const isAsync = res[1] ? LispType.True : LispType.None;\n  const args: (string)[] = res[argPos] ? res[argPos].replace(/\\s+/g, \"\").split(/,/g) : [];\n  if (!isArrow) {\n    args.unshift((res[2] || \"\").trimStart());\n  }\n  let ended = false;\n  args.forEach((arg: string) => {\n    if (ended) throw new SyntaxError('Rest parameter must be last formal parameter');\n    if (arg.startsWith('...')) ended = true;\n  });\n  const f = restOfExp(constants, part.substring(res[0].length), !isReturn ? [/^}/] : [/^[,\\)\\}\\]]/, semiColon])\n  const func = (isReturn ? 'return ' + f : f.toString());\n  ctx.lispTree = lispify(constants, part.substring(res[0].length + func.length + 1), expectTypes[expect].next, createLisp<Function|InlineFunction|ArrowFunction>({\n    op: isArrow ? LispType.ArrowFunction : type === 'function' ? LispType.Function : LispType.InlineFunction,\n    a: [isAsync, ...args],\n    b: constants.eager ? lispifyFunction(new CodeString(func), constants) : func\n  }));\n});\n\nconst iteratorRegex = /^((let|var|const)\\s+)?\\s*([a-zA-Z\\$_][a-zA-Z\\d\\$_]*)\\s+(in|of)(?![\\w\\$])/\nsetLispType(['for', 'do', 'while'] as const, (constants, type, part, res, expect, ctx) => {\n  let i = 0;\n  let startStep: LispItem = LispType.True;\n  let startInternal: Lisp[] = [];\n  let getIterator: Lisp|LispType.None = LispType.None;\n  let beforeStep: LispItem = LispType.None;\n  let checkFirst = LispType.True;\n  let condition: LispItem;\n  let step: LispItem = LispType.True;\n  let body: CodeString;\n  switch (type) {\n    case 'while':\n      i = part.toString().indexOf(\"(\") + 1;\n      let extract = restOfExp(constants, part.substring(i), [], \"(\");\n      condition = lispifyReturnExpr(constants, extract);\n      body = restOfExp(constants, part.substring(i + extract.length + 1)).trim();\n      if (body.char(0) === \"{\") body = body.slice(1, -1);\n      break;\n    case 'for':\n      i = part.toString().indexOf(\"(\") + 1;\n      let args: CodeString[] = [];\n      let extract2 = emptyString;\n      for (let k = 0; k < 3; k++)  {\n        extract2 = restOfExp(constants, part.substring(i), [/^[;\\)]/]);\n        args.push(extract2.trim());\n        i += extract2.length + 1;\n        if (part.char(i - 1) === \")\") break;\n      }\n      let iterator: RegExpExecArray|null;\n      if (args.length === 1 && (iterator = iteratorRegex.exec(args[0].toString()))) {\n        if (iterator[4] === 'of') {\n          getIterator = lispifyReturnExpr(constants, args[0].substring(iterator[0].length)),\n          startInternal = [\n            ofStart2, \n            ofStart3\n          ];\n          condition = ofCondition;\n          step = ofStep;\n          beforeStep = lispify(constants, new CodeString((iterator[1] || 'let ') + iterator[3]  + ' = $$next.value'), ['initialize']);\n        } else {\n          getIterator = lispifyReturnExpr(constants, args[0].substring(iterator[0].length)),\n          startInternal = [\n            inStart2,\n            inStart3\n          ];\n          step = inStep;\n          condition = inCondition;\n          beforeStep = lispify(constants, new CodeString((iterator[1] || 'let ') + iterator[3] + ' = $$keys[$$keyIndex]'), ['initialize']);\n        }\n      } else if (args.length === 3) {\n        startStep = lispifyExpr(constants, args.shift()!, startingExecpted);\n        condition = lispifyReturnExpr(constants, args.shift()!);\n        step = lispifyExpr(constants, args.shift()!);\n      } else {\n        throw new SyntaxError(\"Invalid for loop definition\");\n      }\n      body = restOfExp(constants, part.substring(i)).trim();\n      if (body.char(0) === \"{\") body = body.slice(1, -1);\n\n      break;\n    case 'do':\n      checkFirst = LispType.None;\n      const isBlock = !!res[3];\n      body = restOfExp(constants, part.substring(res[0].length), isBlock ? [/^\\}/] : [semiColon]);\n      condition = lispifyReturnExpr(constants, restOfExp(constants, part.substring(part.toString().indexOf(\"(\", res[0].length + body.length) + 1), [], \"(\"));\n      break;\n  }\n  const a = [checkFirst, startInternal, getIterator, startStep, step, condition, beforeStep] as LispItem;\n  ctx.lispTree = createLisp<Loop>({\n    op: LispType.Loop,\n    a,\n    b: lispifyBlock(body, constants)\n  });\n});\n\nsetLispType(['block'] as const, (constants, type, part, res, expect, ctx) => {\n  ctx.lispTree = createLisp<Block>({\n    op: LispType.Block,\n    a: lispifyBlock(restOfExp(constants, part.substring(1), [], \"{\"), constants),\n    b: LispType.None\n  });\n});\n\nsetLispType(['loopAction'] as const, (constants, type, part, res, expect, ctx) => {\n  ctx.lispTree = createLisp<LoopAction>({\n    op: LispType.LoopAction,\n    a: res[1],\n    b: LispType.None\n  });\n});\n\nconst catchReg = /^\\s*(catch\\s*(\\(\\s*([a-zA-Z\\$_][a-zA-Z\\d\\$_]*)\\s*\\))?|finally)\\s*\\{/\nsetLispType(['try'] as const, (constants, type, part, res, expect, ctx) => {\n  const body = restOfExp(constants, part.substring(res[0].length), [], \"{\");\n  let catchRes = catchReg.exec(part.substring(res[0].length + body.length + 1).toString());\n  let finallyBody;\n  let exception = \"\";\n  let catchBody;\n  let offset = 0;\n  if (catchRes![1].startsWith('catch')) {\n    catchRes = catchReg.exec(part.substring(res[0].length + body.length + 1).toString());\n    exception = catchRes![2];\n    catchBody = restOfExp(constants, part.substring(res[0].length + body.length + 1 + catchRes![0].length), [], \"{\");\n    offset = res[0].length + body.length + 1 + catchRes![0].length + catchBody.length + 1;\n    if ((catchRes = catchReg.exec(part.substring(offset).toString())) && catchRes[1].startsWith('finally')) {\n      finallyBody = restOfExp(constants, part.substring(offset + catchRes[0].length), [], \"{\");\n    }\n  } else {\n    finallyBody = restOfExp(constants, part.substring(res[0].length + body.length + 1 + catchRes![0].length), [], \"{\");\n  }\n  const b = [\n    exception,\n    lispifyBlock(insertSemicolons(constants, catchBody || emptyString), constants),\n    lispifyBlock(insertSemicolons(constants, finallyBody || emptyString), constants),\n  ] as LispItem;\n  ctx.lispTree = createLisp<Try>({\n    op: LispType.Try,\n    a: lispifyBlock(insertSemicolons(constants, body), constants),\n    b\n  });\n});\n\nsetLispType(['void', 'await'] as const, (constants, type, part, res, expect, ctx) => {\n  const extract = restOfExp(constants, part.substring(res[0].length), [/^([^\\s\\.\\?\\w\\$]|\\?[^\\.])/]);\n  ctx.lispTree = lispify(constants, part.substring(res[0].length + extract.length), expectTypes[expect].next, createLisp<Void|Await>({\n    op: type === 'void' ? LispType.Void : LispType.Await,\n    a: lispify(constants, extract),\n    b: LispType.None\n  }));\n});\n\nsetLispType(['new'] as const, (constants, type, part, res, expect, ctx) => {\n  let i = res[0].length;\n  const obj = restOfExp(constants, part.substring(i), [], undefined, \"(\");\n  i += obj.length + 1;\n  const args: CodeString[] = [];\n  if (part.char(i - 1) === \"(\") {\n    const argsString = restOfExp(constants, part.substring(i), [], \"(\");\n    i += argsString.length + 1;\n    let found: CodeString;\n    let j = 0;\n    while((found = restOfExp(constants, argsString.substring(j), [/^,/])).length) {\n      j += found.length + 1;\n      args.push(found.trim());\n    }\n  }\n  ctx.lispTree = lispify(constants, part.substring(i), expectTypes.expEdge.next, createLisp({\n    op: LispType.New,\n    a: lispify(constants, obj, expectTypes.initialize.next),\n    b: args.map((arg) => lispify(constants, arg, expectTypes.initialize.next)),\n  }));\n});\n\nconst ofStart2 = lispify(undefined as any, new CodeString('let $$iterator = $$obj[Symbol.iterator]()'), ['initialize']);\nconst ofStart3 = lispify(undefined as any, new CodeString('let $$next = $$iterator.next()'), ['initialize']);\nconst ofCondition = lispify(undefined as any, new CodeString('return !$$next.done'), ['initialize']);\nconst ofStep = lispify(undefined as any, new CodeString('$$next = $$iterator.next()'));\nconst inStart2 = lispify(undefined as any, new CodeString('let $$keys = Object.keys($$obj)'), ['initialize']);\nconst inStart3 = lispify(undefined as any, new CodeString('let $$keyIndex = 0'), ['initialize']);\nconst inStep = lispify(undefined as any, new CodeString('$$keyIndex++'));\nconst inCondition = lispify(undefined as any, new CodeString('return $$keyIndex < $$keys.length'), ['initialize']);\n\nvar lastType: CodeString|string;\nvar lastPart: CodeString|string;\nvar lastLastPart: CodeString|string;\nvar lastLastLastPart: CodeString|string;\nvar lastLastLastLastPart: CodeString|string;\nfunction lispify(constants: IConstants, part: CodeString, expected?: readonly string[], lispTree?: Lisp, topLevel = false): Lisp {\n  lispTree = lispTree || NullLisp;\n  expected = expected || expectTypes.initialize.next;\n  if (part === undefined) return lispTree;\n\n  part = part.trimStart();\n  const str = part.toString();\n  if (!part.length && !expected.includes('expEnd')) {\n    throw new SyntaxError(\"Unexpected end of expression\");\n  }\n  if (!part.length) return lispTree;\n\n  let ctx = {lispTree: lispTree};\n\n  let res: any;\n  for (let expect of expected) {\n    if (expect === 'expEnd') {\n      continue;\n    }\n    for (let type in expectTypes[expect].types) {\n      if (type === 'expEnd') {\n        continue;\n      }\n      if(res = expectTypes[expect].types[type].exec(str)) {\n        lastType = type;\n        lastLastLastLastPart = lastLastLastPart;\n        lastLastLastPart = lastLastPart;\n        lastLastPart = lastPart;\n        lastPart = part;\n        try {\n          lispTypes.get(type)?.(constants, type, part, res, expect, ctx);\n        } catch(e) {\n          if (topLevel && e instanceof SyntaxError) {\n            throw new ParseError(e.message, str);\n          }\n          throw e;\n        }\n        break;\n      }\n    }\n    if (res) break;\n  }\n\n  if (!res && part.length) {\n    let msg = `Unexpected token after ${lastType}: ${part.char(0)}`;\n    if (topLevel) {\n      throw new ParseError(`Unexpected token after ${lastType}: ${part.char(0)}`, str);\n    }\n    throw new SyntaxError(`Unexpected token after ${lastType}: ${part.char(0)}`);\n  }\n  return ctx.lispTree;\n}\n\nconst startingExpectedWithoutSingle = startingExecpted.filter((r) => r !== 'expSingle');\n\nfunction lispifyExpr(constants: IConstants, str: CodeString, expected?: readonly string[]): Lisp {\n  if (!str.trimStart().length) return NullLisp;\n  let subExpressions: CodeString[] = [];\n  let sub: CodeString;\n  let pos = 0;\n  expected = expected || expectTypes.initialize.next;\n  if (expected.includes('expSingle')) {\n    if (testMultiple(str.toString(), Object.values(expectTypes.expSingle.types))) {\n      return lispify(constants, str, ['expSingle'], undefined, true);\n    }\n  }\n  if (expected === startingExecpted) expected = startingExpectedWithoutSingle;\n  while ((sub = restOfExp(constants, str.substring(pos), [/^,/])).length) {\n    subExpressions.push(sub.trimStart());\n    pos += sub.length + 1;\n  }\n  if (subExpressions.length === 1) {\n    return lispify(constants, str, expected, undefined, true);\n  }\n  if (expected.includes('initialize')) {\n    let defined = expectTypes.initialize.types.initialize.exec(subExpressions[0].toString());\n    if (defined) {\n      return createLisp<Block>({\n        op: LispType.Block,\n        a: subExpressions.map((str, i) => lispify(constants, i ? new CodeString(defined![1] + ' ' + str) : str, ['initialize'], undefined, true)),\n        b: LispType.None\n      });\n    } else if (expectTypes.initialize.types.return.exec(subExpressions[0].toString())) {\n      return lispify(constants, str, expected, undefined, true);\n    }\n  }\n  const exprs = subExpressions.map((str, i) => lispify(constants, str, expected, undefined, true));\n  return createLisp<Expression>({op: LispType.Expression, a: exprs, b: LispType.None});\n}\n\nexport function lispifyReturnExpr(constants: IConstants, str: CodeString) {\n  return createLisp<Return>({op: LispType.Return, a: LispType.None, b: lispifyExpr(constants, str)})\n}\n\nexport function lispifyBlock(str: CodeString, constants: IConstants, expression = false): Lisp[] {\n  str = insertSemicolons(constants, str);\n  if (!str.trim().length) return [];\n  let parts: CodeString[] = [];\n  let part: CodeString;\n  let pos = 0;\n  let start = 0;\n  let details: restDetails = {};\n  let skipped = false;\n  let isInserted = false;\n  while ((part = restOfExp(constants, str.substring(pos), [semiColon], undefined, undefined, undefined, details)).length) {\n    isInserted = !!(str.char(pos + part.length) && str.char(pos + part.length) !== ';');\n    pos += part.length + (isInserted ? 0 : 1);\n    if (/^\\s*else(?![\\w\\$])/.test(str.substring(pos).toString())) {\n      skipped = true;\n    } else if (details['words']?.includes('do') && /^\\s*while(?![\\w\\$])/.test(str.substring(pos).toString())) {\n      skipped = true;\n    } else {\n      skipped = false;\n      parts.push(str.substring(start, pos - (isInserted ? 0 : 1)));\n      start = pos;\n    }\n    details = {};\n    if (expression) break;\n  }\n  if (skipped) {\n    parts.push(str.substring(start, pos - (isInserted ? 0 : 1)));\n  }\n  return parts.map((str) => str.trimStart()).filter((str) => str.length).map((str, j) => {\n    return lispifyExpr(constants, str.trimStart(), startingExecpted);\n  });\n}\n\nexport function lispifyFunction(str: CodeString, constants: IConstants, expression = false): Lisp[] {\n  if (!str.trim().length) return [];\n  const tree = lispifyBlock(str, constants, expression);\n  let hoisted: Lisp[] = [];\n  hoist(tree, hoisted);\n  return hoisted.concat(tree);\n}\n\nfunction hoist(item: LispItem, res: Lisp[]): boolean {\n  if (isLisp(item)) {\n    if (!isLisp<LispFamily>(item)) return false;\n    const [op, a, b] = item;\n    if (op === LispType.Try || op === LispType.If || op === LispType.Loop || op === LispType.Switch) {\n      hoist(a, res);\n      hoist(b, res);\n    } else if (op === LispType.Var) {\n      res.push(createLisp({op: LispType.Var, a: a, b: LispType.None}));\n    } else if (op === LispType.Function && a[1]) {\n      res.push(item);\n      return true;\n    }\n  } else if (Array.isArray(item)) {\n    const rep: LispItemSingle[] = [];\n    for (let it of item) {\n      if (!hoist(it, res)) {\n        rep.push(it);\n      }\n    }\n    if (rep.length !== item.length) {\n      item.length = 0;\n      item.push(...rep);\n    }\n  }\n  return false;\n}\n\nconst closingsNoInsertion = /^(\\})\\s*(catch|finally|else|while|instanceof)(?![\\w\\$])/\n                    //  \\w|)|] \\n \\w = 2                                  // \\} \\w|\\{ = 5 \nconst colonsRegex = /^((([\\w\\$\\]\\)\\\"\\'\\`]|\\+\\+|\\-\\-)\\s*\\r?\\n\\s*([\\w\\$\\+\\-\\!~]))|(\\}\\s*[\\w\\$\\!~\\+\\-\\{\\(\\\"\\'\\`]))/\n\n// if () \\w \\n; \\w              == \\w \\n \\w    | last === if             a\n// if () { }; \\w                == \\} ^else    | last === if             b\n// if () \\w \\n; else \\n \\w \\n;  == \\w \\n \\w    | last === else           a\n// if () {} else {}; \\w         == \\} \\w       | last === else           b\n// while () \\n \\w \\n; \\w        == \\w \\n \\w    | last === while          a\n// while () { }; \\w             == \\} \\w       | last === while          b\n// do \\w \\n; while (); \\w       == \\w \\n while | last === do             a\n// do { } while (); \\w          == \\) \\w       | last === while          c\n// try {} catch () {}; \\w       == \\} \\w       | last === catch|finally  b\n// \\w \\n; \\w                    == \\w \\n \\w    | last === none           a\n// cb() \\n \\w                   == \\) \\n \\w    | last === none           a\n// obj[a] \\n \\w                 == \\] \\n \\w    | last === none           a\n// {} {}                        == \\} \\{       | last === none           b\n\nexport function insertSemicolons(constants: IConstants, str: CodeString): CodeString {\n  let rest = str;\n  let sub = emptyString;\n  let details: restDetails = {};\n  const inserted = insertedSemicolons.get(str.ref) || new Array(str.ref.str.length);\n  while ((sub = restOfExp(constants, rest, [], undefined, undefined, [colonsRegex], details)).length) {\n    let valid = false;\n    let part = sub;\n    let edge = sub.length;\n    if (details.regRes) {\n      valid = true;\n      const [,, a,,, b] = details.regRes;\n      edge = details.regRes[3] === \"++\" || details.regRes[3] === \"--\" ? sub.length + 1 : sub.length;\n      part = rest.substring(0,  edge);\n      if (b) {\n        let res = closingsNoInsertion.exec(rest.substring(sub.length - 1).toString());\n        if (res) {\n          if (res[2] === 'while') {\n            valid = details.lastWord !== 'do';\n          } else {\n            valid = false;\n          }\n        } else if (details.lastWord === 'function' && details.regRes[5][0] === \"}\" && details.regRes[5].slice(-1) === '(') {\n          valid = false;\n        } \n\n      } else if (a) {\n        if (details.lastWord === 'if' || details.lastWord === 'while' || details.lastWord === 'for' || details.lastWord === 'else') {\n          valid = false;\n        }\n      }\n    }\n    if (valid) {\n      inserted[part.end] = true;\n    }\n    rest = rest.substring(edge);\n    details = {};\n  }\n  insertedSemicolons.set(str.ref, inserted);\n  return str;\n}\n\nexport function checkRegex(str: string): IRegEx | null {\n  let i = 1;\n  let escape = false;\n  let done = false;\n  let cancel = false;\n  while (i < str.length && !done && !cancel) {\n    done = (str[i] === '/' && !escape);\n    escape = str[i] === '\\\\' && !escape;\n    cancel = str[i] === '\\n';\n    i++;\n  }\n  let after = str.substring(i);\n  cancel = (cancel || !done) || /^\\s*\\d/.test(after);\n  if (cancel) return null;\n  let flags = /^[a-z]*/.exec(after);\n  if(/^\\s+[\\w\\$]/.test(str.substring(i + flags![0].length))) {\n    return null;\n  }\n  return {\n    regex: str.substring(1, i-1),\n    flags: (flags && flags[0]) || \"\",\n    length: i + ((flags && flags[0].length) || 0)\n  }\n}\n\nconst notDivide = /(typeof|delete|instanceof|return|in|of|throw|new|void|do|if)$/\nconst possibleDivide = /^([\\w\\$\\]\\)]|\\+\\+|\\-\\-)[\\s\\/]/;\nexport function extractConstants(constants: IConstants, str: string, currentEnclosure = \"\"): {str: string, length: number} {\n  let quote;\n  let extract: (string|number)[] = [];\n  let escape = false;\n  let regexFound: IRegEx|null;\n  let comment = \"\";\n  let commentStart = -1;\n  let currJs: string[] = [];\n  let char: string = \"\";\n  const strRes: (string|number)[] = [];\n  const enclosures: string[] = [];\n  let isPossibleDivide: RegExpExecArray|null = null;\n  for (var i = 0; i < str.length; i++) {\n    char = str[i];\n    if (comment) {\n      if (char === comment) {\n        if (comment === \"*\" && str[i + 1] ===\"/\") {\n          comment = \"\";\n          i++\n        } else if (comment === \"\\n\") {\n          comment = \"\";\n        }\n      }\n    } else {\n      if (escape) {\n        escape = false;\n        extract.push(char);\n        continue;\n      }\n\n      if (quote) {\n        if (quote === \"`\" && char === \"$\" && str[i+1] === \"{\") {\n          let skip = extractConstants(constants, str.substring(i+2), \"{\");\n          currJs.push(skip.str);\n          extract.push('${', currJs.length - 1, `}`);\n          i += skip.length + 2;\n        } else if (quote === char) {\n          if (quote === '`') {\n            const li = createLisp<Literal>({\n              op: LispType.Literal,\n              a:  unraw(extract.join(\"\")),\n              b: [],\n            });\n            li.tempJsStrings = currJs\n            constants.literals.push(li);\n            strRes.push(`\\``, constants.literals.length - 1, `\\``);\n          } else {\n            constants.strings.push(unraw(extract.join(\"\")));\n            strRes.push(`\"`, constants.strings.length - 1, `\"`);\n          }\n          quote = null;\n          extract = [];\n        } else {\n          extract.push(char);\n        }\n      } else {\n        if ((char === \"'\"  || char === '\"'  || char === '`')) {\n          currJs = [];\n          quote = char;\n        } else if (closings[currentEnclosure] === char && !enclosures.length) {\n          return {str: strRes.join(\"\"), length: i}\n        } else if (closings[char]) {\n          enclosures.push(char);\n          strRes.push(char);\n        } else if (closings[enclosures[enclosures.length-1]] === char) {\n          enclosures.pop();\n          strRes.push(char);\n        } else if (char === \"/\" && (str[i+1] === \"*\" || str[i+1] === \"/\")) {\n          comment = str[i+1] === \"*\" ? \"*\" : \"\\n\";\n          commentStart = i;\n        } else if (char === '/' && !isPossibleDivide && (regexFound = checkRegex(str.substring(i)))) {\n          constants.regexes.push(regexFound);\n          strRes.push(`/`, constants.regexes.length - 1, `/r`);\n          i += regexFound.length - 1;\n        } else {\n          strRes.push(char);\n        }\n\n        if (!isPossibleDivide || !space.test(char)) {\n          if (isPossibleDivide = possibleDivide.exec(str.substring(i))) {\n            if (notDivide.test(str.substring(0, i + isPossibleDivide[1].length))) {\n              isPossibleDivide = null;\n            }\n          }\n        }\n      }\n      escape = !!(quote && char === \"\\\\\");\n    }\n  }\n\n  if (comment) {\n    if (comment === \"*\") {\n      throw new SyntaxError(`Unclosed comment '/*': ${str.substring(commentStart)}`)\n    }\n  }\n  return {str: strRes.join(\"\"), length: i}\n}\n\nexport default function parse(code: string, eager = false, expression = false): IExecutionTree {\n  if (typeof code !== 'string') throw new ParseError(`Cannot parse ${code}`, code);\n  let str = ' ' + code;\n  const constants: IConstants = {strings: [], literals: [], regexes: [], eager};\n  str = extractConstants(constants, str).str;\n\n  for (let l of constants.literals) {\n    l[2] = l.tempJsStrings!.map((js: string) => lispifyExpr(constants, new CodeString(js)));\n    delete l.tempJsStrings;\n  }\n  return {tree: lispifyFunction(new CodeString(str), constants, expression), constants};\n}\n"],"names":[],"mappings":"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"}