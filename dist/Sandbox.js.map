{"version":3,"file":"Sandbox.js","sources":["../src/unraw.ts","../src/parser.ts","../src/executor.ts","../src/Sandbox.ts"],"sourcesContent":["/**\n * Parse a string as a base-16 number. This is more strict than `parseInt` as it\n * will not allow any other characters, including (for example) \"+\", \"-\", and\n * \".\".\n * @param hex A string containing a hexadecimal number.\n * @returns The parsed integer, or `NaN` if the string is not a valid hex\n * number.\n */\nfunction parseHexToInt(hex: string): number {\n  const isOnlyHexChars = !hex.match(/[^a-f0-9]/i);\n  return isOnlyHexChars ? parseInt(hex, 16) : NaN;\n}\n\n/**\n * Check the validity and length of a hexadecimal code and optionally enforces\n * a specific number of hex digits.\n * @param hex The string to validate and parse.\n * @param errorName The name of the error message to throw a `SyntaxError` with\n * if `hex` is invalid. This is used to index `errorMessages`.\n * @param enforcedLength If provided, will throw an error if `hex` is not\n * exactly this many characters.\n * @returns The parsed hex number as a normal number.\n * @throws {SyntaxError} If the code is not valid.\n */\nfunction validateAndParseHex(\n  hex: string,\n  errorName: string,\n  enforcedLength?: number\n): number {\n  const parsedHex = parseHexToInt(hex);\n  if (\n    Number.isNaN(parsedHex) ||\n    (enforcedLength !== undefined && enforcedLength !== hex.length)\n  ) {\n    throw new SyntaxError(errorName + ': ' + hex);\n  }\n  return parsedHex;\n}\n\n/**\n * Parse a two-digit hexadecimal character escape code.\n * @param code The two-digit hexadecimal number that represents the character to\n * output.\n * @returns The single character represented by the code.\n * @throws {SyntaxError} If the code is not valid hex or is not the right\n * length.\n */\nfunction parseHexadecimalCode(code: string): string {\n  const parsedCode = validateAndParseHex(\n    code,\n    'Malformed Hexadecimal',\n    2\n  );\n  return String.fromCharCode(parsedCode);\n}\n\n/**\n * Parse a four-digit Unicode character escape code.\n * @param code The four-digit unicode number that represents the character to\n * output.\n * @param surrogateCode Optional four-digit unicode surrogate that represents\n * the other half of the character to output.\n * @returns The single character represented by the code.\n * @throws {SyntaxError} If the codes are not valid hex or are not the right\n * length.\n */\nfunction parseUnicodeCode(code: string, surrogateCode?: string): string {\n  const parsedCode = validateAndParseHex(code, 'Malformed Unicode', 4);\n\n  if (surrogateCode !== undefined) {\n    const parsedSurrogateCode = validateAndParseHex(\n      surrogateCode,\n      'Malformed Unicode',\n      4\n    );\n    return String.fromCharCode(parsedCode, parsedSurrogateCode);\n  }\n\n  return String.fromCharCode(parsedCode);\n}\n\n/**\n * Test if the text is surrounded by curly braces (`{}`).\n * @param text Text to check.\n * @returns `true` if the text is in the form `{*}`.\n */\nfunction isCurlyBraced(text: string): boolean {\n  return text.charAt(0) === \"{\" && text.charAt(text.length - 1) === \"}\";\n}\n\n/**\n * Parse a Unicode code point character escape code.\n * @param codePoint A unicode escape code point, including the surrounding curly\n * braces.\n * @returns The single character represented by the code.\n * @throws {SyntaxError} If the code is not valid hex or does not have the\n * surrounding curly braces.\n */\nfunction parseUnicodeCodePointCode(codePoint: string): string {\n  if (!isCurlyBraced(codePoint)) {\n    throw new SyntaxError('Malformed Unicode: +' + codePoint);\n  }\n  const withoutBraces = codePoint.slice(1, -1);\n  const parsedCode = validateAndParseHex(\n    withoutBraces,\n    'Malformed Unicode'\n  );\n\n  try {\n    return String.fromCodePoint(parsedCode);\n  } catch (err) {\n    throw err instanceof RangeError\n      ? new SyntaxError('Code Point Limit:' + parsedCode)\n      : err;\n  }\n}\n\n/**\n * Map of unescaped letters to their corresponding special JS escape characters.\n * Intentionally does not include characters that map to themselves like \"\\'\".\n */\nconst singleCharacterEscapes = new Map<string, string>([\n  [\"b\", \"\\b\"],\n  [\"f\", \"\\f\"],\n  [\"n\", \"\\n\"],\n  [\"r\", \"\\r\"],\n  [\"t\", \"\\t\"],\n  [\"v\", \"\\v\"],\n  [\"0\", \"\\0\"]\n]);\n\n/**\n * Parse a single character escape sequence and return the matching character.\n * If none is matched, defaults to `code`.\n * @param code A single character code.\n */\nfunction parseSingleCharacterCode(code: string): string {\n  return singleCharacterEscapes.get(code) || code;\n}\n\n/**\n * Matches every escape sequence possible, including invalid ones.\n *\n * All capture groups (described below) are unique (only one will match), except\n * for 4, which can only potentially match if 3 does.\n *\n * **Capture Groups:**\n * 0. A single backslash\n * 1. Hexadecimal code\n * 2. Unicode code point code with surrounding curly braces\n * 3. Unicode escape code with surrogate\n * 4. Surrogate code\n * 5. Unicode escape code without surrogate\n * 6. Octal code _NOTE: includes \"0\"._\n * 7. A single character (will never be \\, x, u, or 0-3)\n */\nconst escapeMatch = /\\\\(?:(\\\\)|x([\\s\\S]{0,2})|u(\\{[^}]*\\}?)|u([\\s\\S]{4})\\\\u([^{][\\s\\S]{0,3})|u([\\s\\S]{0,4})|([0-3]?[0-7]{1,2})|([\\s\\S])|$)/g;\n\n/**\n * Replace raw escape character strings with their escape characters.\n * @param raw A string where escape characters are represented as raw string\n * values like `\\'` rather than `'`.\n * @param allowOctals If `true`, will process the now-deprecated octal escape\n * sequences (ie, `\\111`).\n * @returns The processed string, with escape characters replaced by their\n * respective actual Unicode characters.\n */\nexport function unraw(raw: string): string {\n  return raw.replace(escapeMatch, function(\n    _,\n    backslash?: string,\n    hex?: string,\n    codePoint?: string,\n    unicodeWithSurrogate?: string,\n    surrogate?: string,\n    unicode?: string,\n    octal?: string,\n    singleCharacter?: string\n  ): string {\n    // Compare groups to undefined because empty strings mean different errors\n    // Otherwise, `\\u` would fail the same as `\\` which is wrong.\n    if (backslash !== undefined) {\n      return \"\\\\\";\n    }\n    if (hex !== undefined) {\n      return parseHexadecimalCode(hex);\n    }\n    if (codePoint !== undefined) {\n      return parseUnicodeCodePointCode(codePoint);\n    }\n    if (unicodeWithSurrogate !== undefined) {\n      return parseUnicodeCode(unicodeWithSurrogate, surrogate);\n    }\n    if (unicode !== undefined) {\n      return parseUnicodeCode(unicode);\n    }\n    if (octal === \"0\") {\n      return \"\\0\";\n    }\n    if (octal !== undefined) {\n      throw new SyntaxError('Octal Deprecation: ' + octal);\n    }\n    if (singleCharacter !== undefined) {\n      return parseSingleCharacterCode(singleCharacter);\n    }\n    throw new SyntaxError('End of string');\n  });\n}\nexport default unraw;","import unraw from \"./unraw.js\";\nexport type LispArray = Array<LispItem>&{lisp: {}}\nexport type LispItem = Lisp|If|KeyVal|SpreadArray|SpreadObject|(LispArray)|{new(): any }|(new (...args: any[]) => any)|CodeString|String|Number|Boolean|null|undefined;\nexport interface ILiteral extends Lisp {\n  op: 'literal';\n  a: string;\n  b: LispArray;\n}\n\nexport interface IRegEx {\n  regex: string,\n  flags: string,\n  length: number\n}\n\nexport interface IConstants {\n  strings: string[];\n  literals: ILiteral[];\n  regexes: IRegEx[];\n  eager: boolean;\n}\n\nexport interface IExecutionTree {\n  tree: LispArray, \n  constants: IConstants\n}\n\ntype LispCallback = (strings: IConstants, type: string, part: CodeString, res: string[], expect: string, ctx: {lispTree: LispItem}) => any\nlet lispTypes: Map<string, LispCallback> = new Map();\n\nexport class ParseError extends Error {\n  constructor(message: string, public code: string) {\n    super(message + \": \" + code.substring(0, 40));\n  }\n}\n\nexport class Lisp {\n  op: string;\n  a?: LispItem;\n  b?: LispItem;\n  constructor(obj: Lisp) {\n    this.op = obj.op;\n    this.a = obj.a;\n    this.b = obj.b;\n  }\n}\n\nexport class If {\n  constructor(public t: any, public f: any) {}\n}\n\nexport class KeyVal {\n  constructor(public key: string, public val: any) {}\n}\n\nexport class SpreadObject {\n  constructor(public item: {[key: string]: any}) {}\n}\n\nexport class SpreadArray {\n  constructor(public item: any[]) {}\n}\n\nexport const lispArrayKey = {};\n\nexport function toLispArray(arr: LispItem[]): LispArray {\n  (arr as LispArray).lisp = lispArrayKey;\n  return arr as LispArray;\n}\n\nconst inlineIfElse =  /^:/;\nconst elseIf = /^else(?![\\w\\$])/\nconst ifElse = /^if(?![\\w\\$])/\nconst space = /^\\s/;\n\nexport let expectTypes: {[type:string]: {types: {[type:string]: RegExp}, next: string[]}} = {\n  splitter: {\n    types: {\n      opHigh: /^(\\/|\\*\\*|\\*(?!\\*)|\\%)(?!\\=)/,\n      op: /^(\\+(?!(\\+))|\\-(?!(\\-)))(?!\\=)/,\n      comparitor: /^(<=|>=|<(?!<)|>(?!>)|!==|!=(?!\\=)|===|==)/,\n      boolOp: /^(&&|\\|\\||instanceof(?![\\w\\$])|in(?![\\w\\$]))/,\n      bitwise: /^(&(?!&)|\\|(?!\\|)|\\^|<<|>>(?!>)|>>>)(?!\\=)/,\n    },\n    next: [\n      'modifier',\n      'value', \n      'prop', \n      'incrementerBefore',\n    ]\n  },\n  inlineIf: {\n    types: {\n      inlineIf: /^\\?(?!\\.(?!\\d))/,\n    },\n    next: [\n      'expEnd'\n    ]\n  },\n  assignment: {\n    types: {\n      assignModify: /^(\\-=|\\+=|\\/=|\\*\\*=|\\*=|%=|\\^=|\\&=|\\|=|>>>=|>>=|<<=)/,\n      assign: /^(=)(?!=)/\n    },\n    next: [\n      'modifier',\n      'value', \n      'prop', \n      'incrementerBefore',\n    ]\n  },\n  incrementerBefore: {\n    types: {incrementerBefore: /^(\\+\\+|\\-\\-)/},\n    next: [\n      'prop',\n    ]\n  },\n  expEdge: {\n    types: {\n      call: /^(\\?\\.)?[\\(]/,\n      incrementerAfter: /^(\\+\\+|\\-\\-)/\n    },\n    next: [\n      'splitter',\n      'expEdge',\n      'dot',\n      'inlineIf',\n      'expEnd'\n    ]\n  },\n  modifier: {\n    types: {\n      not: /^!/,\n      inverse: /^~/,\n      negative: /^\\-(?!\\-)/,\n      positive: /^\\+(?!\\+)/,\n      typeof: /^typeof(?![\\w\\$])/,\n      delete: /^delete(?![\\w\\$])/,\n    },\n    next: [\n      'modifier', \n      'value',\n      'prop',\n      'incrementerBefore',\n    ]\n  },\n  dot: {\n    types: {\n      arrayProp: /^(\\?\\.)?\\[/,\n      dot: /^(\\?)?\\.(?=\\s*[a-zA-Z\\$\\_])/,\n    },\n    next: [\n      'splitter',\n      'assignment',\n      'expEdge',\n      'dot',\n      'inlineIf',\n      'expEnd'\n    ]\n  },\n  prop: {\n    types: {\n      prop: /^[a-zA-Z\\$\\_][a-zA-Z\\d\\$\\_]*/,\n    },\n    next: [\n      'splitter',\n      'assignment',\n      'expEdge',\n      'dot',\n      'inlineIf',\n      'expEnd'\n    ]\n  },\n  value: {\n    types: {\n      createObject: /^\\{/,\n      createArray: /^\\[/,\n      number: /^(0x[\\da-f]+(_[\\da-f]+)*|(\\d+(_\\d+)*(\\.\\d+(_\\d+)*)?|\\.\\d+(_\\d+)*))(e[\\+\\-]?\\d+(_\\d+)*)?(n)?(?!\\d)/i,\n      string: /^\"(\\d+)\"/,\n      literal: /^`(\\d+)`/,\n      regex: /^\\/(\\d+)\\/r(?![\\w\\$])/,\n      boolean: /^(true|false)(?![\\w\\$])/,\n      null: /^null(?![\\w\\$])/,\n      und: /^undefined(?![\\w\\$])/,\n      arrowFunctionSingle: /^(async\\s+)?([a-zA-Z\\$_][a-zA-Z\\d\\$_]*)\\s*=>\\s*({)?/,\n      arrowFunction: /^(async\\s*)?\\(\\s*((\\.\\.\\.)?\\s*[a-zA-Z\\$_][a-zA-Z\\d\\$_]*(\\s*,\\s*(\\.\\.\\.)?\\s*[a-zA-Z\\$_][a-zA-Z\\d\\$_]*)*)?\\s*\\)\\s*=>\\s*({)?/,\n      inlineFunction: /^(async\\s+)?function(\\s*[a-zA-Z\\$_][a-zA-Z\\d\\$_]*)?\\s*\\(\\s*((\\.\\.\\.)?\\s*[a-zA-Z\\$_][a-zA-Z\\d\\$_]*(\\s*,\\s*(\\.\\.\\.)?\\s*[a-zA-Z\\$_][a-zA-Z\\d\\$_]*)*)?\\s*\\)\\s*{/,\n      group: /^\\(/,\n      NaN: /^NaN(?![\\w\\$])/,\n      Infinity: /^Infinity(?![\\w\\$])/,\n      void: /^void(?![\\w\\$])\\s*/,\n      await: /^await(?![\\w\\$])\\s*/,\n      new: /^new(?![\\w\\$])\\s*/,\n      throw: /^throw(?![\\w\\$])\\s*/\n    },\n    next: [\n      'splitter',\n      'expEdge',\n      'dot',\n      'inlineIf',\n      'expEnd'\n    ]\n  },\n  initialize: {\n    types: {\n      initialize: /^(var|let|const)\\s+([a-zA-Z\\$_][a-zA-Z\\d\\$_]*)\\s*(=)?/,\n      return: /^return(?![\\w\\$])/,\n    },\n    next: [\n      'modifier',\n      'value', \n      'prop', \n      'incrementerBefore',\n      'expEnd'\n    ]\n  },\n  spreadObject: {\n    types: {\n      spreadObject: /^\\.\\.\\./\n    },\n    next: [\n      'value',\n      'prop', \n    ]\n  },\n  spreadArray: {\n    types: {\n      spreadArray: /^\\.\\.\\./\n    },\n    next: [\n      'value', \n      'prop', \n    ]\n  },\n  expEnd: {types: {}, next: []},\n  expFunction: {\n    types: {\n      function: /^(async\\s+)?function(\\s*[a-zA-Z\\$_][a-zA-Z\\d\\$_]*)\\s*\\(\\s*((\\.\\.\\.)?\\s*[a-zA-Z\\$_][a-zA-Z\\d\\$_]*(\\s*,\\s*(\\.\\.\\.)?\\s*[a-zA-Z\\$_][a-zA-Z\\d\\$_]*)*)?\\s*\\)\\s*{/,\n    },\n    next: [\n      'expEdge',\n      'expEnd'\n    ]\n  },\n  expSingle: {\n    types: {\n      for: /^(([a-zA-Z\\$\\_][\\w\\$]*)\\s*:)?\\s*for\\s*\\(/,\n      do: /^(([a-zA-Z\\$\\_][\\w\\$]*)\\s*:)?\\s*do(?![\\w\\$])\\s*(\\{)?/,\n      while: /^(([a-zA-Z\\$\\_][\\w\\$]*)\\s*:)?\\s*while\\s*\\(/,\n      loopAction: /^(break|continue)(?![\\w\\$])\\s*([a-zA-Z\\$\\_][\\w\\$]*)?/,\n      if: /^((([a-zA-Z\\$\\_][\\w\\$]*)\\s*:)?\\s*)if\\s*\\(/,\n      try: /^try\\s*{/,\n      block: /^{/,\n      switch: /^(([a-zA-Z\\$\\_][\\w\\$]*)\\s*:)?\\s*switch\\s*\\(/,\n    },\n    next: [\n      'expEnd'\n    ]\n  }\n};\n\nlet closings = {\n  \"(\": \")\",\n  \"[\": \"]\",\n  \"{\": \"}\",\n  \"'\": \"'\",\n  '\"': '\"',\n  \"`\": \"`\"\n}\n\nexport function testMultiple(str: string, tests: RegExp[]) {\n  let found: RegExpExecArray;\n  for (let i = 0; i < tests.length; i++) {\n    const test = tests[i];\n    found = test.exec(str);\n    if (found) break;\n  }\n  return found;\n}\n\nexport class CodeString {\n  \n  start: number;\n  end: number;\n  ref: {str: string};\n  constructor(str: string|CodeString) {\n    this.ref = {str: \"\"};\n    if (str instanceof CodeString) {\n      this.ref = str.ref;\n      this.start = str.start\n      this.end = str.end;\n    } else {\n      this.ref.str = str;\n      this.start = 0;\n      this.end = str.length;\n    }\n  }\n\n  substring(start: number, end?: number): CodeString {\n    if (!this.length) return this;\n    start = this.start + start;\n    if (start < 0) {\n      start = 0;\n    }\n    if (start > this.end) {\n      start = this.end;\n    }\n    end = end === undefined ? this.end : this.start + end;\n    if (end < 0) {\n      end = 0;\n    }\n    if (end > this.end) {\n      end = this.end;\n    }\n    const code = new CodeString(this);\n    code.start = start;\n    code.end = end;\n    return code;\n  }\n\n  get length () {\n    const len = this.end - this.start;\n    return len < 0 ? 0 : len;\n  }\n\n  char(i: number) {\n    if (this.start === this.end) return undefined;\n    return this.ref.str[this.start + i];\n  }\n\n  toString() {\n    return this.ref.str.substring(this.start, this.end);\n  }\n\n  trimStart() {\n    const found = /^\\s+/.exec(this.toString());\n    const code = new CodeString(this);\n    if (found) {\n      code.start += found[0].length;\n    }\n    return code;\n  }\n\n  slice(start: number, end?: number) {\n    if (start < 0) {\n      start = this.end - this.start + start;\n    }\n    if (start < 0) {\n      start = 0;\n    }\n    if (end === undefined) {\n      end = this.end - this.start;\n    }\n\n    if (end < 0) {\n      end = this.end - this.start + end;\n    }\n    if (end < 0) {\n      end = 0;\n    }\n    return this.substring(start, end);\n  }\n\n  trim() {\n    const code = this.trimStart();\n    const found = /\\s+$/.exec(code.toString());\n    if (found) {\n      code.end -= found[0].length;\n    }\n    return code;\n  }\n\n  valueOf() {\n    return this.toString();\n  }\n}\n\n\nconst emptyString = new CodeString(\"\")\n\nconst okFirstChars = /^[\\+\\-~ !]/;\nconst aChar = /^[\\w\\$]/\nconst aNumber = expectTypes.value.types.number;\nconst wordReg = /^((if|for|else|while|do|function)(?![\\w\\$])|[\\w\\$]+)/;\nconst semiColon = /^;/\nconst insertedSemicolons: WeakMap<{str: string}, Array<number>> = new WeakMap();\nconst quoteCache: WeakMap<{str: string}, Map<number, number>> = new WeakMap();\nexport interface restDetails {oneliner?: boolean, words?: string[], lastWord?: string, lastAnyWord?: string, regRes?: RegExpExecArray}\nexport function restOfExp(constants: IConstants, \n                          part: CodeString, \n                          tests?: RegExp[], \n                          quote?: string, \n                          firstOpening?: string, \n                          closingsTests?: RegExp[], \n                          details: restDetails = {}): CodeString {\n  if (!part.length) {\n    return part;\n  }\n  details.words = details.words || [];\n  let isStart = true;\n  tests = tests || [];\n  const hasSemiTest = tests.includes(semiColon);\n  if (hasSemiTest) {\n    tests = tests.filter((a) => a !== semiColon);\n  }\n  const insertedSemis = insertedSemicolons.get(part.ref) || [];\n  const cache = quoteCache.get(part.ref) || new Map<number, number>();\n  quoteCache.set(part.ref, cache);\n  if (quote && cache.has(part.start - 1)) {\n    return part.substring(0, cache.get(part.start - 1) - part.start);\n  }\n  let escape = false;\n  let done = false;\n  let lastChar = \"\";\n  let isOneLiner = false;\n  let i;\n  let lastInertedSemi = false;\n  for (i = 0; i < part.length && !done; i++) {\n    let char = part.char(i);\n    if (quote === '\"' || quote === \"'\" || quote === \"`\") {\n      if (quote === \"`\" && char === \"$\" && part.char(i+1) === \"{\" && !escape) {\n        let skip = restOfExp(constants, part.substring(i+2), [], \"{\");\n        i += skip.length + 2;\n      } else if (char === quote && !escape) {\n        return part.substring(0, i);\n      }\n      escape = !escape && char === \"\\\\\";\n    } else if (closings[char]) {\n      if (!lastInertedSemi && insertedSemis[i + part.start]) {\n        lastInertedSemi = true\n        if (hasSemiTest) {\n          break;\n        }\n        i--;\n        lastChar = ';';\n        continue;\n      }\n      if (isOneLiner && char === \"{\") {\n        isOneLiner = false;\n      }\n      if (char === firstOpening) {\n        done = true;\n        break;\n      } else {\n        let skip = restOfExp(constants, part.substring(i+1), [], char);\n        cache.set(skip.start - 1, skip.end);\n        i += skip.length + 1;\n        isStart = false;\n        if (closingsTests) {\n          let sub = part.substring(i);\n          let found: RegExpExecArray;\n          if (found = testMultiple(sub.toString(), closingsTests)) {\n            details.regRes = found;\n            done = true;\n          }\n        }\n      }\n    } else if (!quote) {\n      let sub = part.substring(i).toString();\n      let foundWord: RegExpExecArray;\n      let foundNumber: RegExpExecArray;\n      if (closingsTests) {\n        let found: RegExpExecArray;\n        if (found = testMultiple(sub, closingsTests)) {\n          details.regRes = found;\n          i++;\n          done = true;\n          break;\n        }\n      }\n      if (foundNumber = aNumber.exec(sub)) {\n        i += foundNumber[0].length - 1;\n        sub = part.substring(i).toString();\n      } else if (lastChar != char) {\n        let found: [string]|RegExpExecArray;\n        if (char === ';' || (insertedSemis[i + part.start] && !isStart && !lastInertedSemi)) {\n          if (hasSemiTest) {\n            found = [\";\"];\n          } else if (insertedSemis[i + part.start]) {\n            lastInertedSemi = true\n            i--;\n            lastChar = ';';\n            continue;\n          }\n          char = sub = ';';\n        } else {\n          lastInertedSemi = false;\n        }\n        if (!found) {\n          found = testMultiple(sub, tests);\n        }\n        if (found) {\n          done = true;\n        }\n        if (!done && (foundWord = wordReg.exec(sub))) {\n          isOneLiner = true;\n          if (foundWord[0].length > 1) {\n            details.words.push(foundWord[1]);\n            details.lastAnyWord = foundWord[1];\n            if (foundWord[2]) {\n              details.lastWord = foundWord[2];\n            }\n          }\n          if(foundWord[0].length > 2) {\n            i += foundWord[0].length - 2;\n          }\n        }\n      }\n      if (isStart) {\n        if (okFirstChars.test(sub)) {\n          done = false;\n        } else {\n          isStart = false;\n        }\n      }\n      if (done) break;\n    } else if(char === closings[quote]) {\n      return part.substring(0, i);\n    }\n    lastChar = char;\n  }\n  if (quote) {\n    throw new SyntaxError(\"Unclosed '\" + quote + \"'\");\n  }\n  if (details) {\n    details.oneliner = isOneLiner;\n  }\n  return part.substring(0, i);\n}\nrestOfExp.next = [\n  'splitter',\n  'expEnd',\n  'inlineIf'\n];\n\nconst startingExecpted = ['initialize', 'expSingle', 'expFunction', 'value', 'modifier', 'prop', 'incrementerBefore', 'expEnd'];\n\nexport const setLispType = (types: string[], fn: LispCallback) => {\n  types.forEach((type) => {\n    lispTypes.set(type, fn);\n  })\n}\n\nconst closingsCreate: {[type:string]: RegExp} = {\n  'createArray': /^\\]/,\n  'createObject': /^\\}/,\n  'group': /^\\)/,\n  'arrayProp': /^\\]/,\n  'call': /^\\)/\n}\n\nsetLispType(['createArray', 'createObject', 'group', 'arrayProp','call'], (constants, type, part, res, expect, ctx) => {\n  let extract = emptyString;\n  let arg: CodeString[] = [];\n  let end = false;\n  let i = res[0].length;\n  const start = i;\n  while (i < part.length && !end) {\n    extract = restOfExp(constants, part.substring(i), [\n      closingsCreate[type],\n      /^,/\n    ]);\n    i += extract.length;\n    if (extract.length) {\n      arg.push(extract);\n    }\n    if (part.char(i) !== ',') {\n      end = true;\n    } else {\n      i++;\n    }\n  }\n  const next = ['value', 'modifier', 'prop', 'incrementerBefore', 'expEnd'];\n  let l: LispItem;\n\n  let funcFound: RegExpExecArray;\n  switch(type) {\n    case 'group':\n    case 'arrayProp':\n      l = lispifyExpr(constants, part.substring(start, i));\n      break;\n    case 'call':\n    case 'createArray':\n      // @TODO: support 'empty' values\n      l = toLispArray(arg.map((e) => lispify(constants, e, [...next, 'spreadArray'])));\n      break;\n    case 'createObject':\n      l = toLispArray(arg.map((str) => {\n        str = str.trimStart();\n        let value;\n        let key;\n        funcFound = expectTypes.expFunction.types.function.exec('function ' + str);\n        if (funcFound) {\n          key = funcFound[2].trimStart();\n          value = lispify(constants, new CodeString('function ' + str.toString().replace(key, \"\")));\n        } else {\n          let extract = restOfExp(constants, str, [/^:/]);\n          key = lispify(constants, extract, [...next, 'spreadObject']);\n          if (key instanceof Lisp && key.op === 'prop') {\n            key = key.b;\n          }\n          if (extract.length === str.length) return key;\n          value = lispify(constants, str.substring(extract.length + 1));\n        }\n        return new Lisp({\n          op: 'keyVal',\n          a: key,\n          b: value\n        });\n      }));\n      break;\n  }\n  type = type === 'arrayProp' ? (res[1] ? '?prop' : 'prop') : (type === 'call' ? (res[1] ? '?call' : 'call') : type);\n  ctx.lispTree = lispify(constants, part.substring(i + 1), expectTypes[expect].next, new Lisp({\n    op: type, \n    a: ctx.lispTree, \n    b: l,\n  }));\n});\n\nsetLispType(['inverse', 'not', 'negative', 'positive', 'typeof', 'delete'], (constants, type, part, res, expect, ctx) => {\n  let extract = restOfExp(constants, part.substring(res[0].length), [/^([^\\s\\.\\?\\w\\$]|\\?[^\\.])/]);\n  ctx.lispTree = lispify(constants, part.substring(extract.length + res[0].length), restOfExp.next, new Lisp({\n    op: ['positive', 'negative'].includes(type) ? '$' + res[0] : res[0],\n    a: ctx.lispTree, \n    b: lispify(constants, extract, expectTypes[expect].next), \n  }));\n});\n\nsetLispType(['incrementerBefore'], (constants, type, part, res, expect, ctx) => {\n  let extract = restOfExp(constants, part.substring(2), [/^[^\\s\\.\\w\\$]/]);\n  ctx.lispTree = lispify(constants, part.substring(extract.length + 2), restOfExp.next, new Lisp({\n    op: res[0] + \"$\", \n    a: lispify(constants, extract, expectTypes[expect].next), \n  }));\n});\n\nsetLispType(['incrementerAfter'], (constants, type, part, res, expect, ctx) => {\n  ctx.lispTree = lispify(constants, part.substring(res[0].length), expectTypes[expect].next, new Lisp({\n    op: \"$\"  + res[0], \n    a: ctx.lispTree, \n  }));\n});\n\nsetLispType(['assign', 'assignModify', 'boolOp'], (constants, type, part, res, expect, ctx) => {\n  ctx.lispTree = new Lisp({\n    op: res[0], \n    a: ctx.lispTree,\n    b: lispify(constants, part.substring(res[0].length), expectTypes[expect].next)\n  });\n});\n\nsetLispType(['opHigh', 'op', 'comparitor', 'bitwise'], (constants, type, part, res, expect, ctx) => {\n  const next = [\n    expectTypes.inlineIf.types.inlineIf,\n    inlineIfElse\n  ];\n  switch (type) {\n    case 'opHigh':\n      next.push(expectTypes.splitter.types.opHigh);\n    case 'op':\n      next.push(expectTypes.splitter.types.op);\n    case 'comparitor':\n      next.push(expectTypes.splitter.types.comparitor);\n    case 'bitwise':\n      next.push(expectTypes.splitter.types.bitwise);\n      next.push(expectTypes.splitter.types.boolOp);\n  }\n  let extract = restOfExp(constants, part.substring(res[0].length), next);\n  ctx.lispTree = lispify(constants, part.substring(extract.length + res[0].length), restOfExp.next, new Lisp({\n    op: res[0],\n    a: ctx.lispTree, \n    b: lispify(constants, extract, expectTypes[expect].next), \n  }));\n});\n\nsetLispType(['inlineIf'], (constants, type, part, res, expect, ctx) => {\n  let found = false;\n  let extract = part.substring(0, 0);\n  let quoteCount = 1;\n  while(!found && extract.length < part.length) {\n    extract.end = restOfExp(constants, part.substring(extract.length + 1), [\n      expectTypes.inlineIf.types.inlineIf,\n      inlineIfElse\n    ]).end;\n    if (part.char(extract.length) === '?') {\n      quoteCount++\n    } else {\n      quoteCount--\n    }\n    if (!quoteCount) {\n      found = true;\n    }\n  }\n  extract.start = part.start + 1;\n  ctx.lispTree = new Lisp({\n    op: '?',\n    a: ctx.lispTree, \n    b: new If(lispifyExpr(constants, extract), lispifyExpr(constants, part.substring(res[0].length + extract.length + 1)))\n  });\n});\n\n\nfunction extractIfElse(constants: IConstants, part: CodeString) {\n  let count = 0;\n  let found = part.substring(0, 0);\n  let foundElse = emptyString;\n  let foundTrue: CodeString;\n  let first = true;\n  let elseReg: RegExpExecArray;\n  let details: restDetails = {}\n  while((found = restOfExp(constants, part.substring(found.end - part.start), [elseIf, ifElse, semiColon], undefined, undefined , undefined, details)).length || first) {\n    first = false;\n    const f = part.substring(found.end - part.start).toString();\n    \n    if (f.startsWith(\"if\")) {\n      found.end++;\n      count++;\n    } else if (f.startsWith('else')) {\n      foundTrue = part.substring(0, found.end - part.start);\n      found.end++;\n      count--;\n      if (!count) {\n        found.end--;\n      }\n    } else if (elseReg = /^;?\\s*else(?![\\w\\$])/.exec(f)) {\n      foundTrue = part.substring(0, found.end - part.start);\n      found.end += elseReg[0].length - 1;\n      count--;\n      if (!count) {\n        found.end -= elseReg[0].length - 1;\n      }\n    } else {\n      foundTrue = foundElse.length ? foundTrue : part.substring(0, found.end - part.start);\n      break;\n    }\n    if (!count) {\n      let ie = extractIfElse(constants, part.substring(found.end - part.start + (/^;?\\s*else(?![\\w\\$])/.exec(f)?.[0].length)));\n      foundElse = ie.all;\n      break;\n    }\n    details = {};\n  }\n  foundTrue = foundTrue || part.substring(0, found.end - part.start);\n  return {all: part.substring(0, Math.max(foundTrue.end, foundElse.end) - part.start), true: foundTrue, false: foundElse};\n}\n\nsetLispType(['if'], (constants, type, part, res, expect, ctx) => {\n  let condition = restOfExp(constants, part.substring(res[0].length), [], \"(\");\n  const ie = extractIfElse(constants, part.substring(res[1].length));\n  const isBlock = /^\\s*\\{/.exec(part.substring(res[0].length + condition.length + 1).toString());\n  const startTrue = res[0].length - res[1].length + condition.length + 1;\n  \n  let trueBlock = ie.true.substring(startTrue);\n  let elseBlock = ie.false;\n  \n  condition = condition.trim();\n  trueBlock = trueBlock.trim();\n  elseBlock = elseBlock.trim();\n\n  if (trueBlock.char(0) === \"{\") trueBlock = trueBlock.slice(1, -1);\n  if (elseBlock.char(0) === \"{\") elseBlock = elseBlock.slice(1, -1);\n  ctx.lispTree = new Lisp({\n    op: 'if',\n    a: lispifyExpr(constants, condition), \n    b: new If(lispifyBlock(trueBlock, constants), elseBlock.length ? lispifyBlock(elseBlock, constants) : undefined)\n  });\n});\n\nsetLispType(['switch'], (constants, type, part, res, expect, ctx) => {\n  const test = restOfExp(constants, part.substring(res[0].length), [], \"(\");\n  let start = part.toString().indexOf(\"{\", res[0].length + test.length + 1);\n  if (start === -1) throw new SyntaxError(\"Invalid switch\");\n  let statement = insertSemicolons(constants, restOfExp(constants, part.substring(start + 1), [], \"{\"));\n  let caseFound: RegExpExecArray;\n  const caseTest = /^\\s*(case\\s|default)\\s*/;\n  let cases: Lisp[] = [];\n  let defaultFound = false;\n  while(caseFound = caseTest.exec(statement.toString())) {\n    if (caseFound[1] === 'default') {\n      if (defaultFound) throw new SyntaxError(\"Only one default switch case allowed\");\n      defaultFound = true;\n    }\n    let cond = restOfExp(constants, statement.substring(caseFound[0].length), [/^:/]);\n    let found = emptyString;\n    let i = start = caseFound[0].length + cond.length + 1;\n    let bracketFound = /^\\s*\\{/.exec(statement.substring(i).toString());\n    let exprs = [];\n    if (bracketFound) {\n      i += bracketFound[0].length;\n      found = restOfExp(constants, statement.substring(i), [], \"{\");\n      i += found.length + 1;\n      exprs = lispifyBlock(found, constants);\n    } else {\n      let notEmpty = restOfExp(constants, statement.substring(i), [caseTest]);\n      if (!notEmpty.trim().length) {\n        exprs = [];\n        i += notEmpty.length;\n      } else {\n        while((found = restOfExp(constants, statement.substring(i), [semiColon])).length) {\n          i += found.length + (statement.char(i + found.length) === ';' ? 1 : 0);\n          if (caseTest.test(statement.substring(i).toString())) {\n            break;\n          }\n        }\n        exprs = lispifyBlock(statement.substring(start, found.end - statement.start), constants);\n      }\n    }\n    statement = statement.substring(i);\n    cases.push(new Lisp({\n      op: \"case\",\n      a: caseFound[1] === \"default\" ? undefined : lispifyExpr(constants, cond),\n      b: toLispArray(exprs)\n    }));\n  }\n  ctx.lispTree = new Lisp({\n    op: 'switch',\n    a: lispifyExpr(constants, test),\n    b: toLispArray(cases)\n  });\n});\n\nsetLispType(['dot', 'prop'], (constants, type, part, res, expect, ctx) => {\n  let prop = res[0];\n  let index = res[0].length;\n  let op = 'prop';\n  if (type === 'dot') {\n    if (res[1]) {\n      op = '?prop';\n    }\n    let matches = part.substring(res[0].length).toString().match(expectTypes.prop.types.prop);\n    if (matches && matches.length) {\n      prop = matches[0];\n      index = prop.length + res[0].length\n    } else {\n      throw new SyntaxError('Hanging  dot');\n    }\n  }\n  ctx.lispTree = lispify(constants, part.substring(index), expectTypes[expect].next, new Lisp({\n    op: op, \n    a: ctx.lispTree, \n    b: prop\n  }));\n});\n\nsetLispType(['spreadArray', 'spreadObject'], (constants, type, part, res, expect, ctx) => {\n  ctx.lispTree = new Lisp({\n    op: type,\n    b: lispify(constants, part.substring(res[0].length), expectTypes[expect].next)\n  });\n});\n\nsetLispType(['return', 'throw'], (constants, type, part, res, expect, ctx) => {\n  ctx.lispTree = new Lisp({\n    op: type,\n    b: lispifyExpr(constants, part.substring(res[0].length))\n  });\n});\n\nconst primitives = {\n  \"true\": true,\n  \"false\": false,\n  \"null\": null,\n  Infinity,\n  NaN,\n  \"und\": undefined\n}\n\nsetLispType(['number', 'boolean', 'null', 'und', 'NaN', 'Infinity'], (constants, type, part, res, expect, ctx) => {\n  ctx.lispTree = lispify(constants, part.substring(res[0].length), expectTypes[expect].next, type === \"number\" ? (res[10] ? BigInt(res[1]) : Number(res[0])) : primitives[type === \"boolean\" ? res[0] : type]);\n});\n\nsetLispType(['string', 'literal', 'regex'], (constants, type, part, res, expect, ctx) => {\n  ctx.lispTree = lispify(constants, part.substring(res[0].length), expectTypes[expect].next, new Lisp({\n    op: type,\n    b: parseInt(JSON.parse(res[1]), 10),\n  }));\n});\n\nsetLispType(['initialize'], (constants, type, part, res, expect, ctx) => {\n  if (!res[3]) {\n    ctx.lispTree = lispify(constants, part.substring(res[0].length), expectTypes[expect].next, new Lisp({\n      op: res[1],\n      a: res[2]\n    }));\n  } else {\n    ctx.lispTree = new Lisp({\n      op: res[1],\n      a: res[2],\n      b: lispify(constants, part.substring(res[0].length), expectTypes[expect].next)\n    });\n  }\n});\n\nsetLispType(['function', 'inlineFunction', 'arrowFunction', 'arrowFunctionSingle'], (constants, type, part, res, expect, ctx) => {\n  const isArrow = type !== 'function' && type !== 'inlineFunction';\n  const isReturn = isArrow && !res[res.length - 1];\n  const argPos = isArrow ? 2 : 3;\n  const isAsync = !!res[1];\n  const args: any[] = res[argPos] ? res[argPos].replace(/\\s+/g, \"\").split(/,/g) : [];\n  if (!isArrow) {\n    args.unshift((res[2] || \"\").trimStart());\n  }\n  let ended = false;\n  args.forEach((arg) => {\n    if (ended) throw new SyntaxError('Rest parameter must be last formal parameter');\n    if (arg.startsWith('...')) ended = true;\n  });\n  args.unshift(isAsync);\n  const f = restOfExp(constants, part.substring(res[0].length), !isReturn ? [/^}/] : [/^[,\\)\\}\\]]/, semiColon])\n  const func = (isReturn ? 'return ' + f : f);\n  ctx.lispTree = lispify(constants, part.substring(res[0].length + func.length + 1), expectTypes[expect].next, new Lisp({\n    op: isArrow ? 'arrowFunc' : type,\n    a: toLispArray(args),\n    b: constants.eager ? lispifyFunction(new CodeString(func), constants) : func\n  }));\n});\n\nconst iteratorRegex = /^((let|var|const)\\s+)?\\s*([a-zA-Z\\$_][a-zA-Z\\d\\$_]*)\\s+(in|of)(?![\\w\\$])/\nsetLispType(['for', 'do', 'while'], (constants, type, part, res, expect, ctx) => {\n  let i = 0;\n  let startStep: LispItem = true;\n  let startInternal: LispArray = toLispArray([]);\n  let getIterator: LispItem;\n  let beforeStep: LispItem = false;\n  let checkFirst = true;\n  let condition: LispItem;\n  let step: LispItem = true;\n  let body: CodeString;\n  switch (type) {\n    case 'while':\n      i = part.toString().indexOf(\"(\") + 1;\n      let extract = restOfExp(constants, part.substring(i), [], \"(\");\n      condition = lispifyReturnExpr(constants, extract);\n      body = restOfExp(constants, part.substring(i + extract.length + 1)).trim();\n      if (body[0] === \"{\") body = body.slice(1, -1);\n      break;\n    case 'for':\n      i = part.toString().indexOf(\"(\") + 1;\n      let args: CodeString[] = [];\n      let extract2 = emptyString;\n      for (let k = 0; k < 3; k++)  {\n        extract2 = restOfExp(constants, part.substring(i), [/^[;\\)]/]);\n        args.push(extract2.trim());\n        i += extract2.length + 1;\n        if (part.char(i - 1) === \")\") break;\n      }\n      let iterator: RegExpExecArray;\n      if (args.length === 1 && (iterator = iteratorRegex.exec(args[0].toString()))) {\n        if (iterator[4] === 'of') {\n          getIterator = lispifyReturnExpr(constants, args[0].substring(iterator[0].length)),\n          startInternal = toLispArray([\n            ofStart2, \n            ofStart3\n          ]);\n          condition = ofCondition;\n          step = ofStep;\n          beforeStep = lispify(constants, new CodeString((iterator[1] || 'let ') + iterator[3]  + ' = $$next.value'), ['initialize']);\n        } else {\n          getIterator = lispifyReturnExpr(constants, args[0].substring(iterator[0].length)),\n          startInternal = toLispArray([\n            inStart2,\n            inStart3\n          ]);\n          step = inStep;\n          condition = inCondition;\n          beforeStep = lispify(constants, new CodeString((iterator[1] || 'let ') + iterator[3] + ' = $$keys[$$keyIndex]'), ['initialize']);\n        }\n      } else if (args.length === 3) {\n        startStep = lispifyExpr(constants, args.shift(), startingExecpted);\n        condition = lispifyReturnExpr(constants, args.shift());\n        step = lispifyExpr(constants, args.shift());\n      } else {\n        throw new SyntaxError(\"Invalid for loop definition\");\n      }\n      body = restOfExp(constants, part.substring(i)).trim();\n      if (body[0] === \"{\") body = body.slice(1, -1);\n\n      break;\n    case 'do':\n      checkFirst = false;\n      const isBlock = !!res[3];\n      body = restOfExp(constants, part.substring(res[0].length), isBlock ? [/^\\}/] : [semiColon]);\n      condition = lispifyReturnExpr(constants, restOfExp(constants, part.substring(part.toString().indexOf(\"(\", res[0].length + body.length) + 1), [], \"(\"));\n      break;\n  }\n  const a = toLispArray([checkFirst, startInternal, getIterator, startStep, step, condition, beforeStep]);\n  ctx.lispTree = new Lisp({\n    op: 'loop',\n    a,\n    b: lispifyBlock(body, constants)\n  });\n});\n\nsetLispType(['block'], (constants, type, part, res, expect, ctx) => {\n  ctx.lispTree = lispifyBlock(restOfExp(constants, part.substring(1), [], \"{\"), constants);\n});\n\nsetLispType(['loopAction'], (constants, type, part, res, expect, ctx) => {\n  ctx.lispTree = new Lisp({\n    op: 'loopAction',\n    a: res[1],\n  });\n});\n\nconst catchReg = /^\\s*(catch\\s*(\\(\\s*([a-zA-Z\\$_][a-zA-Z\\d\\$_]*)\\s*\\))?|finally)\\s*\\{/\nsetLispType(['try'], (constants, type, part, res, expect, ctx) => {\n  const body = restOfExp(constants, part.substring(res[0].length), [], \"{\");\n  let catchRes = catchReg.exec(part.substring(res[0].length + body.length + 1).toString());\n  let finallyBody;\n  let exception;\n  let catchBody;\n  let offset = 0;\n  if (catchRes[1].startsWith('catch')) {\n    catchRes = catchReg.exec(part.substring(res[0].length + body.length + 1).toString());\n    exception = catchRes[2];\n    catchBody = restOfExp(constants, part.substring(res[0].length + body.length + 1 + catchRes[0].length), [], \"{\");\n    offset = res[0].length + body.length + 1 + catchRes[0].length + catchBody.length + 1;\n    if ((catchRes = catchReg.exec(part.substring(offset).toString())) && catchRes[1].startsWith('finally')) {\n      finallyBody = restOfExp(constants, part.substring(offset + catchRes[0].length), [], \"{\");\n    }\n  } else {\n    finallyBody = restOfExp(constants, part.substring(res[0].length + body.length + 1 + catchRes[0].length), [], \"{\");\n  }\n  const b = toLispArray([\n    exception,\n    lispifyBlock(insertSemicolons(constants, catchBody || emptyString), constants),\n    lispifyBlock(insertSemicolons(constants, finallyBody || emptyString), constants),\n  ]);\n  ctx.lispTree = new Lisp({\n    op: 'try',\n    a: lispifyBlock(insertSemicolons(constants, body), constants),\n    b\n  });\n});\n\nsetLispType(['void', 'await'], (constants, type, part, res, expect, ctx) => {\n  const extract = restOfExp(constants, part.substring(res[0].length), [/^([^\\s\\.\\?\\w\\$]|\\?[^\\.])/]);\n  ctx.lispTree = lispify(constants, part.substring(res[0].length + extract.length), expectTypes[expect].next, new Lisp({\n    op: type,\n    a: lispify(constants, extract),\n  }));\n});\n\nsetLispType(['new'], (constants, type, part, res, expect, ctx) => {\n  let i = res[0].length;\n  const obj = restOfExp(constants, part.substring(i), [], undefined, \"(\");\n  i += obj.length + 1;\n  const args = [];\n  if (part.char(i - 1) === \"(\") {\n    const argsString = restOfExp(constants, part.substring(i), [], \"(\");\n    i += argsString.length + 1;\n    let found;\n    let j = 0;\n    while((found = restOfExp(constants, argsString.substring(j), [/^,/])).length) {\n      j += found.length + 1;\n      args.push(found.trim());\n    }\n  }\n  ctx.lispTree = lispify(constants, part.substring(i), expectTypes.expEdge.next, new Lisp({\n    op: type,\n    a: lispify(constants, obj, expectTypes.initialize.next),\n    b: toLispArray(args.map((arg) => lispify(constants, arg, expectTypes.initialize.next))),\n  }));\n});\n\nconst ofStart2 = lispify(undefined, new CodeString('let $$iterator = $$obj[Symbol.iterator]()'), ['initialize']);\nconst ofStart3 = lispify(undefined, new CodeString('let $$next = $$iterator.next()'), ['initialize']);\nconst ofCondition = lispify(undefined, new CodeString('return !$$next.done'), ['initialize']);\nconst ofStep = lispify(undefined, new CodeString('$$next = $$iterator.next()'));\nconst inStart2 = lispify(undefined, new CodeString('let $$keys = Object.keys($$obj)'), ['initialize']);\nconst inStart3 = lispify(undefined, new CodeString('let $$keyIndex = 0'), ['initialize']);\nconst inStep = lispify(undefined, new CodeString('$$keyIndex++'));\nconst inCondition = lispify(undefined, new CodeString('return $$keyIndex < $$keys.length'), ['initialize']);\n\nvar lastType;\nvar lastPart;\nvar lastLastPart;\nvar lastLastLastPart;\nvar lastLastLastLastPart;\nfunction lispify(constants: IConstants, part: CodeString, expected?: string[], lispTree?: LispItem, topLevel = false): LispItem {\n  expected = expected || expectTypes.initialize.next;\n  if (part === undefined) return lispTree;\n\n  part = part.trimStart();\n  const str = part.toString();\n  if (!part.length && !expected.includes('expEnd')) {\n    throw new SyntaxError(\"Unexpected end of expression\");\n  }\n  if (!part.length) return lispTree;\n\n  let ctx = {lispTree: lispTree};\n\n  let res: any;\n  for (let expect of expected) {\n    if (expect === 'expEnd') {\n      continue;\n    }\n    for (let type in expectTypes[expect].types) {\n      if (type === 'expEnd') {\n        continue;\n      }\n      if(res = expectTypes[expect].types[type].exec(str)) {\n        lastType = type;\n        lastLastLastLastPart = lastLastLastPart;\n        lastLastLastPart = lastLastPart;\n        lastLastPart = lastPart;\n        lastPart = part;\n        try {\n          lispTypes.get(type)(constants, type, part, res, expect, ctx);\n        } catch(e) {\n          if (topLevel && e instanceof SyntaxError) {\n            throw new ParseError(e.message, str);\n          }\n          throw e;\n        }\n        break;\n      }\n    }\n    if (res) break;\n  }\n\n  if (!res && part.length) {\n    let msg = `Unexpected token after ${lastType}: ${part.char(0)}`;\n    if (topLevel) {\n      throw new ParseError(`Unexpected token after ${lastType}: ${part.char(0)}`, str);\n    }\n    throw new SyntaxError(`Unexpected token after ${lastType}: ${part.char(0)}`);\n  }\n  return ctx.lispTree;\n}\n\nconst startingExpectedWithoutSingle = startingExecpted.filter((r) => r !== 'expSingle');\n\nfunction lispifyExpr(constants: IConstants, str: CodeString, expected?: string[]): LispItem {\n  if (!str.trimStart().length) return undefined;\n  let subExpressions: CodeString[] = [];\n  let sub: CodeString;\n  let pos = 0;\n  expected = expected || expectTypes.initialize.next;\n  if (expected.includes('expSingle')) {\n    if (testMultiple(str.toString(), Object.values(expectTypes.expSingle.types))) {\n      return lispify(constants, str, ['expSingle'], undefined, true);\n    }\n  }\n  if (expected === startingExecpted) expected = startingExpectedWithoutSingle;\n  while ((sub = restOfExp(constants, str.substring(pos), [/^,/])).length) {\n    subExpressions.push(sub.trimStart());\n    pos += sub.length + 1;\n  }\n  if (subExpressions.length === 1) {\n    return lispify(constants, str, expected, undefined, true);\n  }\n  if (expected.includes('initialize')) {\n    let defined = expectTypes.initialize.types.initialize.exec(subExpressions[0].toString());\n    if (defined) {\n      return toLispArray(subExpressions.map((str, i) => lispify(constants, i ? new CodeString(defined[1] + ' ' + str) : str, ['initialize'], undefined, true)));\n    } else if (expectTypes.initialize.types.return.exec(subExpressions[0].toString())) {\n      return lispify(constants, str, expected, undefined, true);\n    }\n  }\n  const exprs = toLispArray(subExpressions.map((str, i) => lispify(constants, str, expected, undefined, true)));\n  return new Lisp({op: \"multi\", a: exprs});\n}\n\nexport function lispifyReturnExpr(constants: IConstants, str: CodeString) {\n  return new Lisp({op: 'return', b: lispifyExpr(constants, str)})\n}\n\nexport function lispifyBlock(str: CodeString, constants: IConstants, expression = false): LispArray {\n  str = insertSemicolons(constants, str);\n  if (!str.trim().length) return toLispArray([]);\n  let parts: CodeString[] = [];\n  let part: CodeString;\n  let pos = 0;\n  let start = 0;\n  let details: restDetails = {};\n  let skipped = false;\n  let isInserted = false;\n  while ((part = restOfExp(constants, str.substring(pos), [semiColon], undefined, undefined, undefined, details)).length) {\n    isInserted = str.char(pos + part.length) && str.char(pos + part.length) !== ';';\n    pos += part.length + (isInserted ? 0 : 1);\n    if (/^\\s*else(?![\\w\\$])/.test(str.substring(pos).toString())) {\n      skipped = true;\n    } else if (details.words.includes('do') && /^\\s*while(?![\\w\\$])/.test(str.substring(pos).toString())) {\n      skipped = true;\n    } else {\n      skipped = false;\n      parts.push(str.substring(start, pos - (isInserted ? 0 : 1)));\n      start = pos;\n    }\n    details = {};\n    if (expression) break;\n  }\n  if (skipped) {\n    parts.push(str.substring(start, pos - (isInserted ? 0 : 1)));\n  }\n  return toLispArray(parts.map((str) => str.trimStart()).filter((str) => str.length).map((str, j) => {\n    return lispifyExpr(constants, str.trimStart(), startingExecpted);\n  }).flat());\n}\n\nexport function lispifyFunction(str: CodeString, constants: IConstants, expression = false): LispArray {\n  if (!str.trim().length) return toLispArray([]);\n  const tree = lispifyBlock(str, constants, expression);\n  let hoisted: LispArray = toLispArray([]);\n  hoist(tree, hoisted);\n  return toLispArray(hoisted.concat(tree));\n}\n\nfunction hoist(item: LispItem, res: LispArray): boolean {\n  if (Array.isArray(item)) {\n    const rep = [];\n    for (let it of item) {\n      if (!hoist(it, res)) {\n        rep.push(it);\n      }\n    }\n    if (rep.length !== item.length) {\n      item.length = 0;\n      item.push(...rep);\n    }\n  } else if (item instanceof Lisp) {\n    if (item.op === \"try\" || item.op === \"if\" || item.op === \"loop\" || item.op === \"switch\") {\n      hoist(item.a, res);\n      hoist(item.b, res);\n    } else if (item.op === \"var\") {\n      res.push(new Lisp({op: 'var', a: item.a}));\n    } else if (item.op === \"function\" && item.a[1]) {\n      res.push(item);\n      return true;\n    }\n  }\n  return false;\n}\n\nconst closingsNoInsertion = /^(\\})\\s*(catch|finally|else|while|instanceof)(?![\\w\\$])/\n                    //  \\w|)|] \\n \\w = 2                                  // \\} \\w|\\{ = 5 \nconst colonsRegex = /^((([\\w\\$\\]\\)\\\"\\'\\`]|\\+\\+|\\-\\-)\\s*\\r?\\n\\s*([\\w\\$\\+\\-\\!~]))|(\\}\\s*[\\w\\$\\!~\\+\\-\\{\\(\\\"\\'\\`]))/\n\n// if () \\w \\n; \\w              == \\w \\n \\w    | last === if             a\n// if () { }; \\w                == \\} ^else    | last === if             b\n// if () \\w \\n; else \\n \\w \\n;  == \\w \\n \\w    | last === else           a\n// if () {} else {}; \\w         == \\} \\w       | last === else           b\n// while () \\n \\w \\n; \\w        == \\w \\n \\w    | last === while          a\n// while () { }; \\w             == \\} \\w       | last === while          b\n// do \\w \\n; while (); \\w       == \\w \\n while | last === do             a\n// do { } while (); \\w          == \\) \\w       | last === while          c\n// try {} catch () {}; \\w       == \\} \\w       | last === catch|finally  b\n// \\w \\n; \\w                    == \\w \\n \\w    | last === none           a\n// cb() \\n \\w                   == \\) \\n \\w    | last === none           a\n// obj[a] \\n \\w                 == \\] \\n \\w    | last === none           a\n// {} {}                        == \\} \\{       | last === none           b\n\nexport function insertSemicolons(constants: IConstants, str: CodeString): CodeString {\n  let rest = str;\n  let sub = emptyString;\n  let details: restDetails = {};\n  const inserted = insertedSemicolons.get(str.ref) || new Array(str.ref.str.length);\n  while ((sub = restOfExp(constants, rest, [], undefined, undefined, [colonsRegex], details)).length) {\n    let valid = false;\n    let part = sub;\n    let edge = sub.length;\n    if (details.regRes) {\n      valid = true;\n      const [,, a,,, b] = details.regRes;\n      edge = details.regRes[3] === \"++\" || details.regRes[3] === \"--\" ? sub.length + 1 : sub.length;\n      part = rest.substring(0,  edge);\n      if (b) {\n        let res = closingsNoInsertion.exec(rest.substring(sub.length - 1).toString());\n        if (res) {\n          if (res[2] === 'while') {\n            valid = details.lastWord !== 'do';\n          } else {\n            valid = false;\n          }\n        } else if (details.lastWord === 'function' && details.regRes[5][0] === \"}\" && details.regRes[5].slice(-1) === '(') {\n          valid = false;\n        } \n\n      } else if (a) {\n        if (details.lastWord === 'if' || details.lastWord === 'while' || details.lastWord === 'for' || details.lastWord === 'else') {\n          valid = false;\n        }\n      }\n    }\n    if (valid) {\n      inserted[part.end] = true;\n    }\n    rest = rest.substring(edge);\n    details = {};\n  }\n  insertedSemicolons.set(str.ref, inserted);\n  return str;\n}\n\nexport function checkRegex(str: string): IRegEx | null {\n  let i = 1;\n  let escape = false;\n  let done = false;\n  let cancel = false;\n  while (i < str.length && !done && !cancel) {\n    done = (str[i] === '/' && !escape);\n    escape = str[i] === '\\\\' && !escape;\n    cancel = str[i] === '\\n';\n    i++;\n  }\n  let after = str.substring(i);\n  cancel = (cancel || !done) || /^\\s*\\d/.test(after);\n  if (cancel) return null;\n  let flags = /^[a-z]*/.exec(after);\n  if(/^\\s+[\\w\\$]/.test(str.substring(i + flags[0].length))) {\n    return null;\n  }\n  return {\n    regex: str.substring(1, i-1),\n    flags: (flags && flags[0]) || \"\",\n    length: i + ((flags && flags[0].length) || 0)\n  }\n}\n\nconst notDivide = /(typeof|delete|instanceof|return|in|of|throw|new|void|do|if)$/\nconst possibleDivide = /^([\\w\\$\\]\\)]|\\+\\+|\\-\\-)[\\s\\/]/;\nexport function extractConstants(constants: IConstants, str: string, currentEnclosure = \"\"): {str: string, length: number} {\n  let quote;\n  let extract: (string|number)[] = [];\n  let escape = false;\n  let regexFound: IRegEx;\n  let comment = \"\";\n  let commentStart = -1;\n  let currJs: LispArray = toLispArray([]);\n  let char: string = \"\";\n  const strRes: (string|number)[] = [];\n  const enclosures: string[] = [];\n  let isPossibleDivide: RegExpExecArray;\n  for (var i = 0; i < str.length; i++) {\n    char = str[i];\n    if (comment) {\n      if (char === comment) {\n        if (comment === \"*\" && str[i + 1] ===\"/\") {\n          comment = \"\";\n          i++\n        } else if (comment === \"\\n\") {\n          comment = \"\";\n        }\n      }\n    } else {\n      if (escape) {\n        escape = false;\n        extract.push(char);\n        continue;\n      }\n\n      if (quote) {\n        if (quote === \"`\" && char === \"$\" && str[i+1] === \"{\") {\n          let skip = extractConstants(constants, str.substring(i+2), \"{\");\n          currJs.push(skip.str);\n          extract.push('${', currJs.length - 1, `}`);\n          i += skip.length + 2;\n        } else if (quote === char) {\n          if (quote === '`') {\n            constants.literals.push({\n              op: 'literal',\n              a:  unraw(extract.join(\"\")),\n              b: currJs\n            });\n            strRes.push(`\\``, constants.literals.length - 1, `\\``);\n          } else {\n            constants.strings.push(unraw(extract.join(\"\")));\n            strRes.push(`\"`, constants.strings.length - 1, `\"`);\n          }\n          quote = null;\n          extract = [];\n        } else {\n          extract.push(char);\n        }\n      } else {\n        if ((char === \"'\"  || char === '\"'  || char === '`')) {\n          currJs = toLispArray([]);\n          quote = char;\n        } else if (closings[currentEnclosure] === char && !enclosures.length) {\n          return {str: strRes.join(\"\"), length: i}\n        } else if (closings[char]) {\n          enclosures.push(char);\n          strRes.push(char);\n        } else if (closings[enclosures[enclosures.length-1]] === char) {\n          enclosures.pop();\n          strRes.push(char);\n        } else if (char === \"/\" && (str[i+1] === \"*\" || str[i+1] === \"/\")) {\n          comment = str[i+1] === \"*\" ? \"*\" : \"\\n\";\n          commentStart = i;\n        } else if (char === '/' && !isPossibleDivide && (regexFound = checkRegex(str.substring(i)))) {\n          constants.regexes.push(regexFound);\n          strRes.push(`/`, constants.regexes.length - 1, `/r`);\n          i += regexFound.length - 1;\n        } else {\n          strRes.push(char);\n        }\n\n        if (!isPossibleDivide || !space.test(char)) {\n          if (isPossibleDivide = possibleDivide.exec(str.substring(i))) {\n            if (notDivide.test(str.substring(0, i + isPossibleDivide[1].length))) {\n              isPossibleDivide = null;\n            }\n          }\n        }\n      }\n      escape = quote && char === \"\\\\\";\n    }\n  }\n\n  if (comment) {\n    if (comment === \"*\") {\n      throw new SyntaxError(`Unclosed comment '/*': ${str.substring(commentStart)}`)\n    }\n  }\n  return {str: strRes.join(\"\"), length: i}\n}\nexport function parse(code: string, eager = false, expression = false): IExecutionTree {\n  if (typeof code !== 'string') throw new ParseError(`Cannot parse ${code}`, code);\n  let str = ' ' + code;\n  const constants: IConstants = {strings: [], literals: [], regexes: [], eager};\n  str = extractConstants(constants, str).str;\n\n  for (let l of constants.literals) {\n    l.b = toLispArray(l.b.map((js: string) => lispifyExpr(constants, new CodeString(js))));\n  }\n  return {tree: lispifyFunction(new CodeString(str), constants, expression), constants};\n}\n","import { SpreadArray, LispItem, KeyVal, SpreadObject, If, Lisp, LispArray, toLispArray, parse, IRegEx, lispifyFunction, CodeString, lispArrayKey } from \"./parser.js\";\nimport { IExecContext, IContext, Ticks } from \"./Sandbox.js\";\n\nexport type SandboxFunction = (code: string, ...args: any[]) => () => any;\nexport type sandboxedEval = (code: string) => any;\nexport type sandboxSetTimeout = (handler: TimerHandler, timeout?: any, ...args: any[]) => any;\nexport type sandboxSetInterval = (handler: TimerHandler, timeout?: any, ...args: any[]) => any;\nexport type Done = (err?: any, res?: any) => void\nexport class ExecReturn<T> {\n  constructor(public auditReport: IAuditReport, public result: T, public returned: boolean, public breakLoop = false, public continueLoop = false) {}\n}\n\nexport interface IAuditReport {\n  globalsAccess: Set<any>;\n  prototypeAccess: {[name: string]: Set<string>}\n}\n\nexport interface IGlobals {\n  [key: string]: any\n}\n\nexport interface IChange {\n  type: string;\n}\n\nexport interface ICreate extends IChange {\n  type: \"create\";\n  prop: number|string;\n}\n\nexport interface IReplace extends IChange {\n  type: \"replace\";\n}\n\nexport interface IDelete extends IChange {\n  type: \"delete\";\n  prop: number|string;\n}\n\nexport interface IReverse extends IChange {\n  type: \"reverse\";\n}\n\nexport interface ISort extends IChange {\n  type: \"sort\";\n}\n\nexport interface IPush extends IChange {\n  type: \"push\";\n  added: unknown[];\n}\n\nexport interface IPop extends IChange {\n  type: \"pop\";\n  removed: unknown[];\n}\n\nexport interface IShift extends IChange {\n  type: \"shift\";\n  removed: unknown[];\n}\n\nexport interface IUnShift extends IChange {\n  type: \"unshift\";\n  added: unknown[];\n}\n\nexport interface ISplice extends IChange {\n  type: \"splice\";\n  startIndex: number;\n  deleteCount: number; \n  added: unknown[];\n  removed: unknown[];\n\n}\n\nexport interface ICopyWithin extends IChange {\n  type: \"copyWithin\";\n  startIndex: number;\n  endIndex: number;\n  added: unknown[];\n  removed: unknown[];\n}\n\nexport type Change = ICreate | IReplace | IDelete | IReverse | ISort | IPush | IPop | IUnShift | IShift | ISplice | ICopyWithin\n\nexport type replacementCallback = (obj: any, isStaticAccess: boolean) => any\n\nexport class Prop {\n  constructor(public context: {[key:string]: any}, public prop: string, public isConst = false, public isGlobal = false, public isVariable = false) {\n  }\n\n  get(context: IExecContext): any {\n    if (this.context === undefined) throw new ReferenceError(`${this.prop} is not defined`);\n    context.getSubscriptions.forEach((cb) => cb(this.context, this.prop))\n    return this.context[this.prop];\n  }\n}\n\nconst optional = {};\n\nconst reservedWords = new Set([\n  'instanceof',\n  'typeof',\n  'return',\n  'try',\n  'catch',\n  'if',\n  'finally',\n  'else',\n  'in',\n  'of',\n  'var',\n  'let',\n  'const',\n  'for',\n  'delete',\n  'false',\n  'true',\n  'while',\n  'do',\n  'break',\n  'continue',\n  'new',\n  'function',\n  'async',\n  'await',\n  'switch',\n  'case'\n]);\n\nenum VarType {\n  let = \"let\",\n  const = \"const\",\n  var = \"var\"\n}\n\nfunction keysOnly(obj: any): {[key: string]: true} {\n  const ret = Object.assign({}, obj);\n  for (let key in ret) {\n    ret[key] = true;\n  }\n  return ret;\n}\n\nexport class Scope {\n  parent: Scope;\n  const: {[key: string]: true} = {};\n  let: {[key: string]: true} = {};\n  var: {[key: string]: true} = {};\n  globals: {[key: string]: true};\n  allVars: {[key:string]: any} & Object;\n  functionThis?: any;\n  constructor(parent: Scope, vars = {}, functionThis?: any) {\n    const isFuncScope = functionThis !== undefined || parent === null;\n    this.parent = parent;\n    this.allVars = vars;\n    this.let = isFuncScope ? this.let : keysOnly(vars);\n    this.var = isFuncScope ? keysOnly(vars) : this.var;\n    this.globals = parent === null ? keysOnly(vars) : {};\n    this.functionThis = functionThis;\n  }\n\n  get(key: string, functionScope = false): Prop {\n    if (key === 'this' && this.functionThis !== undefined) {\n      return new Prop({this: this.functionThis}, key, true, false, true);\n    }\n    if (reservedWords.has(key)) throw new SyntaxError(\"Unexepected token '\" + key + \"'\");\n    if (this.parent === null || !functionScope || this.functionThis !== undefined) {\n      if (this.globals.hasOwnProperty(key)) {\n        return new Prop(this.functionThis, key, false, true, true);\n      }\n      if (key in this.allVars && (!(key in {}) || this.allVars.hasOwnProperty(key))) {\n        return new Prop(this.allVars, key, this.const.hasOwnProperty(key), this.globals.hasOwnProperty(key), true);\n      }\n      if (this.parent === null) {\n        return new Prop(undefined, key);\n      }\n    }\n    return this.parent.get(key, functionScope)\n  }\n\n  set(key: string, val: any) {\n    if (key === 'this') throw new SyntaxError('\"this\" cannot be assigned')\n    if (reservedWords.has(key)) throw new SyntaxError(\"Unexepected token '\" + key + \"'\");\n    let prop = this.get(key);\n    if(prop.context === undefined) {\n      throw new ReferenceError(`Variable '${key}' was not declared.`);\n    }\n    if (prop.isConst) {\n      throw new TypeError(`Cannot assign to const variable '${key}'`);\n    }\n    if (prop.isGlobal) {\n      throw new SandboxError(`Cannot override global variable '${key}'`);\n    }\n    prop.context[prop.prop] = val;\n    return prop;\n  }\n\n  declare(key: string, type: VarType = null, value: any = undefined, isGlobal = false) {\n    if (key === 'this') throw new SyntaxError('\"this\" cannot be declared');\n    if (reservedWords.has(key)) throw new SyntaxError(\"Unexepected token '\" + key + \"'\");\n    if (type === 'var' && this.functionThis === undefined && this.parent !== null) {\n      return this.parent.declare(key, type, value, isGlobal)\n    } else if ((this[type].hasOwnProperty(key) && type !== 'const' && !this.globals.hasOwnProperty(key)) || !(key in this.allVars)) {\n      if (isGlobal) {\n        this.globals[key] = true;\n      }\n      this[type][key] = true;\n      this.allVars[key] = value;\n    } else {\n      throw new SandboxError(`Identifier '${key}' has already been declared`);\n    }\n    return new Prop(this.allVars, key, this.const.hasOwnProperty(key), isGlobal);\n  }\n}\n\nexport interface IScope {\n  [key: string]: any;\n}\n\nexport class FunctionScope implements IScope {}\n\nexport class LocalScope implements IScope {}\n\nexport class SandboxError extends Error {}\n\nlet currentTicks: Ticks;\n\nexport function sandboxFunction(context: IExecContext, ticks?: Ticks): SandboxFunction {\n  return SandboxFunction;\n  function SandboxFunction(...params: any[]) {\n    let code = params.pop() || \"\";\n    let parsed = parse(code);\n    return createFunction(params, parsed.tree, ticks || currentTicks, {\n      ...context,\n      constants: parsed.constants,\n      tree: parsed.tree\n    }, undefined, 'anonymous');\n  }\n}\n\nfunction generateArgs(argNames: string[], args: unknown[]) {\n  const vars: any = {};\n  argNames.forEach((arg, i) => {\n    if (arg.startsWith('...')) {\n      vars[arg.substring(3)] = args.slice(i);\n    } else {\n      vars[arg] = args[i];\n    }\n  });\n  return vars;\n}\n\nconst sandboxedFunctions = new WeakSet();\nexport function createFunction(argNames: string[], parsed: LispItem, ticks: Ticks, context: IExecContext, scope?: Scope, name?: string) {\n  if (context.ctx.options.forbidFunctionCreation) {\n    throw new SandboxError(\"Function creation is forbidden\");\n  }\n  let func;\n  if (name === undefined) {\n    func = (...args) => {\n      const vars = generateArgs(argNames, args);\n      const res = executeTree(ticks, context, parsed, scope === undefined ? [] : [new Scope(scope, vars)])\n      return res.result;\n    }\n  } else {\n    func = function sandboxedObject(...args) {\n      const vars = generateArgs(argNames, args);\n      const res = executeTree(ticks, context, parsed, scope === undefined ? [] : [new Scope(scope, vars, this)])\n      return res.result;\n    }\n  }\n  context.registerSandboxFunction(func);\n  sandboxedFunctions.add(func);\n  return func;\n}\n\nexport function createFunctionAsync(argNames: string[], parsed: LispItem, ticks: Ticks, context: IExecContext, scope?: Scope, name?: string) {\n  if (context.ctx.options.forbidFunctionCreation) {\n    throw new SandboxError(\"Function creation is forbidden\");\n  }\n  if (!context.ctx.prototypeWhitelist?.has(Promise.prototype)) {\n    throw new SandboxError(\"Async/await not permitted\");\n  }\n  let func;\n  if (name === undefined) {\n    func = async (...args) => {\n      const vars = generateArgs(argNames, args);\n      const res = await executeTreeAsync(ticks, context, parsed, scope === undefined ? [] : [new Scope(scope, vars)])\n      return res.result;\n    }\n  } else {\n    func = async function sandboxedObject(...args) {\n      const vars = generateArgs(argNames, args);\n      const res = await executeTreeAsync(ticks, context, parsed, scope === undefined ? [] : [new Scope(scope, vars, this)])\n      return res.result;\n    }\n  }\n  context.registerSandboxFunction(func);\n  sandboxedFunctions.add(func);\n  return func;\n}\n\nexport function sandboxedEval(func: SandboxFunction): sandboxedEval {\n  return sandboxEval;\n  function sandboxEval(code: string) {\n    return func(code)();\n  }\n}\n\nexport function sandboxedSetTimeout(func: SandboxFunction): sandboxSetTimeout {\n  return function sandboxSetTimeout(handler, ...args) {\n    if (typeof handler !== 'string') return setTimeout(handler, ...args);\n    return setTimeout(func(handler), ...args);\n  }\n}\n\nexport function sandboxedSetInterval(func: SandboxFunction): sandboxSetInterval {\n  return function sandboxSetInterval(handler, ...args) {\n    if (typeof handler !== 'string') return setInterval(handler, ...args);\n    return setInterval(func(handler), ...args);\n  }\n}\n\nexport function assignCheck(obj: Prop, context: IExecContext, op = 'assign') {\n  if(obj.context === undefined) {\n    throw new ReferenceError(`Cannot ${op} value to undefined.`)\n  }\n  if(typeof obj.context !== 'object' && typeof obj.context !== 'function') {\n    throw new SyntaxError(`Cannot ${op} value to a primitive.`)\n  }\n  if (obj.isConst) {\n    throw new TypeError(`Cannot set value to const variable '${obj.prop}'`);\n  }\n  if (obj.isGlobal) {\n    throw new SandboxError(`Cannot ${op} property '${obj.prop}' of a global object`);\n  }\n  if (typeof obj.context[obj.prop] === 'function' && !obj.context.hasOwnProperty(obj.prop)) {\n    throw new SandboxError(`Override prototype property '${obj.prop}' not allowed`);\n  }\n  if (op === \"delete\") {\n    if (obj.context.hasOwnProperty(obj.prop)) {\n      context.changeSubscriptions.get(obj.context)?.forEach((cb) => cb({type: \"delete\", prop: obj.prop}));\n      context.changeSubscriptionsGlobal.get(obj.context)?.forEach((cb) => cb({type: \"delete\", prop: obj.prop}));\n    }\n  } else if (obj.context.hasOwnProperty(obj.prop)) {\n    context.setSubscriptions.get(obj.context)?.get(obj.prop)?.forEach((cb) => cb({\n      type: \"replace\"\n    }));\n    context.setSubscriptionsGlobal.get(obj.context)?.get(obj.prop)?.forEach((cb) => cb({\n      type: \"replace\"\n    }));\n  } else {\n    context.changeSubscriptions.get(obj.context)?.forEach((cb) => cb({type: \"create\", prop: obj.prop}));\n    context.changeSubscriptionsGlobal.get(obj.context)?.forEach((cb) => cb({type: \"create\", prop: obj.prop}));\n  }\n}\nconst arrayChange = new Set([\n  [].push,\n  [].pop,\n  [].shift,\n  [].unshift,\n  [].splice,\n  [].reverse,\n  [].sort,\n  [].copyWithin\n]);\nconst literalRegex = /(\\$\\$)*(\\$)?\\${(\\d+)}/g;\ntype OpCallback = (exec: Execution, done: Done, ticks: Ticks, a: LispItem|string[], b: LispItem|Lisp[], obj: Prop|any|undefined, context: IExecContext, scope: Scope, bobj?: Prop|any|undefined, inLoopOrSwitch?: string) => void;\nlet ops2: {[op:string]: OpCallback} = {\n  'prop': (exec, done, ticks, a: LispItem|any, b: string, obj, context, scope) => {\n    if(a === null) {\n      throw new TypeError(`Cannot get property ${b} of null`);\n    }\n    const type = typeof a;\n    if (type === 'undefined' && obj === undefined) {\n      let prop = scope.get(b);\n      if (prop.context === context.ctx.sandboxGlobal) {\n        if (context.ctx.options.audit) {\n          context.ctx.auditReport.globalsAccess.add(b);\n        }\n        const rep = context.ctx.globalsWhitelist.has(context.ctx.sandboxGlobal[b]) ? context.evals.get(context.ctx.sandboxGlobal[b]) : undefined;\n        if (rep) {\n          done(undefined, rep);\n          return;\n        }\n      }\n      if (prop.context && prop.context[b] === globalThis) {\n        done(undefined, context.ctx.globalScope.get('this'));\n        return;\n      }\n\n      done(undefined, prop);\n      return;\n    } else if (a === undefined) {\n      throw new SandboxError(\"Cannot get property '\" + b + \"' of undefined\")\n    }\n\n    if (type !== 'object') {\n      if(type === 'number') {\n        a = new Number(a);\n      } else if(type === 'string') {\n        a = new String(a);\n      } else if(type === 'boolean') {\n        a = new Boolean(a);\n      }\n    } else if (typeof a.hasOwnProperty === 'undefined') {\n      done(undefined, new Prop(undefined, b));\n      return;\n    }\n\n    const isFunction = type === 'function';\n    let prototypeAccess = isFunction || !(a.hasOwnProperty(b) || typeof b === 'number');\n\n    if (context.ctx.options.audit && prototypeAccess) {\n      if (typeof b === 'string') {\n        let prot = Object.getPrototypeOf(a);\n        do {\n          if (prot.hasOwnProperty(b)) {\n            if(!context.ctx.auditReport.prototypeAccess[prot.constructor.name]) {\n              context.ctx.auditReport.prototypeAccess[prot.constructor.name] = new Set();\n            }\n            context.ctx.auditReport.prototypeAccess[prot.constructor.name].add(b);\n          }\n        } while(prot = Object.getPrototypeOf(prot))\n      }\n    }\n\n    if (prototypeAccess) {\n      if (isFunction) {\n        if (!['name', 'length', 'constructor'].includes(b) && a.hasOwnProperty(b)) {\n          const whitelist = context.ctx.prototypeWhitelist.get(a.prototype);\n          const replace = context.ctx.options.prototypeReplacements.get(a);\n          if (replace) {\n            done(undefined, new Prop(replace(a, true), b));\n            return;\n          }\n          if (whitelist && (!whitelist.size || whitelist.has(b))) {\n          } else {\n            throw new SandboxError(`Static method or property access not permitted: ${a.name}.${b}`);\n          }\n        }\n      } else if (b !== 'constructor') {\n        let prot = a;\n        while(prot = Object.getPrototypeOf(prot)) {\n          if (prot.hasOwnProperty(b)) {\n            const whitelist = context.ctx.prototypeWhitelist.get(prot);\n            const replace = context.ctx.options.prototypeReplacements.get(prot.constuctor);\n            if (replace) {\n              done(undefined, new Prop(replace(a, false), b));\n              return;\n            }\n            if (whitelist && (!whitelist.size || whitelist.has(b))) {\n              break;\n            }\n            throw new SandboxError(`Method or property access not permitted: ${prot.constructor.name}.${b}`);\n          }\n        };\n      }\n    }\n\n    if (context.evals.has(a[b])) {\n      done(undefined, context.evals.get(a[b]));\n      return;\n    }\n    if (a[b] === globalThis) {\n      done(undefined, context.ctx.globalScope.get('this'));\n      return;\n    }\n\n    let g = obj.isGlobal || (isFunction && !sandboxedFunctions.has(a)) || context.ctx.globalsWhitelist.has(a);\n\n    done(undefined, new Prop(a, b, false, g));\n  },\n  'call': (exec, done, ticks, a, b: LispArray, obj, context, scope) => {\n    if (context.ctx.options.forbidFunctionCalls) throw new SandboxError(\"Function invocations are not allowed\");\n    if (typeof a !== 'function') {\n      throw new TypeError(`${obj.prop} is not a function`);\n    }\n    const args = b.map((item) => {\n      if (item instanceof SpreadArray) {\n        return [...item.item];\n      } else {\n        return [item];\n      }\n    }).flat();\n    execMany(ticks, exec, toLispArray(args), (err, vals) => {\n      if (err) {\n        done(err);\n        return;\n      }\n      if (typeof obj === 'function') {\n        done(undefined, obj(...vals));\n        return;\n      }\n      if (obj.context[obj.prop] === JSON.stringify && context.getSubscriptions.size) {\n        const cache = new Set<any>();\n        const recurse = (x: any) => {\n          if (!x || !(typeof x === 'object') || cache.has(x)) return;\n          cache.add(x);\n          for (let y in x) {\n            context.getSubscriptions.forEach((cb) => cb(x, y));\n            recurse(x[y]);\n          }\n        };\n        recurse(vals[0]);\n      }\n  \n      if (obj.context instanceof Array && arrayChange.has(obj.context[obj.prop]) && (context.changeSubscriptions.get(obj.context) || context.changeSubscriptionsGlobal.get(obj.context))) {\n        let change: Change;\n        let changed = false;\n        if (obj.prop === \"push\") {\n          change = {\n            type: \"push\",\n            added: vals\n          }\n          changed = !!vals.length;\n        } else if (obj.prop === \"pop\") {\n          change = {\n            type: \"pop\",\n            removed: obj.context.slice(-1)\n          }\n          changed = !!change.removed.length;\n        }  else if (obj.prop === \"shift\") {\n          change = {\n            type: \"shift\",\n            removed: obj.context.slice(0, 1)\n          }\n          changed = !!change.removed.length;\n        } else if (obj.prop === \"unshift\") {\n          change = {\n            type: \"unshift\",\n            added: vals\n          }\n          changed = !!vals.length;\n        } else if (obj.prop === \"splice\") {\n          change = {\n            type: \"splice\",\n            startIndex: vals[0],\n            deleteCount: vals[1] === undefined ? obj.context.length : vals[1],\n            added: vals.slice(2),\n            removed: obj.context.slice(vals[0], vals[1] === undefined ? undefined : vals[0] + vals[1])\n          }\n          changed = !!change.added.length || !!change.removed.length;\n        } else if (obj.prop === \"reverse\" || obj.prop === \"sort\") {\n          change = {type: obj.prop}\n          changed = !!obj.context.length;\n        } else if (obj.prop === \"copyWithin\") {\n          let len = vals[2] === undefined ? obj.context.length - vals[1] : Math.min(obj.context.length, vals[2] - vals[1]);\n          change = {\n            type: \"copyWithin\",\n            startIndex: vals[0],\n            endIndex: vals[0] + len,\n            added: obj.context.slice(vals[1], vals[1] + len),\n            removed: obj.context.slice(vals[0], vals[0] + len)\n          }\n          changed = !!change.added.length || !!change.removed.length;\n        }\n        if (changed) {\n          context.changeSubscriptions.get(obj.context)?.forEach((cb) => cb(change));\n          context.changeSubscriptionsGlobal.get(obj.context)?.forEach((cb) => cb(change));\n        }\n      }\n      obj.get(context);\n      done(undefined, obj.context[obj.prop](...vals));\n    }, scope, context);\n  },\n  'createObject': (exec, done, ticks, a, b: LispArray, obj, context, scope) => {\n    let res = {} as any;\n    for (let item of b as (KeyVal|SpreadObject)[]) {\n      if (item instanceof SpreadObject) {\n        res = {...res, ...item.item};\n      } else {\n        res[item.key] = item.val;\n      }\n    }\n    done(undefined, res);\n  },\n  'keyVal': (exec, done, ticks, a: string, b: LispItem) => done(undefined, new KeyVal(a, b)),\n  'createArray': (exec, done, ticks, a, b: LispArray, obj, context, scope) => {\n    const items = b.map((item) => {\n      if (item instanceof SpreadArray) {\n        return [...item.item];\n      } else {\n        return [item];\n      }\n    }).flat()\n    execMany(ticks, exec, toLispArray(items), done, scope, context);\n  },\n  'group': (exec, done, ticks, a, b) => done(undefined, b),\n  'string': (exec, done, ticks, a, b: string, obj, context) => done(undefined, context.constants.strings[b]),\n  'regex': (exec, done, ticks, a, b: string, obj, context) => {\n    const reg: IRegEx = context.constants.regexes[b];\n    if (!context.ctx.globalsWhitelist.has(RegExp)) {\n      throw new SandboxError(\"Regex not permitted\");\n    } else {\n      done(undefined, new RegExp(reg.regex, reg.flags));\n    }\n  },\n  'literal': (exec, done, ticks, a, b: number, obj, context, scope) => {\n    let name: string = context.constants.literals[b].a;\n    let found = toLispArray([]);\n    let f;\n    let resnums = [];\n    while(f = literalRegex.exec(name)) {\n      if (!f[2]) {\n        found.push(context.constants.literals[b].b[parseInt(f[3], 10)]);\n        resnums.push(f[3]);\n      }\n    }\n\n    execMany(ticks, exec, found, (err, processed) => {\n      const reses = {};\n      if(err) {\n        done(err);\n        return;\n      }\n      for (let i in resnums) {\n        const num = resnums[i];\n        reses[num] = processed[i];\n      }\n      done(undefined, name.replace(/(\\\\\\\\)*(\\\\)?\\${(\\d+)}/g, (match, $$, $, num) => {\n        if ($) return match;\n        let res = reses[num];\n        return ($$ ? $$ : '') + `${valueOrProp(res, context)}`;\n      }));\n    }, scope, context)\n  },\n  'spreadArray': (exec, done, ticks, a, b: LispItem, obj, context, scope) => {\n    exec(ticks, b, scope, context, (err, res) => {\n      if (err) {\n        done(err);\n        return;\n      }\n      done(undefined, new SpreadArray(res));\n    });\n  },\n  'spreadObject': (exec, done, ticks, a, b: LispItem, obj, context, scope) => {\n    exec(ticks, b, scope, context, (err, res) => {\n      if (err) {\n        done(err);\n        return;\n      }\n      done(undefined, new SpreadObject(res));\n    });\n  },\n  '!': (exec, done, ticks, a, b) => done(undefined, !b),\n  '~': (exec, done, ticks, a, b) => done(undefined, ~b),\n  '++$': (exec, done, ticks, a, b, obj, context) => {\n    assignCheck(obj, context);\n    done(undefined, ++obj.context[obj.prop]);\n  },\n  '$++': (exec, done, ticks, a, b, obj, context) => {\n    assignCheck(obj, context);\n    done(undefined, obj.context[obj.prop]++);\n  },\n  '--$': (exec, done, ticks, a, b, obj, context) => {\n    assignCheck(obj, context);\n    done(undefined, --obj.context[obj.prop]);\n  },\n  '$--': (exec, done, ticks, a, b, obj, context) => {\n    assignCheck(obj, context);\n    done(undefined, obj.context[obj.prop]--);\n  },\n  '=': (exec, done, ticks, a, b, obj, context) => {\n    assignCheck(obj, context);\n    done(undefined, obj.context[obj.prop] = b);\n  },\n  '+=': (exec, done, ticks, a, b, obj, context) => {\n    assignCheck(obj, context);\n    done(undefined, obj.context[obj.prop] += b);\n  },\n  '-=': (exec, done, ticks, a, b: number, obj, context) => {\n    assignCheck(obj, context);\n    done(undefined, obj.context[obj.prop] -= b);\n  },\n  '/=': (exec, done, ticks, a, b: number, obj, context) => {\n    assignCheck(obj, context);\n    done(undefined, obj.context[obj.prop] /= b);\n  },\n  '*=': (exec, done, ticks, a, b: number, obj, context) => {\n    assignCheck(obj, context);\n    done(undefined, obj.context[obj.prop] *= b);\n  },\n  '**=': (exec, done, ticks, a, b: number, obj, context) => {\n    assignCheck(obj, context);\n    done(undefined, obj.context[obj.prop] **= b);\n  },\n  '%=': (exec, done, ticks, a, b: number, obj, context) => {\n    assignCheck(obj, context);\n    done(undefined, obj.context[obj.prop] %= b);\n  },\n  '^=': (exec, done, ticks, a, b: number, obj, context) => {\n    assignCheck(obj, context);\n    done(undefined, obj.context[obj.prop] ^= b);\n  },\n  '&=': (exec, done, ticks, a, b: number, obj, context) => {\n    assignCheck(obj, context);\n    done(undefined, obj.context[obj.prop] &= b);\n  },\n  '|=': (exec, done, ticks, a, b: number, obj, context) => {\n    assignCheck(obj, context);\n    done(undefined, obj.context[obj.prop] |= b);\n  },\n  '<<=': (exec, done, ticks, a, b: number, obj, context) => {\n    assignCheck(obj, context);\n    done(undefined, obj.context[obj.prop] <<= b);\n  },\n  '>>=': (exec, done, ticks, a, b: number, obj, context) => {\n    assignCheck(obj, context);\n    done(undefined, obj.context[obj.prop] >>= b);\n  },\n  '>>>=': (exec, done, ticks, a, b: number, obj, context) => {\n    assignCheck(obj, context);\n    done(undefined, obj.context[obj.prop] >>= b);\n  },\n  '?': (exec, done, ticks, a: LispItem, b: If, obj, context, scope) => {\n    if (!(b instanceof If)) {\n      throw new SyntaxError('Invalid inline if')\n    }\n    exec(ticks, a, scope, context, (err, res) => {\n      if (err) {\n        done(err);\n      } else {\n        exec(ticks, valueOrProp(res, context) ? b.t : b.f, scope, context, done);\n      }\n    })\n  },\n  '>': (exec, done, ticks, a, b) => done(undefined, a > b),\n  '<': (exec, done, ticks, a, b) => done(undefined, a < b),\n  '>=': (exec, done, ticks, a, b) => done(undefined, a >= b),\n  '<=': (exec, done, ticks, a, b) => done(undefined, a <= b),\n  '==': (exec, done, ticks, a, b) => done(undefined, a == b),\n  '===': (exec, done, ticks, a, b) => done(undefined, a === b),\n  '!=': (exec, done, ticks, a, b) => done(undefined, a != b),\n  '!==': (exec, done, ticks, a, b) => done(undefined, a !== b),\n  '&&': (exec, done, ticks, a, b) => done(undefined, a && b),\n  '||': (exec, done, ticks, a, b) => done(undefined, a || b),\n  '&': (exec, done, ticks, a: number, b: number) => done(undefined, a & b),\n  '|': (exec, done, ticks, a: number, b: number) => done(undefined, a | b),\n  ':': (exec, done, ticks, a, b) => done(undefined, new If(a, b)),\n  '+': (exec, done, ticks, a: number, b: number) => done(undefined, a + b),\n  '-': (exec, done, ticks, a: number, b: number) => done(undefined, a - b),\n  '$+': (exec, done, ticks, a, b) => done(undefined, +b),\n  '$-': (exec, done, ticks, a, b) => done(undefined, -b),\n  '/': (exec, done, ticks, a: number, b: number) => done(undefined, a / b),\n  '^': (exec, done, ticks, a: number, b: number) => done(undefined, a ^ b),\n  '*': (exec, done, ticks, a: number, b: number) => done(undefined, a * b),\n  '%': (exec, done, ticks, a: number, b: number) => done(undefined, a % b),\n  '<<': (exec, done, ticks, a: number, b: number) => done(undefined, a << b),\n  '>>': (exec, done, ticks, a: number, b: number) => done(undefined, a >> b),\n  '>>>': (exec, done, ticks, a: number, b: number) => done(undefined, a >>> b),\n  'typeof': (exec, done, ticks, a, b: LispItem, obj, context, scope) => {\n    exec(ticks, b, scope, context, (e, prop) => {\n      done(undefined, typeof valueOrProp(prop, context));\n    });\n  },\n  'instanceof': (exec, done, ticks, a, b:  { new(): any }) => done(undefined, a instanceof b),\n  'in': (exec, done, ticks, a: string, b) => done(undefined, a in b),\n  'delete': (exec, done, ticks, a, b, obj, context, scope, bobj: Prop) => {\n    if (bobj.context === undefined) {\n      done(undefined, true);\n      return;\n    }\n    assignCheck(bobj, context, 'delete');\n    if (bobj.isVariable) {\n      done(undefined, false);\n      return;\n    }\n    done(undefined, delete bobj.context[bobj.prop]);\n  },\n  'return': (exec, done, ticks, a, b, obj, context) => done(undefined, b),\n  'var': (exec, done, ticks, a: string, b: LispItem, obj, context, scope, bobj) => {\n    exec(ticks, b, scope, context, (err, res) => {\n      if (err) {\n        done(err);\n        return;\n      }\n      done(undefined, scope.declare(a, VarType.var, res));\n    });\n  },\n  'let': (exec, done, ticks, a: string, b: LispItem, obj, context, scope, bobj) => {\n    exec(ticks, b, scope, context, (err, res) => {\n      if (err) {\n        done(err);\n        return;\n      }\n      done(undefined, scope.declare(a, VarType.let, res, bobj && bobj.isGlobal));\n    });\n  },\n  'const': (exec, done, ticks, a: string, b: LispItem, obj, context, scope, bobj) => {\n    exec(ticks, b, scope, context, (err, res) => {\n      if (err) {\n        done(err);\n        return;\n      }\n      done(undefined, scope.declare(a, VarType.const, res));\n    });\n  },\n  'arrowFunc': (exec, done, ticks, a: string[], b: LispItem, obj: Lisp, context, scope) => {\n    a = [...a];\n    if (typeof obj.b === \"string\" || obj.b instanceof CodeString) {\n      obj.b = b = lispifyFunction(new CodeString(obj.b), context.constants);\n    }\n    if (a.shift()) {\n      done(undefined, createFunctionAsync(a, b, ticks, context, scope));\n    } else {\n      done(undefined, createFunction(a, b, ticks, context, scope));\n    }\n  },\n  'function': (exec, done, ticks, a: string[]&LispArray, b: LispItem, obj: Lisp, context, scope) => {\n    if (typeof obj.b === \"string\" || obj.b instanceof CodeString) {\n      obj.b = b = lispifyFunction(new CodeString(obj.b), context.constants);\n    }\n    let isAsync = a.shift();\n    let name = a.shift();\n    let func;\n    if (isAsync) {\n      func = createFunctionAsync(a, b, ticks, context, scope, name);\n    } else {\n      func = createFunction(a, b, ticks, context, scope, name);\n    }\n    if (name) {\n      scope.declare(name, VarType.var, func);\n    }\n    done(undefined, func);\n  },\n  'inlineFunction': (exec, done, ticks, a: string[]&LispArray, b: LispItem, obj: Lisp, context, scope) => {\n    if (typeof obj.b === \"string\" || obj.b instanceof CodeString) {\n      obj.b = b = lispifyFunction(new CodeString(obj.b), context.constants);\n    }\n    let isAsync = a.shift();\n    let name = a.shift();\n    if (name) {\n      scope = new Scope(scope, {})\n    }\n    let func;\n    if (isAsync) {\n      func = createFunctionAsync(a, b, ticks, context, scope, name);\n    } else {\n      func = createFunction(a, b, ticks, context, scope, name);\n    }\n    if (name) {\n      scope.declare(name, VarType.let, func);\n    }\n    done(undefined, func);\n  },\n  'loop': (exec, done, ticks, a: LispArray, b: LispItem, obj, context, scope) => {\n    const [checkFirst, startInternal, getIterator, startStep, step, condition, beforeStep] = a;\n    let loop = true;\n    const loopScope = new Scope(scope, {});\n    let internalVars = {\n      '$$obj': undefined\n    };\n    const interalScope = new Scope(loopScope, internalVars);\n    if (exec === execAsync) {\n      (async() => {\n        let ad: AsyncDoneRet;\n        ad = asyncDone((d) => exec(ticks, startStep, loopScope, context, d));\n        internalVars['$$obj'] = (ad = asyncDone((d) => exec(ticks, getIterator, loopScope, context, d))).isInstant === true ? ad.instant : (await ad.p).result;\n        ad = asyncDone((d) => exec(ticks, startInternal, interalScope, context, d));\n        if (checkFirst) loop = (ad = asyncDone((d) => exec(ticks, condition, interalScope, context, d))).isInstant === true ? ad.instant : (await ad.p).result;\n        while (loop) {\n          let innerLoopVars = {};\n          ad = asyncDone((d) => exec(ticks, beforeStep, new Scope(interalScope, innerLoopVars), context, d));\n          ad.isInstant === true ? ad.instant : (await ad.p).result;\n          let res = await executeTreeAsync(ticks, context, b, [new Scope(loopScope, innerLoopVars)], \"loop\");\n          if (res instanceof ExecReturn && res.returned) {\n            done(undefined, res);\n            return;\n          }\n          if (res instanceof ExecReturn && res.breakLoop) {\n            break;\n          }\n          ad = asyncDone((d) => exec(ticks, step, interalScope, context, d));\n          loop = (ad = asyncDone((d) => exec(ticks, condition, interalScope, context, d))).isInstant === true ? ad.instant : (await ad.p).result;\n        }\n        done();\n      })().catch(done);\n    } else {\n      syncDone((d) => exec(ticks, startStep, loopScope, context, d));\n      internalVars['$$obj'] = syncDone((d) => exec(ticks, getIterator, loopScope, context, d)).result;\n      syncDone((d) => exec(ticks, startInternal, interalScope, context, d));\n      if (checkFirst) loop = (syncDone((d) => exec(ticks, condition, interalScope, context, d))).result;\n      while (loop) {\n        let innerLoopVars = {};\n        syncDone((d) => exec(ticks, beforeStep, new Scope(interalScope, innerLoopVars), context, d));\n        let res = executeTree(ticks, context, b, [new Scope(loopScope, innerLoopVars)], \"loop\");\n        if (res instanceof ExecReturn && res.returned) {\n          done(undefined, res);\n          return;\n        }\n        if (res instanceof ExecReturn && res.breakLoop) {\n          break;\n        }\n        syncDone((d) => exec(ticks, step, interalScope, context, d));\n        loop = (syncDone((d) => exec(ticks, condition, interalScope, context, d))).result;\n      }\n      done();\n    }\n  },\n  'loopAction': (exec, done, ticks, a: LispItem, b: LispItem, obj, context, scope, bobj, inLoopOrSwitch) => {\n    if ((inLoopOrSwitch === \"switch\" && a === \"continue\") || !inLoopOrSwitch) {\n      throw new SandboxError(\"Illegal \" + a + \" statement\");\n    }\n    done(undefined, new ExecReturn(context.ctx.auditReport, undefined, false, a === \"break\", a === \"continue\"));\n  },\n  'if': (exec, done, ticks, a: LispItem, b: If, obj, context, scope, bobj, inLoopOrSwitch) => {\n    if (!(b instanceof If)) {\n      throw new SyntaxError('Invalid if')\n    }\n    exec(ticks, a, scope, context, (err, res) => {\n      if (err) {\n        done(err);\n        return;\n      }\n      executeTreeWithDone(exec, done, ticks, context, valueOrProp(res, context) ? b.t : b.f, [new Scope(scope)], inLoopOrSwitch);\n    });\n  },\n  'switch': (exec, done, ticks, a: LispItem, b: Lisp[], obj, context, scope) => {\n    exec(ticks, a, scope, context, (err, toTest) => {\n      if (err) {\n        done(err);\n        return;\n      }\n      toTest = valueOrProp(toTest, context);\n      if (exec === execSync) {\n        let res: ExecReturn<unknown>;\n        let isTrue = false;\n        for (let caseItem of b) {\n          if (isTrue || (isTrue = !caseItem.a || toTest === valueOrProp((syncDone((d) => exec(ticks, caseItem.a, scope, context, d))).result, context))) {\n            if (!caseItem.b) continue;\n            res = executeTree(ticks, context, caseItem.b, [scope], \"switch\");\n            if (res.breakLoop) break;\n            if (res.returned) {\n              done(undefined, res);\n              return;\n            }\n            if (!caseItem.a) { // default case\n              break;\n            }\n          }\n        }\n        done();\n      } else {\n        (async () => {\n          let res: ExecReturn<unknown>;\n          let isTrue = false;\n          for (let caseItem of b) {\n            let ad: AsyncDoneRet;\n            if (isTrue || (isTrue = !caseItem.a || toTest === valueOrProp((ad = asyncDone((d) => exec(ticks, caseItem.a, scope, context, d))).isInstant === true ? ad.instant : (await ad.p).result, context))) {\n              if (!caseItem.b) continue;\n              res = await executeTreeAsync(ticks, context, caseItem.b, [scope], \"switch\");\n              if (res.breakLoop) break;\n              if (res.returned) {\n                done(undefined, res);\n                return;\n              }\n              if (!caseItem.a) { // default case\n                break;\n              }\n            }\n          }\n          done();\n        })().catch(done)\n      }\n    });\n  },\n  'try': (exec, done, ticks, a: LispItem, b: [string, LispItem, LispItem]&LispArray, obj, context, scope, bobj, inLoopOrSwitch) => {\n    const [exception, catchBody, finallyBody] = b;\n    executeTreeWithDone(exec, (err, res) => {\n      executeTreeWithDone(exec, (e) => {\n        if (e) done(e);\n        else  if (err) {\n          let sc = {};\n          if (exception) sc[exception] = err;\n          executeTreeWithDone(exec, done, ticks, context, catchBody, [new Scope(scope)], inLoopOrSwitch);\n        } else {\n          done(undefined, res);\n        }\n      }, ticks, context, finallyBody, [new Scope(scope, {})]);\n    }, ticks, context, a, [new Scope(scope)], inLoopOrSwitch);\n  },\n  'void': (exec, done, ticks, a) => {done()},\n  'new': (exec, done, ticks, a: new (...args: any[]) => any, b: any, obj, context) => {\n    if (!context.ctx.globalsWhitelist.has(a) && !sandboxedFunctions.has(a)) {\n      throw new SandboxError(`Object construction not allowed: ${a.constructor.name}`)\n    }\n    done(undefined, new a(...b))\n  },\n  'throw': (exec, done, ticks, a, b) => { done(b) },\n  'multi': (exec, done, ticks, a: any[]) => done(undefined, a.pop())\n}\n\nexport let ops = new Map<string, OpCallback>();\nfor (let op in ops2) {\n  ops.set(op, ops2[op]);\n}\n\nfunction valueOrProp(a: any, context: IExecContext) {\n  if (a instanceof Prop) return a.get(context);\n  if (a === optional) return undefined;\n  return a;\n}\n\nexport function execMany(ticks: Ticks, exec: Execution, tree: LispArray, done: Done, scope: Scope, context: IExecContext, inLoopOrSwitch?: string) {\n  if (exec === execSync) {\n    _execManySync(ticks, tree, done, scope, context, inLoopOrSwitch);\n  } else {\n    _execManyAsync(ticks, tree, done, scope, context, inLoopOrSwitch).catch(done);\n  }\n}\n\nfunction _execManySync(ticks: Ticks, tree: LispArray, done: Done, scope: Scope, context: IExecContext, inLoopOrSwitch?: string) {\n  let ret = [];\n  for (let i = 0; i < tree.length; i++) {\n    let res;\n    try {\n      res = syncDone((d) => execSync(ticks, tree[i], scope, context, d, inLoopOrSwitch)).result;\n    } catch(e) {\n      done(e);\n      return;\n    }\n    if (res instanceof ExecReturn && (res.returned || res.breakLoop || res.continueLoop)) {\n      done(undefined, res);\n      return;\n    }\n    ret.push(res);\n  }\n  done(undefined, ret);\n}\n\nasync function _execManyAsync(ticks: Ticks, tree: LispArray, done: Done, scope: Scope, context: IExecContext, inLoopOrSwitch?: string) {\n  let ret = [];\n  for (let i = 0; i < tree.length; i++) {\n    let res;\n    try {\n      let ad: AsyncDoneRet;\n      res = (ad = asyncDone((d) => execAsync(ticks, tree[i], scope, context, d, inLoopOrSwitch))).isInstant === true ? ad.instant : (await ad.p).result;\n    } catch(e) {\n      done(e);\n      return;\n    }\n    if (res instanceof ExecReturn && (res.returned || res.breakLoop || res.continueLoop)) {\n      done(undefined, res);\n      return;\n    }\n    ret.push(res);\n  }\n  done(undefined, ret);\n}\n\ntype Execution = (ticks: Ticks, tree: LispItem, scope: Scope, context: IExecContext, done: Done, inLoopOrSwitch?: string) => void\n\nexport interface AsyncDoneRet {\n  isInstant: boolean,\n  instant: any,\n  p: Promise<{result: any}>\n}\n\nexport function asyncDone(callback: (done: Done) => void): AsyncDoneRet {\n  let isInstant = false;\n  let instant: any;\n  const p = new Promise<any>((resolve, reject) => {\n    callback((err, result) => {\n      if (err) reject(err);\n      else {\n        isInstant = true;\n        instant = result;\n        resolve({result})\n      };\n    });\n  });\n  return {\n    isInstant,\n    instant,\n    p\n  }\n}\n\nexport function syncDone(callback: (done: Done) => void): {result: any} {\n  let result;\n  let err;\n  callback((e, r) => {\n    err = e;\n    result = r;\n  });\n  if (err) throw err;\n  return {result};\n}\n\nexport async function execAsync(ticks: Ticks, tree: LispItem, scope: Scope, context: IExecContext, doneOriginal: Done, inLoopOrSwitch?: string): Promise<void> {\n  let done: Done = doneOriginal;\n  const p = new Promise<void>((resolve) => {\n    done = (e, r?) => {\n      doneOriginal(e, r);\n      resolve();\n    }\n  });\n  if(_execNoneRecurse(ticks, tree, scope, context, done, true, inLoopOrSwitch)) {\n  } else if (tree instanceof Lisp) {\n    let obj;\n    try {\n      let ad: AsyncDoneRet;\n      obj = (ad = asyncDone((d) => execAsync(ticks, tree.a, scope, context, d, inLoopOrSwitch))).isInstant === true ? ad.instant : (await ad.p).result;\n    } catch (e) {\n      done(e);\n      return;\n    }\n    let a = obj;\n    try {\n      a = obj instanceof Prop ? obj.get(context) : obj;\n    } catch (e) {\n      done(e);\n      return;\n    }\n    let op = tree.op;\n    if (op === '?prop' || op === '?call') {\n      if (a === undefined || a === null) {\n        done(undefined, optional);\n        return;\n      }\n      op = op.slice(1);\n    }\n    if (a === optional) {\n      if (op === 'prop' || op === 'call') {\n        done(undefined, a);\n        return;\n      } else {\n        a = undefined;\n      }\n    }\n    let bobj;\n    try {\n      let ad: AsyncDoneRet;\n      bobj = (ad = asyncDone((d) => execAsync(ticks, tree.b, scope, context, d, inLoopOrSwitch))).isInstant === true ? ad.instant : (await ad.p).result;\n    } catch (e) {\n      done(e);\n      return;\n    }\n    let b = bobj;\n    try {\n      b = bobj instanceof Prop ? bobj.get(context) : bobj;\n    } catch (e) {\n      done(e);\n      return;\n    }\n    if (b === optional) {\n      b = undefined;\n    }\n    if (ops.has(op)) {\n      try {\n        ops.get(op)(execAsync, done, ticks, a, b, obj, context, scope, bobj, inLoopOrSwitch);\n      } catch (err) {\n        done(err);\n      }\n    } else {\n      done(new SyntaxError('Unknown operator: ' + op));\n    }\n  }\n  await p;\n}\n\n\nexport function execSync(ticks: Ticks, tree: LispItem, scope: Scope, context: IExecContext, done: Done, inLoopOrSwitch?: string) {\n  if(_execNoneRecurse(ticks, tree, scope, context, done, false, inLoopOrSwitch)) {\n  } else if (tree instanceof Lisp) {\n    let obj;\n    try {\n      obj = syncDone((d) => execSync(ticks, tree.a, scope, context, d, inLoopOrSwitch)).result;\n    } catch (e) {\n      done(e);\n      return;\n    }\n    let a = obj;\n    try {\n      a = obj instanceof Prop ? obj.get(context) : obj;\n    } catch (e) {\n      done(e);\n      return;\n    }\n    let op = tree.op;\n    if (op === '?prop' || op === '?call') {\n      if (a === undefined || a === null) {\n        done(undefined, optional);\n        return;\n      }\n      op = op.slice(1);\n    }\n    if (a === optional) {\n      if (op === 'prop' || op === 'call') {\n        done(undefined, a);\n        return;\n      } else {\n        a = undefined;\n      }\n    }\n    let bobj;\n    try {\n      bobj = syncDone((d) => execSync(ticks, tree.b, scope, context, d, inLoopOrSwitch)).result;\n    } catch (e) {\n      done(e);\n      return;\n    }\n    let b = bobj;\n    try {\n      b = bobj instanceof Prop ? bobj.get(context) : bobj;\n    } catch (e) {\n      done(e);\n      return;\n    }\n    if (b === optional) {\n      b = undefined;\n    }\n    if (ops.has(op)) {\n      try {\n        ops.get(op)(execSync, done, ticks, a, b, obj, context, scope, bobj, inLoopOrSwitch);\n      } catch (err) {\n        done(err);\n      }\n    } else {\n      done(new SyntaxError('Unknown operator: ' + op));\n    }\n  }\n}\n\nconst unexecTypes = new Set(['arrowFunc', 'function', 'inlineFunction', 'loop', 'try', 'switch', 'if', '?', 'typeof']);\n\nfunction _execNoneRecurse(ticks: Ticks, tree: LispItem, scope: Scope, context: IExecContext, done: Done, isAsync: boolean, inLoopOrSwitch?: string): boolean {\n  const exec = isAsync ? execAsync : execSync;\n  if (context.ctx.options.executionQuota <= ticks.ticks) {\n    if (typeof context.ctx.options.onExecutionQuotaReached === 'function' && context.ctx.options.onExecutionQuotaReached(ticks, scope, context, tree)) {\n    } else {\n      done(new SandboxError(\"Execution quota exceeded\"));\n      return;\n    }\n  }\n  ticks.ticks++;\n  currentTicks = ticks;\n  if (tree instanceof Prop) {\n    try {\n      done(undefined, tree.get(context));\n    } catch (err) {\n      done(err);\n    }\n  } else if (tree === optional) {\n    done();\n  } else if (Array.isArray(tree) && tree.lisp === lispArrayKey) {\n    execMany(ticks, exec, tree, done, scope, context, inLoopOrSwitch);\n  } else if (!(tree instanceof Lisp)) {\n    done(undefined, tree);\n  } else if (tree.op === 'await') {\n    if (!isAsync) {\n      done(new SandboxError(\"Illegal use of 'await', must be inside async function\"));\n    } else if (context.ctx.prototypeWhitelist?.has(Promise.prototype)) {\n      execAsync(ticks, tree.a, scope, context, async (e, r) => {\n        if (e) done(e);\n        else try {\n          done(undefined, await valueOrProp(r, context));\n        } catch(err) {\n          done(err);\n        }\n      }, inLoopOrSwitch).catch(done);\n    } else {\n      done(new SandboxError('Async/await is not permitted'))\n    }\n  } else if (unexecTypes.has(tree.op)) {\n    try {\n      ops.get(tree.op)(exec, done, ticks, tree.a, tree.b, tree, context, scope, undefined, inLoopOrSwitch);\n    } catch (err) {\n      done(err);\n    }\n  } else {\n    return false;\n  }\n  return true;\n}\nexport function executeTree<T>(ticks: Ticks, context: IExecContext, executionTree: LispItem, scopes: (IScope)[] = [], inLoopOrSwitch?: string): ExecReturn<T> {\n  return syncDone((done) => executeTreeWithDone(execSync, done, ticks, context, executionTree, scopes, inLoopOrSwitch)).result;\n}\n\nexport async function executeTreeAsync<T>(ticks: Ticks, context: IExecContext, executionTree: LispItem, scopes: (IScope)[] = [], inLoopOrSwitch?: string): Promise<ExecReturn<T>> {\n  let ad: AsyncDoneRet;\n  return (ad = asyncDone((done) => executeTreeWithDone(execAsync, done, ticks, context, executionTree, scopes, inLoopOrSwitch))).isInstant === true ? ad.instant : (await ad.p).result;\n}\n\nfunction executeTreeWithDone(exec: Execution, done: Done, ticks: Ticks, context: IExecContext, executionTree: LispItem, scopes: (IScope)[] = [], inLoopOrSwitch?: string) {\n  if (!executionTree)  {\n    done();\n    return;\n  }\n  if (!(executionTree instanceof Array)) {\n    throw new SyntaxError('Bad execution tree');\n  }\n  let scope = context.ctx.globalScope;\n  let s;\n  while (s = scopes.shift()) {\n    if (typeof s !== \"object\") continue;\n    if (s instanceof Scope) {\n      scope = s;\n    } else {\n      scope = new Scope(scope, s, s instanceof LocalScope ? undefined : null);\n    }\n  }\n  if (context.ctx.options.audit && !context.ctx.auditReport) {\n    context.ctx.auditReport = {\n      globalsAccess: new Set(),\n      prototypeAccess: {},\n    }\n  }\n  if (exec === execSync) {\n    _executeWithDoneSync(done, ticks, context, executionTree, scope, inLoopOrSwitch);\n  } else {\n    _executeWithDoneAsync(done, ticks, context, executionTree, scope, inLoopOrSwitch).catch(done);\n  }\n}\n\nfunction _executeWithDoneSync(done: Done, ticks: Ticks, context: IExecContext, executionTree: LispItem, scope: Scope, inLoopOrSwitch?: string) {\n  if (!(executionTree instanceof Array)) throw new SyntaxError('Bad execution tree');\n  let i = 0;\n  for (i = 0; i < executionTree.length; i++) {\n    let res;\n    let err;\n    const current = executionTree[i];\n    try {\n      execSync(ticks, current, scope, context, (e, r) => {\n        err = e;\n        res = r;\n      }, inLoopOrSwitch);\n    } catch (e) {\n      err = e;\n    }\n    if (err) {\n      done(err);\n      return;\n    }\n    if (res instanceof ExecReturn) {\n      done(undefined, res);\n      return;\n    }\n    if (current instanceof Lisp && current.op === 'return') {\n      done(undefined, new ExecReturn(context.ctx.auditReport, res, true))\n      return;\n    }\n  }\n  done(undefined, new ExecReturn(context.ctx.auditReport, undefined, false));\n}\n\nasync function _executeWithDoneAsync(done: Done, ticks: Ticks, context: IExecContext, executionTree: LispItem, scope: Scope, inLoopOrSwitch?: string) {\n  if (!(executionTree instanceof Array)) throw new SyntaxError('Bad execution tree');\n  let i = 0;\n  for (i = 0; i < executionTree.length; i++) {\n    let res;\n    let err;\n    const current = executionTree[i];\n    try {\n      await execAsync(ticks, current, scope, context, (e, r) => {\n        err = e;\n        res = r;\n      }, inLoopOrSwitch);\n    } catch (e) {\n      err = e;\n    }\n    if (err) {\n      done(err);\n      return;\n    }\n    if (res instanceof ExecReturn) {\n      done(undefined, res);\n      return;\n    }\n    if (current instanceof Lisp && current.op === 'return') {\n      done(undefined, new ExecReturn(context.ctx.auditReport, res, true))\n      return;\n    }\n  }\n  done(undefined, new ExecReturn(context.ctx.auditReport, undefined, false));\n}\n","import { \n  IGlobals, \n  replacementCallback, \n  IAuditReport,  \n  Change, \n  sandboxFunction,\n  sandboxedEval,\n  sandboxedSetTimeout,\n  sandboxedSetInterval,\n  ExecReturn,\n  executeTree,\n  executeTreeAsync,\n  ops,\n  assignCheck,\n  execMany,\n  execAsync,\n  execSync,\n  asyncDone,\n  Scope,\n  IScope,\n  FunctionScope,\n  LocalScope,\n  syncDone\n} from \"./executor.js\";\nimport { parse, IExecutionTree, expectTypes, setLispType, LispItem, LispArray, IConstants } from \"./parser.js\";\n\n\nexport {\n  expectTypes,\n  setLispType,\n  ops as executionOps,\n  assignCheck,\n  execMany,\n  execAsync,\n  execSync,\n  asyncDone,\n  syncDone,\n  executeTree,\n  executeTreeAsync,\n  FunctionScope,\n  LocalScope,\n};\n\nexport interface IOptions {\n  audit?: boolean;\n  forbidFunctionCalls?: boolean;\n  forbidFunctionCreation?: boolean;\n  prototypeReplacements?: Map<new () => any, replacementCallback>;\n  prototypeWhitelist?: Map<any, Set<string>>;\n  globals: IGlobals;\n  executionQuota?: bigint;\n  onExecutionQuotaReached?: (ticks: Ticks, scope: Scope, context: IExecutionTree, tree: LispItem) => boolean|void;\n}\n\nexport interface IContext {\n  sandbox: Sandbox;\n  globalScope: Scope;\n  sandboxGlobal: SandboxGlobal;\n  globalsWhitelist?: Set<any>;\n  prototypeWhitelist?: Map<any, Set<string>>;\n  options: IOptions;\n  auditReport?: IAuditReport;\n}\n\nexport interface Ticks {\n  ticks: bigint;\n}\n\nexport interface IExecContext extends IExecutionTree {\n  ctx: IContext,\n  getSubscriptions: Set<(obj: object, name: string) => void>;\n  setSubscriptions: WeakMap<object, Map<string, Set<(modification: Change) => void>>>;\n  changeSubscriptions: WeakMap<object, Set<(modification: Change) => void>>;\n  setSubscriptionsGlobal: WeakMap<object, Map<string, Set<(modification: Change) => void>>>;\n  changeSubscriptionsGlobal: WeakMap<object, Set<(modification: Change) => void>>;\n  registerSandboxFunction: (fn: (...args: any[]) => any) => void;\n  evals: Map<any, any>;\n}\n\nexport class SandboxGlobal {\n  constructor(globals: IGlobals) {\n    if (globals === globalThis) return globalThis;\n    for (let i in globals) {\n      (this as any)[i] = globals[i];\n    }\n  }\n}\n\nexport class ExecContext implements IExecContext {\n  constructor(\n    public ctx: IContext,\n    public constants: IConstants,\n    public tree: LispArray,\n    public getSubscriptions: Set<(obj: object, name: string) => void>,\n    public setSubscriptions: WeakMap<object, Map<string, Set<(modification: Change) => void>>>,\n    public changeSubscriptions: WeakMap<object, Set<(modification: Change) => void>>,\n    public setSubscriptionsGlobal: WeakMap<object, Map<string, Set<(modification: Change) => void>>>,\n    public changeSubscriptionsGlobal: WeakMap<object, Set<(modification: Change) => void>>,\n    public evals: Map<any, any>,\n    public registerSandboxFunction: (fn: (...args: any[]) => any) => void\n  ) {\n\n  }\n}\n\nfunction subscribeSet(obj: object, name: string, callback: (modification: Change) => void, context: {\n  setSubscriptions: WeakMap<object, Map<string, Set<(modification: Change) => void>>>, \n  changeSubscriptions: WeakMap<object, Set<(modification: Change) => void>>\n}): {unsubscribe: () => void} {\n  const names = context.setSubscriptions.get(obj) || new Map<string, Set<(modification: Change) => void>>();\n  context.setSubscriptions.set(obj, names);\n  const callbacks = names.get(name) || new Set();\n  names.set(name, callbacks);\n  callbacks.add(callback);\n  let changeCbs: Set<(modification: Change) => void>;\n  if (obj && obj[name] && typeof obj[name] === \"object\") {\n    changeCbs = context.changeSubscriptions.get(obj[name]) || new Set();\n    changeCbs.add(callback);\n    context.changeSubscriptions.set(obj[name], changeCbs);\n  }\n  return {\n    unsubscribe: () => {\n      callbacks.delete(callback);\n      changeCbs?.delete(callback);\n    }\n  }\n}\n\n\nexport default class Sandbox {\n  context: IContext;\n  setSubscriptions: WeakMap<object, Map<string, Set<(modification: Change) => void>>> = new WeakMap();\n  changeSubscriptions: WeakMap<object, Set<(modification: Change) => void>> = new WeakMap();\n  sandboxFunctions: WeakMap<(...args: any[]) => any, IExecContext> = new WeakMap();\n  constructor(options?: IOptions) {\n    options = Object.assign({\n      audit: false,\n      forbidFunctionCalls: false,\n      forbidFunctionCreation: false,\n      globals: Sandbox.SAFE_GLOBALS,\n      prototypeWhitelist: Sandbox.SAFE_PROTOTYPES, \n      prototypeReplacements: new Map<new() => any, replacementCallback>(),\n    }, options || {});\n    const sandboxGlobal = new SandboxGlobal(options.globals);\n    this.context = {\n      sandbox: this,\n      globalsWhitelist: new Set(Object.values(options.globals)),\n      prototypeWhitelist: new Map([...options.prototypeWhitelist].map((a) => [a[0].prototype, a[1]])),\n      options,\n      globalScope: new Scope(null, options.globals, sandboxGlobal),\n      sandboxGlobal\n    };\n    this.context.prototypeWhitelist.set(Object.getPrototypeOf([][Symbol.iterator]()), new Set());\n  }\n\n  static get SAFE_GLOBALS(): IGlobals {\n    return {\n      Function,\n      console: {\n        debug: console.debug, \n        error: console.error, \n        info: console.info, \n        log: console.log, \n        table: console.table, \n        warn: console.warn\n      },\n      isFinite,\n      isNaN,\n      parseFloat,\n      parseInt,\n      decodeURI,\n      decodeURIComponent,\n      encodeURI,\n      encodeURIComponent,\n      escape,\n      unescape,\n      Boolean,\n      Number,\n      BigInt,\n      String,\n      Object,\n      Array,\n      Symbol,\n      Error,\n      EvalError,\n      RangeError,\n      ReferenceError,\n      SyntaxError,\n      TypeError,\n      URIError,\n      Int8Array,\n      Uint8Array,\n      Uint8ClampedArray,\n      Int16Array,\n      Uint16Array,\n      Int32Array,\n      Uint32Array,\n      Float32Array,\n      Float64Array,\n      Map,\n      Set,\n      WeakMap,\n      WeakSet,\n      Promise,\n      Intl,\n      JSON,\n      Math,\n      Date,\n      RegExp\n    }\n  }\n\n  \n  static get SAFE_PROTOTYPES(): Map<any, Set<string>> {\n    let protos = [\n      SandboxGlobal,\n      Function,\n      Boolean,\n      Number,\n      BigInt,\n      String,\n      Date,\n      Error,\n      Array,\n      Int8Array,\n      Uint8Array,\n      Uint8ClampedArray,\n      Int16Array,\n      Uint16Array,\n      Int32Array,\n      Uint32Array,\n      Float32Array,\n      Float64Array,\n      Map,\n      Set,\n      WeakMap,\n      WeakSet,\n      Promise,\n      Symbol,\n      Date,\n      RegExp\n    ]\n    let map = new Map<any, Set<string>>();\n    protos.forEach((proto) => {\n      map.set(proto, new Set());\n    });\n    map.set(Object, new Set([\n      'entries',\n      'fromEntries',\n      'getOwnPropertyNames',\n      'is',\n      'keys',\n      'hasOwnProperty',\n      'isPrototypeOf',\n      'propertyIsEnumerable',\n      'toLocaleString',\n      'toString',\n      'valueOf',\n      'values'\n    ]));\n    return map;\n  }\n\n  subscribeGet(callback: (obj: object, name: string) => void, context: IExecContext): {unsubscribe: () => void} {\n    context.getSubscriptions.add(callback);\n    return {unsubscribe: () => context.getSubscriptions.delete(callback)}\n  }\n\n  subscribeSet(obj: object, name: string, callback: (modification: Change) => void, context: Sandbox|IExecContext): {unsubscribe: () => void} {\n    return subscribeSet(obj, name, callback, context);\n  }\n\n  subscribeSetGlobal(obj: object, name: string, callback: (modification: Change) => void): {unsubscribe: () => void} {\n    return subscribeSet(obj, name, callback, this);\n  }\n\n  static audit<T>(code: string, scopes: (IScope)[] = []): ExecReturn<T> {\n    const globals = {};\n    for (let i of Object.getOwnPropertyNames(globalThis)) {\n      globals[i] = globalThis[i];\n    }\n    const sandbox = new Sandbox({\n      globals,\n      audit: true,\n    });\n    return sandbox.executeTree(sandbox.createContext(sandbox.context, parse(code)), scopes);\n  }\n\n  static parse(code: string) {\n    return parse(code);\n  }\n\n  createContext(context: IContext, executionTree: IExecutionTree) {\n    const evals = new Map();\n    const execContext = new ExecContext(\n      context,\n      executionTree.constants,\n      executionTree.tree,\n      new Set<(obj: object, name: string) => void>(),\n      new WeakMap<object, Map<string, Set<(modification: Change) => void>>>(),\n      new WeakMap<object, Set<(modification: Change) => void>>(),\n      this.setSubscriptions,\n      this.changeSubscriptions,\n      evals,\n      (fn) => this.sandboxFunctions.set(fn, execContext)\n    );\n    const func = sandboxFunction(execContext);\n    evals.set(Function, func);\n    evals.set(eval, sandboxedEval(func));\n    evals.set(setTimeout, sandboxedSetTimeout(func));\n    evals.set(setInterval, sandboxedSetInterval(func));\n    return execContext;\n  }\n\n  getContext(fn: (...args: any[]) => any) {\n    return this.sandboxFunctions.get(fn);\n  }\n\n  executeTree<T>(context: IExecContext, scopes: (IScope)[] = []): ExecReturn<T> {\n    return executeTree({\n      ticks: BigInt(0),\n    }, context, context.tree, scopes);\n  }\n\n  executeTreeAsync<T>(context: IExecContext, scopes: (IScope)[] = []): Promise<ExecReturn<T>> {\n    return executeTreeAsync({\n      ticks: BigInt(0),\n    }, context, context.tree, scopes);\n  }\n  \n  compile<T>(code: string, optimize = false): (...scopes: (IScope)[]) => {context: IExecContext, run: () => T} {\n    const parsed = parse(code, optimize);\n    const exec = (...scopes: (IScope)[]) => {\n      const context = this.createContext(this.context, parsed);\n      return {context , run: () => this.executeTree<T>(context, [...scopes]).result};\n    };\n    return exec;\n  };\n  \n  compileAsync<T>(code: string, optimize = false): (...scopes: (IScope)[]) => {context: IExecContext, run: () => Promise<T>} {\n    const parsed = parse(code, optimize);\n    const exec = (...scopes: (IScope)[]) => {\n      const context = this.createContext(this.context, parsed);\n      return {context , run: async () => (await this.executeTreeAsync<T>(context, [...scopes])).result};\n    };\n    return exec;\n  };\n\n  compileExpression<T>(code: string, optimize = false): (...scopes: (IScope)[]) => {context: IExecContext, run: () => T} {\n    const parsed = parse(code, optimize, true);\n    const exec = (...scopes: (IScope)[]) => {\n      const context = this.createContext(this.context, parsed);\n      return {context , run: () => this.executeTree<T>(context, [...scopes]).result};\n    };\n    return exec\n  }\n\n  compileExpressionAsync<T>(code: string, optimize = false): (...scopes: (IScope)[]) => {context: IExecContext, run: () => Promise<T>} {\n    const parsed = parse(code, optimize, true);\n    const exec = (...scopes: (IScope)[]) => {\n      const context = this.createContext(this.context, parsed);\n      return {context , run: async() => (await this.executeTreeAsync<T>(context, [...scopes])).result};\n    };\n    return exec;\n  }\n}\n"],"names":["parseHexToInt","hex","match","parseInt","NaN","validateAndParseHex","errorName","enforcedLength","parsedHex","Number","isNaN","undefined","length","SyntaxError","parseHexadecimalCode","code","parsedCode","String","fromCharCode","parseUnicodeCode","surrogateCode","parsedSurrogateCode","isCurlyBraced","text","charAt","parseUnicodeCodePointCode","codePoint","slice","fromCodePoint","err","RangeError","singleCharacterEscapes","Map","parseSingleCharacterCode","get","escapeMatch","unraw","raw","replace","_","backslash","unicodeWithSurrogate","surrogate","unicode","octal","singleCharacter","lispTypes","ParseError","Error","constructor","message","super","substring","this","Lisp","obj","op","a","b","If","t","f","KeyVal","key","val","SpreadObject","item","SpreadArray","lispArrayKey","toLispArray","arr","lisp","inlineIfElse","elseIf","ifElse","space","expectTypes","splitter","types","opHigh","comparitor","boolOp","bitwise","next","inlineIf","assignment","assignModify","assign","incrementerBefore","expEdge","call","incrementerAfter","modifier","not","inverse","negative","positive","typeof","delete","dot","arrayProp","prop","value","createObject","createArray","number","string","literal","regex","boolean","null","und","arrowFunctionSingle","arrowFunction","inlineFunction","group","Infinity","void","await","new","throw","initialize","return","spreadObject","spreadArray","expEnd","expFunction","function","expSingle","for","do","while","loopAction","if","try","block","switch","closings","testMultiple","str","tests","found","i","exec","CodeString","ref","start","end","len","char","toString","trimStart","trim","valueOf","emptyString","okFirstChars","aNumber","wordReg","semiColon","insertedSemicolons","WeakMap","quoteCache","restOfExp","constants","part","quote","firstOpening","closingsTests","details","words","isStart","hasSemiTest","includes","filter","insertedSemis","cache","set","has","escape","done","lastChar","isOneLiner","lastInertedSemi","skip","regRes","foundWord","foundNumber","sub","push","lastAnyWord","lastWord","test","oneliner","startingExecpted","setLispType","fn","forEach","type","closingsCreate","extractIfElse","foundTrue","elseReg","count","foundElse","first","startsWith","all","Math","max","true","false","res","expect","ctx","extract","arg","l","funcFound","lispifyExpr","map","e","lispify","lispTree","quoteCount","condition","ie","startTrue","trueBlock","elseBlock","lispifyBlock","indexOf","caseFound","statement","insertSemicolons","caseTest","cases","defaultFound","cond","bracketFound","exprs","notEmpty","index","matches","primitives","BigInt","JSON","parse","isArrow","isReturn","argPos","isAsync","args","split","unshift","ended","func","eager","lispifyFunction","iteratorRegex","getIterator","body","startStep","startInternal","beforeStep","checkFirst","step","lispifyReturnExpr","iterator","extract2","k","ofStart2","ofStart3","ofCondition","ofStep","inStart2","inStart3","inStep","inCondition","shift","isBlock","catchReg","finallyBody","exception","catchBody","catchRes","offset","argsString","j","lastType","expected","topLevel","startingExpectedWithoutSingle","r","subExpressions","pos","Object","values","defined","expression","parts","skipped","isInserted","flat","tree","hoisted","hoist","concat","Array","isArray","rep","it","closingsNoInsertion","colonsRegex","rest","inserted","valid","edge","checkRegex","cancel","after","flags","notDivide","possibleDivide","extractConstants","currentEnclosure","regexFound","comment","commentStart","currJs","strRes","enclosures","isPossibleDivide","literals","join","strings","pop","regexes","js","ExecReturn","auditReport","result","returned","breakLoop","continueLoop","Prop","context","isConst","isGlobal","isVariable","ReferenceError","getSubscriptions","cb","optional","reservedWords","Set","VarType","keysOnly","ret","Scope","parent","vars","functionThis","isFuncScope","allVars","let","var","globals","functionScope","hasOwnProperty","const","TypeError","SandboxError","declare","FunctionScope","LocalScope","currentTicks","sandboxFunction","ticks","SandboxFunction","params","parsed","createFunction","generateArgs","argNames","sandboxedFunctions","WeakSet","scope","name","options","forbidFunctionCreation","executeTree","registerSandboxFunction","add","createFunctionAsync","prototypeWhitelist","Promise","prototype","async","executeTreeAsync","sandboxedEval","sandboxedSetTimeout","handler","setTimeout","sandboxedSetInterval","setInterval","assignCheck","changeSubscriptions","changeSubscriptionsGlobal","setSubscriptions","setSubscriptionsGlobal","arrayChange","splice","reverse","sort","copyWithin","literalRegex","ops2","sandboxGlobal","audit","globalsAccess","globalsWhitelist","evals","globalThis","globalScope","Boolean","isFunction","prototypeAccess","prot","getPrototypeOf","whitelist","prototypeReplacements","size","constuctor","g","forbidFunctionCalls","execMany","vals","stringify","recurse","x","y","change","changed","added","removed","startIndex","deleteCount","min","endIndex","keyVal","reg","RegExp","resnums","processed","reses","num","$$","$","valueOrProp","instanceof","in","bobj","arrowFunc","loop","loopScope","internalVars","$$obj","interalScope","execAsync","ad","asyncDone","d","isInstant","instant","p","innerLoopVars","catch","syncDone","inLoopOrSwitch","executeTreeWithDone","toTest","execSync","isTrue","caseItem","sc","multi","ops","_execManySync","_execManyAsync","callback","resolve","reject","doneOriginal","_execNoneRecurse","unexecTypes","executionQuota","onExecutionQuotaReached","executionTree","scopes","s","_executeWithDoneSync","_executeWithDoneAsync","current","SandboxGlobal","ExecContext","subscribeSet","names","callbacks","changeCbs","unsubscribe","Sandbox","SAFE_GLOBALS","SAFE_PROTOTYPES","sandbox","Symbol","Function","console","debug","error","info","log","table","warn","isFinite","parseFloat","decodeURI","decodeURIComponent","encodeURI","encodeURIComponent","unescape","EvalError","URIError","Int8Array","Uint8Array","Uint8ClampedArray","Int16Array","Uint16Array","Int32Array","Uint32Array","Float32Array","Float64Array","Intl","Date","protos","proto","subscribeGet","subscribeSetGlobal","getOwnPropertyNames","createContext","execContext","sandboxFunctions","eval","getContext","compile","optimize","run","compileAsync","compileExpression","compileExpressionAsync"],"mappings":"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"}