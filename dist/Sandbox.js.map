{"version":3,"file":"Sandbox.js","sources":["../src/unraw.ts","../src/parser.ts","../src/executor.ts","../src/Sandbox.ts"],"sourcesContent":["/**\n * Parse a string as a base-16 number. This is more strict than `parseInt` as it\n * will not allow any other characters, including (for example) \"+\", \"-\", and\n * \".\".\n * @param hex A string containing a hexadecimal number.\n * @returns The parsed integer, or `NaN` if the string is not a valid hex\n * number.\n */\nfunction parseHexToInt(hex: string): number {\n  const isOnlyHexChars = !hex.match(/[^a-f0-9]/i);\n  return isOnlyHexChars ? parseInt(hex, 16) : NaN;\n}\n\n/**\n * Check the validity and length of a hexadecimal code and optionally enforces\n * a specific number of hex digits.\n * @param hex The string to validate and parse.\n * @param errorName The name of the error message to throw a `SyntaxError` with\n * if `hex` is invalid. This is used to index `errorMessages`.\n * @param enforcedLength If provided, will throw an error if `hex` is not\n * exactly this many characters.\n * @returns The parsed hex number as a normal number.\n * @throws {SyntaxError} If the code is not valid.\n */\nfunction validateAndParseHex(\n  hex: string,\n  errorName: string,\n  enforcedLength?: number\n): number {\n  const parsedHex = parseHexToInt(hex);\n  if (\n    Number.isNaN(parsedHex) ||\n    (enforcedLength !== undefined && enforcedLength !== hex.length)\n  ) {\n    throw new SyntaxError(errorName + ': ' + hex);\n  }\n  return parsedHex;\n}\n\n/**\n * Parse a two-digit hexadecimal character escape code.\n * @param code The two-digit hexadecimal number that represents the character to\n * output.\n * @returns The single character represented by the code.\n * @throws {SyntaxError} If the code is not valid hex or is not the right\n * length.\n */\nfunction parseHexadecimalCode(code: string): string {\n  const parsedCode = validateAndParseHex(\n    code,\n    'Malformed Hexadecimal',\n    2\n  );\n  return String.fromCharCode(parsedCode);\n}\n\n/**\n * Parse a four-digit Unicode character escape code.\n * @param code The four-digit unicode number that represents the character to\n * output.\n * @param surrogateCode Optional four-digit unicode surrogate that represents\n * the other half of the character to output.\n * @returns The single character represented by the code.\n * @throws {SyntaxError} If the codes are not valid hex or are not the right\n * length.\n */\nfunction parseUnicodeCode(code: string, surrogateCode?: string): string {\n  const parsedCode = validateAndParseHex(code, 'Malformed Unicode', 4);\n\n  if (surrogateCode !== undefined) {\n    const parsedSurrogateCode = validateAndParseHex(\n      surrogateCode,\n      'Malformed Unicode',\n      4\n    );\n    return String.fromCharCode(parsedCode, parsedSurrogateCode);\n  }\n\n  return String.fromCharCode(parsedCode);\n}\n\n/**\n * Test if the text is surrounded by curly braces (`{}`).\n * @param text Text to check.\n * @returns `true` if the text is in the form `{*}`.\n */\nfunction isCurlyBraced(text: string): boolean {\n  return text.charAt(0) === \"{\" && text.charAt(text.length - 1) === \"}\";\n}\n\n/**\n * Parse a Unicode code point character escape code.\n * @param codePoint A unicode escape code point, including the surrounding curly\n * braces.\n * @returns The single character represented by the code.\n * @throws {SyntaxError} If the code is not valid hex or does not have the\n * surrounding curly braces.\n */\nfunction parseUnicodeCodePointCode(codePoint: string): string {\n  if (!isCurlyBraced(codePoint)) {\n    throw new SyntaxError('Malformed Unicode: +' + codePoint);\n  }\n  const withoutBraces = codePoint.slice(1, -1);\n  const parsedCode = validateAndParseHex(\n    withoutBraces,\n    'Malformed Unicode'\n  );\n\n  try {\n    return String.fromCodePoint(parsedCode);\n  } catch (err) {\n    throw err instanceof RangeError\n      ? new SyntaxError('Code Point Limit:' + parsedCode)\n      : err;\n  }\n}\n\n/**\n * Map of unescaped letters to their corresponding special JS escape characters.\n * Intentionally does not include characters that map to themselves like \"\\'\".\n */\nconst singleCharacterEscapes = new Map<string, string>([\n  [\"b\", \"\\b\"],\n  [\"f\", \"\\f\"],\n  [\"n\", \"\\n\"],\n  [\"r\", \"\\r\"],\n  [\"t\", \"\\t\"],\n  [\"v\", \"\\v\"],\n  [\"0\", \"\\0\"]\n]);\n\n/**\n * Parse a single character escape sequence and return the matching character.\n * If none is matched, defaults to `code`.\n * @param code A single character code.\n */\nfunction parseSingleCharacterCode(code: string): string {\n  return singleCharacterEscapes.get(code) || code;\n}\n\n/**\n * Matches every escape sequence possible, including invalid ones.\n *\n * All capture groups (described below) are unique (only one will match), except\n * for 4, which can only potentially match if 3 does.\n *\n * **Capture Groups:**\n * 0. A single backslash\n * 1. Hexadecimal code\n * 2. Unicode code point code with surrounding curly braces\n * 3. Unicode escape code with surrogate\n * 4. Surrogate code\n * 5. Unicode escape code without surrogate\n * 6. Octal code _NOTE: includes \"0\"._\n * 7. A single character (will never be \\, x, u, or 0-3)\n */\nconst escapeMatch = /\\\\(?:(\\\\)|x([\\s\\S]{0,2})|u(\\{[^}]*\\}?)|u([\\s\\S]{4})\\\\u([^{][\\s\\S]{0,3})|u([\\s\\S]{0,4})|([0-3]?[0-7]{1,2})|([\\s\\S])|$)/g;\n\n/**\n * Replace raw escape character strings with their escape characters.\n * @param raw A string where escape characters are represented as raw string\n * values like `\\'` rather than `'`.\n * @param allowOctals If `true`, will process the now-deprecated octal escape\n * sequences (ie, `\\111`).\n * @returns The processed string, with escape characters replaced by their\n * respective actual Unicode characters.\n */\nexport function unraw(raw: string): string {\n  return raw.replace(escapeMatch, function(\n    _,\n    backslash?: string,\n    hex?: string,\n    codePoint?: string,\n    unicodeWithSurrogate?: string,\n    surrogate?: string,\n    unicode?: string,\n    octal?: string,\n    singleCharacter?: string\n  ): string {\n    // Compare groups to undefined because empty strings mean different errors\n    // Otherwise, `\\u` would fail the same as `\\` which is wrong.\n    if (backslash !== undefined) {\n      return \"\\\\\";\n    }\n    if (hex !== undefined) {\n      return parseHexadecimalCode(hex);\n    }\n    if (codePoint !== undefined) {\n      return parseUnicodeCodePointCode(codePoint);\n    }\n    if (unicodeWithSurrogate !== undefined) {\n      return parseUnicodeCode(unicodeWithSurrogate, surrogate);\n    }\n    if (unicode !== undefined) {\n      return parseUnicodeCode(unicode);\n    }\n    if (octal === \"0\") {\n      return \"\\0\";\n    }\n    if (octal !== undefined) {\n      throw new SyntaxError('Octal Deprecation: ' + octal);\n    }\n    if (singleCharacter !== undefined) {\n      return parseSingleCharacterCode(singleCharacter);\n    }\n    throw new SyntaxError('End of string');\n  });\n}\nexport default unraw;","import unraw from \"./unraw.js\";\n\nexport const enum LispType {\n  None,\n  Prop,\n  StringIndex,\n  Let,\n  Const,\n  Call,\n  KeyVal,\n  Number,\n  Return,\n  Assign,\n  InlineFunction,\n  ArrowFunction,\n  CreateArray,\n  If,\n  IfCase,\n  InlineIf,\n  InlineIfCase,\n  SpreadObject,\n  SpreadArray,\n  ArrayProp,\n  PropOptional,\n  CallOptional,\n  CreateObject,\n  Group,\n  Not,\n  IncrementBefore,\n  IncrementAfter,\n  DecrementBefore,\n  DecrementAfter,\n  And,\n  Or,\n  StrictNotEqual,\n  StrictEqual,\n  Plus,\n  Var,\n  GlobalSymbol,\n  Literal,\n  Function,\n  Loop,\n  Try,\n  Switch,\n  SwitchCase,\n  Block,\n  Expression,\n  Await,\n  New,\n  Throw,\n  Minus,\n  Divide,\n  Power,\n  Multiply,\n  Modulus,\n  Equal,\n  NotEqual,\n  SmallerEqualThan,\n  LargerEqualThan,\n  SmallerThan,\n  LargerThan,\n  Negative,\n  Positive,\n  Typeof,\n  Delete,\n  Instanceof,\n  In,\n  Inverse,\n  SubractEquals,\n  AddEquals,\n  DivideEquals,\n  PowerEquals,\n  MultiplyEquals,\n  ModulusEquals,\n  BitNegateEquals,\n  BitAndEquals,\n  BitOrEquals,\n  UnsignedShiftRightEquals,\n  ShiftRightEquals,\n  ShiftLeftEquals,\n  BitAnd,\n  BitOr,\n  BitNegate,\n  BitShiftLeft,\n  BitShiftRight,\n  BitUnsignedShiftRight,\n  BigInt,\n  LiteralIndex,\n  RegexIndex,\n  LoopAction,\n  Void,\n  True,\n}\n\nexport type DefineLisp<op extends LispType, a extends LispItem|LispItem, b extends LispItem|LispItem> = [op, a, b];\n\nexport type ExtractLispOp<L> = L extends DefineLisp<infer i, any, any> ? i : never;\nexport type ExtractLispA<L> = L extends DefineLisp<any, infer i, any> ? i : never;\nexport type ExtractLispB<L> = L extends DefineLisp<any, any, infer i> ? i : never;\n\nexport type LispItemSingle = LispType.None|LispType.True|string|Lisp;\nexport type LispItem = LispItemSingle|LispItemSingle[];\nexport type Lisp = [LispType, LispItem, LispItem];\n\nfunction createLisp<L extends Lisp>(obj: {op: ExtractLispOp<L>, a: ExtractLispA<L>, b: ExtractLispB<L>}) {\n  return [obj.op, obj.a, obj.b] as L;\n}\n\nexport type Literal = DefineLisp<LispType.Literal, string, Lisp[]> & {tempJsStrings?: string[]}\nexport type If = DefineLisp<LispType.If, Lisp, IfCase>\nexport type InlineIf = DefineLisp<LispType.InlineIf, Lisp, InlineIfCase>\nexport type IfCase = DefineLisp<LispType.IfCase, Lisp[], Lisp[]>\nexport type InlineIfCase = DefineLisp<LispType.InlineIfCase, Lisp, Lisp>\nexport type KeyVal = DefineLisp<LispType.KeyVal, string|Lisp, Lisp[]>\nexport type SpreadObject = DefineLisp<LispType.SpreadObject, LispType.None, Lisp>;\nexport type SpreadArray = DefineLisp<LispType.SpreadArray, LispType.None, Lisp>;\nexport type ArrayProp = DefineLisp<LispType.ArrayProp, Lisp, Lisp>;\nexport type Prop = DefineLisp<LispType.Prop, Lisp, string|Lisp>;\nexport type PropOptional = DefineLisp<LispType.PropOptional, Lisp, Lisp[]>;\nexport type Call = DefineLisp<LispType.Call, Lisp, Lisp[]>;\nexport type CallOptional = DefineLisp<LispType.CallOptional, Lisp, Lisp[]>;\nexport type CreateArray = DefineLisp<LispType.CreateArray, Lisp, Lisp[]>;\nexport type CreateObject = DefineLisp<LispType.CreateObject, Lisp, Lisp[]>;\nexport type Group = DefineLisp<LispType.Group, Lisp, Lisp[]>;\nexport type Inverse = DefineLisp<LispType.Inverse, Lisp, Lisp>;\nexport type Not = DefineLisp<LispType.Not, Lisp, Lisp>;\nexport type Negative = DefineLisp<LispType.Negative, Lisp, Lisp>;\nexport type Positive = DefineLisp<LispType.Positive, Lisp, Lisp>;\nexport type Typeof = DefineLisp<LispType.Typeof, Lisp, Lisp>;\nexport type Delete = DefineLisp<LispType.Delete, Lisp, Lisp>;\nexport type IncrementBefore = DefineLisp<LispType.IncrementBefore, Lisp, LispType.None>;\nexport type IncrementAfter = DefineLisp<LispType.IncrementAfter, Lisp, LispType.None>;\nexport type DecrementBefore = DefineLisp<LispType.DecrementBefore, Lisp, LispType.None>;\nexport type DecrementAfter = DefineLisp<LispType.DecrementAfter, Lisp, LispType.None>;\n\nexport type And = DefineLisp<LispType.And, Lisp, Lisp>;\nexport type Or = DefineLisp<LispType.Or, Lisp, Lisp>;\nexport type Instanceof = DefineLisp<LispType.Instanceof, Lisp, Lisp>;\nexport type In = DefineLisp<LispType.In, Lisp, Lisp>;\nexport type Assigns = DefineLisp<LispType.Assign, Lisp, Lisp>;\nexport type SubractEquals = DefineLisp<LispType.SubractEquals, Lisp, Lisp>;\nexport type AddEquals = DefineLisp<LispType.AddEquals, Lisp, Lisp>;\nexport type DivideEquals = DefineLisp<LispType.DivideEquals, Lisp, Lisp>;\nexport type PowerEquals = DefineLisp<LispType.PowerEquals, Lisp, Lisp>;\nexport type MultiplyEquals = DefineLisp<LispType.MultiplyEquals, Lisp, Lisp>;\nexport type ModulusEquals = DefineLisp<LispType.ModulusEquals, Lisp, Lisp>;\nexport type BitNegateEquals = DefineLisp<LispType.BitNegateEquals, Lisp, Lisp>;\nexport type BitAndEquals = DefineLisp<LispType.BitAndEquals, Lisp, Lisp>;\nexport type BitOrEquals = DefineLisp<LispType.BitOrEquals, Lisp, Lisp>;\nexport type UnsignedShiftRightEquals = DefineLisp<LispType.UnsignedShiftRightEquals, Lisp, Lisp>;\nexport type ShiftLeftEquals = DefineLisp<LispType.ShiftLeftEquals, Lisp, Lisp>;\nexport type ShiftRightEquals = DefineLisp<LispType.ShiftRightEquals, Lisp, Lisp>;\n\nexport type BitAnd = DefineLisp<LispType.BitAnd, Lisp, Lisp>;\nexport type BitOr = DefineLisp<LispType.BitOr, Lisp, Lisp>;\nexport type BitNegate = DefineLisp<LispType.BitNegate, Lisp, Lisp>;\nexport type BitShiftLeft = DefineLisp<LispType.BitShiftLeft, Lisp, Lisp>;\nexport type BitShiftRight = DefineLisp<LispType.BitShiftRight, Lisp, Lisp>;\nexport type BitUnsignedShiftRight = DefineLisp<LispType.BitUnsignedShiftRight, Lisp, Lisp>;\nexport type SmallerEqualThan = DefineLisp<LispType.SmallerEqualThan, Lisp, Lisp>;\nexport type LargerEqualThan = DefineLisp<LispType.LargerEqualThan, Lisp, Lisp>;\nexport type SmallerThan = DefineLisp<LispType.SmallerThan, Lisp, Lisp>;\nexport type LargerThan = DefineLisp<LispType.LargerThan, Lisp, Lisp>;\nexport type StrictNotEqual = DefineLisp<LispType.StrictNotEqual, Lisp, Lisp>;\nexport type NotEqual = DefineLisp<LispType.NotEqual, Lisp, Lisp>;\nexport type StrictEqual = DefineLisp<LispType.StrictEqual, Lisp, Lisp>;\nexport type Equal = DefineLisp<LispType.Equal, Lisp, Lisp>;\nexport type Plus = DefineLisp<LispType.Plus, Lisp, Lisp>;\nexport type Minus = DefineLisp<LispType.Minus, Lisp, Lisp>;\nexport type Divide = DefineLisp<LispType.Divide, Lisp, Lisp>;\nexport type Power = DefineLisp<LispType.Power, Lisp, Lisp>;\nexport type Multiply = DefineLisp<LispType.Multiply, Lisp, Lisp>;\nexport type Modulus = DefineLisp<LispType.Modulus, Lisp, Lisp>;\n\nexport type Block = DefineLisp<LispType.Block, Lisp[], LispType.None>;\nexport type Expression = DefineLisp<LispType.Expression, Lisp[], LispType.None>;\nexport type Return = DefineLisp<LispType.Return, LispType.None, Lisp>;\nexport type Throw = DefineLisp<LispType.Throw, LispType.None, Lisp>;\nexport type Switch = DefineLisp<LispType.Switch, Lisp, SwitchCase[]>;\nexport type SwitchCase = DefineLisp<LispType.SwitchCase, LispType.None|Lisp, Lisp[]>;\nexport type Var = DefineLisp<LispType.Var, string, Lisp|LispType.None>;\nexport type Let = DefineLisp<LispType.Let, string, Lisp|LispType.None>;\nexport type Const = DefineLisp<LispType.Const, string, Lisp|LispType.None>;\n\nexport type Number = DefineLisp<LispType.Number, LispType.None, string>;\nexport type BigInt = DefineLisp<LispType.BigInt, LispType.None, string>;\nexport type GlobalSymbol = DefineLisp<LispType.GlobalSymbol, LispType.None, string>;\nexport type LiteralIndex = DefineLisp<LispType.LiteralIndex, LispType.None, string>;\nexport type StringIndex = DefineLisp<LispType.StringIndex, LispType.None, string>;\nexport type RegexIndex = DefineLisp<LispType.RegexIndex, LispType.None, string>;\n\nexport type Function = DefineLisp<LispType.Function, (string|LispType.None|LispType.True)[], string|Lisp[]>;\nexport type InlineFunction = DefineLisp<LispType.InlineFunction, string[], string|Lisp[]>;\nexport type ArrowFunction = DefineLisp<LispType.ArrowFunction, string[], string|Lisp[]>;\nexport type Loop = DefineLisp<LispType.Loop, LispItem, Lisp[]>;\nexport type LoopAction = DefineLisp<LispType.LoopAction, string, LispType.None>;\nexport type Try = DefineLisp<LispType.Try, Lisp[], LispItem>;\n\nexport type Void = DefineLisp<LispType.Void, Lisp, LispType.None>;\nexport type Await = DefineLisp<LispType.Await, Lisp, LispType.None>;\nexport type New = DefineLisp<LispType.New, Lisp, Lisp[]>;\nexport type None = DefineLisp<LispType.None, LispType.None, LispType.None>;\n\nexport type LispFamily = \n  Literal\n  |If\n  |InlineIf\n  |IfCase\n  |InlineIfCase\n  |KeyVal\n  |SpreadObject\n  |SpreadArray\n  |ArrayProp\n  |Prop\n  |PropOptional\n  |Call\n  |CallOptional\n  |CreateArray\n  |CreateObject\n  |Group\n  |Inverse\n  |Not\n  |Negative\n  |Positive\n  |Typeof\n  |Delete\n  |IncrementBefore\n  |IncrementAfter\n  |DecrementBefore\n  |DecrementAfter\n  |And\n  |Or\n  |Instanceof\n  |In\n  |Assigns\n  |SubractEquals\n  |AddEquals\n  |DivideEquals\n  |PowerEquals\n  |MultiplyEquals\n  |ModulusEquals\n  |BitNegateEquals\n  |BitAndEquals\n  |BitOrEquals\n  |UnsignedShiftRightEquals\n  |ShiftLeftEquals\n  |ShiftRightEquals\n  |BitAnd\n  |BitOr\n  |BitNegate\n  |BitShiftLeft\n  |BitShiftRight\n  |BitUnsignedShiftRight\n  |SmallerEqualThan\n  |LargerEqualThan\n  |SmallerThan\n  |LargerThan\n  |StrictNotEqual\n  |NotEqual\n  |StrictEqual\n  |Equal\n  |Plus\n  |Minus\n  |Divide\n  |Power\n  |Multiply\n  |Modulus\n  |Block\n  |Expression\n  |Return\n  |Throw\n  |Switch\n  |SwitchCase\n  |Var\n  |Let\n  |Const\n  |Number\n  |BigInt\n  |GlobalSymbol\n  |LiteralIndex\n  |StringIndex\n  |RegexIndex\n  |Function\n  |InlineFunction\n  |ArrowFunction\n  |Loop\n  |LoopAction\n  |Try\n  |Void\n  |Await\n  |New\n  |None;\n\nexport interface IRegEx {\n  regex: string,\n  flags: string,\n  length: number\n}\n\nexport interface IConstants {\n  strings: string[];\n  literals: Literal[];\n  regexes: IRegEx[];\n  eager: boolean;\n}\n\nexport interface IExecutionTree {\n  tree: Lisp[], \n  constants: IConstants\n}\n\ntype LispCallback<T> = (strings: IConstants, type: T, part: CodeString, res: string[], expect: string, ctx: {lispTree: Lisp}) => any\nlet lispTypes: Map<string, LispCallback<string>> = new Map();\n\nexport class ParseError extends Error {\n  constructor(message: string, public code: string) {\n    super(message + \": \" + code.substring(0, 40));\n  }\n}\n\nconst inlineIfElse =  /^:/;\nconst elseIf = /^else(?![\\w\\$])/\nconst ifElse = /^if(?![\\w\\$])/\nconst space = /^\\s/;\n\nexport let expectTypes = {\n  splitter: {\n    types: {\n      opHigh: /^(\\/|\\*\\*|\\*(?!\\*)|\\%)(?!\\=)/,\n      op: /^(\\+(?!(\\+))|\\-(?!(\\-)))(?!\\=)/,\n      comparitor: /^(<=|>=|<(?!<)|>(?!>)|!==|!=(?!\\=)|===|==)/,\n      boolOp: /^(&&|\\|\\||instanceof(?![\\w\\$])|in(?![\\w\\$]))/,\n      bitwise: /^(&(?!&)|\\|(?!\\|)|\\^|<<|>>(?!>)|>>>)(?!\\=)/,\n    },\n    next: [\n      'modifier',\n      'value', \n      'prop', \n      'incrementerBefore',\n    ]\n  },\n  inlineIf: {\n    types: {\n      inlineIf: /^\\?(?!\\.(?!\\d))/,\n    },\n    next: [\n      'expEnd'\n    ]\n  },\n  assignment: {\n    types: {\n      assignModify: /^(\\-=|\\+=|\\/=|\\*\\*=|\\*=|%=|\\^=|\\&=|\\|=|>>>=|>>=|<<=)/,\n      assign: /^(=)(?!=)/\n    },\n    next: [\n      'modifier',\n      'value', \n      'prop', \n      'incrementerBefore',\n    ]\n  },\n  incrementerBefore: {\n    types: {incrementerBefore: /^(\\+\\+|\\-\\-)/},\n    next: [\n      'prop',\n    ]\n  },\n  expEdge: {\n    types: {\n      call: /^(\\?\\.)?[\\(]/,\n      incrementerAfter: /^(\\+\\+|\\-\\-)/\n    },\n    next: [\n      'splitter',\n      'expEdge',\n      'dot',\n      'inlineIf',\n      'expEnd'\n    ]\n  },\n  modifier: {\n    types: {\n      not: /^!/,\n      inverse: /^~/,\n      negative: /^\\-(?!\\-)/,\n      positive: /^\\+(?!\\+)/,\n      typeof: /^typeof(?![\\w\\$])/,\n      delete: /^delete(?![\\w\\$])/,\n    },\n    next: [\n      'modifier', \n      'value',\n      'prop',\n      'incrementerBefore',\n    ]\n  },\n  dot: {\n    types: {\n      arrayProp: /^(\\?\\.)?\\[/,\n      dot: /^(\\?)?\\.(?=\\s*[a-zA-Z\\$\\_])/,\n    },\n    next: [\n      'splitter',\n      'assignment',\n      'expEdge',\n      'dot',\n      'inlineIf',\n      'expEnd'\n    ]\n  },\n  prop: {\n    types: {\n      prop: /^[a-zA-Z\\$\\_][a-zA-Z\\d\\$\\_]*/,\n    },\n    next: [\n      'splitter',\n      'assignment',\n      'expEdge',\n      'dot',\n      'inlineIf',\n      'expEnd'\n    ]\n  },\n  value: {\n    types: {\n      createObject: /^\\{/,\n      createArray: /^\\[/,\n      number: /^(0x[\\da-f]+(_[\\da-f]+)*|(\\d+(_\\d+)*(\\.\\d+(_\\d+)*)?|\\.\\d+(_\\d+)*))(e[\\+\\-]?\\d+(_\\d+)*)?(n)?(?!\\d)/i,\n      string: /^\"(\\d+)\"/,\n      literal: /^`(\\d+)`/,\n      regex: /^\\/(\\d+)\\/r(?![\\w\\$])/,\n      boolean: /^(true|false)(?![\\w\\$])/,\n      null: /^null(?![\\w\\$])/,\n      und: /^undefined(?![\\w\\$])/,\n      arrowFunctionSingle: /^(async\\s+)?([a-zA-Z\\$_][a-zA-Z\\d\\$_]*)\\s*=>\\s*({)?/,\n      arrowFunction: /^(async\\s*)?\\(\\s*((\\.\\.\\.)?\\s*[a-zA-Z\\$_][a-zA-Z\\d\\$_]*(\\s*,\\s*(\\.\\.\\.)?\\s*[a-zA-Z\\$_][a-zA-Z\\d\\$_]*)*)?\\s*\\)\\s*=>\\s*({)?/,\n      inlineFunction: /^(async\\s+)?function(\\s*[a-zA-Z\\$_][a-zA-Z\\d\\$_]*)?\\s*\\(\\s*((\\.\\.\\.)?\\s*[a-zA-Z\\$_][a-zA-Z\\d\\$_]*(\\s*,\\s*(\\.\\.\\.)?\\s*[a-zA-Z\\$_][a-zA-Z\\d\\$_]*)*)?\\s*\\)\\s*{/,\n      group: /^\\(/,\n      NaN: /^NaN(?![\\w\\$])/,\n      Infinity: /^Infinity(?![\\w\\$])/,\n      void: /^void(?![\\w\\$])\\s*/,\n      await: /^await(?![\\w\\$])\\s*/,\n      new: /^new(?![\\w\\$])\\s*/,\n    },\n    next: [\n      'splitter',\n      'expEdge',\n      'dot',\n      'inlineIf',\n      'expEnd'\n    ]\n  },\n  initialize: {\n    types: {\n      initialize: /^(var|let|const)\\s+([a-zA-Z\\$_][a-zA-Z\\d\\$_]*)\\s*(=)?/,\n      return: /^return(?![\\w\\$])/,\n      throw: /^throw(?![\\w\\$])\\s*/\n    },\n    next: [\n      'modifier',\n      'value', \n      'prop', \n      'incrementerBefore',\n      'expEnd'\n    ]\n  },\n  spreadObject: {\n    types: {\n      spreadObject: /^\\.\\.\\./\n    },\n    next: [\n      'value',\n      'prop', \n    ]\n  },\n  spreadArray: {\n    types: {\n      spreadArray: /^\\.\\.\\./\n    },\n    next: [\n      'value', \n      'prop', \n    ]\n  },\n  expEnd: {types: {}, next: []},\n  expFunction: {\n    types: {\n      function: /^(async\\s+)?function(\\s*[a-zA-Z\\$_][a-zA-Z\\d\\$_]*)\\s*\\(\\s*((\\.\\.\\.)?\\s*[a-zA-Z\\$_][a-zA-Z\\d\\$_]*(\\s*,\\s*(\\.\\.\\.)?\\s*[a-zA-Z\\$_][a-zA-Z\\d\\$_]*)*)?\\s*\\)\\s*{/,\n    },\n    next: [\n      'expEdge',\n      'expEnd'\n    ]\n  },\n  expSingle: {\n    types: {\n      for: /^(([a-zA-Z\\$\\_][\\w\\$]*)\\s*:)?\\s*for\\s*\\(/,\n      do: /^(([a-zA-Z\\$\\_][\\w\\$]*)\\s*:)?\\s*do(?![\\w\\$])\\s*(\\{)?/,\n      while: /^(([a-zA-Z\\$\\_][\\w\\$]*)\\s*:)?\\s*while\\s*\\(/,\n      loopAction: /^(break|continue)(?![\\w\\$])\\s*([a-zA-Z\\$\\_][\\w\\$]*)?/,\n      if: /^((([a-zA-Z\\$\\_][\\w\\$]*)\\s*:)?\\s*)if\\s*\\(/,\n      try: /^try\\s*{/,\n      block: /^{/,\n      switch: /^(([a-zA-Z\\$\\_][\\w\\$]*)\\s*:)?\\s*switch\\s*\\(/,\n    },\n    next: [\n      'expEnd'\n    ]\n  }\n} as const;\n\nlet closings = {\n  \"(\": \")\",\n  \"[\": \"]\",\n  \"{\": \"}\",\n  \"'\": \"'\",\n  '\"': '\"',\n  \"`\": \"`\"\n}\n\nexport function testMultiple(str: string, tests: RegExp[]) {\n  let found: RegExpExecArray;\n  for (let i = 0; i < tests.length; i++) {\n    const test = tests[i];\n    found = test.exec(str);\n    if (found) break;\n  }\n  return found;\n}\n\nexport class CodeString {\n  \n  start: number;\n  end: number;\n  ref: {str: string};\n  constructor(str: string|CodeString) {\n    this.ref = {str: \"\"};\n    if (str instanceof CodeString) {\n      this.ref = str.ref;\n      this.start = str.start\n      this.end = str.end;\n    } else {\n      this.ref.str = str;\n      this.start = 0;\n      this.end = str.length;\n    }\n  }\n\n  substring(start: number, end?: number): CodeString {\n    if (!this.length) return this;\n    start = this.start + start;\n    if (start < 0) {\n      start = 0;\n    }\n    if (start > this.end) {\n      start = this.end;\n    }\n    end = end === undefined ? this.end : this.start + end;\n    if (end < 0) {\n      end = 0;\n    }\n    if (end > this.end) {\n      end = this.end;\n    }\n    const code = new CodeString(this);\n    code.start = start;\n    code.end = end;\n    return code;\n  }\n\n  get length () {\n    const len = this.end - this.start;\n    return len < 0 ? 0 : len;\n  }\n\n  char(i: number) {\n    if (this.start === this.end) return undefined;\n    return this.ref.str[this.start + i];\n  }\n\n  toString() {\n    return this.ref.str.substring(this.start, this.end);\n  }\n\n  trimStart() {\n    const found = /^\\s+/.exec(this.toString());\n    const code = new CodeString(this);\n    if (found) {\n      code.start += found[0].length;\n    }\n    return code;\n  }\n\n  slice(start: number, end?: number) {\n    if (start < 0) {\n      start = this.end - this.start + start;\n    }\n    if (start < 0) {\n      start = 0;\n    }\n    if (end === undefined) {\n      end = this.end - this.start;\n    }\n\n    if (end < 0) {\n      end = this.end - this.start + end;\n    }\n    if (end < 0) {\n      end = 0;\n    }\n    return this.substring(start, end);\n  }\n\n  trim() {\n    const code = this.trimStart();\n    const found = /\\s+$/.exec(code.toString());\n    if (found) {\n      code.end -= found[0].length;\n    }\n    return code;\n  }\n\n  valueOf() {\n    return this.toString();\n  }\n}\n\n\nconst emptyString = new CodeString(\"\")\n\nconst okFirstChars = /^[\\+\\-~ !]/;\nconst aChar = /^[\\w\\$]/\nconst aNumber = expectTypes.value.types.number;\nconst wordReg = /^((if|for|else|while|do|function)(?![\\w\\$])|[\\w\\$]+)/;\nconst semiColon = /^;/\nconst insertedSemicolons: WeakMap<{str: string}, Array<number>> = new WeakMap();\nconst quoteCache: WeakMap<{str: string}, Map<number, number>> = new WeakMap();\nexport interface restDetails {oneliner?: boolean, words?: string[], lastWord?: string, lastAnyWord?: string, regRes?: RegExpExecArray}\nexport function restOfExp(constants: IConstants, \n                          part: CodeString, \n                          tests?: RegExp[], \n                          quote?: string, \n                          firstOpening?: string, \n                          closingsTests?: RegExp[], \n                          details: restDetails = {}): CodeString {\n  if (!part.length) {\n    return part;\n  }\n  details.words = details.words || [];\n  let isStart = true;\n  tests = tests || [];\n  const hasSemiTest = tests.includes(semiColon);\n  if (hasSemiTest) {\n    tests = tests.filter((a) => a !== semiColon);\n  }\n  const insertedSemis = insertedSemicolons.get(part.ref) || [];\n  const cache = quoteCache.get(part.ref) || new Map<number, number>();\n  quoteCache.set(part.ref, cache);\n  if (quote && cache.has(part.start - 1)) {\n    return part.substring(0, cache.get(part.start - 1) - part.start);\n  }\n  let escape = false;\n  let done = false;\n  let lastChar = \"\";\n  let isOneLiner = false;\n  let i;\n  let lastInertedSemi = false;\n  for (i = 0; i < part.length && !done; i++) {\n    let char = part.char(i);\n    if (quote === '\"' || quote === \"'\" || quote === \"`\") {\n      if (quote === \"`\" && char === \"$\" && part.char(i+1) === \"{\" && !escape) {\n        let skip = restOfExp(constants, part.substring(i+2), [], \"{\");\n        i += skip.length + 2;\n      } else if (char === quote && !escape) {\n        return part.substring(0, i);\n      }\n      escape = !escape && char === \"\\\\\";\n    } else if (closings[char]) {\n      if (!lastInertedSemi && insertedSemis[i + part.start]) {\n        lastInertedSemi = true\n        if (hasSemiTest) {\n          break;\n        }\n        i--;\n        lastChar = ';';\n        continue;\n      }\n      if (isOneLiner && char === \"{\") {\n        isOneLiner = false;\n      }\n      if (char === firstOpening) {\n        done = true;\n        break;\n      } else {\n        let skip = restOfExp(constants, part.substring(i+1), [], char);\n        cache.set(skip.start - 1, skip.end);\n        i += skip.length + 1;\n        isStart = false;\n        if (closingsTests) {\n          let sub = part.substring(i);\n          let found: RegExpExecArray;\n          if (found = testMultiple(sub.toString(), closingsTests)) {\n            details.regRes = found;\n            done = true;\n          }\n        }\n      }\n    } else if (!quote) {\n      let sub = part.substring(i).toString();\n      let foundWord: RegExpExecArray;\n      let foundNumber: RegExpExecArray;\n      if (closingsTests) {\n        let found: RegExpExecArray;\n        if (found = testMultiple(sub, closingsTests)) {\n          details.regRes = found;\n          i++;\n          done = true;\n          break;\n        }\n      }\n      if (foundNumber = aNumber.exec(sub)) {\n        i += foundNumber[0].length - 1;\n        sub = part.substring(i).toString();\n      } else if (lastChar != char) {\n        let found: [string]|RegExpExecArray;\n        if (char === ';' || (insertedSemis[i + part.start] && !isStart && !lastInertedSemi)) {\n          if (hasSemiTest) {\n            found = [\";\"];\n          } else if (insertedSemis[i + part.start]) {\n            lastInertedSemi = true\n            i--;\n            lastChar = ';';\n            continue;\n          }\n          char = sub = ';';\n        } else {\n          lastInertedSemi = false;\n        }\n        if (!found) {\n          found = testMultiple(sub, tests);\n        }\n        if (found) {\n          done = true;\n        }\n        if (!done && (foundWord = wordReg.exec(sub))) {\n          isOneLiner = true;\n          if (foundWord[0].length > 1) {\n            details.words.push(foundWord[1]);\n            details.lastAnyWord = foundWord[1];\n            if (foundWord[2]) {\n              details.lastWord = foundWord[2];\n            }\n          }\n          if(foundWord[0].length > 2) {\n            i += foundWord[0].length - 2;\n          }\n        }\n      }\n      if (isStart) {\n        if (okFirstChars.test(sub)) {\n          done = false;\n        } else {\n          isStart = false;\n        }\n      }\n      if (done) break;\n    } else if(char === closings[quote]) {\n      return part.substring(0, i);\n    }\n    lastChar = char;\n  }\n  if (quote) {\n    throw new SyntaxError(\"Unclosed '\" + quote + \"'\");\n  }\n  if (details) {\n    details.oneliner = isOneLiner;\n  }\n  return part.substring(0, i);\n}\nrestOfExp.next = [\n  'splitter',\n  'expEnd',\n  'inlineIf'\n];\n\nconst startingExecpted = ['initialize', 'expSingle', 'expFunction', 'value', 'modifier', 'prop', 'incrementerBefore', 'expEnd'];\n\nexport const setLispType = <T extends readonly string[]>(types: T, fn: LispCallback<T[number]>) => {\n  types.forEach((type) => {\n    lispTypes.set(type, fn);\n  })\n}\n\nconst closingsCreate: {[type:string]: RegExp} = {\n  'createArray': /^\\]/,\n  'createObject': /^\\}/,\n  'group': /^\\)/,\n  'arrayProp': /^\\]/,\n  'call': /^\\)/\n}\n\nconst typesCreate = {\n  'createArray': LispType.CreateArray,\n  'createObject': LispType.CreateObject,\n  'group': LispType.Group,\n  'arrayProp': LispType.ArrayProp,\n  'call': LispType.Call,\n  'prop': LispType.Prop,\n  '?prop': LispType.PropOptional,\n  '?call': LispType.CallOptional,\n} as const\n\nsetLispType(['createArray', 'createObject', 'group', 'arrayProp','call'] as const, (constants, type, part, res, expect, ctx) => {\n  let extract = emptyString;\n  let arg: CodeString[] = [];\n  let end = false;\n  let i = res[0].length;\n  const start = i;\n  while (i < part.length && !end) {\n    extract = restOfExp(constants, part.substring(i), [\n      closingsCreate[type],\n      /^,/\n    ]);\n    i += extract.length;\n    if (extract.length) {\n      arg.push(extract);\n    }\n    if (part.char(i) !== ',') {\n      end = true;\n    } else {\n      i++;\n    }\n  }\n  const next = ['value', 'modifier', 'prop', 'incrementerBefore', 'expEnd'];\n  let l: Lisp|Lisp[];\n\n  let funcFound: RegExpExecArray;\n  switch(type) {\n    case 'group':\n    case 'arrayProp':\n      l = lispifyExpr(constants, part.substring(start, i));\n      break;\n    case 'call':\n    case 'createArray':\n      // @TODO: support 'empty' values\n      l = arg.map((e) => lispify(constants, e, [...next, 'spreadArray']));\n      break;\n    case 'createObject':\n      l = arg.map((str) => {\n        str = str.trimStart();\n        let value;\n        let key: string|Lisp = '';\n        funcFound = expectTypes.expFunction.types.function.exec('function ' + str);\n        if (funcFound) {\n          key = funcFound[2].trimStart();\n          value = lispify(constants, new CodeString('function ' + str.toString().replace(key, \"\")));\n        } else {\n          let extract = restOfExp(constants, str, [/^:/]);\n          key = lispify(constants, extract, [...next, 'spreadObject']) as Prop;\n          if (key[0] === LispType.Prop) {\n            key = (key as Prop)[2];\n          }\n          value = lispify(constants, str.substring(extract.length + 1));\n        }\n        return createLisp<KeyVal>({\n          op: LispType.KeyVal,\n          a: key,\n          b: value\n        });\n      });\n      break;\n  }\n  let lisptype = (type === 'arrayProp' ? (res[1] ? LispType.PropOptional : LispType.Prop) : (type === 'call' ? (res[1] ? LispType.CallOptional : LispType.Call) : typesCreate[type])) as (typeof typesCreate)[keyof typeof typesCreate];\n  ctx.lispTree = lispify(constants, part.substring(i + 1), expectTypes[expect].next, createLisp<ArrayProp|Prop|Call|CreateObject|CreateArray|Group|PropOptional|CallOptional>({\n    op: lisptype, \n    a: ctx.lispTree, \n    b: l,\n  }));\n});\n\nconst modifierTypes = {\n  'inverse': LispType.Inverse,\n  'not': LispType.Not,\n  'positive': LispType.Positive,\n  'negative': LispType.Negative,\n  'typeof': LispType.Typeof,  \n  'delete': LispType.Delete\n} as const\n\nsetLispType(['inverse', 'not', 'negative', 'positive', 'typeof', 'delete'] as const, (constants, type, part, res, expect, ctx) => {\n  let extract = restOfExp(constants, part.substring(res[0].length), [/^([^\\s\\.\\?\\w\\$]|\\?[^\\.])/]);\n  ctx.lispTree = lispify(constants, part.substring(extract.length + res[0].length), restOfExp.next, createLisp<Inverse|Not|Negative|Positive|Typeof|Delete>({\n    op: modifierTypes[type],\n    a: ctx.lispTree, \n    b: lispify(constants, extract, expectTypes[expect].next), \n  }));\n});\n\nconst incrementTypes = {\n  '++$': LispType.IncrementBefore,\n  '--$': LispType.DecrementBefore,\n  '$++': LispType.IncrementAfter,\n  '$--': LispType.DecrementAfter\n} as const\n\nsetLispType(['incrementerBefore'] as const, (constants, type, part, res, expect, ctx) => {\n  let extract = restOfExp(constants, part.substring(2), [/^[^\\s\\.\\w\\$]/]);\n  ctx.lispTree = lispify(constants, part.substring(extract.length + 2), restOfExp.next, createLisp<IncrementBefore|DecrementBefore>({\n    op: incrementTypes[res[0] + \"$\"], \n    a: lispify(constants, extract, expectTypes[expect].next),\n    b: LispType.None\n  }));\n});\n\nsetLispType(['incrementerAfter'] as const, (constants, type, part, res, expect, ctx) => {\n  ctx.lispTree = lispify(constants, part.substring(res[0].length), expectTypes[expect].next, createLisp<IncrementAfter|DecrementAfter>({\n    op: incrementTypes[\"$\"  + res[0]], \n    a: ctx.lispTree, \n    b: LispType.None\n  }));\n});\n\nconst adderTypes = {\n  '&&': LispType.And,\n  '||': LispType.Or,\n  'instanceof': LispType.Instanceof,\n  'in': LispType.In,\n  '=': LispType.Assign,\n  '-=': LispType.SubractEquals,\n  '+=': LispType.AddEquals,\n  '/=': LispType.DivideEquals,\n  '**=': LispType.PowerEquals,\n  '*=': LispType.MultiplyEquals,\n  '%=': LispType.ModulusEquals,\n  '^=': LispType.BitNegateEquals,\n  '&=': LispType.BitAndEquals,\n  '|=': LispType.BitOrEquals,\n  '>>>=': LispType.UnsignedShiftRightEquals,\n  '<<=': LispType.ShiftLeftEquals,\n  '>>=': LispType.ShiftRightEquals,\n} as const;\n\nsetLispType(['assign', 'assignModify', 'boolOp'] as const, (constants, type, part, res, expect, ctx) => {\n  ctx.lispTree = createLisp<And|Or|Instanceof|In|Assigns|SubractEquals|AddEquals|DivideEquals|PowerEquals|MultiplyEquals|ModulusEquals|BitNegateEquals|BitAndEquals|BitOrEquals|UnsignedShiftRightEquals|ShiftLeftEquals|ShiftRightEquals>({\n    op: adderTypes[res[0]], \n    a: ctx.lispTree,\n    b: lispify(constants, part.substring(res[0].length), expectTypes[expect].next)\n  });\n});\n\nconst opTypes = {\n  '&': LispType.BitAnd,\n  '|': LispType.BitOr,\n  '^': LispType.BitNegate,\n  '<<': LispType.BitShiftLeft,\n  '>>': LispType.BitShiftRight,\n  '>>>': LispType.BitUnsignedShiftRight,\n  '<=': LispType.SmallerEqualThan,\n  '>=': LispType.LargerEqualThan,\n  '<': LispType.SmallerThan,\n  '>': LispType.LargerThan,\n  '!==': LispType.StrictNotEqual,\n  '!=': LispType.NotEqual,\n  '===': LispType.StrictEqual,\n  '==': LispType.Equal,\n  '+': LispType.Plus,\n  '-': LispType.Minus,\n  '/': LispType.Divide,\n  '**': LispType.Power,\n  '*': LispType.Multiply,\n  '%': LispType.Modulus,\n} as const\n\nsetLispType(['opHigh', 'op', 'comparitor', 'bitwise'] as const, (constants, type, part, res, expect, ctx) => {\n  const next = [\n    expectTypes.inlineIf.types.inlineIf,\n    inlineIfElse\n  ];\n  switch (type) {\n    case 'opHigh':\n      next.push(expectTypes.splitter.types.opHigh);\n    case 'op':\n      next.push(expectTypes.splitter.types.op);\n    case 'comparitor':\n      next.push(expectTypes.splitter.types.comparitor);\n    case 'bitwise':\n      next.push(expectTypes.splitter.types.bitwise);\n      next.push(expectTypes.splitter.types.boolOp);\n  }\n  let extract = restOfExp(constants, part.substring(res[0].length), next);\n  ctx.lispTree = lispify(constants, part.substring(extract.length + res[0].length), restOfExp.next, createLisp<BitAnd|BitOr|BitNegate|BitShiftLeft|BitShiftRight|BitUnsignedShiftRight|SmallerEqualThan|LargerEqualThan|SmallerThan|LargerThan|StrictNotEqual|NotEqual|StrictEqual|Equal|Plus|Minus|Divide|Power|Multiply|Modulus>  ({\n    op: opTypes[res[0]],\n    a: ctx.lispTree, \n    b: lispify(constants, extract, expectTypes[expect].next), \n  }));\n});\n\nsetLispType(['inlineIf'] as const, (constants, type, part, res, expect, ctx) => {\n  let found = false;\n  let extract = part.substring(0, 0);\n  let quoteCount = 1;\n  while(!found && extract.length < part.length) {\n    extract.end = restOfExp(constants, part.substring(extract.length + 1), [\n      expectTypes.inlineIf.types.inlineIf,\n      inlineIfElse\n    ]).end;\n    if (part.char(extract.length) === '?') {\n      quoteCount++\n    } else {\n      quoteCount--\n    }\n    if (!quoteCount) {\n      found = true;\n    }\n  }\n  extract.start = part.start + 1;\n  ctx.lispTree = createLisp<InlineIf>({\n    op: LispType.InlineIf,\n    a: ctx.lispTree, \n    b: createLisp<InlineIfCase>({\n      op: LispType.InlineIfCase,\n      a: lispifyExpr(constants, extract),\n      b: lispifyExpr(constants, part.substring(res[0].length + extract.length + 1))\n    })\n  });\n});\n\n\nfunction extractIfElse(constants: IConstants, part: CodeString) {\n  let count = 0;\n  let found = part.substring(0, 0);\n  let foundElse = emptyString;\n  let foundTrue: CodeString;\n  let first = true;\n  let elseReg: RegExpExecArray;\n  let details: restDetails = {}\n  while((found = restOfExp(constants, part.substring(found.end - part.start), [elseIf, ifElse, semiColon], undefined, undefined , undefined, details)).length || first) {\n    first = false;\n    const f = part.substring(found.end - part.start).toString();\n    \n    if (f.startsWith(\"if\")) {\n      found.end++;\n      count++;\n    } else if (f.startsWith('else')) {\n      foundTrue = part.substring(0, found.end - part.start);\n      found.end++;\n      count--;\n      if (!count) {\n        found.end--;\n      }\n    } else if (elseReg = /^;?\\s*else(?![\\w\\$])/.exec(f)) {\n      foundTrue = part.substring(0, found.end - part.start);\n      found.end += elseReg[0].length - 1;\n      count--;\n      if (!count) {\n        found.end -= elseReg[0].length - 1;\n      }\n    } else {\n      foundTrue = foundElse.length ? foundTrue : part.substring(0, found.end - part.start);\n      break;\n    }\n    if (!count) {\n      let ie = extractIfElse(constants, part.substring(found.end - part.start + (/^;?\\s*else(?![\\w\\$])/.exec(f)?.[0].length)));\n      foundElse = ie.all;\n      break;\n    }\n    details = {};\n  }\n  foundTrue = foundTrue || part.substring(0, found.end - part.start);\n  return {all: part.substring(0, Math.max(foundTrue.end, foundElse.end) - part.start), true: foundTrue, false: foundElse};\n}\n\nsetLispType(['if'] as const, (constants, type, part, res, expect, ctx) => {\n  let condition = restOfExp(constants, part.substring(res[0].length), [], \"(\");\n  const ie = extractIfElse(constants, part.substring(res[1].length));\n  const isBlock = /^\\s*\\{/.exec(part.substring(res[0].length + condition.length + 1).toString());\n  const startTrue = res[0].length - res[1].length + condition.length + 1;\n  \n  let trueBlock = ie.true.substring(startTrue);\n  let elseBlock = ie.false;\n  \n  condition = condition.trim();\n  trueBlock = trueBlock.trim();\n  elseBlock = elseBlock.trim();\n\n  if (trueBlock.char(0) === \"{\") trueBlock = trueBlock.slice(1, -1);\n  if (elseBlock.char(0) === \"{\") elseBlock = elseBlock.slice(1, -1);\n  ctx.lispTree = createLisp<If>({\n    op: LispType.If,\n    a: lispifyExpr(constants, condition), \n    b: createLisp<IfCase>({\n      op: LispType.IfCase,\n      a: lispifyBlock(trueBlock, constants),\n      b: lispifyBlock(elseBlock, constants)\n    })\n  });\n});\n\nsetLispType(['switch'] as const, (constants, type, part, res, expect, ctx) => {\n  const test = restOfExp(constants, part.substring(res[0].length), [], \"(\");\n  let start = part.toString().indexOf(\"{\", res[0].length + test.length + 1);\n  if (start === -1) throw new SyntaxError(\"Invalid switch\");\n  let statement = insertSemicolons(constants, restOfExp(constants, part.substring(start + 1), [], \"{\"));\n  let caseFound: RegExpExecArray;\n  const caseTest = /^\\s*(case\\s|default)\\s*/;\n  let cases: SwitchCase[] = [];\n  let defaultFound = false;\n  while(caseFound = caseTest.exec(statement.toString())) {\n    if (caseFound[1] === 'default') {\n      if (defaultFound) throw new SyntaxError(\"Only one default switch case allowed\");\n      defaultFound = true;\n    }\n    let cond = restOfExp(constants, statement.substring(caseFound[0].length), [/^:/]);\n    let found = emptyString;\n    let i = start = caseFound[0].length + cond.length + 1;\n    let bracketFound = /^\\s*\\{/.exec(statement.substring(i).toString());\n    let exprs: Lisp[] = [];\n    if (bracketFound) {\n      i += bracketFound[0].length;\n      found = restOfExp(constants, statement.substring(i), [], \"{\");\n      i += found.length + 1;\n      exprs = lispifyBlock(found, constants);\n    } else {\n      let notEmpty = restOfExp(constants, statement.substring(i), [caseTest]);\n      if (!notEmpty.trim().length) {\n        exprs = [];\n        i += notEmpty.length;\n      } else {\n        while((found = restOfExp(constants, statement.substring(i), [semiColon])).length) {\n          i += found.length + (statement.char(i + found.length) === ';' ? 1 : 0);\n          if (caseTest.test(statement.substring(i).toString())) {\n            break;\n          }\n        }\n        exprs = lispifyBlock(statement.substring(start, found.end - statement.start), constants);\n      }\n    }\n    statement = statement.substring(i);\n    cases.push(createLisp<SwitchCase>({\n      op: LispType.SwitchCase,\n      a: caseFound[1] === \"default\" ? undefined : lispifyExpr(constants, cond),\n      b: exprs\n    }));\n  }\n  ctx.lispTree = createLisp<Switch>({\n    op: LispType.Switch,\n    a: lispifyExpr(constants, test),\n    b: cases\n  });\n});\n\nsetLispType(['dot', 'prop'] as const, (constants, type, part, res, expect, ctx) => {\n  let prop = res[0];\n  let index = res[0].length;\n  let op = 'prop';\n  if (type === 'dot') {\n    if (res[1]) {\n      op = '?prop';\n    }\n    let matches = part.substring(res[0].length).toString().match(expectTypes.prop.types.prop);\n    if (matches && matches.length) {\n      prop = matches[0];\n      index = prop.length + res[0].length\n    } else {\n      throw new SyntaxError('Hanging  dot');\n    }\n  }\n  ctx.lispTree = lispify(constants, part.substring(index), expectTypes[expect].next, createLisp<Prop|PropOptional>({\n    op: typesCreate[op], \n    a: ctx.lispTree, \n    b: prop\n  }));\n});\n\nsetLispType(['spreadArray', 'spreadObject'] as const, (constants, type, part, res, expect, ctx) => {\n  ctx.lispTree = createLisp<SpreadArray|SpreadObject>({\n    op: type === 'spreadArray' ? LispType.SpreadArray : LispType.SpreadObject,\n    a: LispType.None,\n    b: lispify(constants, part.substring(res[0].length), expectTypes[expect].next)\n  });\n});\n\nsetLispType(['return', 'throw'] as const, (constants, type, part, res, expect, ctx) => {\n  ctx.lispTree = createLisp<Return|Throw>({\n    op: type === 'return' ? LispType.Return : LispType.Throw,\n    a: LispType.None,\n    b: lispifyExpr(constants, part.substring(res[0].length))\n  });\n});\n\nsetLispType(['number', 'boolean', 'null', 'und', 'NaN', 'Infinity'] as const, (constants, type, part, res, expect, ctx) => {\n  ctx.lispTree = lispify(constants, part.substring(res[0].length), expectTypes[expect].next, createLisp<Number|BigInt|GlobalSymbol>({\n    op: type === \"number\" ? res[10] ? LispType.BigInt : LispType.Number : LispType.GlobalSymbol,\n    a: LispType.None,\n    b: res[10] ? res[1] : res[0]\n  }));\n});\n\nsetLispType(['string', 'literal', 'regex'] as const, (constants, type, part, res, expect, ctx) => {\n  ctx.lispTree = lispify(constants, part.substring(res[0].length), expectTypes[expect].next, createLisp<StringIndex|LiteralIndex|RegexIndex>({\n    op: type === 'string' ? LispType.StringIndex : type === 'literal' ? LispType.LiteralIndex : LispType.RegexIndex,\n    a: LispType.None,\n    b: res[1],\n  }));\n});\n\nsetLispType(['initialize'] as const, (constants, type, part, res, expect, ctx) => {\n  const lt = res[1] === 'var' ? LispType.Var : res[1] === 'let' ? LispType.Let : LispType.Const;\n  if (!res[3]) {\n    ctx.lispTree = lispify(constants, part.substring(res[0].length), expectTypes[expect].next, createLisp<Var|Let|Const>({\n      op: lt,\n      a: res[2],\n      b: LispType.None\n    }));\n  } else {\n    ctx.lispTree = createLisp<Var|Let|Const>({\n      op: lt,\n      a: res[2],\n      b: lispify(constants, part.substring(res[0].length), expectTypes[expect].next)\n    });\n  }\n});\n\nsetLispType(['function', 'inlineFunction', 'arrowFunction', 'arrowFunctionSingle'] as const, (constants, type, part, res, expect, ctx) => {\n  const isArrow = type !== 'function' && type !== 'inlineFunction';\n  const isReturn = isArrow && !res[res.length - 1];\n  const argPos = isArrow ? 2 : 3;\n  const isAsync = res[1] ? LispType.True : LispType.None;\n  const args: (string|typeof isAsync)[] = res[argPos] ? res[argPos].replace(/\\s+/g, \"\").split(/,/g) : [];\n  if (!isArrow) {\n    args.unshift((res[2] || \"\").trimStart());\n  }\n  let ended = false;\n  args.forEach((arg: string) => {\n    if (ended) throw new SyntaxError('Rest parameter must be last formal parameter');\n    if (arg.startsWith('...')) ended = true;\n  });\n  args.unshift(isAsync);\n  const f = restOfExp(constants, part.substring(res[0].length), !isReturn ? [/^}/] : [/^[,\\)\\}\\]]/, semiColon])\n  const func = (isReturn ? 'return ' + f : f.toString());\n  ctx.lispTree = lispify(constants, part.substring(res[0].length + func.length + 1), expectTypes[expect].next, createLisp<Function|InlineFunction|ArrowFunction>({\n    op: isArrow ? LispType.ArrowFunction : type === 'function' ? LispType.Function : LispType.InlineFunction,\n    a: args,\n    b: constants.eager ? lispifyFunction(new CodeString(func), constants) : func\n  }));\n});\n\nconst iteratorRegex = /^((let|var|const)\\s+)?\\s*([a-zA-Z\\$_][a-zA-Z\\d\\$_]*)\\s+(in|of)(?![\\w\\$])/\nsetLispType(['for', 'do', 'while'] as const, (constants, type, part, res, expect, ctx) => {\n  let i = 0;\n  let startStep: LispItem = LispType.True;\n  let startInternal: Lisp[] = [];\n  let getIterator: Lisp;\n  let beforeStep: LispItem = LispType.None;\n  let checkFirst = LispType.True;\n  let condition: LispItem;\n  let step: LispItem = LispType.True;\n  let body: CodeString;\n  switch (type) {\n    case 'while':\n      i = part.toString().indexOf(\"(\") + 1;\n      let extract = restOfExp(constants, part.substring(i), [], \"(\");\n      condition = lispifyReturnExpr(constants, extract);\n      body = restOfExp(constants, part.substring(i + extract.length + 1)).trim();\n      if (body[0] === \"{\") body = body.slice(1, -1);\n      break;\n    case 'for':\n      i = part.toString().indexOf(\"(\") + 1;\n      let args: CodeString[] = [];\n      let extract2 = emptyString;\n      for (let k = 0; k < 3; k++)  {\n        extract2 = restOfExp(constants, part.substring(i), [/^[;\\)]/]);\n        args.push(extract2.trim());\n        i += extract2.length + 1;\n        if (part.char(i - 1) === \")\") break;\n      }\n      let iterator: RegExpExecArray;\n      if (args.length === 1 && (iterator = iteratorRegex.exec(args[0].toString()))) {\n        if (iterator[4] === 'of') {\n          getIterator = lispifyReturnExpr(constants, args[0].substring(iterator[0].length)),\n          startInternal = [\n            ofStart2, \n            ofStart3\n          ];\n          condition = ofCondition;\n          step = ofStep;\n          beforeStep = lispify(constants, new CodeString((iterator[1] || 'let ') + iterator[3]  + ' = $$next.value'), ['initialize']);\n        } else {\n          getIterator = lispifyReturnExpr(constants, args[0].substring(iterator[0].length)),\n          startInternal = [\n            inStart2,\n            inStart3\n          ];\n          step = inStep;\n          condition = inCondition;\n          beforeStep = lispify(constants, new CodeString((iterator[1] || 'let ') + iterator[3] + ' = $$keys[$$keyIndex]'), ['initialize']);\n        }\n      } else if (args.length === 3) {\n        startStep = lispifyExpr(constants, args.shift(), startingExecpted);\n        condition = lispifyReturnExpr(constants, args.shift());\n        step = lispifyExpr(constants, args.shift());\n      } else {\n        throw new SyntaxError(\"Invalid for loop definition\");\n      }\n      body = restOfExp(constants, part.substring(i)).trim();\n      if (body[0] === \"{\") body = body.slice(1, -1);\n\n      break;\n    case 'do':\n      checkFirst = LispType.None;\n      const isBlock = !!res[3];\n      body = restOfExp(constants, part.substring(res[0].length), isBlock ? [/^\\}/] : [semiColon]);\n      condition = lispifyReturnExpr(constants, restOfExp(constants, part.substring(part.toString().indexOf(\"(\", res[0].length + body.length) + 1), [], \"(\"));\n      break;\n  }\n  const a = [checkFirst, startInternal, getIterator, startStep, step, condition, beforeStep] as LispItem;\n  ctx.lispTree = createLisp<Loop>({\n    op: LispType.Loop,\n    a,\n    b: lispifyBlock(body, constants)\n  });\n});\n\nsetLispType(['block'] as const, (constants, type, part, res, expect, ctx) => {\n  ctx.lispTree = createLisp<Block>({\n    op: LispType.Block,\n    a: lispifyBlock(restOfExp(constants, part.substring(1), [], \"{\"), constants),\n    b: LispType.None\n  });\n});\n\nsetLispType(['loopAction'] as const, (constants, type, part, res, expect, ctx) => {\n  ctx.lispTree = createLisp<LoopAction>({\n    op: LispType.LoopAction,\n    a: res[1],\n    b: LispType.None\n  });\n});\n\nconst catchReg = /^\\s*(catch\\s*(\\(\\s*([a-zA-Z\\$_][a-zA-Z\\d\\$_]*)\\s*\\))?|finally)\\s*\\{/\nsetLispType(['try'] as const, (constants, type, part, res, expect, ctx) => {\n  const body = restOfExp(constants, part.substring(res[0].length), [], \"{\");\n  let catchRes = catchReg.exec(part.substring(res[0].length + body.length + 1).toString());\n  let finallyBody;\n  let exception = \"\";\n  let catchBody;\n  let offset = 0;\n  if (catchRes[1].startsWith('catch')) {\n    catchRes = catchReg.exec(part.substring(res[0].length + body.length + 1).toString());\n    exception = catchRes[2];\n    catchBody = restOfExp(constants, part.substring(res[0].length + body.length + 1 + catchRes[0].length), [], \"{\");\n    offset = res[0].length + body.length + 1 + catchRes[0].length + catchBody.length + 1;\n    if ((catchRes = catchReg.exec(part.substring(offset).toString())) && catchRes[1].startsWith('finally')) {\n      finallyBody = restOfExp(constants, part.substring(offset + catchRes[0].length), [], \"{\");\n    }\n  } else {\n    finallyBody = restOfExp(constants, part.substring(res[0].length + body.length + 1 + catchRes[0].length), [], \"{\");\n  }\n  const b = [\n    exception,\n    lispifyBlock(insertSemicolons(constants, catchBody || emptyString), constants),\n    lispifyBlock(insertSemicolons(constants, finallyBody || emptyString), constants),\n  ] as LispItem;\n  ctx.lispTree = createLisp<Try>({\n    op: LispType.Try,\n    a: lispifyBlock(insertSemicolons(constants, body), constants),\n    b\n  });\n});\n\nsetLispType(['void', 'await'] as const, (constants, type, part, res, expect, ctx) => {\n  const extract = restOfExp(constants, part.substring(res[0].length), [/^([^\\s\\.\\?\\w\\$]|\\?[^\\.])/]);\n  ctx.lispTree = lispify(constants, part.substring(res[0].length + extract.length), expectTypes[expect].next, createLisp<Void|Await>({\n    op: type === 'void' ? LispType.Void : LispType.Await,\n    a: lispify(constants, extract),\n    b: LispType.None\n  }));\n});\n\nsetLispType(['new'] as const, (constants, type, part, res, expect, ctx) => {\n  let i = res[0].length;\n  const obj = restOfExp(constants, part.substring(i), [], undefined, \"(\");\n  i += obj.length + 1;\n  const args: CodeString[] = [];\n  if (part.char(i - 1) === \"(\") {\n    const argsString = restOfExp(constants, part.substring(i), [], \"(\");\n    i += argsString.length + 1;\n    let found: CodeString;\n    let j = 0;\n    while((found = restOfExp(constants, argsString.substring(j), [/^,/])).length) {\n      j += found.length + 1;\n      args.push(found.trim());\n    }\n  }\n  ctx.lispTree = lispify(constants, part.substring(i), expectTypes.expEdge.next, createLisp({\n    op: LispType.New,\n    a: lispify(constants, obj, expectTypes.initialize.next),\n    b: args.map((arg) => lispify(constants, arg, expectTypes.initialize.next)),\n  }));\n});\n\nconst ofStart2 = lispify(undefined, new CodeString('let $$iterator = $$obj[Symbol.iterator]()'), ['initialize']);\nconst ofStart3 = lispify(undefined, new CodeString('let $$next = $$iterator.next()'), ['initialize']);\nconst ofCondition = lispify(undefined, new CodeString('return !$$next.done'), ['initialize']);\nconst ofStep = lispify(undefined, new CodeString('$$next = $$iterator.next()'));\nconst inStart2 = lispify(undefined, new CodeString('let $$keys = Object.keys($$obj)'), ['initialize']);\nconst inStart3 = lispify(undefined, new CodeString('let $$keyIndex = 0'), ['initialize']);\nconst inStep = lispify(undefined, new CodeString('$$keyIndex++'));\nconst inCondition = lispify(undefined, new CodeString('return $$keyIndex < $$keys.length'), ['initialize']);\n\nvar lastType;\nvar lastPart;\nvar lastLastPart;\nvar lastLastLastPart;\nvar lastLastLastLastPart;\nfunction lispify(constants: IConstants, part: CodeString, expected?: readonly string[], lispTree?: Lisp, topLevel = false): Lisp {\n  lispTree = lispTree || [LispType.None,LispType.None,LispType.None];\n  expected = expected || expectTypes.initialize.next;\n  if (part === undefined) return lispTree;\n\n  part = part.trimStart();\n  const str = part.toString();\n  if (!part.length && !expected.includes('expEnd')) {\n    throw new SyntaxError(\"Unexpected end of expression\");\n  }\n  if (!part.length) return lispTree;\n\n  let ctx = {lispTree: lispTree};\n\n  let res: any;\n  for (let expect of expected) {\n    if (expect === 'expEnd') {\n      continue;\n    }\n    for (let type in expectTypes[expect].types) {\n      if (type === 'expEnd') {\n        continue;\n      }\n      if(res = expectTypes[expect].types[type].exec(str)) {\n        lastType = type;\n        lastLastLastLastPart = lastLastLastPart;\n        lastLastLastPart = lastLastPart;\n        lastLastPart = lastPart;\n        lastPart = part;\n        try {\n          lispTypes.get(type)(constants, type, part, res, expect, ctx);\n        } catch(e) {\n          if (topLevel && e instanceof SyntaxError) {\n            throw new ParseError(e.message, str);\n          }\n          throw e;\n        }\n        break;\n      }\n    }\n    if (res) break;\n  }\n\n  if (!res && part.length) {\n    let msg = `Unexpected token after ${lastType}: ${part.char(0)}`;\n    if (topLevel) {\n      throw new ParseError(`Unexpected token after ${lastType}: ${part.char(0)}`, str);\n    }\n    throw new SyntaxError(`Unexpected token after ${lastType}: ${part.char(0)}`);\n  }\n  return ctx.lispTree;\n}\n\nconst startingExpectedWithoutSingle = startingExecpted.filter((r) => r !== 'expSingle');\n\nfunction lispifyExpr(constants: IConstants, str: CodeString, expected?: readonly string[]): Lisp {\n  if (!str.trimStart().length) return undefined;\n  let subExpressions: CodeString[] = [];\n  let sub: CodeString;\n  let pos = 0;\n  expected = expected || expectTypes.initialize.next;\n  if (expected.includes('expSingle')) {\n    if (testMultiple(str.toString(), Object.values(expectTypes.expSingle.types))) {\n      return lispify(constants, str, ['expSingle'], undefined, true);\n    }\n  }\n  if (expected === startingExecpted) expected = startingExpectedWithoutSingle;\n  while ((sub = restOfExp(constants, str.substring(pos), [/^,/])).length) {\n    subExpressions.push(sub.trimStart());\n    pos += sub.length + 1;\n  }\n  if (subExpressions.length === 1) {\n    return lispify(constants, str, expected, undefined, true);\n  }\n  if (expected.includes('initialize')) {\n    let defined = expectTypes.initialize.types.initialize.exec(subExpressions[0].toString());\n    if (defined) {\n      return createLisp<Block>({\n        op: LispType.Block,\n        a: subExpressions.map((str, i) => lispify(constants, i ? new CodeString(defined[1] + ' ' + str) : str, ['initialize'], undefined, true)),\n        b: LispType.None\n      });\n    } else if (expectTypes.initialize.types.return.exec(subExpressions[0].toString())) {\n      return lispify(constants, str, expected, undefined, true);\n    }\n  }\n  const exprs = subExpressions.map((str, i) => lispify(constants, str, expected, undefined, true));\n  return createLisp<Expression>({op: LispType.Expression, a: exprs, b: LispType.None});\n}\n\nexport function lispifyReturnExpr(constants: IConstants, str: CodeString) {\n  return createLisp<Return>({op: LispType.Return, a: LispType.None, b: lispifyExpr(constants, str)})\n}\n\nexport function lispifyBlock(str: CodeString, constants: IConstants, expression = false): Lisp[] {\n  str = insertSemicolons(constants, str);\n  if (!str.trim().length) return [];\n  let parts: CodeString[] = [];\n  let part: CodeString;\n  let pos = 0;\n  let start = 0;\n  let details: restDetails = {};\n  let skipped = false;\n  let isInserted = false;\n  while ((part = restOfExp(constants, str.substring(pos), [semiColon], undefined, undefined, undefined, details)).length) {\n    isInserted = str.char(pos + part.length) && str.char(pos + part.length) !== ';';\n    pos += part.length + (isInserted ? 0 : 1);\n    if (/^\\s*else(?![\\w\\$])/.test(str.substring(pos).toString())) {\n      skipped = true;\n    } else if (details.words.includes('do') && /^\\s*while(?![\\w\\$])/.test(str.substring(pos).toString())) {\n      skipped = true;\n    } else {\n      skipped = false;\n      parts.push(str.substring(start, pos - (isInserted ? 0 : 1)));\n      start = pos;\n    }\n    details = {};\n    if (expression) break;\n  }\n  if (skipped) {\n    parts.push(str.substring(start, pos - (isInserted ? 0 : 1)));\n  }\n  return parts.map((str) => str.trimStart()).filter((str) => str.length).map((str, j) => {\n    return lispifyExpr(constants, str.trimStart(), startingExecpted);\n  });\n}\n\nexport function lispifyFunction(str: CodeString, constants: IConstants, expression = false): Lisp[] {\n  if (!str.trim().length) return [];\n  const tree = lispifyBlock(str, constants, expression);\n  let hoisted: Lisp[] = [];\n  hoist(tree, hoisted);\n  return hoisted.concat(tree);\n}\n\nexport function isLisp<Type extends Lisp = Lisp>(item: LispItem|LispItem): item is Type {\n  return Array.isArray(item) && typeof item[0] === 'number' && item[0] !== LispType.None && item[0] !== LispType.True;\n}\n\nfunction hoist(item: LispItem|LispItem, res: Lisp[]): boolean {\n  if (isLisp(item)) {\n    const [op, a, b] = item;\n    if (op === LispType.Try || op === LispType.If || op === LispType.Loop || op === LispType.Switch) {\n      hoist(a, res);\n      hoist(b, res);\n    } else if (op === LispType.Var) {\n      res.push(createLisp({op: LispType.Var, a: a, b: LispType.None}));\n    } else if (op === LispType.Function && a[1]) {\n      res.push(item);\n      return true;\n    }\n  } else if (Array.isArray(item)) {\n    const rep = [];\n    for (let it of item) {\n      if (!hoist(it, res)) {\n        rep.push(it);\n      }\n    }\n    if (rep.length !== item.length) {\n      item.length = 0;\n      item.push(...rep);\n    }\n  }\n  return false;\n}\n\nconst closingsNoInsertion = /^(\\})\\s*(catch|finally|else|while|instanceof)(?![\\w\\$])/\n                    //  \\w|)|] \\n \\w = 2                                  // \\} \\w|\\{ = 5 \nconst colonsRegex = /^((([\\w\\$\\]\\)\\\"\\'\\`]|\\+\\+|\\-\\-)\\s*\\r?\\n\\s*([\\w\\$\\+\\-\\!~]))|(\\}\\s*[\\w\\$\\!~\\+\\-\\{\\(\\\"\\'\\`]))/\n\n// if () \\w \\n; \\w              == \\w \\n \\w    | last === if             a\n// if () { }; \\w                == \\} ^else    | last === if             b\n// if () \\w \\n; else \\n \\w \\n;  == \\w \\n \\w    | last === else           a\n// if () {} else {}; \\w         == \\} \\w       | last === else           b\n// while () \\n \\w \\n; \\w        == \\w \\n \\w    | last === while          a\n// while () { }; \\w             == \\} \\w       | last === while          b\n// do \\w \\n; while (); \\w       == \\w \\n while | last === do             a\n// do { } while (); \\w          == \\) \\w       | last === while          c\n// try {} catch () {}; \\w       == \\} \\w       | last === catch|finally  b\n// \\w \\n; \\w                    == \\w \\n \\w    | last === none           a\n// cb() \\n \\w                   == \\) \\n \\w    | last === none           a\n// obj[a] \\n \\w                 == \\] \\n \\w    | last === none           a\n// {} {}                        == \\} \\{       | last === none           b\n\nexport function insertSemicolons(constants: IConstants, str: CodeString): CodeString {\n  let rest = str;\n  let sub = emptyString;\n  let details: restDetails = {};\n  const inserted = insertedSemicolons.get(str.ref) || new Array(str.ref.str.length);\n  while ((sub = restOfExp(constants, rest, [], undefined, undefined, [colonsRegex], details)).length) {\n    let valid = false;\n    let part = sub;\n    let edge = sub.length;\n    if (details.regRes) {\n      valid = true;\n      const [,, a,,, b] = details.regRes;\n      edge = details.regRes[3] === \"++\" || details.regRes[3] === \"--\" ? sub.length + 1 : sub.length;\n      part = rest.substring(0,  edge);\n      if (b) {\n        let res = closingsNoInsertion.exec(rest.substring(sub.length - 1).toString());\n        if (res) {\n          if (res[2] === 'while') {\n            valid = details.lastWord !== 'do';\n          } else {\n            valid = false;\n          }\n        } else if (details.lastWord === 'function' && details.regRes[5][0] === \"}\" && details.regRes[5].slice(-1) === '(') {\n          valid = false;\n        } \n\n      } else if (a) {\n        if (details.lastWord === 'if' || details.lastWord === 'while' || details.lastWord === 'for' || details.lastWord === 'else') {\n          valid = false;\n        }\n      }\n    }\n    if (valid) {\n      inserted[part.end] = true;\n    }\n    rest = rest.substring(edge);\n    details = {};\n  }\n  insertedSemicolons.set(str.ref, inserted);\n  return str;\n}\n\nexport function checkRegex(str: string): IRegEx | null {\n  let i = 1;\n  let escape = false;\n  let done = false;\n  let cancel = false;\n  while (i < str.length && !done && !cancel) {\n    done = (str[i] === '/' && !escape);\n    escape = str[i] === '\\\\' && !escape;\n    cancel = str[i] === '\\n';\n    i++;\n  }\n  let after = str.substring(i);\n  cancel = (cancel || !done) || /^\\s*\\d/.test(after);\n  if (cancel) return null;\n  let flags = /^[a-z]*/.exec(after);\n  if(/^\\s+[\\w\\$]/.test(str.substring(i + flags[0].length))) {\n    return null;\n  }\n  return {\n    regex: str.substring(1, i-1),\n    flags: (flags && flags[0]) || \"\",\n    length: i + ((flags && flags[0].length) || 0)\n  }\n}\n\nconst notDivide = /(typeof|delete|instanceof|return|in|of|throw|new|void|do|if)$/\nconst possibleDivide = /^([\\w\\$\\]\\)]|\\+\\+|\\-\\-)[\\s\\/]/;\nexport function extractConstants(constants: IConstants, str: string, currentEnclosure = \"\"): {str: string, length: number} {\n  let quote;\n  let extract: (string|number)[] = [];\n  let escape = false;\n  let regexFound: IRegEx;\n  let comment = \"\";\n  let commentStart = -1;\n  let currJs: string[] = [];\n  let char: string = \"\";\n  const strRes: (string|number)[] = [];\n  const enclosures: string[] = [];\n  let isPossibleDivide: RegExpExecArray;\n  for (var i = 0; i < str.length; i++) {\n    char = str[i];\n    if (comment) {\n      if (char === comment) {\n        if (comment === \"*\" && str[i + 1] ===\"/\") {\n          comment = \"\";\n          i++\n        } else if (comment === \"\\n\") {\n          comment = \"\";\n        }\n      }\n    } else {\n      if (escape) {\n        escape = false;\n        extract.push(char);\n        continue;\n      }\n\n      if (quote) {\n        if (quote === \"`\" && char === \"$\" && str[i+1] === \"{\") {\n          let skip = extractConstants(constants, str.substring(i+2), \"{\");\n          currJs.push(skip.str);\n          extract.push('${', currJs.length - 1, `}`);\n          i += skip.length + 2;\n        } else if (quote === char) {\n          if (quote === '`') {\n            const li = createLisp<Literal>({\n              op: LispType.Literal,\n              a:  unraw(extract.join(\"\")),\n              b: [],\n            });\n            li.tempJsStrings = currJs\n            constants.literals.push(li);\n            strRes.push(`\\``, constants.literals.length - 1, `\\``);\n          } else {\n            constants.strings.push(unraw(extract.join(\"\")));\n            strRes.push(`\"`, constants.strings.length - 1, `\"`);\n          }\n          quote = null;\n          extract = [];\n        } else {\n          extract.push(char);\n        }\n      } else {\n        if ((char === \"'\"  || char === '\"'  || char === '`')) {\n          currJs = [];\n          quote = char;\n        } else if (closings[currentEnclosure] === char && !enclosures.length) {\n          return {str: strRes.join(\"\"), length: i}\n        } else if (closings[char]) {\n          enclosures.push(char);\n          strRes.push(char);\n        } else if (closings[enclosures[enclosures.length-1]] === char) {\n          enclosures.pop();\n          strRes.push(char);\n        } else if (char === \"/\" && (str[i+1] === \"*\" || str[i+1] === \"/\")) {\n          comment = str[i+1] === \"*\" ? \"*\" : \"\\n\";\n          commentStart = i;\n        } else if (char === '/' && !isPossibleDivide && (regexFound = checkRegex(str.substring(i)))) {\n          constants.regexes.push(regexFound);\n          strRes.push(`/`, constants.regexes.length - 1, `/r`);\n          i += regexFound.length - 1;\n        } else {\n          strRes.push(char);\n        }\n\n        if (!isPossibleDivide || !space.test(char)) {\n          if (isPossibleDivide = possibleDivide.exec(str.substring(i))) {\n            if (notDivide.test(str.substring(0, i + isPossibleDivide[1].length))) {\n              isPossibleDivide = null;\n            }\n          }\n        }\n      }\n      escape = quote && char === \"\\\\\";\n    }\n  }\n\n  if (comment) {\n    if (comment === \"*\") {\n      throw new SyntaxError(`Unclosed comment '/*': ${str.substring(commentStart)}`)\n    }\n  }\n  return {str: strRes.join(\"\"), length: i}\n}\nexport function parse(code: string, eager = false, expression = false): IExecutionTree {\n  if (typeof code !== 'string') throw new ParseError(`Cannot parse ${code}`, code);\n  let str = ' ' + code;\n  const constants: IConstants = {strings: [], literals: [], regexes: [], eager};\n  str = extractConstants(constants, str).str;\n\n  for (let l of constants.literals) {\n    l[2] = l.tempJsStrings.map((js: string) => lispifyExpr(constants, new CodeString(js)));\n    delete l.tempJsStrings;\n  }\n  return {tree: lispifyFunction(new CodeString(str), constants, expression), constants};\n}\n","import { LispItem, Lisp, parse, IRegEx, lispifyFunction, CodeString, LispType, LispFamily, ExtractLispOp, isLisp, SwitchCase } from \"./parser.js\";\nimport { IExecContext, Ticks } from \"./Sandbox.js\";\n\nexport type SandboxFunction = (code: string, ...args: unknown[]) => () => unknown;\nexport type sandboxedEval = (code: string) => unknown;\nexport type sandboxSetTimeout = (handler: TimerHandler, timeout?: number, ...args: unknown[]) => any;\nexport type sandboxSetInterval = (handler: TimerHandler, timeout?: number, ...args: unknown[]) => any;\nexport type Done = (err?: unknown, res?: unknown) => void\nexport class ExecReturn<T> {\n  constructor(public auditReport: IAuditReport, public result: T, public returned: boolean, public breakLoop = false, public continueLoop = false) {}\n}\n\nexport interface IAuditReport {\n  globalsAccess: Set<unknown>;\n  prototypeAccess: {[name: string]: Set<string>}\n}\n\nexport interface IGlobals {\n  [key: string]: unknown\n}\n\nexport interface IChange {\n  type: string;\n}\n\nexport interface ICreate extends IChange {\n  type: \"create\";\n  prop: number|string;\n}\n\nexport interface IReplace extends IChange {\n  type: \"replace\";\n}\n\nexport interface IDelete extends IChange {\n  type: \"delete\";\n  prop: number|string;\n}\n\nexport interface IReverse extends IChange {\n  type: \"reverse\";\n}\n\nexport interface ISort extends IChange {\n  type: \"sort\";\n}\n\nexport interface IPush extends IChange {\n  type: \"push\";\n  added: unknown[];\n}\n\nexport interface IPop extends IChange {\n  type: \"pop\";\n  removed: unknown[];\n}\n\nexport interface IShift extends IChange {\n  type: \"shift\";\n  removed: unknown[];\n}\n\nexport interface IUnShift extends IChange {\n  type: \"unshift\";\n  added: unknown[];\n}\n\nexport interface ISplice extends IChange {\n  type: \"splice\";\n  startIndex: number;\n  deleteCount: number; \n  added: unknown[];\n  removed: unknown[];\n\n}\n\nexport interface ICopyWithin extends IChange {\n  type: \"copyWithin\";\n  startIndex: number;\n  endIndex: number;\n  added: unknown[];\n  removed: unknown[];\n}\n\nexport type Change = ICreate | IReplace | IDelete | IReverse | ISort | IPush | IPop | IUnShift | IShift | ISplice | ICopyWithin\n\nexport class Prop {\n  constructor(public context: {[key:string]: any}, public prop: string, public isConst = false, public isGlobal = false, public isVariable = false) {\n  }\n\n  get<T = unknown>(context: IExecContext): T {\n    if (this.context === undefined) throw new ReferenceError(`${this.prop} is not defined`);\n    context.getSubscriptions.forEach((cb) => cb(this.context, this.prop))\n    return this.context[this.prop];\n  }\n}\n\nconst optional = {};\n\nconst reservedWords = new Set([\n  'instanceof',\n  'typeof',\n  'return',\n  'try',\n  'catch',\n  'if',\n  'finally',\n  'else',\n  'in',\n  'of',\n  'var',\n  'let',\n  'const',\n  'for',\n  'delete',\n  'false',\n  'true',\n  'while',\n  'do',\n  'break',\n  'continue',\n  'new',\n  'function',\n  'async',\n  'await',\n  'switch',\n  'case'\n]);\n\nenum VarType {\n  let = \"let\",\n  const = \"const\",\n  var = \"var\"\n}\n\nfunction keysOnly(obj: unknown): {[key: string]: true} {\n  const ret = Object.assign({}, obj);\n  for (let key in ret) {\n    ret[key] = true;\n  }\n  return ret;\n}\n\nexport class Scope {\n  parent: Scope;\n  const: {[key: string]: true} = {};\n  let: {[key: string]: true} = {};\n  var: {[key: string]: true} = {};\n  globals: {[key: string]: true};\n  allVars: {[key:string]: unknown} & Object;\n  functionThis?: unknown;\n  constructor(parent: Scope, vars = {}, functionThis?: unknown) {\n    const isFuncScope = functionThis !== undefined || parent === null;\n    this.parent = parent;\n    this.allVars = vars;\n    this.let = isFuncScope ? this.let : keysOnly(vars);\n    this.var = isFuncScope ? keysOnly(vars) : this.var;\n    this.globals = parent === null ? keysOnly(vars) : {};\n    this.functionThis = functionThis;\n  }\n\n  get(key: string, functionScope = false): Prop {\n    if (key === 'this' && this.functionThis !== undefined) {\n      return new Prop({this: this.functionThis}, key, true, false, true);\n    }\n    if (reservedWords.has(key)) throw new SyntaxError(\"Unexepected token '\" + key + \"'\");\n    if (this.parent === null || !functionScope || this.functionThis !== undefined) {\n      if (this.globals.hasOwnProperty(key)) {\n        return new Prop(this.functionThis, key, false, true, true);\n      }\n      if (key in this.allVars && (!(key in {}) || this.allVars.hasOwnProperty(key))) {\n        return new Prop(this.allVars, key, this.const.hasOwnProperty(key), this.globals.hasOwnProperty(key), true);\n      }\n      if (this.parent === null) {\n        return new Prop(undefined, key);\n      }\n    }\n    return this.parent.get(key, functionScope)\n  }\n\n  set(key: string, val: unknown) {\n    if (key === 'this') throw new SyntaxError('\"this\" cannot be assigned')\n    if (reservedWords.has(key)) throw new SyntaxError(\"Unexepected token '\" + key + \"'\");\n    let prop = this.get(key);\n    if(prop.context === undefined) {\n      throw new ReferenceError(`Variable '${key}' was not declared.`);\n    }\n    if (prop.isConst) {\n      throw new TypeError(`Cannot assign to const variable '${key}'`);\n    }\n    if (prop.isGlobal) {\n      throw new SandboxError(`Cannot override global variable '${key}'`);\n    }\n    prop.context[prop.prop] = val;\n    return prop;\n  }\n\n  declare(key: string, type: VarType = null, value: unknown = undefined, isGlobal = false): Prop {\n    if (key === 'this') throw new SyntaxError('\"this\" cannot be declared');\n    if (reservedWords.has(key)) throw new SyntaxError(\"Unexepected token '\" + key + \"'\");\n    if (type === 'var' && this.functionThis === undefined && this.parent !== null) {\n      return this.parent.declare(key, type, value, isGlobal)\n    } else if ((this[type].hasOwnProperty(key) && type !== 'const' && !this.globals.hasOwnProperty(key)) || !(key in this.allVars)) {\n      if (isGlobal) {\n        this.globals[key] = true;\n      }\n      this[type][key] = true;\n      this.allVars[key] = value;\n    } else {\n      throw new SandboxError(`Identifier '${key}' has already been declared`);\n    }\n    return new Prop(this.allVars, key, this.const.hasOwnProperty(key), isGlobal);\n  }\n}\n\nexport interface IScope {\n  [key: string]: any;\n}\n\nexport class FunctionScope implements IScope {}\n\nexport class LocalScope implements IScope {}\n\nexport class SandboxError extends Error {}\n\nlet currentTicks: Ticks;\n\nexport function sandboxFunction(context: IExecContext, ticks?: Ticks): SandboxFunction {\n  return SandboxFunction;\n  function SandboxFunction(...params: string[]) {\n    let code = params.pop() || \"\";\n    let parsed = parse(code);\n    return createFunction(params, parsed.tree, ticks || currentTicks, {\n      ...context,\n      constants: parsed.constants,\n      tree: parsed.tree\n    }, undefined, 'anonymous');\n  }\n}\n\nfunction generateArgs(argNames: string[], args: unknown[]) {\n  const vars: unknown = {};\n  argNames.forEach((arg, i) => {\n    if (arg.startsWith('...')) {\n      vars[arg.substring(3)] = args.slice(i);\n    } else {\n      vars[arg] = args[i];\n    }\n  });\n  return vars;\n}\n\nconst sandboxedFunctions = new WeakSet();\nexport function createFunction(argNames: string[], parsed: Lisp[], ticks: Ticks, context: IExecContext, scope?: Scope, name?: string) {\n  if (context.ctx.options.forbidFunctionCreation) {\n    throw new SandboxError(\"Function creation is forbidden\");\n  }\n  let func;\n  if (name === undefined) {\n    func = (...args) => {\n      const vars = generateArgs(argNames, args);\n      const res = executeTree(ticks, context, parsed, scope === undefined ? [] : [new Scope(scope, vars)])\n      return res.result;\n    }\n  } else {\n    func = function sandboxedObject(...args) {\n      const vars = generateArgs(argNames, args);\n      const res = executeTree(ticks, context, parsed, scope === undefined ? [] : [new Scope(scope, vars, this)])\n      return res.result;\n    }\n  }\n  context.registerSandboxFunction(func);\n  sandboxedFunctions.add(func);\n  return func;\n}\n\nexport function createFunctionAsync(argNames: string[], parsed: Lisp[], ticks: Ticks, context: IExecContext, scope?: Scope, name?: string) {\n  if (context.ctx.options.forbidFunctionCreation) {\n    throw new SandboxError(\"Function creation is forbidden\");\n  }\n  if (!context.ctx.prototypeWhitelist?.has(Promise.prototype)) {\n    throw new SandboxError(\"Async/await not permitted\");\n  }\n  let func;\n  if (name === undefined) {\n    func = async (...args) => {\n      const vars = generateArgs(argNames, args);\n      const res = await executeTreeAsync(ticks, context, parsed, scope === undefined ? [] : [new Scope(scope, vars)])\n      return res.result;\n    }\n  } else {\n    func = async function sandboxedObject(...args) {\n      const vars = generateArgs(argNames, args);\n      const res = await executeTreeAsync(ticks, context, parsed, scope === undefined ? [] : [new Scope(scope, vars, this)])\n      return res.result;\n    }\n  }\n  context.registerSandboxFunction(func);\n  sandboxedFunctions.add(func);\n  return func;\n}\n\nexport function sandboxedEval(func: SandboxFunction): sandboxedEval {\n  return sandboxEval;\n  function sandboxEval(code: string) {\n    return func(code)();\n  }\n}\n\nexport function sandboxedSetTimeout(func: SandboxFunction): sandboxSetTimeout {\n  return function sandboxSetTimeout(handler, ...args) {\n    if (typeof handler !== 'string') return setTimeout(handler, ...args);\n    return setTimeout(func(handler), ...args);\n  }\n}\n\nexport function sandboxedSetInterval(func: SandboxFunction): sandboxSetInterval {\n  return function sandboxSetInterval(handler, ...args) {\n    if (typeof handler !== 'string') return setInterval(handler, ...args);\n    return setInterval(func(handler), ...args);\n  }\n}\n\nexport function assignCheck(obj: Prop, context: IExecContext, op = 'assign') {\n  if(obj.context === undefined) {\n    throw new ReferenceError(`Cannot ${op} value to undefined.`)\n  }\n  if(typeof obj.context !== 'object' && typeof obj.context !== 'function') {\n    throw new SyntaxError(`Cannot ${op} value to a primitive.`)\n  }\n  if (obj.isConst) {\n    throw new TypeError(`Cannot set value to const variable '${obj.prop}'`);\n  }\n  if (obj.isGlobal) {\n    throw new SandboxError(`Cannot ${op} property '${obj.prop}' of a global object`);\n  }\n  if (typeof obj.context[obj.prop] === 'function' && !obj.context.hasOwnProperty(obj.prop)) {\n    throw new SandboxError(`Override prototype property '${obj.prop}' not allowed`);\n  }\n  if (op === \"delete\") {\n    if (obj.context.hasOwnProperty(obj.prop)) {\n      context.changeSubscriptions.get(obj.context)?.forEach((cb) => cb({type: \"delete\", prop: obj.prop}));\n      context.changeSubscriptionsGlobal.get(obj.context)?.forEach((cb) => cb({type: \"delete\", prop: obj.prop}));\n    }\n  } else if (obj.context.hasOwnProperty(obj.prop)) {\n    context.setSubscriptions.get(obj.context)?.get(obj.prop)?.forEach((cb) => cb({\n      type: \"replace\"\n    }));\n    context.setSubscriptionsGlobal.get(obj.context)?.get(obj.prop)?.forEach((cb) => cb({\n      type: \"replace\"\n    }));\n  } else {\n    context.changeSubscriptions.get(obj.context)?.forEach((cb) => cb({type: \"create\", prop: obj.prop}));\n    context.changeSubscriptionsGlobal.get(obj.context)?.forEach((cb) => cb({type: \"create\", prop: obj.prop}));\n  }\n}\nconst arrayChange = new Set([\n  [].push,\n  [].pop,\n  [].shift,\n  [].unshift,\n  [].splice,\n  [].reverse,\n  [].sort,\n  [].copyWithin\n]);\n\nexport class KeyVal {\n  constructor(public key: string|SpreadObject, public val: unknown) {}\n}\n\nexport class SpreadObject {\n  constructor(public item: {[key: string]: unknown}) {}\n}\n\nexport class SpreadArray {\n  constructor(public item: unknown[]) {}\n}\n\nexport class If {\n  constructor(public t: Lisp, public f: Lisp) {}\n}\n\nconst literalRegex = /(\\$\\$)*(\\$)?\\${(\\d+)}/g;\ntype OpCallback = (exec: Execution, done: Done, ticks: Ticks, a: any, b: any, obj: any, context: IExecContext, scope: Scope, bobj?: any, inLoopOrSwitch?: string) => void;\n\nexport const ops = new Map<LispType, OpCallback>();\nexport function addOps<Type extends LispFamily>(type: ExtractLispOp<Type>, cb: OpCallback) {\n  ops.set(type, cb);\n}\n\naddOps(LispType.Prop, (exec, done, ticks, a, b: string, obj, context, scope) => {\n    if(a === null) {\n      throw new TypeError(`Cannot get property ${b} of null`);\n    }\n    const type = typeof a;\n    if (type === 'undefined' && obj === undefined) {\n      let prop = scope.get(b);\n      if (prop.context === context.ctx.sandboxGlobal) {\n        if (context.ctx.options.audit) {\n          context.ctx.auditReport.globalsAccess.add(b);\n        }\n        const rep = context.ctx.globalsWhitelist.has(context.ctx.sandboxGlobal[b]) ? context.evals.get(context.ctx.sandboxGlobal[b]) : undefined;\n        if (rep) {\n          done(undefined, rep);\n          return;\n        }\n      }\n      if (prop.context && prop.context[b] === globalThis) {\n        done(undefined, context.ctx.globalScope.get('this'));\n        return;\n      }\n\n      done(undefined, prop);\n      return;\n    } else if (a === undefined) {\n      throw new SandboxError(\"Cannot get property '\" + b + \"' of undefined\")\n    }\n\n    if (type !== 'object') {\n      if(type === 'number') {\n        a = new Number(a);\n      } else if(type === 'string') {\n        a = new String(a);\n      } else if(type === 'boolean') {\n        a = new Boolean(a);\n      }\n    } else if (typeof a.hasOwnProperty === 'undefined') {\n      done(undefined, new Prop(undefined, b));\n      return;\n    }\n\n    const isFunction = type === 'function';\n    let prototypeAccess = isFunction || !(a.hasOwnProperty(b) || typeof b === 'number');\n\n    if (context.ctx.options.audit && prototypeAccess) {\n      if (typeof b === 'string') {\n        let prot = Object.getPrototypeOf(a);\n        do {\n          if (prot.hasOwnProperty(b)) {\n            if(!context.ctx.auditReport.prototypeAccess[prot.constructor.name]) {\n              context.ctx.auditReport.prototypeAccess[prot.constructor.name] = new Set();\n            }\n            context.ctx.auditReport.prototypeAccess[prot.constructor.name].add(b);\n          }\n        } while(prot = Object.getPrototypeOf(prot))\n      }\n    }\n\n    if (prototypeAccess) {\n      if (isFunction) {\n        if (!['name', 'length', 'constructor'].includes(b) && a.hasOwnProperty(b)) {\n          const whitelist = context.ctx.prototypeWhitelist.get(a.prototype);\n          const replace = context.ctx.options.prototypeReplacements.get(a);\n          if (replace) {\n            done(undefined, new Prop(replace(a, true), b));\n            return;\n          }\n          if (whitelist && (!whitelist.size || whitelist.has(b))) {\n          } else {\n            throw new SandboxError(`Static method or property access not permitted: ${a.name}.${b}`);\n          }\n        }\n      } else if (b !== 'constructor') {\n        let prot = a;\n        while(prot = Object.getPrototypeOf(prot)) {\n          if (prot.hasOwnProperty(b)) {\n            const whitelist = context.ctx.prototypeWhitelist.get(prot);\n            const replace = context.ctx.options.prototypeReplacements.get(prot.constuctor);\n            if (replace) {\n              done(undefined, new Prop(replace(a, false), b));\n              return;\n            }\n            if (whitelist && (!whitelist.size || whitelist.has(b))) {\n              break;\n            }\n            throw new SandboxError(`Method or property access not permitted: ${prot.constructor.name}.${b}`);\n          }\n        };\n      }\n    }\n\n    if (context.evals.has(a[b])) {\n      done(undefined, context.evals.get(a[b]));\n      return;\n    }\n    if (a[b] === globalThis) {\n      done(undefined, context.ctx.globalScope.get('this'));\n      return;\n    }\n\n    let g = obj.isGlobal || (isFunction && !sandboxedFunctions.has(a)) || context.ctx.globalsWhitelist.has(a);\n\n    done(undefined, new Prop(a, b, false, g));\n  });\n\naddOps(LispType.Call, (exec, done, ticks, a, b: Lisp[], obj, context, scope) => {\n  if (context.ctx.options.forbidFunctionCalls) throw new SandboxError(\"Function invocations are not allowed\");\n  if (typeof a !== 'function') {\n    throw new TypeError(`${typeof obj.prop === 'symbol' ? 'Symbol' : obj.prop} is not a function`);\n  }\n  const vals = b.map((item) => {\n    if (item instanceof SpreadArray) {\n      return [...item.item];\n    } else {\n      return [item];\n    }\n  }).flat().map((item) => valueOrProp(item, context));\n\n  if (typeof obj === 'function') {\n    done(undefined, obj(...vals));\n    return;\n  }\n  if (obj.context[obj.prop] === JSON.stringify && context.getSubscriptions.size) {\n    const cache = new Set<any>();\n    const recurse = (x: unknown) => {\n      if (!x || !(typeof x === 'object') || cache.has(x)) return;\n      cache.add(x);\n      for (let y in x) {\n        context.getSubscriptions.forEach((cb) => cb(x, y));\n        recurse(x[y]);\n      }\n    };\n    recurse(vals[0]);\n  }\n\n  if (obj.context instanceof Array && arrayChange.has(obj.context[obj.prop]) && (context.changeSubscriptions.get(obj.context) || context.changeSubscriptionsGlobal.get(obj.context))) {\n    let change: Change;\n    let changed = false;\n    if (obj.prop === \"push\") {\n      change = {\n        type: \"push\",\n        added: vals\n      }\n      changed = !!vals.length;\n    } else if (obj.prop === \"pop\") {\n      change = {\n        type: \"pop\",\n        removed: obj.context.slice(-1)\n      }\n      changed = !!change.removed.length;\n    }  else if (obj.prop === \"shift\") {\n      change = {\n        type: \"shift\",\n        removed: obj.context.slice(0, 1)\n      }\n      changed = !!change.removed.length;\n    } else if (obj.prop === \"unshift\") {\n      change = {\n        type: \"unshift\",\n        added: vals\n      }\n      changed = !!vals.length;\n    } else if (obj.prop === \"splice\") {\n      change = {\n        type: \"splice\",\n        startIndex: vals[0],\n        deleteCount: vals[1] === undefined ? obj.context.length : vals[1],\n        added: vals.slice(2),\n        removed: obj.context.slice(vals[0], vals[1] === undefined ? undefined : vals[0] + vals[1])\n      }\n      changed = !!change.added.length || !!change.removed.length;\n    } else if (obj.prop === \"reverse\" || obj.prop === \"sort\") {\n      change = {type: obj.prop}\n      changed = !!obj.context.length;\n    } else if (obj.prop === \"copyWithin\") {\n      let len = vals[2] === undefined ? obj.context.length - vals[1] : Math.min(obj.context.length, vals[2] - vals[1]);\n      change = {\n        type: \"copyWithin\",\n        startIndex: vals[0],\n        endIndex: vals[0] + len,\n        added: obj.context.slice(vals[1], vals[1] + len),\n        removed: obj.context.slice(vals[0], vals[0] + len)\n      }\n      changed = !!change.added.length || !!change.removed.length;\n    }\n    if (changed) {\n      context.changeSubscriptions.get(obj.context)?.forEach((cb) => cb(change));\n      context.changeSubscriptionsGlobal.get(obj.context)?.forEach((cb) => cb(change));\n    }\n  }\n  obj.get(context);\n  done(undefined, obj.context[obj.prop](...vals));\n});\n\naddOps(LispType.CreateObject, (exec, done, ticks, a, b: KeyVal[], obj, context, scope) => {\n  let res = {} as any;\n  for (let item of b) {\n    if (item.key instanceof SpreadObject) {\n      res = {...res, ...item.key.item};\n    } else {\n      res[item.key] = item.val;\n    }\n  }\n  done(undefined, res);\n});\n\naddOps(LispType.KeyVal, (exec, done, ticks, a: string, b: LispItem) => done(undefined, new KeyVal(a, b)));\n\naddOps(LispType.CreateArray, (exec, done, ticks, a, b: Lisp[], obj, context, scope) => {\n  const items = b.map((item) => {\n    if (item instanceof SpreadArray) {\n      return [...item.item];\n    } else {\n      return [item];\n    }\n  }).flat().map((item) => valueOrProp(item, context))\n  done(undefined, items)\n});\n\naddOps(LispType.Group, (exec, done, ticks, a, b) => done(undefined, b));\n\naddOps(LispType.GlobalSymbol, (exec, done, ticks, a, b: string) => {\n  switch (b) {\n    case 'true': return done(undefined, true);\n    case 'false': return done(undefined, false);\n    case 'null': return done(undefined, null);\n    case 'undefined': return done(undefined, undefined);\n    case 'NaN': return done(undefined, NaN);\n    case 'Infinity': return done(undefined, Infinity);\n  }\n  done(new Error('Unknown symbol: ' + b))\n})\n\naddOps(LispType.Number, (exec, done, ticks, a, b) => done(undefined, Number(b)));\naddOps(LispType.BigInt, (exec, done, ticks, a, b) => done(undefined, BigInt(b)));\naddOps(LispType.StringIndex, (exec, done, ticks, a, b: string, obj, context) => done(undefined, context.constants.strings[parseInt(b)]));\n\naddOps(LispType.RegexIndex, (exec, done, ticks, a, b: string, obj, context) => {\n  const reg: IRegEx = context.constants.regexes[parseInt(b)];\n  if (!context.ctx.globalsWhitelist.has(RegExp)) {\n    throw new SandboxError(\"Regex not permitted\");\n  } else {\n    done(undefined, new RegExp(reg.regex, reg.flags));\n  }\n});\n\naddOps(LispType.LiteralIndex, (exec, done, ticks, a, b: string, obj, context, scope) => {\n  let item = context.constants.literals[parseInt(b)];\n  const [,name,js] = item;\n  let found: Lisp[] = [];\n  let f: RegExpExecArray;\n  let resnums: string[] = [];\n  while(f = literalRegex.exec(name)) {\n    if (!f[2]) {\n      found.push(js[parseInt(f[3], 10)]);\n      resnums.push(f[3]);\n    }\n  }\n\n  exec(ticks, found, scope, context, (err, processed) => {\n    const reses = {};\n    if(err) {\n      done(err);\n      return;\n    }\n    for (let i in resnums) {\n      const num = resnums[i];\n      reses[num] = processed[i];\n    }\n    done(undefined, name.replace(/(\\\\\\\\)*(\\\\)?\\${(\\d+)}/g, (match, $$, $, num) => {\n      if ($) return match;\n      let res = reses[num];\n      return ($$ ? $$ : '') + `${valueOrProp(res, context)}`;\n    }));\n  })\n});\n\naddOps(LispType.SpreadArray, (exec, done, ticks, a, b, obj, context, scope) => {\n  done(undefined, new SpreadArray(b));\n});\n\naddOps(LispType.SpreadObject, (exec, done, ticks, a, b, obj, context, scope) => {\n  done(undefined, new SpreadObject(b));\n});\n\naddOps(LispType.Not, (exec, done, ticks, a, b) => done(undefined, !b));\naddOps(LispType.Inverse, (exec, done, ticks, a, b) => done(undefined, ~b));\n\naddOps(LispType.IncrementBefore, (exec, done, ticks, a, b, obj, context) => {\n  assignCheck(obj, context);\n  done(undefined, ++obj.context[obj.prop]);\n});\n\naddOps(LispType.IncrementAfter, (exec, done, ticks, a, b, obj, context) => {\n  assignCheck(obj, context);\n  done(undefined, obj.context[obj.prop]++);\n});\n\naddOps(LispType.DecrementBefore, (exec, done, ticks, a, b, obj, context) => {\n  assignCheck(obj, context);\n  done(undefined, --obj.context[obj.prop]);\n});\n\naddOps(LispType.DecrementAfter, (exec, done, ticks, a, b, obj, context) => {\n  assignCheck(obj, context);\n  done(undefined, obj.context[obj.prop]--);\n});\n\naddOps(LispType.Assign, (exec, done, ticks, a, b, obj, context) => {\n  assignCheck(obj, context);\n  done(undefined, obj.context[obj.prop] = b);\n});\n\naddOps(LispType.AddEquals, (exec, done, ticks, a, b, obj, context) => {\n  assignCheck(obj, context);\n  done(undefined, obj.context[obj.prop] += b);\n});\n\naddOps(LispType.SubractEquals, (exec, done, ticks, a, b: number, obj, context) => {\n  assignCheck(obj, context);\n  done(undefined, obj.context[obj.prop] -= b);\n});\n\naddOps(LispType.DivideEquals, (exec, done, ticks, a, b: number, obj, context) => {\n  assignCheck(obj, context);\n  done(undefined, obj.context[obj.prop] /= b);\n});\n\naddOps(LispType.MultiplyEquals, (exec, done, ticks, a, b: number, obj, context) => {\n  assignCheck(obj, context);\n  done(undefined, obj.context[obj.prop] *= b);\n});\n\naddOps(LispType.PowerEquals, (exec, done, ticks, a, b: number, obj, context) => {\n  assignCheck(obj, context);\n  done(undefined, obj.context[obj.prop] **= b);\n});\n\naddOps(LispType.ModulusEquals, (exec, done, ticks, a, b: number, obj, context) => {\n  assignCheck(obj, context);\n  done(undefined, obj.context[obj.prop] %= b);\n});\n\naddOps(LispType.BitNegateEquals, (exec, done, ticks, a, b: number, obj, context) => {\n  assignCheck(obj, context);\n  done(undefined, obj.context[obj.prop] ^= b);\n});\n\naddOps(LispType.BitAndEquals, (exec, done, ticks, a, b: number, obj, context) => {\n  assignCheck(obj, context);\n  done(undefined, obj.context[obj.prop] &= b);\n});\n\naddOps(LispType.BitOrEquals, (exec, done, ticks, a, b: number, obj, context) => {\n  assignCheck(obj, context);\n  done(undefined, obj.context[obj.prop] |= b);\n});\n\naddOps(LispType.ShiftLeftEquals, (exec, done, ticks, a, b: number, obj, context) => {\n  assignCheck(obj, context);\n  done(undefined, obj.context[obj.prop] <<= b);\n});\n\naddOps(LispType.ShiftRightEquals, (exec, done, ticks, a, b: number, obj, context) => {\n  assignCheck(obj, context);\n  done(undefined, obj.context[obj.prop] >>= b);\n});\n\naddOps(LispType.UnsignedShiftRightEquals, (exec, done, ticks, a, b: number, obj, context) => {\n  assignCheck(obj, context);\n  done(undefined, obj.context[obj.prop] >>= b);\n});\n\naddOps(LispType.LargerThan, (exec, done, ticks, a, b) => done(undefined, a > b));\naddOps(LispType.SmallerThan, (exec, done, ticks, a, b) => done(undefined, a < b));\naddOps(LispType.LargerEqualThan, (exec, done, ticks, a, b) => done(undefined, a >= b));\naddOps(LispType.SmallerEqualThan, (exec, done, ticks, a, b) => done(undefined, a <= b));\naddOps(LispType.Equal, (exec, done, ticks, a, b) => done(undefined, a == b));\naddOps(LispType.StrictEqual, (exec, done, ticks, a, b) => done(undefined, a === b));\naddOps(LispType.NotEqual, (exec, done, ticks, a, b) => done(undefined, a != b));\naddOps(LispType.StrictNotEqual, (exec, done, ticks, a, b) => done(undefined, a !== b));\naddOps(LispType.And, (exec, done, ticks, a, b) => done(undefined, a && b));\naddOps(LispType.Or, (exec, done, ticks, a, b) => done(undefined, a || b));\naddOps(LispType.BitAnd, (exec, done, ticks, a: number, b: number) => done(undefined, a & b));\naddOps(LispType.BitOr, (exec, done, ticks, a: number, b: number) => done(undefined, a | b));\naddOps(LispType.Plus, (exec, done, ticks, a: number, b: number) => done(undefined, a + b));\naddOps(LispType.Minus, (exec, done, ticks, a: number, b: number) => done(undefined, a - b));\naddOps(LispType.Positive, (exec, done, ticks, a, b) => done(undefined, +b));\naddOps(LispType.Negative, (exec, done, ticks, a, b) => done(undefined, -b));\naddOps(LispType.Divide, (exec, done, ticks, a: number, b: number) => done(undefined, a / b));\naddOps(LispType.BitNegate, (exec, done, ticks, a: number, b: number) => done(undefined, a ^ b));\naddOps(LispType.Multiply, (exec, done, ticks, a: number, b: number) => done(undefined, a * b));\naddOps(LispType.Modulus, (exec, done, ticks, a: number, b: number) => done(undefined, a % b));\naddOps(LispType.BitShiftLeft, (exec, done, ticks, a: number, b: number) => done(undefined, a << b));\naddOps(LispType.BitShiftRight, (exec, done, ticks, a: number, b: number) => done(undefined, a >> b));\naddOps(LispType.BitUnsignedShiftRight, (exec, done, ticks, a: number, b: number) => done(undefined, a >>> b));\naddOps(LispType.Typeof, (exec, done, ticks, a, b: LispItem, obj, context, scope) => {\n    exec(ticks, b, scope, context, (e, prop) => {\n      done(undefined, typeof valueOrProp(prop, context));\n    });\n  });\n\naddOps(LispType.Instanceof, (exec, done, ticks, a, b:  { new(): unknown }) => done(undefined, a instanceof b));\naddOps(LispType.In, (exec, done, ticks, a: string, b) => done(undefined, a in b));\n\naddOps(LispType.Delete, (exec, done, ticks, a, b, obj, context, scope, bobj: Prop) => {\n  if (bobj.context === undefined) {\n    done(undefined, true);\n    return;\n  }\n  assignCheck(bobj, context, 'delete');\n  if (bobj.isVariable) {\n    done(undefined, false);\n    return;\n  }\n  done(undefined, delete bobj.context[bobj.prop]);\n});\n\naddOps(LispType.Return, (exec, done, ticks, a, b, obj, context) => done(undefined, b));\n\naddOps(LispType.Var, (exec, done, ticks, a: string, b: LispItem, obj, context, scope, bobj) => {\n  done(undefined, scope.declare(a, VarType.var, b));\n});\n\naddOps(LispType.Let, (exec, done, ticks, a: string, b: LispItem, obj, context, scope, bobj) => {\n  done(undefined, scope.declare(a, VarType.let, b, bobj && bobj.isGlobal));\n});\n\naddOps(LispType.Const, (exec, done, ticks, a: string, b: LispItem, obj, context, scope, bobj) => {\n  done(undefined, scope.declare(a, VarType.const, b));\n});\n\naddOps(LispType.ArrowFunction, (exec, done, ticks, a: string[], b: Lisp[], obj: Lisp, context, scope) => {\n  a = [...a];\n    if (typeof obj[2] === \"string\" || obj[2] instanceof CodeString) {\n      obj[2] = b = lispifyFunction(new CodeString(obj[2]), context.constants);\n    }\n    if (a.shift()) {\n      done(undefined, createFunctionAsync(a, b, ticks, context, scope));\n    } else {\n      done(undefined, createFunction(a, b, ticks, context, scope));\n    }\n});\n\naddOps(LispType.Function, (exec, done, ticks, a: (string|LispType)[], b: Lisp[], obj: Lisp, context, scope) => {   \n  if (typeof obj[2] === \"string\" || obj[2] instanceof CodeString) {\n    obj[2] = b = lispifyFunction(new CodeString(obj[2]), context.constants);\n  }\n  let isAsync = a.shift();\n  let name = a.shift() as string;\n  let func;\n  if (isAsync === LispType.True) {\n    func = createFunctionAsync(a as string[], b, ticks, context, scope, name);\n  } else {\n    func = createFunction(a as string[], b, ticks, context, scope, name);\n  }\n  if (name) {\n    scope.declare(name, VarType.var, func);\n  }\n  done(undefined, func);\n});\n\naddOps(LispType.InlineFunction, (exec, done, ticks, a: (string|LispType)[], b: Lisp[], obj: Lisp, context, scope) => {\n  if (typeof obj[2] === \"string\" || obj[2] instanceof CodeString) {\n    obj[2] = b = lispifyFunction(new CodeString(obj[2]), context.constants);\n  }\n  let isAsync = a.shift();\n  let name = a.shift() as string;\n  if (name) {\n    scope = new Scope(scope, {})\n  }\n  let func;\n  if (isAsync === LispType.True) {\n    func = createFunctionAsync(a as string[], b, ticks, context, scope, name);\n  } else {\n    func = createFunction(a as string[], b, ticks, context, scope, name);\n  }\n  if (name) {\n    scope.declare(name, VarType.let, func);\n  }\n  done(undefined, func);\n});\n\naddOps(LispType.Loop, (exec, done, ticks, a: Lisp[], b: Lisp[], obj, context, scope) => {\n  const [checkFirst, startInternal, getIterator, startStep, step, condition, beforeStep] = a;\n  let loop = true;\n  const loopScope = new Scope(scope, {});\n  let internalVars = {\n    '$$obj': undefined\n  };\n  const interalScope = new Scope(loopScope, internalVars);\n  if (exec === execAsync) {\n    (async() => {\n      let ad: AsyncDoneRet;\n      ad = asyncDone((d) => exec(ticks, startStep, loopScope, context, d));\n      internalVars['$$obj'] = (ad = asyncDone((d) => exec(ticks, getIterator, loopScope, context, d))).isInstant === true ? ad.instant : (await ad.p).result;\n      ad = asyncDone((d) => exec(ticks, startInternal, interalScope, context, d));\n      if (checkFirst) loop = (ad = asyncDone((d) => exec(ticks, condition, interalScope, context, d))).isInstant === true ? ad.instant : (await ad.p).result;\n      while (loop) {\n        let innerLoopVars = {};\n        ad = asyncDone((d) => exec(ticks, beforeStep, new Scope(interalScope, innerLoopVars), context, d));\n        ad.isInstant === true ? ad.instant : (await ad.p).result;\n        let res = await executeTreeAsync(ticks, context, b, [new Scope(loopScope, innerLoopVars)], \"loop\");\n        if (res instanceof ExecReturn && res.returned) {\n          done(undefined, res);\n          return;\n        }\n        if (res instanceof ExecReturn && res.breakLoop) {\n          break;\n        }\n        ad = asyncDone((d) => exec(ticks, step, interalScope, context, d));\n        loop = (ad = asyncDone((d) => exec(ticks, condition, interalScope, context, d))).isInstant === true ? ad.instant : (await ad.p).result;\n      }\n      done();\n    })().catch(done);\n  } else {\n    syncDone((d) => exec(ticks, startStep, loopScope, context, d));\n    internalVars['$$obj'] = syncDone((d) => exec(ticks, getIterator, loopScope, context, d)).result;\n    syncDone((d) => exec(ticks, startInternal, interalScope, context, d));\n    if (checkFirst) loop = (syncDone((d) => exec(ticks, condition, interalScope, context, d))).result;\n    while (loop) {\n      let innerLoopVars = {};\n      syncDone((d) => exec(ticks, beforeStep, new Scope(interalScope, innerLoopVars), context, d));\n      let res = executeTree(ticks, context, b, [new Scope(loopScope, innerLoopVars)], \"loop\");\n      if (res instanceof ExecReturn && res.returned) {\n        done(undefined, res);\n        return;\n      }\n      if (res instanceof ExecReturn && res.breakLoop) {\n        break;\n      }\n      syncDone((d) => exec(ticks, step, interalScope, context, d));\n      loop = (syncDone((d) => exec(ticks, condition, interalScope, context, d))).result;\n    }\n    done();\n  }\n});\n\naddOps(LispType.LoopAction, (exec, done, ticks, a: LispItem, b: LispItem, obj, context, scope, bobj, inLoopOrSwitch) => {\n  if ((inLoopOrSwitch === \"switch\" && a === \"continue\") || !inLoopOrSwitch) {\n    throw new SandboxError(\"Illegal \" + a + \" statement\");\n  }\n  done(undefined, new ExecReturn(context.ctx.auditReport, undefined, false, a === \"break\", a === \"continue\"));\n});\n\naddOps(LispType.If, (exec, done, ticks, a: LispItem, b:If, obj, context, scope, bobj, inLoopOrSwitch) => {\n  exec(ticks, valueOrProp(a, context) ? b.t : b.f, scope, context, done);\n});\n\naddOps(LispType.InlineIf, (exec, done, ticks, a: LispItem, b: If, obj, context, scope) => {\n  exec(ticks, valueOrProp(a, context) ? b.t : b.f, scope, context, done);\n});\naddOps(LispType.InlineIfCase, (exec, done, ticks, a, b) => done(undefined, new If(a, b)));\naddOps(LispType.IfCase, (exec, done, ticks, a, b) => done(undefined, new If(a, b)));\n\naddOps(LispType.Switch, (exec, done, ticks, a: LispItem, b: SwitchCase[], obj, context, scope) => {\n  exec(ticks, a, scope, context, (err, toTest) => {\n    if (err) {\n      done(err);\n      return;\n    }\n    toTest = valueOrProp(toTest, context);\n    if (exec === execSync) {\n      let res: ExecReturn<unknown>;\n      let isTrue = false;\n      for (let caseItem of b) {\n        if (isTrue || (isTrue = !caseItem[1] || toTest === valueOrProp((syncDone((d) => exec(ticks, caseItem[1], scope, context, d))).result, context))) {\n          if (!caseItem[2]) continue;\n          res = executeTree(ticks, context, caseItem[2], [scope], \"switch\");\n          if (res.breakLoop) break;\n          if (res.returned) {\n            done(undefined, res);\n            return;\n          }\n          if (!caseItem[1]) { // default case\n            break;\n          }\n        }\n      }\n      done();\n    } else {\n      (async () => {\n        let res: ExecReturn<unknown>;\n        let isTrue = false;\n        for (let caseItem of b) {\n          let ad: AsyncDoneRet;\n          if (isTrue || (isTrue = !caseItem[1] || toTest === valueOrProp((ad = asyncDone((d) => exec(ticks, caseItem[1], scope, context, d))).isInstant === true ? ad.instant : (await ad.p).result, context))) {\n            if (!caseItem[2]) continue;\n            res = await executeTreeAsync(ticks, context, caseItem[2], [scope], \"switch\");\n            if (res.breakLoop) break;\n            if (res.returned) {\n              done(undefined, res);\n              return;\n            }\n            if (!caseItem[1]) { // default case\n              break;\n            }\n          }\n        }\n        done();\n      })().catch(done)\n    }\n  });\n});\n\naddOps(LispType.Try, (exec, done, ticks, a: Lisp[], b: [string, Lisp[], Lisp[]], obj, context, scope, bobj, inLoopOrSwitch) => {\n  const [exception, catchBody, finallyBody] = b;\n  executeTreeWithDone(exec, (err, res) => {\n    executeTreeWithDone(exec, (e) => {\n      if (e) done(e);\n      else  if (err) {\n        let sc = {};\n        if (exception) sc[exception] = err;\n        executeTreeWithDone(exec, done, ticks, context, catchBody, [new Scope(scope)], inLoopOrSwitch);\n      } else {\n        done(undefined, res);\n      }\n    }, ticks, context, finallyBody, [new Scope(scope, {})]);\n  }, ticks, context, a, [new Scope(scope)], inLoopOrSwitch);\n});\n\naddOps(LispType.Void, (exec, done, ticks, a) => {done()});\naddOps(LispType.New, (exec, done, ticks, a: new (...args: unknown[]) => unknown, b: unknown[], obj, context) => {\n  if (!context.ctx.globalsWhitelist.has(a) && !sandboxedFunctions.has(a)) {\n    throw new SandboxError(`Object construction not allowed: ${a.constructor.name}`)\n  }\n  done(undefined, new a(...b))\n});\n\naddOps(LispType.Throw, (exec, done, ticks, a, b) => { done(b) });\naddOps(LispType.Expression, (exec, done, ticks, a: unknown[]) => done(undefined, a.pop()));\naddOps(LispType.None, (exec, done, ticks, a: unknown[]) => done());\n\nfunction valueOrProp(a: unknown, context: IExecContext): any {\n  if (a instanceof Prop) return a.get(context);\n  if (a === optional) return undefined;\n  return a;\n}\n\nexport function execMany(ticks: Ticks, exec: Execution, tree: Lisp[], done: Done, scope: Scope, context: IExecContext, inLoopOrSwitch?: string) {\n  if (exec === execSync) {\n    _execManySync(ticks, tree, done, scope, context, inLoopOrSwitch);\n  } else {\n    _execManyAsync(ticks, tree, done, scope, context, inLoopOrSwitch).catch(done);\n  }\n}\n\nfunction _execManySync(ticks: Ticks, tree: Lisp[], done: Done, scope: Scope, context: IExecContext, inLoopOrSwitch?: string) {\n  let ret = [];\n  for (let i = 0; i < tree.length; i++) {\n    let res;\n    try {\n      res = syncDone((d) => execSync(ticks, tree[i], scope, context, d, inLoopOrSwitch)).result;\n    } catch(e) {\n      done(e);\n      return;\n    }\n    if (res instanceof ExecReturn && (res.returned || res.breakLoop || res.continueLoop)) {\n      done(undefined, res);\n      return;\n    }\n    if (isLisp(tree[i]) && tree[i][0] === LispType.Return) {\n      done(undefined, new ExecReturn(context.ctx.auditReport, res, true))\n      return;\n    }\n    ret.push(res);\n  }\n  done(undefined, ret);\n}\n\nasync function _execManyAsync(ticks: Ticks, tree: Lisp[], done: Done, scope: Scope, context: IExecContext, inLoopOrSwitch?: string) {\n  let ret = [];\n  for (let i = 0; i < tree.length; i++) {\n    let res;\n    try {\n      let ad: AsyncDoneRet;\n      res = (ad = asyncDone((d) => execAsync(ticks, tree[i], scope, context, d, inLoopOrSwitch))).isInstant === true ? ad.instant : (await ad.p).result;\n    } catch(e) {\n      done(e);\n      return;\n    }\n    if (res instanceof ExecReturn && (res.returned || res.breakLoop || res.continueLoop)) {\n      done(undefined, res);\n      return;\n    }\n    if (isLisp(tree[i]) && tree[i][0] === LispType.Return) {\n      done(undefined, new ExecReturn(context.ctx.auditReport, res, true))\n      return;\n    }\n    ret.push(res);\n  }\n  done(undefined, ret);\n}\n\ntype Execution = (ticks: Ticks, tree: LispItem, scope: Scope, context: IExecContext, done: Done, inLoopOrSwitch?: string) => void\n\nexport interface AsyncDoneRet {\n  isInstant: boolean,\n  instant: any,\n  p: Promise<{result: any}>\n}\n\nexport function asyncDone(callback: (done: Done) => void): AsyncDoneRet {\n  let isInstant = false;\n  let instant: unknown;\n  const p = new Promise<any>((resolve, reject) => {\n    callback((err, result) => {\n      if (err) reject(err);\n      else {\n        isInstant = true;\n        instant = result;\n        resolve({result})\n      };\n    });\n  });\n  return {\n    isInstant,\n    instant,\n    p\n  }\n}\n\nexport function syncDone(callback: (done: Done) => void): {result: any} {\n  let result;\n  let err;\n  callback((e, r) => {\n    err = e;\n    result = r;\n  });\n  if (err) throw err;\n  return {result};\n}\n\nexport async function execAsync(ticks: Ticks, tree: LispItem, scope: Scope, context: IExecContext, doneOriginal: Done, inLoopOrSwitch?: string): Promise<void> {\n  let done: Done = doneOriginal;\n  const p = new Promise<void>((resolve) => {\n    done = (e, r?) => {\n      doneOriginal(e, r);\n      resolve();\n    }\n  });\n  if(_execNoneRecurse(ticks, tree, scope, context, done, true, inLoopOrSwitch)) {\n  } else if (isLisp(tree)) {\n    let op = tree[0];\n    let obj;\n    try {\n      let ad: AsyncDoneRet;\n      obj = (ad = asyncDone((d) => execAsync(ticks, tree[1], scope, context, d, inLoopOrSwitch))).isInstant === true ? ad.instant : (await ad.p).result;\n    } catch (e) {\n      done(e);\n      return;\n    }\n    let a = obj;\n    try {\n      a = obj instanceof Prop ? obj.get(context) : obj;\n    } catch (e) {\n      done(e);\n      return;\n    }\n    if (op === LispType.PropOptional || op === LispType.CallOptional) {\n      if (a === undefined || a === null) {\n        done(undefined, optional);\n        return;\n      }\n      op = op === LispType.PropOptional ? LispType.Prop : LispType.Call;\n    }\n    if (a === optional) {\n      if (op === LispType.Prop || op === LispType.Call) {\n        done(undefined, a);\n        return;\n      } else {\n        a = undefined;\n      }\n    }\n    let bobj;\n    try {\n      let ad: AsyncDoneRet;\n      bobj = (ad = asyncDone((d) => execAsync(ticks, tree[2], scope, context, d, inLoopOrSwitch))).isInstant === true ? ad.instant : (await ad.p).result;\n    } catch (e) {\n      done(e);\n      return;\n    }\n    let b = bobj;\n    try {\n      b = bobj instanceof Prop ? bobj.get(context) : bobj;\n    } catch (e) {\n      done(e);\n      return;\n    }\n    if (b === optional) {\n      b = undefined;\n    }\n    if (ops.has(op)) {\n      try {\n        ops.get(op)(execAsync, done, ticks, a, b, obj, context, scope, bobj, inLoopOrSwitch);\n      } catch (err) {\n        done(err);\n      }\n    } else {\n      done(new SyntaxError('Unknown operator: ' + op));\n    }\n  }\n  await p;\n}\n\n\nexport function execSync(ticks: Ticks, tree: LispItem, scope: Scope, context: IExecContext, done: Done, inLoopOrSwitch?: string) {\n  if(_execNoneRecurse(ticks, tree, scope, context, done, false, inLoopOrSwitch)) {\n  } else if (isLisp(tree)) {\n    let op = tree[0];\n    let obj;\n    try {\n      obj = syncDone((d) => execSync(ticks, tree[1], scope, context, d, inLoopOrSwitch)).result;\n    } catch (e) {\n      done(e);\n      return;\n    }\n    let a = obj;\n    try {\n      a = obj instanceof Prop ? obj.get(context) : obj;\n    } catch (e) {\n      done(e);\n      return;\n    }\n    if (op === LispType.PropOptional || op === LispType.CallOptional) {\n      if (a === undefined || a === null) {\n        done(undefined, optional);\n        return;\n      }\n      op = op === LispType.PropOptional ? LispType.Prop : LispType.Call;\n    }\n    if (a === optional) {\n      if (op === LispType.Prop || op === LispType.Call) {\n        done(undefined, a);\n        return;\n      } else {\n        a = undefined;\n      }\n    }\n    let bobj;\n    try {\n      bobj = syncDone((d) => execSync(ticks, tree[2], scope, context, d, inLoopOrSwitch)).result;\n    } catch (e) {\n      done(e);\n      return;\n    }\n    let b = bobj;\n    try {\n      b = bobj instanceof Prop ? bobj.get(context) : bobj;\n    } catch (e) {\n      done(e);\n      return;\n    }\n    if (b === optional) {\n      b = undefined;\n    }\n    if (ops.has(op)) {\n      try {\n        ops.get(op)(execSync, done, ticks, a, b, obj, context, scope, bobj, inLoopOrSwitch);\n      } catch (err) {\n        done(err);\n      }\n    } else {\n      done(new SyntaxError('Unknown operator: ' + op));\n    }\n  }\n}\n\nconst unexecTypes = new Set([\n  LispType.ArrowFunction,\n  LispType.Function,\n  LispType.InlineFunction,\n  LispType.Loop,\n  LispType.Try,\n  LispType.Switch,\n  LispType.IfCase,\n  LispType.InlineIfCase,\n  LispType.Typeof\n]);\n\nfunction _execNoneRecurse(ticks: Ticks, tree: LispItem, scope: Scope, context: IExecContext, done: Done, isAsync: boolean, inLoopOrSwitch?: string): boolean {\n  const exec = isAsync ? execAsync : execSync;\n  if (context.ctx.options.executionQuota <= ticks.ticks) {\n    if (typeof context.ctx.options.onExecutionQuotaReached === 'function' && context.ctx.options.onExecutionQuotaReached(ticks, scope, context, tree)) {\n    } else {\n      done(new SandboxError(\"Execution quota exceeded\"));\n      return;\n    }\n  }\n  ticks.ticks++;\n  currentTicks = ticks;\n  if (tree instanceof Prop) {\n    try {\n      done(undefined, tree.get(context));\n    } catch (err) {\n      done(err);\n    }\n  } else if (tree === optional) {\n    done();\n  } else if (Array.isArray(tree) && !isLisp(tree)) {\n    if (tree[0] === LispType.None) {\n      done();\n    } else {\n      execMany(ticks, exec, tree as Lisp[], done, scope, context, inLoopOrSwitch);\n    }\n  } else if (!isLisp(tree)) {\n    done(undefined, tree);\n  } else if (tree[0] === LispType.Block) {\n    execMany(ticks, exec, tree[1] as Lisp[], done, scope, context, inLoopOrSwitch);\n  } else if (tree[0] === LispType.Await) {\n    if (!isAsync) {\n      done(new SandboxError(\"Illegal use of 'await', must be inside async function\"));\n    } else if (context.ctx.prototypeWhitelist?.has(Promise.prototype)) {\n      execAsync(ticks, tree[1], scope, context, async (e, r) => {\n        if (e) done(e);\n        else try {\n          done(undefined, await valueOrProp(r, context));\n        } catch(err) {\n          done(err);\n        }\n      }, inLoopOrSwitch).catch(done);\n    } else {\n      done(new SandboxError('Async/await is not permitted'))\n    }\n  } else if (unexecTypes.has(tree[0])) {\n    try {\n      ops.get(tree[0])(exec, done, ticks, tree[1], tree[2], tree, context, scope, undefined, inLoopOrSwitch);\n    } catch (err) {\n      done(err);\n    }\n  } else {\n    return false;\n  }\n  return true;\n}\nexport function executeTree<T>(ticks: Ticks, context: IExecContext, executionTree: Lisp[], scopes: (IScope)[] = [], inLoopOrSwitch?: string): ExecReturn<T> {\n  return syncDone((done) => executeTreeWithDone(execSync, done, ticks, context, executionTree, scopes, inLoopOrSwitch)).result;\n}\n\nexport async function executeTreeAsync<T>(ticks: Ticks, context: IExecContext, executionTree: Lisp[], scopes: (IScope)[] = [], inLoopOrSwitch?: string): Promise<ExecReturn<T>> {\n  let ad: AsyncDoneRet;\n  return (ad = asyncDone((done) => executeTreeWithDone(execAsync, done, ticks, context, executionTree, scopes, inLoopOrSwitch))).isInstant === true ? ad.instant : (await ad.p).result;\n}\n\nfunction executeTreeWithDone(exec: Execution, done: Done, ticks: Ticks, context: IExecContext, executionTree: Lisp[], scopes: (IScope)[] = [], inLoopOrSwitch?: string) {\n  if (!executionTree)  {\n    done();\n    return;\n  }\n  if (!(executionTree instanceof Array)) {\n    throw new SyntaxError('Bad execution tree');\n  }\n  let scope = context.ctx.globalScope;\n  let s;\n  while (s = scopes.shift()) {\n    if (typeof s !== \"object\") continue;\n    if (s instanceof Scope) {\n      scope = s;\n    } else {\n      scope = new Scope(scope, s, s instanceof LocalScope ? undefined : null);\n    }\n  }\n  if (context.ctx.options.audit && !context.ctx.auditReport) {\n    context.ctx.auditReport = {\n      globalsAccess: new Set(),\n      prototypeAccess: {},\n    }\n  }\n  if (exec === execSync) {\n    _executeWithDoneSync(done, ticks, context, executionTree, scope, inLoopOrSwitch);\n  } else {\n    _executeWithDoneAsync(done, ticks, context, executionTree, scope, inLoopOrSwitch).catch(done);\n  }\n}\n\nfunction _executeWithDoneSync(done: Done, ticks: Ticks, context: IExecContext, executionTree: Lisp[], scope: Scope, inLoopOrSwitch?: string) {\n  if (!(executionTree instanceof Array)) throw new SyntaxError('Bad execution tree');\n  let i = 0;\n  for (i = 0; i < executionTree.length; i++) {\n    let res;\n    let err;\n    const current = executionTree[i];\n    try {\n      execSync(ticks, current, scope, context, (e, r) => {\n        err = e;\n        res = r;\n      }, inLoopOrSwitch);\n    } catch (e) {\n      err = e;\n    }\n    if (err) {\n      done(err);\n      return;\n    }\n    if (res instanceof ExecReturn) {\n      done(undefined, res);\n      return;\n    }\n    if (isLisp(current) && current[0] === LispType.Return) {\n      done(undefined, new ExecReturn(context.ctx.auditReport, res, true))\n      return;\n    }\n  }\n  done(undefined, new ExecReturn(context.ctx.auditReport, undefined, false));\n}\n\nasync function _executeWithDoneAsync(done: Done, ticks: Ticks, context: IExecContext, executionTree: Lisp[], scope: Scope, inLoopOrSwitch?: string) {\n  if (!(executionTree instanceof Array)) throw new SyntaxError('Bad execution tree');\n  let i = 0;\n  for (i = 0; i < executionTree.length; i++) {\n    let res;\n    let err;\n    const current = executionTree[i];\n    try {\n      await execAsync(ticks, current, scope, context, (e, r) => {\n        err = e;\n        res = r;\n      }, inLoopOrSwitch);\n    } catch (e) {\n      err = e;\n    }\n    if (err) {\n      done(err);\n      return;\n    }\n    if (res instanceof ExecReturn) {\n      done(undefined, res);\n      return;\n    }\n    if (isLisp(current) && current[0] === LispType.Return) {\n      done(undefined, new ExecReturn(context.ctx.auditReport, res, true))\n      return;\n    }\n  }\n  done(undefined, new ExecReturn(context.ctx.auditReport, undefined, false));\n}\n","import { \n  IGlobals, \n  IAuditReport,  \n  Change, \n  sandboxFunction,\n  sandboxedEval,\n  sandboxedSetTimeout,\n  sandboxedSetInterval,\n  ExecReturn,\n  executeTree,\n  executeTreeAsync,\n  ops,\n  assignCheck,\n  execMany,\n  execAsync,\n  execSync,\n  asyncDone,\n  Scope,\n  IScope,\n  FunctionScope,\n  LocalScope,\n  syncDone\n} from \"./executor.js\";\nimport { parse, IExecutionTree, expectTypes, setLispType, LispItem, IConstants, Lisp } from \"./parser.js\";\n\ntype replacementCallback = (obj: any, isStaticAccess: boolean) => any\n\nexport {\n  expectTypes,\n  setLispType,\n  ops as executionOps,\n  assignCheck,\n  execMany,\n  execAsync,\n  execSync,\n  asyncDone,\n  syncDone,\n  executeTree,\n  executeTreeAsync,\n  FunctionScope,\n  LocalScope,\n};\n\nexport interface IOptions {\n  audit?: boolean;\n  forbidFunctionCalls?: boolean;\n  forbidFunctionCreation?: boolean;\n  prototypeReplacements?: Map<new () => any, replacementCallback>;\n  prototypeWhitelist?: Map<any, Set<string>>;\n  globals: IGlobals;\n  executionQuota?: bigint;\n  onExecutionQuotaReached?: (ticks: Ticks, scope: Scope, context: IExecutionTree, tree: LispItem) => boolean|void;\n}\n\nexport interface IContext {\n  sandbox: Sandbox;\n  globalScope: Scope;\n  sandboxGlobal: SandboxGlobal;\n  globalsWhitelist?: Set<any>;\n  prototypeWhitelist?: Map<any, Set<string>>;\n  options: IOptions;\n  auditReport?: IAuditReport;\n}\n\nexport interface Ticks {\n  ticks: bigint;\n}\n\nexport interface IExecContext extends IExecutionTree {\n  ctx: IContext,\n  getSubscriptions: Set<(obj: object, name: string) => void>;\n  setSubscriptions: WeakMap<object, Map<string, Set<(modification: Change) => void>>>;\n  changeSubscriptions: WeakMap<object, Set<(modification: Change) => void>>;\n  setSubscriptionsGlobal: WeakMap<object, Map<string, Set<(modification: Change) => void>>>;\n  changeSubscriptionsGlobal: WeakMap<object, Set<(modification: Change) => void>>;\n  registerSandboxFunction: (fn: (...args: any[]) => any) => void;\n  evals: Map<any, any>;\n}\n\nexport class SandboxGlobal {\n  constructor(globals: IGlobals) {\n    if (globals === globalThis) return globalThis;\n    for (let i in globals) {\n      (this as any)[i] = globals[i];\n    }\n  }\n}\n\nexport class ExecContext implements IExecContext {\n  constructor(\n    public ctx: IContext,\n    public constants: IConstants,\n    public tree: Lisp[],\n    public getSubscriptions: Set<(obj: object, name: string) => void>,\n    public setSubscriptions: WeakMap<object, Map<string, Set<(modification: Change) => void>>>,\n    public changeSubscriptions: WeakMap<object, Set<(modification: Change) => void>>,\n    public setSubscriptionsGlobal: WeakMap<object, Map<string, Set<(modification: Change) => void>>>,\n    public changeSubscriptionsGlobal: WeakMap<object, Set<(modification: Change) => void>>,\n    public evals: Map<any, any>,\n    public registerSandboxFunction: (fn: (...args: any[]) => any) => void\n  ) {\n\n  }\n}\n\nfunction subscribeSet(obj: object, name: string, callback: (modification: Change) => void, context: {\n  setSubscriptions: WeakMap<object, Map<string, Set<(modification: Change) => void>>>, \n  changeSubscriptions: WeakMap<object, Set<(modification: Change) => void>>\n}): {unsubscribe: () => void} {\n  const names = context.setSubscriptions.get(obj) || new Map<string, Set<(modification: Change) => void>>();\n  context.setSubscriptions.set(obj, names);\n  const callbacks = names.get(name) || new Set();\n  names.set(name, callbacks);\n  callbacks.add(callback);\n  let changeCbs: Set<(modification: Change) => void>;\n  if (obj && obj[name] && typeof obj[name] === \"object\") {\n    changeCbs = context.changeSubscriptions.get(obj[name]) || new Set();\n    changeCbs.add(callback);\n    context.changeSubscriptions.set(obj[name], changeCbs);\n  }\n  return {\n    unsubscribe: () => {\n      callbacks.delete(callback);\n      changeCbs?.delete(callback);\n    }\n  }\n}\n\n\nexport default class Sandbox {\n  context: IContext;\n  setSubscriptions: WeakMap<object, Map<string, Set<(modification: Change) => void>>> = new WeakMap();\n  changeSubscriptions: WeakMap<object, Set<(modification: Change) => void>> = new WeakMap();\n  sandboxFunctions: WeakMap<(...args: any[]) => any, IExecContext> = new WeakMap();\n  constructor(options?: IOptions) {\n    options = Object.assign({\n      audit: false,\n      forbidFunctionCalls: false,\n      forbidFunctionCreation: false,\n      globals: Sandbox.SAFE_GLOBALS,\n      prototypeWhitelist: Sandbox.SAFE_PROTOTYPES, \n      prototypeReplacements: new Map<new() => any, replacementCallback>(),\n    }, options || {});\n    const sandboxGlobal = new SandboxGlobal(options.globals);\n    this.context = {\n      sandbox: this,\n      globalsWhitelist: new Set(Object.values(options.globals)),\n      prototypeWhitelist: new Map([...options.prototypeWhitelist].map((a) => [a[0].prototype, a[1]])),\n      options,\n      globalScope: new Scope(null, options.globals, sandboxGlobal),\n      sandboxGlobal\n    };\n    this.context.prototypeWhitelist.set(Object.getPrototypeOf([][Symbol.iterator]()), new Set());\n  }\n\n  static get SAFE_GLOBALS(): IGlobals {\n    return {\n      Function,\n      console: {\n        debug: console.debug, \n        error: console.error, \n        info: console.info, \n        log: console.log, \n        table: console.table, \n        warn: console.warn\n      },\n      isFinite,\n      isNaN,\n      parseFloat,\n      parseInt,\n      decodeURI,\n      decodeURIComponent,\n      encodeURI,\n      encodeURIComponent,\n      escape,\n      unescape,\n      Boolean,\n      Number,\n      BigInt,\n      String,\n      Object,\n      Array,\n      Symbol,\n      Error,\n      EvalError,\n      RangeError,\n      ReferenceError,\n      SyntaxError,\n      TypeError,\n      URIError,\n      Int8Array,\n      Uint8Array,\n      Uint8ClampedArray,\n      Int16Array,\n      Uint16Array,\n      Int32Array,\n      Uint32Array,\n      Float32Array,\n      Float64Array,\n      Map,\n      Set,\n      WeakMap,\n      WeakSet,\n      Promise,\n      Intl,\n      JSON,\n      Math,\n      Date,\n      RegExp\n    }\n  }\n\n  \n  static get SAFE_PROTOTYPES(): Map<any, Set<string>> {\n    let protos = [\n      SandboxGlobal,\n      Function,\n      Boolean,\n      Number,\n      BigInt,\n      String,\n      Date,\n      Error,\n      Array,\n      Int8Array,\n      Uint8Array,\n      Uint8ClampedArray,\n      Int16Array,\n      Uint16Array,\n      Int32Array,\n      Uint32Array,\n      Float32Array,\n      Float64Array,\n      Map,\n      Set,\n      WeakMap,\n      WeakSet,\n      Promise,\n      Symbol,\n      Date,\n      RegExp\n    ]\n    let map = new Map<any, Set<string>>();\n    protos.forEach((proto) => {\n      map.set(proto, new Set());\n    });\n    map.set(Object, new Set([\n      'entries',\n      'fromEntries',\n      'getOwnPropertyNames',\n      'is',\n      'keys',\n      'hasOwnProperty',\n      'isPrototypeOf',\n      'propertyIsEnumerable',\n      'toLocaleString',\n      'toString',\n      'valueOf',\n      'values'\n    ]));\n    return map;\n  }\n\n  subscribeGet(callback: (obj: object, name: string) => void, context: IExecContext): {unsubscribe: () => void} {\n    context.getSubscriptions.add(callback);\n    return {unsubscribe: () => context.getSubscriptions.delete(callback)}\n  }\n\n  subscribeSet(obj: object, name: string, callback: (modification: Change) => void, context: Sandbox|IExecContext): {unsubscribe: () => void} {\n    return subscribeSet(obj, name, callback, context);\n  }\n\n  subscribeSetGlobal(obj: object, name: string, callback: (modification: Change) => void): {unsubscribe: () => void} {\n    return subscribeSet(obj, name, callback, this);\n  }\n\n  static audit<T>(code: string, scopes: (IScope)[] = []): ExecReturn<T> {\n    const globals = {};\n    for (let i of Object.getOwnPropertyNames(globalThis)) {\n      globals[i] = globalThis[i];\n    }\n    const sandbox = new Sandbox({\n      globals,\n      audit: true,\n    });\n    return sandbox.executeTree(sandbox.createContext(sandbox.context, parse(code)), scopes);\n  }\n\n  static parse(code: string) {\n    return parse(code);\n  }\n\n  createContext(context: IContext, executionTree: IExecutionTree) {\n    const evals = new Map();\n    const execContext = new ExecContext(\n      context,\n      executionTree.constants,\n      executionTree.tree,\n      new Set<(obj: object, name: string) => void>(),\n      new WeakMap<object, Map<string, Set<(modification: Change) => void>>>(),\n      new WeakMap<object, Set<(modification: Change) => void>>(),\n      this.setSubscriptions,\n      this.changeSubscriptions,\n      evals,\n      (fn) => this.sandboxFunctions.set(fn, execContext)\n    );\n    const func = sandboxFunction(execContext);\n    evals.set(Function, func);\n    evals.set(eval, sandboxedEval(func));\n    evals.set(setTimeout, sandboxedSetTimeout(func));\n    evals.set(setInterval, sandboxedSetInterval(func));\n    return execContext;\n  }\n\n  getContext(fn: (...args: any[]) => any) {\n    return this.sandboxFunctions.get(fn);\n  }\n\n  executeTree<T>(context: IExecContext, scopes: (IScope)[] = []): ExecReturn<T> {\n    return executeTree({\n      ticks: BigInt(0),\n    }, context, context.tree, scopes);\n  }\n\n  executeTreeAsync<T>(context: IExecContext, scopes: (IScope)[] = []): Promise<ExecReturn<T>> {\n    return executeTreeAsync({\n      ticks: BigInt(0),\n    }, context, context.tree, scopes);\n  }\n  \n  compile<T>(code: string, optimize = false): (...scopes: (IScope)[]) => {context: IExecContext, run: () => T} {\n    const parsed = parse(code, optimize);\n    const exec = (...scopes: (IScope)[]) => {\n      const context = this.createContext(this.context, parsed);\n      return {context , run: () => this.executeTree<T>(context, [...scopes]).result};\n    };\n    return exec;\n  };\n  \n  compileAsync<T>(code: string, optimize = false): (...scopes: (IScope)[]) => {context: IExecContext, run: () => Promise<T>} {\n    const parsed = parse(code, optimize);\n    const exec = (...scopes: (IScope)[]) => {\n      const context = this.createContext(this.context, parsed);\n      return {context , run: () => this.executeTreeAsync<T>(context, [...scopes]).then((ret) => ret.result)};\n    };\n    return exec;\n  };\n\n  compileExpression<T>(code: string, optimize = false): (...scopes: (IScope)[]) => {context: IExecContext, run: () => T} {\n    const parsed = parse(code, optimize, true);\n    const exec = (...scopes: (IScope)[]) => {\n      const context = this.createContext(this.context, parsed);\n      return {context , run: () => this.executeTree<T>(context, [...scopes]).result};\n    };\n    return exec\n  }\n\n  compileExpressionAsync<T>(code: string, optimize = false): (...scopes: (IScope)[]) => {context: IExecContext, run: () => Promise<T>} {\n    const parsed = parse(code, optimize, true);\n    const exec = (...scopes: (IScope)[]) => {\n      const context = this.createContext(this.context, parsed);\n      return {context , run: () => this.executeTreeAsync<T>(context, [...scopes]).then((ret) => ret.result)};\n    };\n    return exec;\n  }\n}\n"],"names":["parseHexToInt","hex","match","parseInt","NaN","validateAndParseHex","errorName","enforcedLength","parsedHex","Number","isNaN","undefined","length","SyntaxError","parseHexadecimalCode","code","parsedCode","String","fromCharCode","parseUnicodeCode","surrogateCode","parsedSurrogateCode","isCurlyBraced","text","charAt","parseUnicodeCodePointCode","codePoint","slice","fromCodePoint","err","RangeError","singleCharacterEscapes","Map","parseSingleCharacterCode","get","escapeMatch","unraw","raw","replace","_","backslash","unicodeWithSurrogate","surrogate","unicode","octal","singleCharacter","createLisp","obj","op","a","b","lispTypes","ParseError","Error","constructor","message","super","substring","this","inlineIfElse","elseIf","ifElse","space","expectTypes","splitter","types","opHigh","comparitor","boolOp","bitwise","next","inlineIf","assignment","assignModify","assign","incrementerBefore","expEdge","call","incrementerAfter","modifier","not","inverse","negative","positive","typeof","delete","dot","arrayProp","prop","value","createObject","createArray","number","string","literal","regex","boolean","null","und","arrowFunctionSingle","arrowFunction","inlineFunction","group","Infinity","void","await","new","initialize","return","throw","spreadObject","spreadArray","expEnd","expFunction","function","expSingle","for","do","while","loopAction","if","try","block","switch","closings","testMultiple","str","tests","found","i","exec","CodeString","ref","start","end","len","char","toString","trimStart","trim","valueOf","emptyString","okFirstChars","aNumber","wordReg","semiColon","insertedSemicolons","WeakMap","quoteCache","restOfExp","constants","part","quote","firstOpening","closingsTests","details","words","isStart","hasSemiTest","includes","filter","insertedSemis","cache","set","has","escape","done","lastChar","isOneLiner","lastInertedSemi","skip","regRes","foundWord","foundNumber","sub","push","lastAnyWord","lastWord","test","oneliner","startingExecpted","setLispType","fn","forEach","type","closingsCreate","typesCreate","res","expect","ctx","extract","arg","l","funcFound","lispifyExpr","map","e","lispify","key","lisptype","lispTree","modifierTypes","incrementTypes","adderTypes","instanceof","in","opTypes","extractIfElse","foundTrue","elseReg","count","foundElse","first","f","startsWith","_a","all","Math","max","true","false","quoteCount","condition","ie","startTrue","trueBlock","elseBlock","lispifyBlock","indexOf","caseFound","statement","insertSemicolons","caseTest","cases","defaultFound","cond","bracketFound","exprs","notEmpty","index","matches","lt","isArrow","isReturn","argPos","isAsync","args","split","unshift","ended","func","eager","lispifyFunction","iteratorRegex","getIterator","body","startStep","startInternal","beforeStep","checkFirst","step","lispifyReturnExpr","iterator","extract2","k","ofStart2","ofStart3","ofCondition","ofStep","inStart2","inStart3","inStep","inCondition","shift","isBlock","catchReg","finallyBody","catchBody","catchRes","exception","offset","argsString","j","lastType","expected","topLevel","startingExpectedWithoutSingle","r","subExpressions","pos","Object","values","defined","expression","parts","skipped","isInserted","tree","hoisted","hoist","concat","isLisp","item","Array","isArray","rep","it","closingsNoInsertion","colonsRegex","rest","inserted","valid","edge","checkRegex","cancel","after","flags","notDivide","possibleDivide","extractConstants","currentEnclosure","regexFound","comment","commentStart","currJs","strRes","enclosures","isPossibleDivide","li","join","tempJsStrings","literals","strings","pop","regexes","parse","js","ExecReturn","auditReport","result","returned","breakLoop","continueLoop","Prop","context","isConst","isGlobal","isVariable","ReferenceError","getSubscriptions","cb","optional","reservedWords","Set","VarType","keysOnly","ret","Scope","parent","vars","functionThis","const","let","var","isFuncScope","allVars","globals","functionScope","hasOwnProperty","val","TypeError","SandboxError","declare","FunctionScope","LocalScope","currentTicks","sandboxFunction","ticks","SandboxFunction","params","parsed","createFunction","generateArgs","argNames","sandboxedFunctions","WeakSet","scope","name","options","forbidFunctionCreation","executeTree","registerSandboxFunction","add","createFunctionAsync","prototypeWhitelist","Promise","prototype","async","executeTreeAsync","sandboxedEval","sandboxedSetTimeout","handler","setTimeout","sandboxedSetInterval","setInterval","assignCheck","changeSubscriptions","_b","changeSubscriptionsGlobal","_d","_c","setSubscriptions","_f","_e","setSubscriptionsGlobal","_g","_h","arrayChange","splice","reverse","sort","copyWithin","KeyVal","SpreadObject","SpreadArray","If","t","literalRegex","ops","addOps","valueOrProp","execMany","inLoopOrSwitch","execSync","_execManySync","_execManyAsync","catch","syncDone","d","ad","asyncDone","execAsync","isInstant","instant","p","callback","resolve","reject","doneOriginal","_execNoneRecurse","bobj","sandboxGlobal","audit","globalsAccess","globalsWhitelist","evals","globalThis","globalScope","Boolean","isFunction","prototypeAccess","prot","getPrototypeOf","whitelist","prototypeReplacements","size","constuctor","g","forbidFunctionCalls","vals","flat","JSON","stringify","recurse","x","y","change","changed","added","removed","startIndex","deleteCount","min","endIndex","BigInt","reg","RegExp","resnums","processed","reses","num","$$","$","loop","loopScope","internalVars","$$obj","interalScope","innerLoopVars","toTest","isTrue","caseItem","executeTreeWithDone","unexecTypes","executionQuota","onExecutionQuotaReached","executionTree","scopes","s","_executeWithDoneSync","_executeWithDoneAsync","current","SandboxGlobal","ExecContext","subscribeSet","names","callbacks","changeCbs","unsubscribe","Sandbox","sandboxFunctions","SAFE_GLOBALS","SAFE_PROTOTYPES","sandbox","Symbol","Function","console","debug","error","info","log","table","warn","isFinite","parseFloat","decodeURI","decodeURIComponent","encodeURI","encodeURIComponent","unescape","EvalError","URIError","Int8Array","Uint8Array","Uint8ClampedArray","Int16Array","Uint16Array","Int32Array","Uint32Array","Float32Array","Float64Array","Intl","Date","protos","proto","subscribeGet","subscribeSetGlobal","static","getOwnPropertyNames","createContext","execContext","eval","getContext","compile","optimize","run","compileAsync","then","compileExpression","compileExpressionAsync"],"mappings":"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"}