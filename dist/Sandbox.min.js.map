{"version":3,"file":"Sandbox.min.js","sources":["../src/unraw.ts","../src/parser.ts","../src/executor.ts","../src/Sandbox.ts"],"sourcesContent":["/**\n * Parse a string as a base-16 number. This is more strict than `parseInt` as it\n * will not allow any other characters, including (for example) \"+\", \"-\", and\n * \".\".\n * @param hex A string containing a hexadecimal number.\n * @returns The parsed integer, or `NaN` if the string is not a valid hex\n * number.\n */\nfunction parseHexToInt(hex: string): number {\n  const isOnlyHexChars = !hex.match(/[^a-f0-9]/i);\n  return isOnlyHexChars ? parseInt(hex, 16) : NaN;\n}\n\n/**\n * Check the validity and length of a hexadecimal code and optionally enforces\n * a specific number of hex digits.\n * @param hex The string to validate and parse.\n * @param errorName The name of the error message to throw a `SyntaxError` with\n * if `hex` is invalid. This is used to index `errorMessages`.\n * @param enforcedLength If provided, will throw an error if `hex` is not\n * exactly this many characters.\n * @returns The parsed hex number as a normal number.\n * @throws {SyntaxError} If the code is not valid.\n */\nfunction validateAndParseHex(\n  hex: string,\n  errorName: string,\n  enforcedLength?: number\n): number {\n  const parsedHex = parseHexToInt(hex);\n  if (\n    Number.isNaN(parsedHex) ||\n    (enforcedLength !== undefined && enforcedLength !== hex.length)\n  ) {\n    throw new SyntaxError(errorName + ': ' + hex);\n  }\n  return parsedHex;\n}\n\n/**\n * Parse a two-digit hexadecimal character escape code.\n * @param code The two-digit hexadecimal number that represents the character to\n * output.\n * @returns The single character represented by the code.\n * @throws {SyntaxError} If the code is not valid hex or is not the right\n * length.\n */\nfunction parseHexadecimalCode(code: string): string {\n  const parsedCode = validateAndParseHex(\n    code,\n    'Malformed Hexadecimal',\n    2\n  );\n  return String.fromCharCode(parsedCode);\n}\n\n/**\n * Parse a four-digit Unicode character escape code.\n * @param code The four-digit unicode number that represents the character to\n * output.\n * @param surrogateCode Optional four-digit unicode surrogate that represents\n * the other half of the character to output.\n * @returns The single character represented by the code.\n * @throws {SyntaxError} If the codes are not valid hex or are not the right\n * length.\n */\nfunction parseUnicodeCode(code: string, surrogateCode?: string): string {\n  const parsedCode = validateAndParseHex(code, 'Malformed Unicode', 4);\n\n  if (surrogateCode !== undefined) {\n    const parsedSurrogateCode = validateAndParseHex(\n      surrogateCode,\n      'Malformed Unicode',\n      4\n    );\n    return String.fromCharCode(parsedCode, parsedSurrogateCode);\n  }\n\n  return String.fromCharCode(parsedCode);\n}\n\n/**\n * Test if the text is surrounded by curly braces (`{}`).\n * @param text Text to check.\n * @returns `true` if the text is in the form `{*}`.\n */\nfunction isCurlyBraced(text: string): boolean {\n  return text.charAt(0) === \"{\" && text.charAt(text.length - 1) === \"}\";\n}\n\n/**\n * Parse a Unicode code point character escape code.\n * @param codePoint A unicode escape code point, including the surrounding curly\n * braces.\n * @returns The single character represented by the code.\n * @throws {SyntaxError} If the code is not valid hex or does not have the\n * surrounding curly braces.\n */\nfunction parseUnicodeCodePointCode(codePoint: string): string {\n  if (!isCurlyBraced(codePoint)) {\n    throw new SyntaxError('Malformed Unicode: +' + codePoint);\n  }\n  const withoutBraces = codePoint.slice(1, -1);\n  const parsedCode = validateAndParseHex(\n    withoutBraces,\n    'Malformed Unicode'\n  );\n\n  try {\n    return String.fromCodePoint(parsedCode);\n  } catch (err) {\n    throw err instanceof RangeError\n      ? new SyntaxError('Code Point Limit:' + parsedCode)\n      : err;\n  }\n}\n\n/**\n * Map of unescaped letters to their corresponding special JS escape characters.\n * Intentionally does not include characters that map to themselves like \"\\'\".\n */\nconst singleCharacterEscapes = new Map<string, string>([\n  [\"b\", \"\\b\"],\n  [\"f\", \"\\f\"],\n  [\"n\", \"\\n\"],\n  [\"r\", \"\\r\"],\n  [\"t\", \"\\t\"],\n  [\"v\", \"\\v\"],\n  [\"0\", \"\\0\"]\n]);\n\n/**\n * Parse a single character escape sequence and return the matching character.\n * If none is matched, defaults to `code`.\n * @param code A single character code.\n */\nfunction parseSingleCharacterCode(code: string): string {\n  return singleCharacterEscapes.get(code) || code;\n}\n\n/**\n * Matches every escape sequence possible, including invalid ones.\n *\n * All capture groups (described below) are unique (only one will match), except\n * for 4, which can only potentially match if 3 does.\n *\n * **Capture Groups:**\n * 0. A single backslash\n * 1. Hexadecimal code\n * 2. Unicode code point code with surrounding curly braces\n * 3. Unicode escape code with surrogate\n * 4. Surrogate code\n * 5. Unicode escape code without surrogate\n * 6. Octal code _NOTE: includes \"0\"._\n * 7. A single character (will never be \\, x, u, or 0-3)\n */\nconst escapeMatch = /\\\\(?:(\\\\)|x([\\s\\S]{0,2})|u(\\{[^}]*\\}?)|u([\\s\\S]{4})\\\\u([^{][\\s\\S]{0,3})|u([\\s\\S]{0,4})|([0-3]?[0-7]{1,2})|([\\s\\S])|$)/g;\n\n/**\n * Replace raw escape character strings with their escape characters.\n * @param raw A string where escape characters are represented as raw string\n * values like `\\'` rather than `'`.\n * @param allowOctals If `true`, will process the now-deprecated octal escape\n * sequences (ie, `\\111`).\n * @returns The processed string, with escape characters replaced by their\n * respective actual Unicode characters.\n */\nexport function unraw(raw: string): string {\n  return raw.replace(escapeMatch, function(\n    _,\n    backslash?: string,\n    hex?: string,\n    codePoint?: string,\n    unicodeWithSurrogate?: string,\n    surrogate?: string,\n    unicode?: string,\n    octal?: string,\n    singleCharacter?: string\n  ): string {\n    // Compare groups to undefined because empty strings mean different errors\n    // Otherwise, `\\u` would fail the same as `\\` which is wrong.\n    if (backslash !== undefined) {\n      return \"\\\\\";\n    }\n    if (hex !== undefined) {\n      return parseHexadecimalCode(hex);\n    }\n    if (codePoint !== undefined) {\n      return parseUnicodeCodePointCode(codePoint);\n    }\n    if (unicodeWithSurrogate !== undefined) {\n      return parseUnicodeCode(unicodeWithSurrogate, surrogate);\n    }\n    if (unicode !== undefined) {\n      return parseUnicodeCode(unicode);\n    }\n    if (octal === \"0\") {\n      return \"\\0\";\n    }\n    if (octal !== undefined) {\n      throw new SyntaxError('Octal Deprecation: ' + octal);\n    }\n    if (singleCharacter !== undefined) {\n      return parseSingleCharacterCode(singleCharacter);\n    }\n    throw new SyntaxError('End of string');\n  });\n}\nexport default unraw;","import unraw from \"./unraw.js\";\nexport type LispItem = Lisp|If|KeyVal|SpreadArray|SpreadObject|(LispItem[])|{new(): any }|String|Number|Boolean|null|undefined;\nexport interface ILiteral extends Lisp {\n  op: 'literal';\n  a: string;\n  b: LispItem[];\n}\n\nexport interface IRegEx {\n  regex: string,\n  flags: string,\n  length: number\n}\n\nexport interface IConstants {\n  strings: string[];\n  literals: ILiteral[];\n  regexes: IRegEx[];\n}\n\nexport interface IExecutionTree {\n  tree: LispItem[], \n  constants: IConstants\n}\n\ntype LispCallback = (strings: IConstants, type: string, parts: string, res: string[], expect: string, ctx: {lispTree: LispItem}) => any\nlet lispTypes: Map<string, LispCallback> = new Map();\n\nexport class ParseError extends Error {\n  constructor(message: string, public code: string) {\n    super(message);\n  }\n}\n\nexport class Lisp {\n  op: string;\n  a?: LispItem;\n  b?: LispItem;\n  constructor(obj: Lisp) {\n    this.op = obj.op;\n    this.a = obj.a;\n    this.b = obj.b;\n  }\n}\n\nexport class If {\n  constructor(public t: any, public f: any) {}\n}\n\nexport class KeyVal {\n  constructor(public key: string, public val: any) {}\n}\n\nexport class SpreadObject {\n  constructor(public item: {[key: string]: any}) {}\n}\n\nexport class SpreadArray {\n  constructor(public item: any[]) {}\n}\n\nconst inlineIfElse =  /^:/;\nconst space = /^\\s/;\n\nlet expectTypes: {[type:string]: {types: {[type:string]: RegExp}, next: string[]}} = {\n  splitter: {\n    types: {\n      split: /^(&&|&(?!&)|\\|\\||\\|(?!\\|)|<=|>=|<(?!<)|>(?!>)|!==|!=(?!\\=)|===|==(?!\\=)|\\+(?!\\+)|\\-(?!\\-)|\\^|<<|>>(?!>)|>>>|instanceof(?![\\w\\$\\_])|in(?![\\w\\$\\_]))(?!\\=)/,\n      op: /^(\\/|\\*\\*|\\*(?!\\*)|\\%)(?!\\=)/,\n    },\n    next: [\n      'modifier',\n      'value', \n      'prop', \n      'incrementerBefore',\n    ]\n  },\n  inlineIf: {\n    types: {\n      inlineIf: /^\\?/,\n    },\n    next: [\n      'expEnd'\n    ]\n  },\n  assignment: {\n    types: {\n      assignModify: /^(\\-=|\\+=|\\/=|\\*\\*=|\\*=|%=|\\^=|\\&=|\\|=|>>>=|>>=|<<=)/,\n      assign: /^(=)(?!=)/\n    },\n    next: [\n      'modifier',\n      'value', \n      'prop', \n      'incrementerBefore',\n    ]\n  },\n  incrementerBefore: {\n    types: {incrementerBefore: /^(\\+\\+|\\-\\-)/},\n    next: [\n      'prop',\n    ]\n  },\n  expEdge: {\n    types: {\n      call: /^[\\(]/,\n      incrementerAfter: /^(\\+\\+|\\-\\-)/\n    },\n    next: [\n      'splitter',\n      'expEdge',\n      'inlineIf',\n      'dot',\n      'expEnd'\n    ]\n  },\n  modifier: {\n    types: {\n      not: /^!/,\n      inverse: /^~/,\n      negative: /^\\-(?!\\-)/,\n      positive: /^\\+(?!\\+)/,\n      typeof: /^typeof(?![\\w\\$\\_])/,\n      delete: /^delete(?![\\w\\$\\_])/,\n    },\n    next: [\n      'modifier', \n      'value',\n      'prop',\n      'incrementerBefore',\n    ]\n  },\n  dot: {\n    types: {\n      arrayProp: /^[\\[]/,\n      dot: /^\\.(?!\\.)/\n    },\n    next: [\n      'splitter',\n      'assignment',\n      'expEdge',\n      'inlineIf',\n      'dot',\n      'expEnd'\n    ]\n  },\n  prop: {\n    types: {\n      prop: /^[a-zA-Z\\$\\_][a-zA-Z\\d\\$\\_]*/,\n    },\n    next: [\n      'splitter',\n      'assignment',\n      'expEdge',\n      'inlineIf',\n      'dot',\n      'expEnd'\n    ]\n  },\n  value: {\n    types: {\n      createObject: /^\\{/,\n      createArray: /^\\[/,\n      number: /^(0x[\\da-f]+|\\d+(\\.\\d+)?(e[\\+\\-]?\\d+)?)/i,\n      string: /^\"(\\d+)\"/,\n      literal: /^`(\\d+)`/,\n      regex: /^\\/(\\d+)\\/r(?![\\w\\$\\_])/,\n      boolean: /^(true|false)(?![\\w\\$\\_])/,\n      null: /^null(?![\\w\\$\\_])/,\n      und: /^undefined(?![\\w\\$\\_])/,\n      arrowFunctionSingle: /^(async\\s+)?([a-zA-Z\\$_][a-zA-Z\\d\\$_]*)\\s*=>\\s*({)?/,\n      arrowFunction: /^(async\\s*)?\\(\\s*((\\.\\.\\.)?\\s*[a-zA-Z\\$_][a-zA-Z\\d\\$_]*(\\s*,\\s*(\\.\\.\\.)?\\s*[a-zA-Z\\$_][a-zA-Z\\d\\$_]*)*)?\\s*\\)\\s*=>\\s*({)?/,\n      inlineFunction: /^(async\\s+)?function(\\s*[a-zA-Z\\$_][a-zA-Z\\d\\$_]*)?\\s*\\(\\s*((\\.\\.\\.)?\\s*[a-zA-Z\\$_][a-zA-Z\\d\\$_]*(\\s*,\\s*(\\.\\.\\.)?\\s*[a-zA-Z\\$_][a-zA-Z\\d\\$_]*)*)?\\s*\\)\\s*{/,\n      group: /^\\(/,\n      NaN: /^NaN(?![\\w\\$\\_])/,\n      Infinity: /^Infinity(?![\\w\\$\\_])/,\n      void: /^void(?![\\w\\$\\_])\\s*/,\n      await: /^await(?![\\w\\$\\_])\\s*/,\n      new: /^new(?![\\w\\$\\_])\\s*/,\n      throw: /^throw(?![\\w\\$\\_])\\s*/\n    },\n    next: [\n      'splitter',\n      'expEdge',\n      'inlineIf',\n      'dot',\n      'expEnd'\n    ]\n  },\n  initialize: {\n    types: {\n      initialize: /^(var|let|const)\\s+([a-zA-Z\\$_][a-zA-Z\\d\\$_]*)\\s*(=)?/,\n      return: /^return(?![\\w\\$\\_])/,\n    },\n    next: [\n      'modifier',\n      'value', \n      'prop', \n      'incrementerBefore',\n      'expEnd'\n    ]\n  },\n  spreadObject: {\n    types: {\n      spreadObject: /^\\.\\.\\./\n    },\n    next: [\n      'value',\n      'prop', \n    ]\n  },\n  spreadArray: {\n    types: {\n      spreadArray: /^\\.\\.\\./\n    },\n    next: [\n      'value', \n      'prop', \n    ]\n  },\n  expEnd: {types: {}, next: []},\n  expSingle: {\n    types: {\n      for: /^(([a-zA-Z\\$\\_][\\w\\$\\_]*)\\s*:)?\\s*for\\s*\\(/,\n      do: /^(([a-zA-Z\\$\\_][\\w\\$\\_]*)\\s*:)?\\s*do\\s*\\{/,\n      while: /^(([a-zA-Z\\$\\_][\\w\\$\\_]*)\\s*:)?\\s*while\\s*\\(/,\n      loopAction: /^(break|continue)(?![\\w\\$\\_])/,\n      if: /^if\\s*\\(/,\n      try: /^try\\s*{/,\n      // block: /^{/,\n      function: /^(async\\s+)?function(\\s*[a-zA-Z\\$_][a-zA-Z\\d\\$_]*)\\s*\\(\\s*((\\.\\.\\.)?\\s*[a-zA-Z\\$_][a-zA-Z\\d\\$_]*(\\s*,\\s*(\\.\\.\\.)?\\s*[a-zA-Z\\$_][a-zA-Z\\d\\$_]*)*)?\\s*\\)\\s*{/,\n      switch: /^(([a-zA-Z\\$\\_][\\w\\$\\_]*)\\s*:)?\\s*switch\\s*\\(/,\n    },\n    next: [\n      'expEnd'\n    ]\n  }\n};\n\nlet closings = {\n  \"(\": \")\",\n  \"[\": \"]\",\n  \"{\": \"}\",\n  \"'\": \"'\",\n  '\"': '\"',\n  \"`\": \"`\"\n}\n\nlet closingsRegex: any = {\n  \"(\": /^\\)/,\n  \"[\": /^\\]/,\n  \"{\": /^\\}/,\n  \"'\": /^\\'/,\n  '\"': /^\\\"/,\n  \"`\": /^\\`/\n}\n\nconst okFirstChars = /^[\\+\\-~ !]/;\nconst aChar = /^[\\w\\$]/\nconst aNumber = expectTypes.value.types.number;\nexport function restOfExp(constants: IConstants, \n                          part: string, \n                          tests?: RegExp[], \n                          quote?: string, \n                          firstOpening?: string, \n                          closingsTests?: RegExp[], \n                          details: {[k: string]: string} = {}, \n                          allChars?: boolean) {\n  let isStart = true;\n  tests = tests || [];\n  let escape = false;\n  let done = false;\n  let lastIsChar = false;\n  let currentIsChar = false;\n  let lastChar = \"\";\n  let word = \"\";\n  let i;\n  for (i = 0; i < part.length && !done; i++) {\n    let char = part[i];\n    lastIsChar = currentIsChar;\n    currentIsChar = aChar.test(char);\n    if (!currentIsChar && !space.test(char) && !closings[char]) word = \"\";\n    if (currentIsChar && closingsTests) word += char;\n    if (quote === '\"' || quote === \"'\" || quote === \"`\") {\n      if (quote === \"`\" && char === \"$\" && part[i+1] === \"{\" && !escape) {\n        let skip = restOfExp(constants, part.substring(i+2), [], \"{\");\n        i += skip.length + 2;\n      } else if (char === quote && !escape) {\n        return part.substring(0, i);\n      }\n      escape = !escape && char === \"\\\\\";\n    } else if (closings[char]) {\n      if (char === firstOpening) {\n        done = true;\n        break;\n      } else {\n        let skip = restOfExp(constants, part.substring(i+1), [], char);\n        i += skip.length + 1;\n        isStart = false;\n        if (closingsTests) {\n          let sub = part.substring(i);\n          for (let test of closingsTests) {\n            test.lastIndex = 0;\n            const found = test.exec(sub);\n            if (!found) continue;\n            i += found[1].length - 1;\n            details['word'] = word;\n            done = true;\n            if (done) break;\n          }\n        }\n      }\n    } else if (!quote) {\n      let sub = part.substring(i);\n      let foundNumber: RegExpExecArray;\n      if (foundNumber = aNumber.exec(sub)) {\n        i += foundNumber[0].length - 1;\n        sub = part.substring(i);\n      }\n      if (allChars || (!lastIsChar || !currentIsChar) && lastChar !== char) {\n        for (let test of tests) {\n          const found = test.exec(sub);\n          if (!found) continue;\n          if (closingsTests) {\n            i += found[1].length;\n          }\n          done = true;\n          break;\n        }\n      }\n      if (isStart) {\n        if (okFirstChars.test(sub)) {\n          done = false;\n        } else {\n          isStart = false;\n        }\n      }\n      if (done) break;\n    } else if(char === closings[quote]) {\n      return part.substring(0, i);\n    }\n    lastChar = char;\n  }\n  if (quote) {\n    throw new SyntaxError(\"Unclosed '\" + quote + \"': \" + quote + part.substring(0, Math.min(i, 40)));\n  }\n  return part.substring(0, i);\n}\nrestOfExp.next = [\n  'splitter',\n  'expEnd',\n  'inlineIf'\n];\n\nconst setLispType = (types: string[], fn: LispCallback) => {\n  types.forEach((type) => {\n    lispTypes.set(type, fn);\n  })\n}\n\nconst closingsCreate: {[type:string]: RegExp} = {\n  'createArray': /^\\]/,\n  'createObject': /^\\}/,\n  'group': /^\\)/,\n  'arrayProp': /^\\]/,\n  'call': /^\\)/\n}\n\nsetLispType(['createArray', 'createObject', 'group', 'arrayProp','call'], (constants, type, part, res, expect, ctx) => {\n  let extract = \"\";\n  let arg: string[] = [];\n  let end = false;\n  let i = 1;\n  while (i < part.length && !end) {\n    extract = restOfExp(constants, part.substring(i), [\n      closingsCreate[type],\n      /^,/\n    ]);\n    i += extract.length;\n    if (extract) {\n      arg.push(extract);\n    }\n    if (part[i] !== ',') {\n      end = true;\n    } else {\n      i++;\n    }\n  }\n  const next = ['value', 'modifier', 'prop', 'incrementerBefore', 'expEnd'];\n  let l: LispItem;\n\n  let funcFound: RegExpExecArray;\n  switch(type) {\n    case 'group':\n    case 'arrayProp':\n      l = lispifyExpr(constants, arg.join(\",\"));\n      break;\n    case 'call':\n    case 'createArray':\n      // @TODO: support 'empty' values\n      l = arg.map((e) => lispify(constants, e, [...next, 'spreadArray']));\n      break;\n    case 'createObject':\n      l = arg.map((str) => {\n        str = str.trimStart();\n        let value;\n        let key;\n        funcFound = expectTypes.expSingle.types.function.exec('function ' + str);\n        if (funcFound) {\n          key = funcFound[2].trimStart();\n          value = lispify(constants, 'function ' + str.replace(key, \"\"));\n        } else {\n          let extract = restOfExp(constants, str, [/^:/]);\n          key = lispify(constants, extract, [...next, 'spreadObject']);\n          if (key instanceof Lisp && key.op === 'prop') {\n            key = key.b;\n          }\n          if (extract.length === str.length) return key;\n          value = lispify(constants, str.substring(extract.length + 1));\n        }\n        return new Lisp({\n          op: 'keyVal',\n          a: key,\n          b: value\n        });\n      })\n      break;\n  }\n  type = type === 'arrayProp' ? 'prop' : type;\n  ctx.lispTree = lispify(constants, part.substring(i + 1), expectTypes[expect].next, new Lisp({\n    op: type, \n    a: ctx.lispTree, \n    b: l,\n  }));\n});\n\nsetLispType(['inverse', 'not', 'negative', 'positive', 'typeof', 'delete', 'op'], (constants, type, part, res, expect, ctx) => {\n  let extract = restOfExp(constants, part.substring(res[0].length), [/^[^\\s\\.\\w\\d\\$]/]);\n  ctx.lispTree = lispify(constants, part.substring(extract.length + res[0].length), restOfExp.next, new Lisp({\n    op: ['positive', 'negative'].includes(type) ? '$' + res[0] : res[0],\n    a: ctx.lispTree, \n    b: lispify(constants, extract, expectTypes[expect].next), \n  }));\n});\n\nsetLispType(['incrementerBefore'], (constants, type, part, res, expect, ctx) => {\n  let extract = restOfExp(constants, part.substring(2), [/^[^\\s\\.\\w\\d\\$]/]);\n  ctx.lispTree = lispify(constants, part.substring(extract.length + 2), restOfExp.next, new Lisp({\n    op: res[0] + \"$\", \n    a: lispify(constants, extract, expectTypes[expect].next), \n  }));\n});\n\nsetLispType(['incrementerAfter'], (constants, type, part, res, expect, ctx) => {\n  ctx.lispTree = lispify(constants, part.substring(res[0].length), expectTypes[expect].next, new Lisp({\n    op: \"$\"  + res[0], \n    a: ctx.lispTree, \n  }));\n});\n\nsetLispType(['assign', 'assignModify'], (constants, type, part, res, expect, ctx) => {\n  ctx.lispTree = new Lisp({\n    op: res[0], \n    a: ctx.lispTree,\n    b: lispify(constants, part.substring(res[0].length), expectTypes[expect].next)\n  });\n});\n\nsetLispType(['split'], (constants, type, part, res, expect, ctx) => {\n  let extract = restOfExp(constants, part.substring(res[0].length),[\n    expectTypes.splitter.types.split,\n    expectTypes.inlineIf.types.inlineIf,\n    inlineIfElse\n  ]);\n  ctx.lispTree = lispify(constants, part.substring(extract.length + res[0].length).trim(), restOfExp.next, new Lisp({\n    op: res[0].trim(),\n    a: ctx.lispTree, \n    b: lispify(constants, extract, expectTypes[expect].next), \n  }));\n});\n\nsetLispType(['inlineIf'], (constants, type, part, res, expect, ctx) => {\n  let found = false;\n  let extract = \"\";\n  let quoteCount = 1;\n  while(!found && extract.length < part.length) {\n    extract += restOfExp(constants, part.substring(extract.length + 1), [\n      expectTypes.inlineIf.types.inlineIf,\n      inlineIfElse\n    ]);\n    if (part[extract.length + 1] === '?') {\n      quoteCount++\n    } else {\n      quoteCount--\n    }\n    if (!quoteCount) {\n      found = true;\n    } else {\n      extract += part[extract.length + 1];\n    }\n  }\n  ctx.lispTree = new Lisp({\n    op: '?',\n    a: ctx.lispTree, \n    b: new Lisp({\n      op: ':',\n      a: lispifyExpr(constants, extract),\n      b: lispifyExpr(constants, part.substring(res[0].length + extract.length + 1))\n    })\n  });\n});\n\nsetLispType(['if'], (constants, type, part, res, expect, ctx) => {\n  let condition = restOfExp(constants, part.substring(res[0].length), [], \"(\");\n  const isBlock = /^\\s*\\{/.exec(part.substring(res[0].length + condition.length + 1));\n  const startTrue = res[0].length + condition.length + 1 + (isBlock ? isBlock[0].length : 0);\n  let trueBlock = restOfExp(constants, part.substring(startTrue), isBlock ? [/^\\}/] : [/^else(?!\\w\\$)/]);\n  let elseBlock = \"\";\n  if (startTrue + trueBlock.length + (isBlock ? isBlock[0].length : 0) < part.length) {\n    const end = part.substring(startTrue + trueBlock.length + (isBlock ? isBlock[0].length : 0));\n    const foundElse = /\\s*else(?!\\w\\$\\s)\\s*/.exec(end);\n    if (foundElse) {\n      elseBlock = end.substring(foundElse[0].length);\n    }\n  }\n  \n  condition = condition.trim();\n  trueBlock = trueBlock.trim();\n  elseBlock = elseBlock.trim();\n  if (trueBlock[0] === \"{\") trueBlock = trueBlock.slice(1, -1);\n  if (elseBlock[0] === \"{\") elseBlock = elseBlock.slice(1, -1);\n  ctx.lispTree = new Lisp({\n    op: 'if',\n    a: lispifyExpr(constants, condition), \n    b: new If(lispifyBlock(trueBlock, constants), elseBlock ? lispifyBlock(elseBlock, constants) : undefined)\n  });\n});\n\nsetLispType(['switch'], (constants, type, part, res, expect, ctx) => {\n  const test = restOfExp(constants, part.substring(res[0].length), [], \"(\");\n  let start = part.indexOf(\"{\", res[0].length + test.length + 1);\n  if (start === -1) throw new SyntaxError(\"Invalid switch: \" + part);\n  let statement = insertSemicolons(constants, restOfExp(constants, part.substring(start + 1), [], \"{\"), false);\n  let caseFound: RegExpExecArray;\n  const caseTest = /^\\s*(case\\s|default)\\s*/;\n  let cases: Lisp[] = [];\n  let defaultFound = false;\n  while(caseFound = caseTest.exec(statement)) {\n    if (caseFound[1] === 'default') {\n      if (defaultFound) throw new SyntaxError(\"Only one default switch case allowed:\" + statement);\n      defaultFound = true;\n    }\n    let cond = restOfExp(constants, statement.substring(caseFound[0].length), [/^:/]);\n    let found = \"\";\n    let i = start = caseFound[0].length + cond.length + 1;\n    let bracketFound = /^\\s*\\{/.exec(statement.substring(i));\n    let exprs = [];\n    if (bracketFound) {\n      i += bracketFound[0].length;\n      found = restOfExp(constants, statement.substring(i), [], \"{\");\n      i += found.length + 1;\n      exprs = lispifyBlock(found, constants);\n    } else {\n      let notEmpty = restOfExp(constants, statement.substring(i), [caseTest]);\n      if (!notEmpty.trim()) {\n        exprs = undefined;\n        i += notEmpty.length;\n      } else {\n        let lines = [];\n        while(found = restOfExp(constants, statement.substring(i), [/^;/])) {\n          lines.push(found);\n          i += found.length + 1;\n          if (caseTest.test(statement.substring(i))) {\n            break;\n          }\n        }\n        exprs = lispifyBlock(lines.join(\";\"), constants);\n      }\n    }\n    statement = statement.substring(i);\n    cases.push(new Lisp({\n      op: \"case\",\n      a: caseFound[1] === \"default\" ? undefined : lispifyExpr(constants, cond),\n      b: exprs\n    }));\n  }\n  ctx.lispTree = new Lisp({\n    op: 'switch',\n    a: lispifyExpr(constants, test),\n    b: cases\n  });\n});\n\nsetLispType(['dot', 'prop'], (constants, type, part, res, expect, ctx) => {\n  let prop = res[0];\n  let index = res[0].length;\n  if (res[0] === '.') {\n    let matches = part.substring(res[0].length).match(expectTypes.prop.types.prop);\n    if (matches && matches.length) {\n      prop = matches[0];\n      index = prop.length + res[0].length\n    } else {\n      throw new SyntaxError('Hanging  dot:' + part);\n    }\n  }\n  ctx.lispTree = lispify(constants, part.substring(index), expectTypes[expect].next, new Lisp({\n    op: 'prop', \n    a: ctx.lispTree, \n    b: prop\n  }));\n});\n\nsetLispType(['spreadArray', 'spreadObject'], (constants, type, part, res, expect, ctx) => {\n  ctx.lispTree = new Lisp({\n    op: type,\n    b: lispify(constants, part.substring(res[0].length), expectTypes[expect].next)\n  });\n});\n\nsetLispType(['return'], (constants, type, part, res, expect, ctx) => {\n  ctx.lispTree = new Lisp({\n    op: type,\n    b: lispifyExpr(constants, part.substring(res[0].length))\n  });\n});\n\nconst primitives = {\n  \"true\": true,\n  \"false\": false,\n  \"null\": null,\n  Infinity,\n  NaN,\n  \"und\": undefined\n}\n\nsetLispType(['number', 'boolean', 'null', 'und', 'NaN', 'Infinity'], (constants, type, part, res, expect, ctx) => {\n  ctx.lispTree = lispify(constants, part.substring(res[0].length), expectTypes[expect].next, type === \"number\" ? Number(res[0]) : primitives[type === \"boolean\" ? res[0] : type]);\n});\n\nsetLispType(['string', 'literal', 'regex'], (constants, type, part, res, expect, ctx) => {\n  ctx.lispTree = lispify(constants, part.substring(res[0].length), expectTypes[expect].next, new Lisp({\n    op: type,\n    b: parseInt(JSON.parse(res[1]), 10),\n  }));\n});\n\nsetLispType(['initialize'], (constants, type, part, res, expect, ctx) => {\n  if (!res[3]) {\n    ctx.lispTree = lispify(constants, part.substring(res[0].length), expectTypes[expect].next, new Lisp({\n      op: res[1],\n      a: res[2]\n    }));\n  } else {\n    ctx.lispTree = new Lisp({\n      op: res[1],\n      a: res[2],\n      b: lispify(constants, part.substring(res[0].length), expectTypes[expect].next)\n    });\n  }\n});\n\nsetLispType(['function', 'inlineFunction', 'arrowFunction', 'arrowFunctionSingle'], (constants, type, part, res, expect, ctx) => {\n  const isArrow = type !== 'function' && type !== 'inlineFunction';\n  const isReturn = isArrow && !res[res.length - 1];\n  const argPos = isArrow ? 2 : 3;\n  const isAsync = !!res[1];\n  const args: any[] = res[argPos] ? res[argPos].replace(/\\s+/g, \"\").split(/,/g) : [];\n  if (!isArrow) {\n    args.unshift((res[2] || \"\").trimStart());\n  }\n  let ended = false;\n  args.forEach((arg) => {\n    if (ended) throw new SyntaxError('Rest parameter must be last formal parameter');\n    if (arg.startsWith('...')) ended = true;\n  });\n  args.unshift(isAsync);\n  const func = (isReturn ? 'return ' : '') + restOfExp(constants, part.substring(res[0].length), !isReturn ? [/^}/] : [/^[,;\\)\\}\\]]/]);\n  ctx.lispTree = lispify(constants, part.substring(res[0].length + func.length + 1), expectTypes[expect].next, new Lisp({\n    op: isArrow ? 'arrowFunc' : type,\n    a: args,\n    b: lispifyFunction(func, constants)\n  }));\n});\n\nconst iteratorRegex = /^((let|var|const)\\s+)?\\s*([a-zA-Z\\$_][a-zA-Z\\d\\$_]*)\\s+(in|of)\\s+/\nsetLispType(['for', 'do', 'while'], (constants, type, part, res, expect, ctx) => {\n  let i = part.indexOf(\"(\") + 1;\n  let startStep: LispItem = true;\n  let startInternal: LispItem[] = [];\n  let beforeStep: LispItem = false;\n  let checkFirst = true;\n  let condition: LispItem;\n  let step: LispItem = true;\n  let body: string;\n  switch (type) {\n    case 'while':\n      let extract = restOfExp(constants, part.substring(i), [], \"(\");\n      condition = lispifyExpr(constants, extract);\n      body = restOfExp(constants, part.substring(i + extract.length + 1)).trim();\n      if (body[0] === \"{\") body = body.slice(1, -1);\n      break;\n    case 'for':\n      let args: string[] = [];\n      let extract2 = \"\";\n      for (let k = 0; k < 3; k++)  {\n        extract2 = restOfExp(constants, part.substring(i), [/^[;\\)]/]);\n        args.push(extract2.trim());\n        i += extract2.length + 1;\n        if (part[i - 1] === \")\") break;\n      }\n      let iterator: RegExpExecArray;\n      if (args.length === 1 && (iterator = iteratorRegex.exec(args[0]))) {\n        if (iterator[4] === 'of') {\n          startInternal = [\n            lispify(constants, 'let $$obj = '+ args[0].substring(iterator[0].length), ['initialize']),\n            ofStart2, \n            ofStart3\n          ];\n          condition = ofCondition;\n          step = ofStep;\n          beforeStep = lispify(constants, (iterator[1] || 'let ') + iterator[3]  + ' = $$next.value', ['initialize']);\n        } else {\n          startInternal = [\n            lispify(constants, 'let $$obj = '+ args[0].substring(iterator[0].length), ['initialize']),\n            inStart2,\n            inStart3\n          ];\n          step = inStep;\n          condition = inCondition;\n          beforeStep = lispify(constants, (iterator[1] || 'let ') + iterator[3] + ' = $$keys[$$keyIndex]', ['initialize']);\n        }\n      } else if (args.length === 3) {\n        startStep = lispifyExpr(constants, args.shift(), startingExecpted);\n        condition = lispifyExpr(constants, args.shift());\n        step = lispifyExpr(constants, args.shift());\n      } else {\n        throw new SyntaxError(\"Invalid for loop definition\");\n      }\n      body = restOfExp(constants, part.substring(i)).trim();\n      if (body[0] === \"{\") body = body.slice(1, -1);\n\n      break;\n    case 'do':\n      checkFirst = false;\n      const start = part.indexOf(\"{\") + 1;\n      body = restOfExp(constants, part.substring(start), [], \"{\");\n      condition = lispifyExpr(constants, restOfExp(constants, part.substring(part.indexOf(\"(\", start + body.length) + 1), [], \"(\"));\n      break;\n  }\n  ctx.lispTree = new Lisp({\n    op: 'loop',\n    a: [checkFirst, startInternal, startStep, step, condition, beforeStep],\n    b: lispifyBlock(body, constants)\n  });\n});\n\nsetLispType(['block'], (constants, type, part, res, expect, ctx) => {\n  ctx.lispTree = lispifyBlock(restOfExp(constants, part.substring(1), [], \"{\"), constants);\n});\n\nsetLispType(['loopAction'], (constants, type, part, res, expect, ctx) => {\n  ctx.lispTree = new Lisp({\n    op: 'loopAction',\n    a: res[1],\n  });\n});\n\nconst catchReg = /^\\s*(catch\\s*(\\(\\s*([a-zA-Z\\$_][a-zA-Z\\d\\$_]*)\\s*\\))?|finally)\\s*\\{/\nsetLispType(['try'], (constants, type, part, res, expect, ctx) => {\n  const body = restOfExp(constants, part.substring(res[0].length), [], \"{\");\n  let catchRes = catchReg.exec(part.substring(res[0].length + body.length + 1));\n  let finallyBody;\n  let exception;\n  let catchBody;\n  let offset = 0;\n  if (catchRes[1].startsWith('catch')) {\n    catchRes = catchReg.exec(part.substring(res[0].length + body.length + 1));\n    exception = catchRes[2];\n    catchBody = restOfExp(constants, part.substring(res[0].length + body.length + 1 + catchRes[0].length), [], \"{\");\n    offset = res[0].length + body.length + 1 + catchRes[0].length + catchBody.length + 1;\n    if ((catchRes = catchReg.exec(part.substring(offset))) && catchRes[1].startsWith('finally')) {\n      finallyBody = restOfExp(constants, part.substring(offset + catchRes[0].length), [], \"{\");\n    }\n  } else {\n    finallyBody = restOfExp(constants, part.substring(res[0].length + body.length + 1 + catchRes[0].length), [], \"{\");\n  }\n  ctx.lispTree = new Lisp({\n    op: 'try',\n    a: lispifyBlock(insertSemicolons(constants, body, false), constants),\n    b: [\n      exception,\n      lispifyBlock(insertSemicolons(constants, catchBody || \"\", false), constants),\n      lispifyBlock(insertSemicolons(constants, finallyBody || \"\", false), constants),\n    ]\n  });\n});\n\nsetLispType(['void', 'await', 'throw'], (constants, type, part, res, expect, ctx) => {\n  const extract = restOfExp(constants, part.substring(res[0].length), [/^[^\\s\\.\\w\\d\\$]/]);\n  ctx.lispTree = lispify(constants, part.substring(res[0].length + extract.length), expectTypes[expect].next, new Lisp({\n    op: type,\n    a: lispify(constants, extract),\n  }));\n});\n\nsetLispType(['new'], (constants, type, part, res, expect, ctx) => {\n  let i = res[0].length;\n  const obj = restOfExp(constants, part.substring(i), [], undefined, \"(\");\n  i += obj.length + 1;\n  const args = [];\n  if (part[i - 1] === \"(\") {\n    const argsString = restOfExp(constants, part.substring(i), [], \"(\");\n    i += argsString.length + 1;\n    let found;\n    let j = 0;\n    while(found = restOfExp(constants, argsString.substring(j), [/^,/])) {\n      j += found.length + 1;\n      args.push(found.trim());\n    } \n  }\n  ctx.lispTree = lispify(constants, part.substring(i), expectTypes.expEdge.next, new Lisp({\n    op: type,\n    a: lispify(constants, obj, expectTypes.initialize.next),\n    b: args.map((arg) => lispify(constants, arg, expectTypes.initialize.next)),\n  }));\n});\n\nconst ofStart2 = lispify(undefined, 'let $$iterator = $$obj[Symbol.iterator]()', ['initialize']);\nconst ofStart3 = lispify(undefined, 'let $$next = $$iterator.next()', ['initialize']);\nconst ofCondition = lispify(undefined, 'return !$$next.done', ['initialize']);\nconst ofStep = lispify(undefined, '$$next = $$iterator.next()');\nconst inStart2 = lispify(undefined, 'let $$keys = Object.keys($$obj)', ['initialize']);\nconst inStart3 = lispify(undefined, 'let $$keyIndex = 0', ['initialize']);\nconst inStep = lispify(undefined, '$$keyIndex++');\nconst inCondition = lispify(undefined, 'return $$keyIndex < $$keys.length', ['initialize']);\n\nconst startingExecpted = ['initialize', 'expSingle', 'value', 'modifier', 'prop', 'incrementerBefore', 'expEnd'];\nvar lastType;\nvar lastPart;\n// var lastLastPart;\n// var lastLastLastPart;\n// var lastLastLastLastPart;\nfunction lispify(constants: IConstants, part: string, expected?: string[], lispTree?: LispItem): LispItem {\n  expected = expected || expectTypes.initialize.next;\n  if (part === undefined) return lispTree;\n\n  part = part.trimStart();\n\n  if (!part.length && !expected.includes('expEnd')) {\n    throw new SyntaxError(\"Unexpected end of expression: \" + lastPart);\n  }\n  \n  if (!part) return lispTree;\n\n  let ctx = {lispTree: lispTree};\n\n  let res: any;\n  for (let expect of expected) {\n    if (expect === 'expEnd') {\n      continue;\n    }\n    for (let type in expectTypes[expect].types) {\n      if (type === 'expEnd') {\n        continue;\n      }\n      if(res = expectTypes[expect].types[type].exec(part)) {\n        lastType = type;\n        // lastLastLastLastPart = lastLastLastPart;\n        // lastLastLastPart = lastLastPart;\n        // lastLastPart = lastPart;\n        lastPart = part;\n        lispTypes.get(type)(constants, type, part, res, expect, ctx);\n        break;\n      }\n    }\n    if (res) break;\n  }\n\n  if (!res && part.length) {\n    throw SyntaxError(`Unexpected token (${lastType}): ${part.substring(0, 40)}`);\n  }\n  return ctx.lispTree;\n}\n\nfunction lispifyExpr(constants: IConstants, str: string, expected?: string[]): LispItem {\n  if (!str.trim()) return undefined;\n  let subExpressions = [];\n  let sub: string;\n  let pos = 0;\n  expected = expected || expectTypes.initialize.next;\n  while ((sub = restOfExp(constants, str.substring(pos), [/^,/]))) {\n    subExpressions.push(sub.trimStart());\n    pos += sub.length + 1;\n  }\n  if (subExpressions.length === 1) {\n    return lispify(constants, str, expected);\n  }\n  if (expected === startingExecpted) {\n    let defined = expectTypes.initialize.types.initialize.exec(subExpressions[0]);\n    if (defined) {\n      return subExpressions.map((str, i) => lispify(constants, i ? defined[1] + ' ' + str : str, ['initialize']));\n    } else if (expectTypes.initialize.types.return.exec(subExpressions[0])) {\n      return lispify(constants, str, expected);\n    }\n  }\n  const exprs = subExpressions.map((str, i) => lispify(constants, str, expected));\n  return new Lisp({op: \"multi\", a: exprs});\n}\n\nexport function lispifyBlock(str: string, constants: IConstants): LispItem[] {\n  str = insertSemicolons(constants, str, false);\n  if (!str.trim()) return [];\n  let parts = [];\n  let part: string;\n  let pos = 0;\n  while ((part = restOfExp(constants, str.substring(pos), [/^;/]))) {\n    parts.push(part.trim());\n    pos += part.length + 1;\n  }\n  return parts.filter(Boolean).map((str, j) => {\n    return lispifyExpr(constants, str, startingExecpted);\n  }).flat();\n}\n\nexport function lispifyFunction(str: string, constants: IConstants): LispItem[] {\n  if (!str.trim()) return [];\n  const tree = lispifyBlock(str, constants);\n  let hoisted: LispItem[] = [];\n  hoist(tree, hoisted);\n  return hoisted.concat(tree);\n}\n\nfunction hoist(item: LispItem, res: LispItem[]): boolean {\n  if (Array.isArray(item)) {\n    const rep = [];\n    for (let it of item) {\n      if (!hoist(it, res)) {\n        rep.push(it);\n      }\n    }\n    if (rep.length !== item.length) {\n      item.length = 0;\n      item.push(...rep);\n    }\n  } else if (item instanceof Lisp) {\n    if (item.op === \"try\" || item.op === \"if\" || item.op === \"loop\" || item.op === \"switch\") {\n      hoist(item.a, res);\n      hoist(item.b, res);\n    } else if (item.op === \"var\") {\n      res.push(new Lisp({op: 'var', a: item.a}));\n    } else if (item.op === \"function\" && item.a[1]) {\n      res.push(item);\n      return true;\n    }\n  }\n  return false;\n}\n\nconst edgesForInsertion = [\n  /^([\\w\\$]|\\+\\+|\\-\\-)\\s*\\r?\\n\\s*([\\w\\$\\+\\-])/,\n  /^([^\\w\\$](return|continue|break|throw))\\s*\\r?\\n\\s*[^\\s]/\n];\nconst closingsForInsertion = [\n  /^([\\)\\]])\\s*\\r?\\n\\s*([\\w\\$\\{\\+\\-])/,\n  /^(\\})\\s*\\r?\\n?\\s*([\\(])/,\n  /^(\\})\\s*(\\r?\\n)?\\s*([\\w\\[\\+\\-])/,\n];\nconst closingsNoInsertion = /^(\\})\\s*(catch|finally|else|while|instanceof)(?![\\w\\$])/\nconst whileEnding = /^\\}\\s*while/\n\nexport function insertSemicolons(constants: IConstants, part: string, type: boolean) {\n  let rest = part;\n  let sub = \"\"\n  let res = [];\n  let details: any = {};\n  while (sub = restOfExp(constants, rest, edgesForInsertion, undefined, undefined, !type ? closingsForInsertion : undefined, details, true)) {\n    res.push(sub);\n    if (!closingsNoInsertion.test(rest.substring(sub.length - 1))) {\n      res.push(\";\");\n    } else if (details.word !== \"do\" && whileEnding.test(rest.substring(sub.length - 1))) {\n      res.push(\";\");\n    }\n    rest = rest.substring(sub.length);\n  }\n  res.pop();\n  return res.join(\"\");\n}\n\nconst oneLinerBlocks = /[^\\w\\$](if|do)(?![\\w\\$])/g;\nexport function convertOneLiners(constants: IConstants, str: string): string {\n  let res: RegExpExecArray;\n  let lastIndex = 0;\n  let parts: Array<string|string[]> = [];\n  while (res = oneLinerBlocks.exec(str)) {\n    let sub = str.substring(res.index + res[0].length);\n    let nextIndex = res.index + res[0].length;\n    if (res[1] === 'if') {\n      let c = sub.indexOf(\"(\") + 1;\n      nextIndex += c\n      let condition = restOfExp(constants, sub.substring(c), [], \"(\");\n      oneLinerBlocks.lastIndex = res.index + c + condition.length + 1;\n      parts.push(str.substring(lastIndex, nextIndex), [condition], ')');\n      nextIndex += condition.length + 1;\n    } else {\n      parts.push(str.substring(lastIndex, nextIndex));\n    }\n    const spaceCount = /^\\s*/.exec(str.substring(nextIndex));\n    nextIndex += spaceCount[0].length;\n    sub = str.substring(nextIndex);\n    if (sub[0] !== '{') {\n      let body = restOfExp(constants, sub, [/^([;\\)\\]\\}]|\\r?\\n)/]);\n      let semi = 0;\n      if (sub[body.length] === \";\") semi = 1;\n      parts.push(\"{\", body, \"}\");\n      let rest = sub.substring(body.length + semi);\n      if (res[1] === 'if' && !/^\\s*else(?![\\w\\$])/.test(rest)) {\n        parts.push(\";\");\n      }\n      lastIndex = nextIndex + body.length + semi;\n    } else {\n      lastIndex = nextIndex;\n    }\n  }\n  parts.push(str.substring(lastIndex));\n  for (let p of parts) {\n    if (p instanceof Array) {\n      let c = convertOneLiners(constants, p[0]);\n      p.length = 0;\n      p.push(c)\n    }\n  }\n  return parts.flat().join(\"\");\n}\n\nexport function checkRegex(str: string): IRegEx | null {\n  let i = 1;\n  let escape = false;\n  let done = false;\n  let cancel = false;\n  while (i < str.length && !done && !cancel) {\n    done = (str[i] === '/' && !escape);\n    escape = str[i] === '\\\\' && !escape;\n    cancel = str[i] === '\\n';\n    i++;\n  }\n  let after = str.substring(i);\n  cancel = (cancel || !done) || /^\\s*\\d/.test(after);\n  if (cancel) return null;\n  let flags = /^[a-z]*/.exec(after);\n  if(/^\\s+[\\w\\$]/.test(str.substring(i + flags[0].length))) {\n    return null;\n  }\n  return {\n    regex: str.substring(1, i-1),\n    flags: (flags && flags[0]) || \"\",\n    length: i + ((flags && flags[0].length) || 0)\n  }\n}\n\nconst notDivide = /(typeof|delete|instanceof|return|in|of|throw|new|void|do|if)$/\nconst possibleDivide = /^([\\w\\$\\]\\)]|\\+\\+|\\-\\-)[^\\w\\$\\]\\)\\+\\-]/;\nexport function extractConstants(constants: IConstants, str: string, currentEnclosure = \"\"): {str: string, length: number} {\n  let quote;\n  let extract: string[] = [];\n  let escape = false;\n  let regexFound: IRegEx;\n  let comment = \"\";\n  let commentStart = -1;\n  let currJs: LispItem[] = [];\n  let char: string = \"\";\n  const strRes: string[] = []\n  const enclosures: string[] = [];\n  let isPossibleDivide: RegExpExecArray;\n  for (var i = 0; i < str.length; i++) {\n    char = str[i];\n    if (comment) {\n      if (char === comment) {\n        if (comment === \"*\" && str[i + 1] ===\"/\") {\n          comment = \"\";\n          i++\n        } else if (comment === \"\\n\") {\n          comment = \"\";\n        }\n      }\n    } else {\n      if (escape) {\n        escape = false;\n        extract.push(char);\n        continue;\n      }\n\n      if (quote) {\n        if (quote === \"`\" && char === \"$\" && str[i+1] === \"{\") {\n          let skip = extractConstants(constants, str.substring(i+2), \"{\");\n          currJs.push(skip.str);\n          extract.push(`\\${${currJs.length - 1}}`);\n          i += skip.length + 2;\n        } else if (quote === char) {\n          if (quote === '`') {\n            constants.literals.push({\n              op: 'literal',\n              a:  unraw(extract.join(\"\")),\n              b: currJs\n            });\n            strRes.push(`\\`${constants.literals.length - 1}\\``);\n          } else {\n            constants.strings.push(unraw(extract.join(\"\")));\n            strRes.push( `\"${constants.strings.length - 1}\"`);\n          }\n          quote = null;\n          extract = [];\n        } else {\n          extract.push(char);\n        }\n      } else {\n        if ((char === \"'\"  || char === '\"'  || char === '`')) {\n          currJs = [];\n          quote = char;\n        } else if (closings[currentEnclosure] === char && !enclosures.length) {\n          return {str: strRes.join(\"\"), length: i}\n        } else if (closings[char]) {\n          enclosures.push(char);\n          strRes.push(char);\n        } else if (closings[enclosures[enclosures.length-1]] === char) {\n          enclosures.pop();\n          strRes.push(char);\n        } else if (char === \"/\" && (str[i+1] === \"*\" || str[i+1] === \"/\")) {\n          comment = str[i+1] === \"*\" ? \"*\" : \"\\n\";\n          commentStart = i;\n        } else if (char === '/' && !isPossibleDivide && (regexFound = checkRegex(str.substring(i)))) {\n          constants.regexes.push(regexFound);\n          strRes.push(`/${constants.regexes.length - 1}/r`);\n          i += regexFound.length - 1;\n        } else {\n          strRes.push(char);\n        }\n\n        if (!(isPossibleDivide && space.test(char))) {\n          if (isPossibleDivide = possibleDivide.exec(str.substring(i))) {\n            if (notDivide.test(str.substring(0, i + isPossibleDivide[1].length))) {\n              isPossibleDivide = null;\n            }\n          }\n        }\n      }\n      escape = quote && char === \"\\\\\";\n    }\n  }\n\n  if (comment) {\n    if (comment === \"*\") {\n      throw new SyntaxError(`Unclosed comment '/*': ${str.substring(commentStart)}`)\n    }\n  }\n  return {str: strRes.join(\"\"), length: i}\n}\nexport function parse(code: string): IExecutionTree {\n  if (typeof code !== 'string') throw new ParseError(`Cannot parse ${code}`, code);\n  // console.log('parse', str);\n  let str = ' ' + code;\n  const constants: IConstants = {strings: [], literals: [], regexes: []};\n  str = extractConstants(constants, str).str;\n  str = insertSemicolons(constants, str, true);\n  str = convertOneLiners(constants, str);\n  // console.log(str);\n\n  try {\n    for (let l of constants.literals) {\n      l.b = l.b.map((js: string) => lispifyExpr(constants, js));\n    }\n    return {tree: lispifyFunction(str, constants), constants};\n  } catch (e) {\n    throw e;\n    throw new ParseError(e.message + \": \" + str.substring(0, 100) + '...', str);\n  }\n}\n","import { SpreadArray, LispItem, KeyVal, SpreadObject, If, Lisp, parse, IRegEx } from \"./parser.js\";\nimport { IExecContext, IContext } from \"./Sandbox.js\";\n\n\nexport type SandboxFunction = (code: string, ...args: any[]) => () => any;\nexport type sandboxedEval = (code: string) => any;\nexport type sandboxSetTimeout = (handler: TimerHandler, timeout?: any, ...args: any[]) => any;\nexport type sandboxSetInterval = (handler: TimerHandler, timeout?: any, ...args: any[]) => any;\nexport type Done = (err?: any, res?: any) => void\nexport class ExecReturn {\n  constructor(public auditReport: IAuditReport, public result: any, public returned: boolean, public breakLoop = false, public continueLoop = false) {}\n}\n\nexport interface IAuditReport {\n  globalsAccess: Set<any>;\n  prototypeAccess: {[name: string]: Set<string>}\n}\n\nexport interface IGlobals {\n  [key: string]: any\n}\n\nexport interface IChange {\n  type: string;\n}\n\nexport interface ICreate extends IChange {\n  type: \"create\";\n  prop: number|string;\n}\n\nexport interface IReplace extends IChange {\n  type: \"replace\";\n}\n\nexport interface IDelete extends IChange {\n  type: \"delete\";\n  prop: number|string;\n}\n\nexport interface IReverse extends IChange {\n  type: \"reverse\";\n}\n\nexport interface ISort extends IChange {\n  type: \"sort\";\n}\n\nexport interface IPush extends IChange {\n  type: \"push\";\n  added: unknown[];\n}\n\nexport interface IPop extends IChange {\n  type: \"pop\";\n  removed: unknown[];\n}\n\nexport interface IShift extends IChange {\n  type: \"shift\";\n  removed: unknown[];\n}\n\nexport interface IUnShift extends IChange {\n  type: \"unshift\";\n  added: unknown[];\n}\n\nexport interface ISplice extends IChange {\n  type: \"splice\";\n  startIndex: number;\n  deleteCount: number; \n  added: unknown[];\n  removed: unknown[];\n\n}\n\nexport interface ICopyWithin extends IChange {\n  type: \"copyWithin\";\n  startIndex: number;\n  endIndex: number;\n  added: unknown[];\n  removed: unknown[];\n}\n\nexport type Change = ICreate | IReplace | IDelete | IReverse | ISort | IPush | IPop | IUnShift | IShift | ISplice | ICopyWithin\n\nexport type replacementCallback = (obj: any, isStaticAccess: boolean) => any\n\nexport class Prop {\n  constructor(public context: {[key:string]: any}, public prop: string, public isConst = false, public isGlobal = false, public isVariable = false) {\n  }\n}\n\nconst reservedWords = new Set([\n  'instanceof',\n  'typeof',\n  'return',\n  'try',\n  'catch',\n  'if',\n  'finally',\n  'else',\n  'in',\n  'of',\n  'var',\n  'let',\n  'const',\n  'for',\n  'delete',\n  'false',\n  'true',\n  'while',\n  'do',\n  'break',\n  'continue',\n  'new',\n  'function',\n  'async',\n  'await',\n  'switch',\n  'case'\n]);\n\nenum VarType {\n  let = \"let\",\n  const = \"const\",\n  var = \"var\"\n}\n\nexport class Scope {\n  parent: Scope;\n  const = new Set<string>();\n  let = new Set<string>();\n  var: Set<string>;\n  globals: Set<string>;\n  allVars: {[key:string]: any} & Object;\n  functionThis?: any;\n  constructor(parent: Scope, vars = {}, functionThis?: any) {\n    const isFuncScope = functionThis !== undefined || parent === null;\n    this.parent = parent;\n    this.allVars = vars;\n    this.let = isFuncScope ? this.let : new Set(Object.keys(vars));\n    this.var = isFuncScope ? new Set(Object.keys(vars)) : this.var;\n    this.globals = parent === null ? new Set(Object.keys(vars)) : new Set();\n    this.functionThis = functionThis;\n  }\n\n  get(key: string, functionScope = false): any {\n    if (key === 'this' && this.functionThis !== undefined) {\n      return new Prop({this: this.functionThis}, key, true, false, true);\n    }\n    if (reservedWords.has(key)) throw new SyntaxError(\"Unexepected token '\" + key + \"'\");\n    if (this.parent === null || !functionScope || this.functionThis !== undefined) {\n      if (this.globals.has(key)) {\n        return new Prop(this.functionThis, key, false, true, true);\n      }\n      if (key in this.allVars && (!(key in {}) || this.allVars.hasOwnProperty(key))) {\n        return new Prop(this.allVars, key, this.const.has(key), this.globals.has(key), true);\n      }\n      if (this.parent === null) {\n        return new Prop(undefined, key);\n      }\n    }\n    return this.parent.get(key, functionScope)\n  }\n\n  set(key: string, val: any) {\n    if (key === 'this') throw new SyntaxError('\"this\" cannot be assigned')\n    if (reservedWords.has(key)) throw new SyntaxError(\"Unexepected token '\" + key + \"'\");\n    let prop = this.get(key);\n    if(prop.context === undefined) {\n      throw new ReferenceError(`Variable '${key}' was not declared.`);\n    }``\n    if (prop.isConst) {\n      throw new TypeError(`Cannot assign to const variable '${key}'`);\n    }\n    if (prop.isGlobal) {\n      throw new SandboxError(`Cannot override global variable '${key}'`);\n    }\n    prop.context[prop] = val;\n    return prop;\n  }\n\n  declare(key: string, type: VarType = null, value: any = undefined, isGlobal = false) {\n    if (key === 'this') throw new SyntaxError('\"this\" cannot be declared');\n    if (reservedWords.has(key)) throw new SyntaxError(\"Unexepected token '\" + key + \"'\");\n    if (type === 'var' && this.functionThis === undefined && this.parent !== null) {\n      return this.parent.declare(key, type, value, isGlobal)\n    } else if ((this[type].has(key) && type !== 'const' && !this.globals.has(key)) || !(key in this.allVars)) {\n      if (isGlobal) {\n        this.globals.add(key);\n      }\n      this[type].add(key);\n      this.allVars[key] = value;\n    } else {\n      throw new SandboxError(`Identifier '${key}' has already been declared`);\n    }\n    return new Prop(this.allVars, key, this.const.has(key), isGlobal);\n  }\n}\n\nexport class SandboxError extends Error {\n\n}\n\nexport function sandboxFunction(context: IContext): SandboxFunction {\n  return SandboxFunction;\n  function SandboxFunction(...params: any[]) {\n    let code = params.pop() || \"\";\n    let parsed = parse(code);\n    return createFunction(params, parsed.tree, {\n      ctx: context,\n      constants: parsed.constants\n    }, undefined, 'anonymous');\n  }\n}\n\nconst sandboxedFunctions = new WeakSet();\nexport function createFunction(argNames: string[], parsed: LispItem, context: IExecContext, scope?: Scope, name?: string) {\n  let func = function sandboxedObject(...args) {\n    const vars: any = {};\n    argNames.forEach((arg, i) => {\n      if (arg.startsWith('...')) {\n        vars[arg.substring(3)] = args.slice(i);\n      } else {\n        vars[arg] = args[i];\n      }\n    });\n    const res = executeTree(context, parsed, scope === undefined ? [] : [new Scope(scope, vars, name === undefined ? undefined : this)])\n    return res.result;\n  };\n  sandboxedFunctions.add(func);\n  return func;\n}\n\nexport function createFunctionAsync(argNames: string[], parsed: LispItem, context: IExecContext, scope?: Scope, name?: string) {\n  let func = async function sandboxedObject(...args) {\n    const vars: any = {};\n    argNames.forEach((arg, i) => {\n      if (arg.startsWith('...')) {\n        vars[arg.substring(3)] = args.slice(i);\n      } else {\n        vars[arg] = args[i];\n      }\n    });\n    const res = await executeTreeAsync(context, parsed, scope === undefined ? [] : [new Scope(scope, vars, name === undefined ? undefined : this)])\n    return res.result;\n  }\n  sandboxedFunctions.add(func);\n  return func;\n}\n\nexport function sandboxedEval(func: SandboxFunction): sandboxedEval {\n  return sandboxEval;\n  function sandboxEval(code: string) {\n    return func(code)();\n  }\n}\n\nexport function sandboxedSetTimeout(func: SandboxFunction): sandboxSetTimeout {\n  return function sandboxSetTimeout(handler, ...args) {\n    if (typeof handler !== 'string') return setTimeout(handler, ...args);\n    return setTimeout(func(handler), ...args);\n  }\n}\n\nexport function sandboxedSetInterval(func: SandboxFunction): sandboxSetInterval {\n  return function sandboxSetInterval(handler, ...args) {\n    if (typeof handler !== 'string') return setInterval(handler, ...args);\n    return setInterval(func(handler), ...args);\n  }\n}\n\nfunction assignCheck(obj: Prop, context: IExecContext, op = 'assign') {\n  if(obj.context === undefined) {\n    throw new ReferenceError(`Cannot ${op} value to undefined.`)\n  }\n  if(typeof obj.context !== 'object' && typeof obj.context !== 'function') {\n    throw new SyntaxError(`Cannot ${op} value to a primitive.`)\n  }\n  if (obj.isConst) {\n    throw new TypeError(`Cannot set value to const variable '${obj.prop}'`);\n  }\n  if (obj.isGlobal) {\n    throw new SandboxError(`Cannot ${op} property '${obj.prop}' of a global object`);\n  }\n  if (typeof obj.context[obj.prop] === 'function' && !obj.context.hasOwnProperty(obj.prop)) {\n    throw new SandboxError(`Override prototype property '${obj.prop}' not allowed`);\n  }\n  if (op === \"delete\") {\n    if (obj.context.hasOwnProperty(obj.prop)) {\n      context.ctx.changeSubscriptions.get(obj.context)?.forEach((cb) => cb({type: \"delete\", prop: obj.prop}));\n    }\n  } else if (obj.context.hasOwnProperty(obj.prop)) {\n    context.ctx.setSubscriptions.get(obj.context)?.get(obj.prop)?.forEach((cb) => cb({\n      type: \"replace\"\n    }));\n  } else {\n    context.ctx.changeSubscriptions.get(obj.context)?.forEach((cb) => cb({type: \"create\", prop: obj.prop}));\n  }\n}\nconst arrayChange = new Set([\n  [].push,\n  [].pop,\n  [].shift,\n  [].unshift,\n  [].splice,\n  [].reverse,\n  [].sort,\n  [].copyWithin\n]);\nconst literalRegex = /(\\$\\$)*(\\$)?\\${(\\d+)}/g;\ntype OpCallback = (exec: Execution, done: Done, a: LispItem, b: LispItem, obj: Prop|any|undefined, context: IExecContext, scope: Scope, bobj?: Prop|any|undefined) => void;\nlet ops2: {[op:string]: OpCallback} = {\n  'prop': (exec, done, a: LispItem|any, b: string, obj, context, scope) => {\n    if(a === null) {\n      throw new TypeError(`Cannot get property ${b} of null`);\n    }\n    const type = typeof a;\n    if (type === 'undefined' && obj === undefined) {\n      let prop = scope.get(b);\n      if (prop.context === undefined) throw new ReferenceError(`${b} is not defined`);\n      if (prop.context === context.ctx.sandboxGlobal) {\n        if (context.ctx.options.audit) {\n          context.ctx.auditReport.globalsAccess.add(b);\n        }\n        const rep = context.ctx.globalsWhitelist.has(context.ctx.sandboxGlobal[b]) ? context.ctx.evals.get(context.ctx.sandboxGlobal[b]) : undefined;\n        if (rep) {\n          done(undefined, rep);\n          return;\n        }\n      }\n      if (prop.context && prop.context[b] === globalThis) {\n        done(undefined, context.ctx.globalScope.get('this'));\n        return;\n      }\n\n      context.ctx.getSubscriptions.forEach((cb) => cb(prop.context, prop.prop));\n      done(undefined, prop);\n      return;\n    } else if (a === undefined) {\n      throw new SandboxError(\"Cannot get property '\" + b + \"' of undefined\")\n    }\n\n    if (type !== 'object') {\n      if(type === 'number') {\n        a = new Number(a);\n      } else if(type === 'string') {\n        a = new String(a);\n      } else if(type === 'boolean') {\n        a = new Boolean(a);\n      }\n    } else if (typeof a.hasOwnProperty === 'undefined') {\n      done(undefined, new Prop(undefined, b));\n      return;\n    }\n\n    const isFunction = type === 'function';\n    let prototypeAccess = isFunction || !(a.hasOwnProperty(b) || typeof b === 'number');\n\n    if (context.ctx.options.audit && prototypeAccess) {\n      if (typeof b === 'string') {\n        let prot = a.constructor.prototype;\n        do {\n          if (prot.hasOwnProperty(b)) {\n            if(!context.ctx.auditReport.prototypeAccess[prot.constructor.name]) {\n              context.ctx.auditReport.prototypeAccess[prot.constructor.name] = new Set();\n            }\n            context.ctx.auditReport.prototypeAccess[prot.constructor.name].add(b);\n          }\n        } while(prot = Object.getPrototypeOf(prot))\n      }\n    }\n\n    if (prototypeAccess) {\n      if (isFunction) {\n        if (!['name', 'length', 'constructor'].includes(b) && a.hasOwnProperty(b)) {\n          const whitelist = context.ctx.options.prototypeWhitelist.get(a);\n          const replace = context.ctx.options.prototypeReplacements.get(a);\n          if (replace) {\n            done(undefined, new Prop(replace(a, true), b));\n            return;\n          }\n          if (whitelist && (!whitelist.size || whitelist.has(b))) {\n          } else {\n            throw new SandboxError(`Static method or property access not permitted: ${a.name}.${b}`);\n          }\n        }\n      } else if (b !== 'constructor') {\n        let prot = a.constructor.prototype;\n        do {\n          if (prot.hasOwnProperty(b)) {\n            const whitelist = context.ctx.options.prototypeWhitelist.get(prot.constructor);\n            const replace = context.ctx.options.prototypeReplacements.get(prot.constuctor);\n            if (replace) {\n              done(undefined, new Prop(replace(a, false), b));\n              return;\n            }\n            if (whitelist && (!whitelist.size || whitelist.has(b))) {\n              break;\n            }\n            throw new SandboxError(`Method or property access not permitted: ${prot.constructor.name}.${b}`);\n          }\n        } while(prot = Object.getPrototypeOf(prot));\n      }\n    }\n\n    const rep = context.ctx.globalsWhitelist.has(a[b]) ? context.ctx.evals.get(a[b]) : undefined;\n    if (rep) {\n      done(undefined, rep);\n      return;\n    }\n    if (a[b] === globalThis) {\n      done(undefined, context.ctx.globalScope.get('this'));\n      return;\n    }\n\n    let g = obj.isGlobal || (isFunction && !sandboxedFunctions.has(a)) || context.ctx.globalsWhitelist.has(a);\n\n    if (!g) {\n      context.ctx.getSubscriptions.forEach((cb) => cb(a, b));\n    }\n    done(undefined, new Prop(a, b, false, g));\n  },\n  'call': (exec, done, a, b: LispItem[], obj, context, scope) => {\n    if (context.ctx.options.forbidMethodCalls) throw new SandboxError(\"Method calls are not allowed\");\n    if (typeof a !== 'function') {\n      throw new TypeError(`${obj.prop} is not a function`);\n    }\n    const args = b.map((item) => {\n      if (item instanceof SpreadArray) {\n        return [...item.item];\n      } else {\n        return [item];\n      }\n    }).flat();\n    execMany(exec, args, (err, vals) => {\n      if (err) {\n        done(err);\n        return;\n      }\n      if (typeof obj === 'function') {\n        done(undefined, obj(...vals));\n        return;\n      }\n      if (obj.context[obj.prop] === JSON.stringify && context.ctx.getSubscriptions.size) {\n        const cache = new Set<any>();\n        const recurse = (x: any) => {\n          if (!x || !(typeof x === 'object') || cache.has(x)) return;\n          cache.add(x);\n          for (let y in x) {\n            context.ctx.getSubscriptions.forEach((cb) => cb(x, y));\n            recurse(x[y]);\n          }\n        };\n        recurse(vals[0]);\n      }\n  \n      if (obj.context instanceof Array && arrayChange.has(obj.context[obj.prop]) && context.ctx.changeSubscriptions.get(obj.context)) {\n        let change: Change;\n        let changed = false;\n        if (obj.prop === \"push\") {\n          change = {\n            type: \"push\",\n            added: vals\n          }\n          changed = !!vals.length;\n        } else if (obj.prop === \"pop\") {\n          change = {\n            type: \"pop\",\n            removed: obj.context.slice(-1)\n          }\n          changed = !!change.removed.length;\n        }  else if (obj.prop === \"shift\") {\n          change = {\n            type: \"shift\",\n            removed: obj.context.slice(0, 1)\n          }\n          changed = !!change.removed.length;\n        } else if (obj.prop === \"unshift\") {\n          change = {\n            type: \"unshift\",\n            added: vals\n          }\n          changed = !!vals.length;\n        } else if (obj.prop === \"splice\") {\n          change = {\n            type: \"splice\",\n            startIndex: vals[0],\n            deleteCount: vals[1] === undefined ? obj.context.length : vals[1],\n            added: vals.slice(2),\n            removed: obj.context.slice(vals[0], vals[1] === undefined ? undefined : vals[0] + vals[1])\n          }\n          changed = !!change.added.length || !!change.removed.length;\n        } else if (obj.prop === \"reverse\" || obj.prop === \"sort\") {\n          change = {type: obj.prop}\n          changed = !!obj.context.length;\n        } else if (obj.prop === \"copyWithin\") {\n          let len = vals[2] === undefined ? obj.context.length - vals[1] : Math.min(obj.context.length, vals[2] - vals[1]);\n          change = {\n            type: \"copyWithin\",\n            startIndex: vals[0],\n            endIndex: vals[0] + len,\n            added: obj.context.slice(vals[1], vals[1] + len),\n            removed: obj.context.slice(vals[0], vals[0] + len)\n          }\n          changed = !!change.added.length || !!change.removed.length;\n        }\n        if (changed) {\n          context.ctx.changeSubscriptions.get(obj.context)?.forEach((cb) => cb(change));\n        }\n      }\n      done(undefined, obj.context[obj.prop](...vals));\n    }, scope, context);\n  },\n  'createObject': (exec, done, a, b: (KeyVal|SpreadObject)[], obj, context, scope) => {\n    let res = {} as any;\n    for (let item of b) {\n      if (item instanceof SpreadObject) {\n        res = {...res, ...item.item};\n      } else {\n        res[item.key] = item.val;\n      }\n    }\n    done(undefined, res);\n  },\n  'keyVal': (exec, done, a: string, b: LispItem) => done(undefined, new KeyVal(a, b)),\n  'createArray': (exec, done, a, b: LispItem[], obj, context, scope) => {\n    const items = b.map((item) => {\n      if (item instanceof SpreadArray) {\n        return [...item.item];\n      } else {\n        return [item];\n      }\n    }).flat()\n    execMany(exec, items, done, scope, context);\n  },\n  'group': (exec, done, a, b) => done(undefined, b),\n  'string': (exec, done, a, b: string, obj, context) => done(undefined, context.constants.strings[b]),\n  'regex': (exec, done, a, b: string, obj, context) => {\n    const reg: IRegEx = context.constants.regexes[b];\n    if (!context.ctx.globalsWhitelist.has(RegExp)) {\n      throw new SandboxError(\"Regex not permitted\");\n    } else {\n      done(undefined, new RegExp(reg.regex, reg.flags));\n    }\n  },\n  'literal': (exec, done, a, b: number, obj, context, scope) => {\n    let name: string = context.constants.literals[b].a;\n    let found = [];\n    let f;\n    let resnums = [];\n    while(f = literalRegex.exec(name)) {\n      if (!f[2]) {\n        found.push(context.constants.literals[b].b[parseInt(f[3], 10)]);\n        resnums.push(f[3]);\n      }\n    }\n\n    execMany(exec, found, (err, processed) => {\n      const reses = {};\n      if(err) {\n        done(err);\n        return;\n      }\n      for (let i in resnums) {\n        const num = resnums[i];\n        reses[num] = processed[i];\n      }\n      done(undefined, name.replace(/(\\\\\\\\)*(\\\\)?\\${(\\d+)}/g, (match, $$, $, num) => {\n        if ($) return match;\n        let res = reses[num]\n        res =  res instanceof Prop ? res.context[res.prop] : res;\n        return ($$ ? $$ : '') + `${res}`;\n      }));\n    }, scope, context)\n  },\n  'spreadArray': (exec, done, a, b, obj, context, scope) => {\n    exec(b, scope, context, (err, res) => {\n      if (err) {\n        done(err);\n        return;\n      }\n      done(undefined, new SpreadArray(res));\n    });\n  },\n  'spreadObject': (exec, done, a, b, obj, context, scope) => {\n    exec(b, scope, context, (err, res) => {\n      if (err) {\n        done(err);\n        return;\n      }\n      done(undefined, new SpreadObject(res));\n    });\n  },\n  '!': (exec, done, a, b) => done(undefined, !b),\n  '~': (exec, done, a, b) => done(undefined, ~b),\n  '++$': (exec, done, a, b, obj, context) => {\n    assignCheck(obj, context);\n    done(undefined, ++obj.context[obj.prop]);\n  },\n  '$++': (exec, done, a, b, obj, context) => {\n    assignCheck(obj, context);\n    done(undefined, obj.context[obj.prop]++);\n  },\n  '--$': (exec, done, a, b, obj, context) => {\n    assignCheck(obj, context);\n    done(undefined, --obj.context[obj.prop]);\n  },\n  '$--': (exec, done, a, b, obj, context) => {\n    assignCheck(obj, context);\n    done(undefined, obj.context[obj.prop]--);\n  },\n  '=': (exec, done, a, b, obj, context) => {\n    assignCheck(obj, context);\n    obj.context[obj.prop] = b;\n    done(undefined, new Prop(obj.context, obj.prop, false, obj.isGlobal));\n  },\n  '+=': (exec, done, a, b, obj, context) => {\n    assignCheck(obj, context);\n    done(undefined, obj.context[obj.prop] += b);\n  },\n  '-=': (exec, done, a, b: number, obj, context) => {\n    assignCheck(obj, context);\n    done(undefined, obj.context[obj.prop] -= b);\n  },\n  '/=': (exec, done, a, b: number, obj, context) => {\n    assignCheck(obj, context);\n    done(undefined, obj.context[obj.prop] /= b);\n  },\n  '*=': (exec, done, a, b: number, obj, context) => {\n    assignCheck(obj, context);\n    done(undefined, obj.context[obj.prop] *= b);\n  },\n  '**=': (exec, done, a, b: number, obj, context) => {\n    assignCheck(obj, context);\n    done(undefined, obj.context[obj.prop] **= b);\n  },\n  '%=': (exec, done, a, b: number, obj, context) => {\n    assignCheck(obj, context);\n    done(undefined, obj.context[obj.prop] %= b);\n  },\n  '^=': (exec, done, a, b: number, obj, context) => {\n    assignCheck(obj, context);\n    done(undefined, obj.context[obj.prop] ^= b);\n  },\n  '&=': (exec, done, a, b: number, obj, context) => {\n    assignCheck(obj, context);\n    done(undefined, obj.context[obj.prop] &= b);\n  },\n  '|=': (exec, done, a, b: number, obj, context) => {\n    assignCheck(obj, context);\n    done(undefined, obj.context[obj.prop] |= b);\n  },\n  '<<=': (exec, done, a, b: number, obj, context) => {\n    assignCheck(obj, context);\n    done(undefined, obj.context[obj.prop] <<= b);\n  },\n  '>>=': (exec, done, a, b: number, obj, context) => {\n    assignCheck(obj, context);\n    done(undefined, obj.context[obj.prop] >>= b);\n  },\n  '>>>=': (exec, done, a, b: number, obj, context) => {\n    assignCheck(obj, context);\n    done(undefined, obj.context[obj.prop] >>= b);\n  },\n  '?': (exec, done, a, b) => {\n    if (!(b instanceof If)) {\n      throw new SyntaxError('Invalid inline if')\n    }\n    done(undefined, a ? (b as any).t : (b as any).f);\n  },\n  '>': (exec, done, a, b) => done(undefined, a > b),\n  '<': (exec, done, a, b) => done(undefined, a < b),\n  '>=': (exec, done, a, b) => done(undefined, a >= b),\n  '<=': (exec, done, a, b) => done(undefined, a <= b),\n  '==': (exec, done, a, b) => done(undefined, a == b),\n  '===': (exec, done, a, b) => done(undefined, a === b),\n  '!=': (exec, done, a, b) => done(undefined, a != b),\n  '!==': (exec, done, a, b) => done(undefined, a !== b),\n  '&&': (exec, done, a, b) => done(undefined, a && b),\n  '||': (exec, done, a, b) => done(undefined, a || b),\n  '&': (exec, done, a: number, b: number) => done(undefined, a & b),\n  '|': (exec, done, a: number, b: number) => done(undefined, a | b),\n  ':': (exec, done, a, b) => done(undefined, new If(a, b)),\n  '+': (exec, done, a: number, b: number) => done(undefined, a + b),\n  '-': (exec, done, a: number, b: number) => done(undefined, a - b),\n  '$+': (exec, done, a, b) => done(undefined, +b),\n  '$-': (exec, done, a, b) => done(undefined, -b),\n  '/': (exec, done, a: number, b: number) => done(undefined, a / b),\n  '^': (exec, done, a: number, b: number) => done(undefined, a ^ b),\n  '*': (exec, done, a: number, b: number) => done(undefined, a * b),\n  '%': (exec, done, a: number, b: number) => done(undefined, a % b),\n  '<<': (exec, done, a: number, b: number) => done(undefined, a << b),\n  '>>': (exec, done, a: number, b: number) => done(undefined, a >> b),\n  '>>>': (exec, done, a: number, b: number) => done(undefined, a >>> b),\n  'typeof': (exec, done, a, b) => done(undefined, typeof b),\n  'instanceof': (exec, done, a, b:  { new(): any }) => done(undefined, a instanceof b),\n  'in': (exec, done, a: string, b) => done(undefined, a in b),\n  'delete': (exec, done, a, b, obj, context, scope, bobj: Prop) => {\n    if (bobj.context === undefined) {\n      done(undefined, true);\n      return;\n    }\n    assignCheck(bobj, context, 'delete');\n    if (bobj.isVariable) {\n      done(undefined, false);\n      return;\n    }\n    done(undefined, delete bobj.context[bobj.prop]);\n  },\n  'return': (exec, done, a, b, obj, context) => done(undefined, b),\n  'var': (exec, done, a: string, b, obj, context, scope, bobj) => {\n    exec(b, scope, context, (err, res) => {\n      if (err) {\n        done(err);\n        return;\n      }\n      done(undefined, scope.declare(a, VarType.var, res));\n    });\n  },\n  'let': (exec, done, a: string, b, obj, context, scope, bobj) => {\n    exec(b, scope, context, (err, res) => {\n      if (err) {\n        done(err);\n        return;\n      }\n      done(undefined, scope.declare(a, VarType.let, res, bobj && bobj.isGlobal));\n    });\n  },\n  'const': (exec, done, a: string, b, obj, context, scope, bobj) => {\n    exec(b, scope, context, (err, res) => {\n      if (err) {\n        done(err);\n        return;\n      }\n      done(undefined, scope.declare(a, VarType.const, res));\n    });\n  },\n  'arrowFunc': (exec, done, a: string[], b: LispItem, obj, context, scope) => {\n    if (a.shift()) {\n      done(undefined, createFunctionAsync(a, b, context, scope));\n    } else {\n      done(undefined, createFunction(a, b, context, scope));\n    }\n  },\n  'function': (exec, done, a: string[], b: LispItem, obj, context, scope) => {\n    let isAsync = a.shift();\n    let name = a.shift();\n    let func;\n    if (isAsync) {\n      func = createFunctionAsync(a, b, context, scope, name);\n    } else {\n      func = createFunction(a, b, context, scope, name);\n    }\n    if (name) {\n      scope.declare(name, VarType.var, func);\n    }\n    done(undefined, func);\n  },\n  'inlineFunction': (exec, done, a: string[], b: LispItem, obj, context, scope) => {\n    let isAsync = a.shift();\n    let name = a.shift();\n    if (name) {\n      scope = new Scope(scope, {})\n    }\n    let func;\n    if (isAsync) {\n      func = createFunctionAsync(a, b, context, scope, name);\n    } else {\n      func = createFunction(a, b, context, scope, name);\n    }\n    if (name) {\n      scope.declare(name, VarType.let, func);\n    }\n    done(undefined, func);\n  },\n  'loop': (exec, done, a: LispItem[], b: LispItem, obj, context, scope) => {\n    const [checkFirst, startInternal, startStep, step, condition, beforeStep] = a;\n    let loop = true;\n    const loopScope = new Scope(scope, {});\n    const interalScope = new Scope(loopScope, {});\n    if (exec === execAsync) {\n      (async() => {\n        await asyncDone((d) => exec(startStep, loopScope, context, d));\n        await asyncDone((d) => exec(startInternal, interalScope, context, d));\n        if (checkFirst) loop = (await asyncDone((d) => exec(condition, interalScope, context, d))).result;\n        while (loop) {\n          let innerLoopVars = {};\n          await asyncDone((d) => exec(beforeStep, new Scope(interalScope, innerLoopVars), context, d));\n          let res = await executeTreeAsync(context, b, [new Scope(loopScope, innerLoopVars)], \"loop\");\n          if (res instanceof ExecReturn && res.returned) {\n            done(undefined, res);\n            return;\n          }\n          if (res instanceof ExecReturn && res.breakLoop) {\n            break;\n          }\n          await asyncDone((d) => exec(step, interalScope, context, d));\n          loop = (await asyncDone((d) => exec(condition, interalScope, context, d))).result;\n        }\n        done();\n      })().catch(done);\n    } else {\n      syncDone((d) => exec(startStep, loopScope, context, d));\n      syncDone((d) => exec(startInternal, interalScope, context, d));\n      if (checkFirst) loop = (syncDone((d) => exec(condition, interalScope, context, d))).result;\n      while (loop) {\n        let innerLoopVars = {};\n        syncDone((d) => exec(beforeStep, new Scope(interalScope, innerLoopVars), context, d));\n        let res = executeTree(context, b, [new Scope(loopScope, innerLoopVars)], \"loop\");\n        if (res instanceof ExecReturn && res.returned) {\n          done(undefined, res);\n          return;\n        }\n        if (res instanceof ExecReturn && res.breakLoop) {\n          break;\n        }\n        syncDone((d) => exec(step, interalScope, context, d));\n        loop = (syncDone((d) => exec(condition, interalScope, context, d))).result;\n      }\n      done();\n    }\n  },\n  'loopAction': (exec, done, a: LispItem, b: LispItem, obj, context, scope) => {\n    if ((context.inLoopOrSwitch === \"switch\" && a === \"continue\") || !context.inLoopOrSwitch) {\n      throw new SandboxError(\"Illegal \" + a + \" statement\");\n    }\n    done(undefined, new ExecReturn(context.ctx.auditReport, undefined, false, a === \"break\", a === \"continue\"));\n  },\n  'if': (exec, done, a: LispItem, b: If, obj, context, scope) => {\n    if (!(b instanceof If)) {\n      throw new SyntaxError('Invalid if')\n    }\n    exec(a, scope, context, (err, res) => {\n      if (err) {\n        done(err);\n        return;\n      }\n      executeTreeWithDone(exec, done, context, res ? b.t : b.f, [new Scope(scope)], context.inLoopOrSwitch);\n    });\n  },\n  'switch': (exec, done, a: LispItem, b: Lisp[], obj, context, scope) => {\n    exec(a, scope, context, (err, toTest) => {\n      if (err) {\n        done(err);\n        return;\n      }\n      if (exec === execSync) {\n        let res: ExecReturn;\n        let isTrue = false;\n        for (let caseItem of b) {\n          if (isTrue || (isTrue = !caseItem.a || toTest === valueOrProp((syncDone((d) => exec(caseItem.a, scope, context, d))).result))) {\n            if (!caseItem.b) continue;\n            res = executeTree(context, caseItem.b, [scope], \"switch\");\n            if (res.breakLoop) break;\n            if (res.returned) {\n              done(undefined, res);\n              return;\n            }\n            if (!caseItem.a) { // default case\n              break;\n            }\n          }\n        }\n        done();\n      } else {\n        (async () => {\n          let res: ExecReturn;\n          let isTrue = false;\n          for (let caseItem of b) {\n            if (isTrue || (isTrue = !caseItem.a || toTest === valueOrProp((await asyncDone((d) => exec(caseItem.a, scope, context, d))).result))) {\n              if (!caseItem.b) continue;\n              res = await executeTreeAsync(context, caseItem.b, [scope], \"switch\");\n              if (res.breakLoop) break;\n              if (res.returned) {\n                done(undefined, res);\n                return;\n              }\n              if (!caseItem.a) { // default case\n                break;\n              }\n            }\n          }\n          done();\n        })().catch(done)\n      }\n    });\n  },\n  'try': (exec, done, a: LispItem, b: [string, LispItem, LispItem], obj, context, scope) => {\n    const [exception, catchBody, finallyBody] = b;\n    executeTreeWithDone(exec, (err, res) => {\n      executeTreeWithDone(exec, (e) => {\n        if (e) done(e);\n        else  if (err) {\n          let sc = {};\n          if (exception) sc[exception] = err;\n          executeTreeWithDone(exec, done, context, catchBody, [new Scope(scope)], context.inLoopOrSwitch);\n        } else {\n          done(undefined, res);\n        }\n      }, context, finallyBody, [new Scope(scope, {})]);\n    }, context, a, [new Scope(scope)], context.inLoopOrSwitch);\n  },\n  'void': (exec, done, a) => {done()},\n  'new': (exec, done, a: new (...args: any[]) => any, b: any[], obj, context) => {\n    if (!context.ctx.globalsWhitelist.has(a) && !sandboxedFunctions.has(a)) {\n      throw new SandboxError(`Object construction not allowed: ${a.constructor.name}`)\n    }\n    done(undefined, new a(...b))\n  },\n  'throw': (exec, done, a) => { done(a) },\n  'multi': (exec, done, a: any[], b, obj, context, scope) => done(undefined, a.pop())\n}\n\nlet ops = new Map<string, OpCallback>();\nfor (let op in ops2) {\n  ops.set(op, ops2[op]);\n}\n\nfunction valueOrProp(a: any) {\n  if (a instanceof Prop) return a.context[a.prop];\n  return a;\n}\n\nfunction execMany(exec: Execution, tree: LispItem[], done: Done, scope: Scope, context: IExecContext) {\n  let ret = [];\n  let i = 0;\n  if (!tree.length) {\n    done(undefined, []);\n    return;\n  }\n  const next = (err, res) => {\n    if (err) {\n      done(err);\n      return;\n    }\n    ret.push(res);\n    if (++i < tree.length) {\n      exec(tree[i], scope, context, next);\n    } else {\n      done(undefined, ret);\n    }\n  }\n  exec(tree[i], scope, context, next);\n}\n\ntype Execution = (tree: LispItem, scope: Scope, context: IExecContext, done: Done) => void\n\nfunction asyncDone(callback: (done: Done) => void): Promise<{result: any}> {\n  return new Promise((resolve, reject) => {\n    callback((err, result) => {\n      if (err) reject(err);\n      else resolve({result});\n    });\n  });\n}\n\nfunction syncDone(callback: (done: Done) => void): {result: any} {\n  let result;\n  let err;\n  callback((e, r) => {\n    err = e;\n    result = r;\n  });\n  // console.log(result);\n  if (err) throw err;\n  return {result};\n}\n\nasync function execAsync(tree: LispItem, scope: Scope, context: IExecContext, done: Done): Promise<any> {\n  let result;\n  try {\n    if (tree instanceof Prop) {\n      result = tree.context[tree.prop];\n    } else if (Array.isArray(tree)) {\n      let res: any[]|ExecReturn = [];\n      for (let item of tree) {\n        const ret = (await asyncDone((done) => execAsync(item, scope, context, done))).result;\n        if (ret instanceof ExecReturn) {\n          res.push(ret.result);\n          if (ret.returned || ret.breakLoop || ret.continueLoop) {\n            res = ret;\n            break;\n          }\n        } else {\n          res.push(ret);\n        }\n      }\n      result =  res;\n    } else if (!(tree instanceof Lisp)) {\n      result = tree;\n    } else if (['arrowFunc', 'function', 'inlineFunction', 'loop', 'try', 'switch', 'if'].includes(tree.op)) {\n      result = (await asyncDone((d) => ops.get(tree.op)(execAsync, d, tree.a, tree.b, undefined, context, scope))).result;\n    } else if (tree.op === 'await') {\n      result = await (await asyncDone((done) => execAsync(tree.a, scope, context, done))).result;\n    } else {\n      let obj = (await asyncDone((done) => execAsync(tree.a, scope, context, done))).result;\n      let a = obj instanceof Prop ? (obj.context ? obj.context[obj.prop] : undefined) : obj;\n      let bobj = (await asyncDone((done) => execAsync(tree.b, scope, context, done))).result;\n      let b = bobj instanceof Prop ? (bobj.context ? bobj.context[bobj.prop] : undefined) : bobj;\n      if (ops.has(tree.op)) {\n        result = (await asyncDone((d) => ops.get(tree.op)(execAsync, d, a, b, obj, context, scope, bobj))).result;\n      } else {\n        throw new SyntaxError('Unknown operator: ' + tree.op);\n      }\n    }\n    done(undefined, result);\n  } catch (err) {\n    done(err);\n  }\n}\n\nfunction syncDoneExec(tree: LispItem, scope: Scope, context: IExecContext) {\n  let result;\n  let err;\n  execSync(tree, scope, context, (e, r) => {\n    err = e;\n    result = r;\n  });\n  if (err) throw err;\n  return {result}\n}\n\nfunction syncDoneOp(op: string, a: LispItem, b: LispItem, obj: Prop|any|undefined, context: IExecContext, scope: Scope, bobj?: Prop|any|undefined) {\n  let result;\n  let err;\n  ops.get(op)(execSync, (e, r) => {\n    err = e;\n    result = r;\n  }, a, b , obj, context, scope, bobj);\n  if (err) throw err;\n  return {result}\n}\n\nfunction execSync(tree: LispItem, scope: Scope, context: IExecContext, done: Done): any {\n  let result;\n  if (tree instanceof Prop) {\n    result = tree.context[tree.prop];\n  } else if (Array.isArray(tree)) {\n    let res: any[]|ExecReturn = [];\n    for (let item of tree) {\n      const ret = syncDoneExec(item, scope, context).result;\n      if (ret instanceof ExecReturn) {\n        res.push(ret.result);\n        if (ret.returned || ret.breakLoop || ret.continueLoop) {\n          res = ret;\n          break;\n        }\n      } else {\n        res.push(ret);\n      }\n    }\n    result =  res;\n  } else if (!(tree instanceof Lisp)) {\n    result = tree;\n  } else if (['arrowFunc', 'function', 'inlineFunction', 'loop', 'try', 'switch', 'if'].includes(tree.op)) {\n    result = syncDoneOp(tree.op, tree.a, tree.b, undefined, context, scope).result;\n  } else if (tree.op === 'await') {\n      throw new SandboxError(\"Illegal use of 'await', must be inside async function\");\n  } else {\n    let obj = syncDoneExec(tree.a, scope, context).result;\n    let a = obj instanceof Prop ? (obj.context ? obj.context[obj.prop] : undefined) : obj;\n    let bobj = syncDoneExec(tree.b, scope, context).result;\n    let b = bobj instanceof Prop ? (bobj.context ? bobj.context[bobj.prop] : undefined) : bobj;\n    if (ops.has(tree.op)) {\n      result = syncDoneOp(tree.op, a, b, obj, context, scope, bobj).result;\n    } else {\n      throw new SyntaxError('Unknown operator: ' + tree.op);\n    }\n  }\n  done(undefined, result);\n}\n\nexport function executeTree(context: IExecContext, executionTree: LispItem, scopes: ({[key:string]: any}|Scope)[] = [], inLoopOrSwitch?: string): ExecReturn {\n  return syncDone((done) => executeTreeWithDone(execSync, done, context, executionTree, scopes, inLoopOrSwitch)).result;\n}\n\nexport async function executeTreeAsync(context: IExecContext, executionTree: LispItem, scopes: ({[key:string]: any}|Scope)[] = [], inLoopOrSwitch?: string): Promise<ExecReturn> {\n  return (await asyncDone((done) => executeTreeWithDone(execAsync, done, context, executionTree, scopes, inLoopOrSwitch))).result;\n}\n\nfunction executeTreeWithDone(exec: Execution, done: Done, context: IExecContext, executionTree: LispItem, scopes: ({[key:string]: any}|Scope)[] = [], inLoopOrSwitch?: string) {\n  if (!executionTree)  {\n    done();\n    return;\n  }\n  if (!(executionTree instanceof Array)) throw new SyntaxError('Bad execution tree')\n  context = {\n    ctx: context.ctx,\n    constants: context.constants, \n    inLoopOrSwitch\n  };\n  let scope = context.ctx.globalScope;\n  let s;\n  while (s = scopes.shift()) {\n    if (typeof s !== \"object\") continue;\n    if (s instanceof Scope) {\n      scope = s;\n    } else {\n      scope = new Scope(scope, s, null);\n    }\n  }\n  if (context.ctx.options.audit && !context.ctx.auditReport) {\n    context.ctx.auditReport = {\n      globalsAccess: new Set(),\n      prototypeAccess: {},\n    }\n  }\n  let i = 0;\n  let current = executionTree[i];\n  const next = (err, res) => {\n    if (err) {\n      done(new err.constructor(err.message));\n      return;\n    }\n    if (res instanceof ExecReturn) {\n      done(undefined, res);\n      return;\n    }\n    if (current instanceof Lisp && current.op === 'return') {\n      done(undefined, new ExecReturn(context.ctx.auditReport, res, true))\n      return;\n    }\n    if (++i < executionTree.length) {\n      current = executionTree[i];\n      try {\n        exec(current, scope, context, next);\n      } catch (e) {\n        done(e);\n      }\n    } else {\n      done(undefined, new ExecReturn(context.ctx.auditReport, undefined, false));\n    }\n  }\n  try {\n    exec(current, scope, context, next);\n  } catch (e) {\n    done(e);\n  }\n}\n","import { \n  IGlobals, \n  replacementCallback, \n  IAuditReport, \n  Scope, \n  Change, \n  sandboxFunction,\n  sandboxedEval,\n  sandboxedSetTimeout,\n  sandboxedSetInterval,\n  ExecReturn,\n  executeTree,\n  executeTreeAsync\n} from \"./executor.js\";\nimport { IConstants, parse, IExecutionTree } from \"./parser.js\";\n\nexport interface IOptions {\n  audit?: boolean;\n  forbidMethodCalls?: boolean;\n  prototypeReplacements?: Map<Function, replacementCallback>;\n  prototypeWhitelist?: Map<Function, Set<string>>;\n  globals: IGlobals;\n}\n\nexport interface IContext {\n  sandbox: Sandbox;\n  globalScope: Scope;\n  sandboxGlobal: SandboxGlobal;\n  globalsWhitelist?: Set<any>;\n  options: IOptions;\n  evals: Map<any, any>;\n  getSubscriptions: Set<(obj: object, name: string) => void>;\n  setSubscriptions: WeakMap<object, Map<string, Set<(modification: Change) => void>>>;\n  changeSubscriptions: WeakMap<object, Set<(modification: Change) => void>>;\n  auditReport?: IAuditReport;\n}\n\nexport interface IExecContext {\n  ctx: IContext\n  inLoopOrSwitch?: string;\n  constants: IConstants\n}\n\nexport class SandboxGlobal {\n  constructor(globals: IGlobals) {\n    if (globals === globalThis) return globalThis;\n    for (let i in globals) {\n      (this as any)[i] = globals[i];\n    }\n  }\n}\n\nexport default class Sandbox {\n  context: IContext\n  constructor(options?: IOptions) {\n    options = Object.assign({\n      audit: false,\n      forbidMethodCalls: false,\n      globals: Sandbox.SAFE_GLOBALS,\n      prototypeWhitelist: Sandbox.SAFE_PROTOTYPES, \n      prototypeReplacements: new Map<Function, replacementCallback>()\n    }, options || {});\n    const sandboxGlobal = new SandboxGlobal(options.globals);\n    this.context = {\n      sandbox: this,\n      globalsWhitelist: new Set(Object.values(options.globals)),\n      options,\n      globalScope: new Scope(null, options.globals, sandboxGlobal),\n      sandboxGlobal,\n      evals: new Map(),\n      getSubscriptions: new Set<(obj: object, name: string) => void>(),\n      setSubscriptions: new WeakMap<object, Map<string, Set<() => void>>>(),\n      changeSubscriptions: new WeakMap()\n    };\n    const func = sandboxFunction(this.context);\n    this.context.evals.set(Function, func);\n    this.context.evals.set(eval, sandboxedEval(func));\n    this.context.evals.set(setTimeout, sandboxedSetTimeout(func));\n    this.context.evals.set(setInterval, sandboxedSetInterval(func));\n  }\n\n  static get SAFE_GLOBALS(): IGlobals {\n    return {\n      Function,\n      console: {\n        debug: console.debug, \n        error: console.error, \n        info: console.info, \n        log: console.log, \n        table: console.table, \n        warn: console.warn\n      },\n      isFinite,\n      isNaN,\n      parseFloat,\n      parseInt,\n      decodeURI,\n      decodeURIComponent,\n      encodeURI,\n      encodeURIComponent,\n      escape,\n      unescape,\n      Boolean,\n      Number,\n      String,\n      Object,\n      Array,\n      Symbol,\n      Error,\n      EvalError,\n      RangeError,\n      ReferenceError,\n      SyntaxError,\n      TypeError,\n      URIError,\n      Int8Array,\n      Uint8Array,\n      Uint8ClampedArray,\n      Int16Array,\n      Uint16Array,\n      Int32Array,\n      Uint32Array,\n      Float32Array,\n      Float64Array,\n      Map,\n      Set,\n      WeakMap,\n      WeakSet,\n      Promise,\n      Intl,\n      JSON,\n      Math,\n      Date,\n      RegExp\n    }\n  }\n\n  \n  static get SAFE_PROTOTYPES(): Map<any, Set<string>> {\n    let protos = [\n      SandboxGlobal,\n      Function,\n      Boolean,\n      Number,\n      String,\n      Date,\n      Error,\n      Array,\n      Int8Array,\n      Uint8Array,\n      Uint8ClampedArray,\n      Int16Array,\n      Uint16Array,\n      Int32Array,\n      Uint32Array,\n      Float32Array,\n      Float64Array,\n      Map,\n      Set,\n      WeakMap,\n      WeakSet,\n      Promise,\n      Symbol,\n      Date,\n      RegExp\n    ]\n    let map = new Map<any, Set<string>>();\n    protos.forEach((proto) => {\n      map.set(proto, new Set());\n    });\n    map.set(Object, new Set([\n      'entries',\n      'fromEntries',\n      'getOwnPropertyNames',\n      'is',\n      'keys',\n      'hasOwnProperty',\n      'isPrototypeOf',\n      'propertyIsEnumerable',\n      'toLocaleString',\n      'toString',\n      'valueOf',\n      'values'\n    ]));\n    return map;\n  }\n  \n  subscribeGet(callback: (obj: object, name: string) => void): {unsubscribe: () => void} {\n    this.context.getSubscriptions.add(callback);\n    return {unsubscribe: () => this.context.getSubscriptions.delete(callback)}\n  }\n\n  subscribeSet(obj: object, name: string, callback: (modification: Change) => void): {unsubscribe: () => void} {\n    const names = this.context.setSubscriptions.get(obj) || new Map<string, Set<(modification: Change) => void>>();\n    this.context.setSubscriptions.set(obj, names);\n    const callbacks = names.get(name) || new Set();\n    names.set(name, callbacks);\n    callbacks.add(callback);\n    let changeCbs: Set<(modification: Change) => void>;\n    if (obj && obj[name] && typeof obj[name] === \"object\") {\n      changeCbs = this.context.changeSubscriptions.get(obj[name]) || new Set();\n      changeCbs.add(callback);\n      this.context.changeSubscriptions.set(obj[name], changeCbs);\n    }\n    return {unsubscribe: () => {\n      callbacks.delete(callback);\n      if (changeCbs) changeCbs.delete(callback);\n    }}\n  }\n\n  static audit(code: string, scopes: ({[prop: string]: any}|Scope)[] = []): ExecReturn {\n    const globals = {};\n    for (let i of Object.getOwnPropertyNames(globalThis)) {\n      globals[i] = globalThis[i];\n    }\n    return new Sandbox({\n      globals,\n      audit: true,\n    }).executeTree(parse(code), scopes);\n  }\n\n  static parse(code: string) {\n    return parse(code);\n  }\n\n  executeTree(executionTree: IExecutionTree, scopes: ({[key:string]: any}|Scope)[] = []): ExecReturn {\n    return executeTree({\n      ctx: this.context,\n      constants: executionTree.constants\n    }, executionTree.tree, scopes);\n  }\n\n  executeTreeAsync(executionTree: IExecutionTree, scopes: ({[key:string]: any}|Scope)[] = []): Promise<ExecReturn> {\n    return executeTreeAsync({\n      ctx: this.context,\n      constants: executionTree.constants\n    }, executionTree.tree, scopes);\n  }\n  \n  compile(code: string): (...scopes: ({[prop: string]: any}|Scope)[]) => any {\n    const executionTree = parse(code);\n    return (...scopes: {[key:string]: any}[]) => {\n      return this.executeTree(executionTree, scopes).result;\n    };\n  };\n  \n  compileAsync(code: string): (...scopes: ({[prop: string]: any}|Scope)[]) => Promise<any> {\n    const executionTree = parse(code);\n    return async (...scopes: {[key:string]: any}[]) => {\n      return (await this.executeTreeAsync(executionTree, scopes)).result;\n    };\n  };\n}\n"],"names":["parseHexToInt","hex","match","parseInt","NaN","validateAndParseHex","errorName","enforcedLength","parsedHex","Number","isNaN","undefined","length","SyntaxError","parseHexadecimalCode","code","parsedCode","String","fromCharCode","parseUnicodeCode","surrogateCode","parsedSurrogateCode","isCurlyBraced","text","charAt","parseUnicodeCodePointCode","codePoint","slice","fromCodePoint","err","RangeError","singleCharacterEscapes","Map","parseSingleCharacterCode","get","escapeMatch","unraw","raw","replace","_","backslash","unicodeWithSurrogate","surrogate","unicode","octal","singleCharacter","lispTypes","ParseError","Error","[object Object]","message","super","this","Lisp","obj","op","a","b","If","t","f","KeyVal","key","val","SpreadObject","item","SpreadArray","inlineIfElse","space","expectTypes","splitter","types","split","next","inlineIf","assignment","assignModify","assign","incrementerBefore","expEdge","call","incrementerAfter","modifier","not","inverse","negative","positive","typeof","delete","dot","arrayProp","prop","value","createObject","createArray","number","string","literal","regex","boolean","null","und","arrowFunctionSingle","arrowFunction","inlineFunction","group","Infinity","void","await","new","throw","initialize","return","spreadObject","spreadArray","expEnd","expSingle","for","do","while","loopAction","if","try","function","switch","closings","(","[","{","'","\"","`","okFirstChars","aChar","aNumber","restOfExp","constants","part","tests","quote","firstOpening","closingsTests","details","allChars","isStart","i","escape","done","lastIsChar","currentIsChar","lastChar","word","char","test","substring","sub","lastIndex","found","exec","foundNumber","Math","min","setLispType","fn","forEach","type","set","closingsCreate","res","expect","ctx","extract","arg","end","push","l","funcFound","lispifyExpr","join","map","e","lispify","str","trimStart","lispTree","includes","trim","quoteCount","condition","isBlock","startTrue","trueBlock","elseBlock","foundElse","lispifyBlock","start","indexOf","caseFound","statement","insertSemicolons","caseTest","cases","defaultFound","cond","bracketFound","exprs","notEmpty","lines","index","matches","primitives","true","false","JSON","parse","isArrow","isReturn","argPos","isAsync","args","unshift","ended","startsWith","func","lispifyFunction","iteratorRegex","body","startStep","startInternal","beforeStep","checkFirst","step","iterator","extract2","k","ofStart2","ofStart3","ofCondition","ofStep","inStart2","inStart3","inStep","inCondition","shift","startingExecpted","catchReg","finallyBody","exception","catchBody","catchRes","offset","argsString","j","lastType","lastPart","expected","subExpressions","pos","defined","parts","filter","Boolean","flat","tree","hoisted","hoist","concat","Array","isArray","rep","it","edgesForInsertion","closingsForInsertion","closingsNoInsertion","whileEnding","rest","pop","oneLinerBlocks","convertOneLiners","nextIndex","c","semi","p","checkRegex","cancel","after","flags","notDivide","possibleDivide","extractConstants","currentEnclosure","regexFound","comment","commentStart","currJs","strRes","enclosures","isPossibleDivide","skip","literals","strings","regexes","js","ExecReturn","auditReport","result","returned","breakLoop","continueLoop","Prop","context","isConst","isGlobal","isVariable","reservedWords","Set","VarType","Scope","parent","vars","functionThis","isFuncScope","allVars","let","Object","keys","var","globals","functionScope","has","hasOwnProperty","const","ReferenceError","TypeError","SandboxError","declare","add","sandboxFunction","SandboxFunction","params","parsed","createFunction","sandboxedFunctions","WeakSet","argNames","scope","name","executeTree","createFunctionAsync","async","executeTreeAsync","sandboxedEval","sandboxedSetTimeout","handler","setTimeout","sandboxedSetInterval","setInterval","assignCheck","changeSubscriptions","cb","setSubscriptions","arrayChange","splice","reverse","sort","copyWithin","literalRegex","ops2","sandboxGlobal","options","audit","globalsAccess","globalsWhitelist","evals","globalThis","globalScope","getSubscriptions","isFunction","prototypeAccess","prot","constructor","prototype","getPrototypeOf","whitelist","prototypeWhitelist","prototypeReplacements","size","constuctor","g","forbidMethodCalls","execMany","vals","stringify","cache","recurse","x","y","change","changed","added","removed","startIndex","deleteCount","len","endIndex","keyVal","reg","RegExp","resnums","processed","reses","num","$$","$","!","~","++$","$++","--$","$--","=","+=","-=","/=","*=","**=","%=","^=","&=","|=","<<=",">>=",">>>=","?",">","<",">=","<=","==","===","!=","!==","&&","||","&","|",":","+","-","$+","$-","/","^","*","%","<<",">>",">>>","instanceof","in","bobj","arrowFunc","loop","loopScope","interalScope","execAsync","asyncDone","d","innerLoopVars","catch","syncDone","inLoopOrSwitch","executeTreeWithDone","toTest","execSync","isTrue","caseItem","valueOrProp","multi","ops","ret","callback","Promise","resolve","reject","r","syncDoneExec","syncDoneOp","executionTree","scopes","s","current","SandboxGlobal","Sandbox","SAFE_GLOBALS","SAFE_PROTOTYPES","sandbox","values","WeakMap","Function","eval","console","debug","error","info","log","table","warn","isFinite","parseFloat","decodeURI","decodeURIComponent","encodeURI","encodeURIComponent","unescape","Symbol","EvalError","URIError","Int8Array","Uint8Array","Uint8ClampedArray","Int16Array","Uint16Array","Int32Array","Uint32Array","Float32Array","Float64Array","Intl","Date","protos","proto","unsubscribe","names","callbacks","changeCbs","getOwnPropertyNames"],"mappings":"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"}