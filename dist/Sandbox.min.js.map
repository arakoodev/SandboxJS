{"version":3,"file":"Sandbox.min.js","sources":["../src/unraw.ts","../src/parser.ts","../src/executor.ts","../src/Sandbox.ts"],"sourcesContent":["/**\n * Parse a string as a base-16 number. This is more strict than `parseInt` as it\n * will not allow any other characters, including (for example) \"+\", \"-\", and\n * \".\".\n * @param hex A string containing a hexadecimal number.\n * @returns The parsed integer, or `NaN` if the string is not a valid hex\n * number.\n */\nfunction parseHexToInt(hex: string): number {\n  const isOnlyHexChars = !hex.match(/[^a-f0-9]/i);\n  return isOnlyHexChars ? parseInt(hex, 16) : NaN;\n}\n\n/**\n * Check the validity and length of a hexadecimal code and optionally enforces\n * a specific number of hex digits.\n * @param hex The string to validate and parse.\n * @param errorName The name of the error message to throw a `SyntaxError` with\n * if `hex` is invalid. This is used to index `errorMessages`.\n * @param enforcedLength If provided, will throw an error if `hex` is not\n * exactly this many characters.\n * @returns The parsed hex number as a normal number.\n * @throws {SyntaxError} If the code is not valid.\n */\nfunction validateAndParseHex(\n  hex: string,\n  errorName: string,\n  enforcedLength?: number\n): number {\n  const parsedHex = parseHexToInt(hex);\n  if (\n    Number.isNaN(parsedHex) ||\n    (enforcedLength !== undefined && enforcedLength !== hex.length)\n  ) {\n    throw new SyntaxError(errorName + ': ' + hex);\n  }\n  return parsedHex;\n}\n\n/**\n * Parse a two-digit hexadecimal character escape code.\n * @param code The two-digit hexadecimal number that represents the character to\n * output.\n * @returns The single character represented by the code.\n * @throws {SyntaxError} If the code is not valid hex or is not the right\n * length.\n */\nfunction parseHexadecimalCode(code: string): string {\n  const parsedCode = validateAndParseHex(\n    code,\n    'Malformed Hexadecimal',\n    2\n  );\n  return String.fromCharCode(parsedCode);\n}\n\n/**\n * Parse a four-digit Unicode character escape code.\n * @param code The four-digit unicode number that represents the character to\n * output.\n * @param surrogateCode Optional four-digit unicode surrogate that represents\n * the other half of the character to output.\n * @returns The single character represented by the code.\n * @throws {SyntaxError} If the codes are not valid hex or are not the right\n * length.\n */\nfunction parseUnicodeCode(code: string, surrogateCode?: string): string {\n  const parsedCode = validateAndParseHex(code, 'Malformed Unicode', 4);\n\n  if (surrogateCode !== undefined) {\n    const parsedSurrogateCode = validateAndParseHex(\n      surrogateCode,\n      'Malformed Unicode',\n      4\n    );\n    return String.fromCharCode(parsedCode, parsedSurrogateCode);\n  }\n\n  return String.fromCharCode(parsedCode);\n}\n\n/**\n * Test if the text is surrounded by curly braces (`{}`).\n * @param text Text to check.\n * @returns `true` if the text is in the form `{*}`.\n */\nfunction isCurlyBraced(text: string): boolean {\n  return text.charAt(0) === \"{\" && text.charAt(text.length - 1) === \"}\";\n}\n\n/**\n * Parse a Unicode code point character escape code.\n * @param codePoint A unicode escape code point, including the surrounding curly\n * braces.\n * @returns The single character represented by the code.\n * @throws {SyntaxError} If the code is not valid hex or does not have the\n * surrounding curly braces.\n */\nfunction parseUnicodeCodePointCode(codePoint: string): string {\n  if (!isCurlyBraced(codePoint)) {\n    throw new SyntaxError('Malformed Unicode: +' + codePoint);\n  }\n  const withoutBraces = codePoint.slice(1, -1);\n  const parsedCode = validateAndParseHex(\n    withoutBraces,\n    'Malformed Unicode'\n  );\n\n  try {\n    return String.fromCodePoint(parsedCode);\n  } catch (err) {\n    throw err instanceof RangeError\n      ? new SyntaxError('Code Point Limit:' + parsedCode)\n      : err;\n  }\n}\n\n/**\n * Map of unescaped letters to their corresponding special JS escape characters.\n * Intentionally does not include characters that map to themselves like \"\\'\".\n */\nconst singleCharacterEscapes = new Map<string, string>([\n  [\"b\", \"\\b\"],\n  [\"f\", \"\\f\"],\n  [\"n\", \"\\n\"],\n  [\"r\", \"\\r\"],\n  [\"t\", \"\\t\"],\n  [\"v\", \"\\v\"],\n  [\"0\", \"\\0\"]\n]);\n\n/**\n * Parse a single character escape sequence and return the matching character.\n * If none is matched, defaults to `code`.\n * @param code A single character code.\n */\nfunction parseSingleCharacterCode(code: string): string {\n  return singleCharacterEscapes.get(code) || code;\n}\n\n/**\n * Matches every escape sequence possible, including invalid ones.\n *\n * All capture groups (described below) are unique (only one will match), except\n * for 4, which can only potentially match if 3 does.\n *\n * **Capture Groups:**\n * 0. A single backslash\n * 1. Hexadecimal code\n * 2. Unicode code point code with surrounding curly braces\n * 3. Unicode escape code with surrogate\n * 4. Surrogate code\n * 5. Unicode escape code without surrogate\n * 6. Octal code _NOTE: includes \"0\"._\n * 7. A single character (will never be \\, x, u, or 0-3)\n */\nconst escapeMatch = /\\\\(?:(\\\\)|x([\\s\\S]{0,2})|u(\\{[^}]*\\}?)|u([\\s\\S]{4})\\\\u([^{][\\s\\S]{0,3})|u([\\s\\S]{0,4})|([0-3]?[0-7]{1,2})|([\\s\\S])|$)/g;\n\n/**\n * Replace raw escape character strings with their escape characters.\n * @param raw A string where escape characters are represented as raw string\n * values like `\\'` rather than `'`.\n * @param allowOctals If `true`, will process the now-deprecated octal escape\n * sequences (ie, `\\111`).\n * @returns The processed string, with escape characters replaced by their\n * respective actual Unicode characters.\n */\nexport function unraw(raw: string): string {\n  return raw.replace(escapeMatch, function(\n    _,\n    backslash?: string,\n    hex?: string,\n    codePoint?: string,\n    unicodeWithSurrogate?: string,\n    surrogate?: string,\n    unicode?: string,\n    octal?: string,\n    singleCharacter?: string\n  ): string {\n    // Compare groups to undefined because empty strings mean different errors\n    // Otherwise, `\\u` would fail the same as `\\` which is wrong.\n    if (backslash !== undefined) {\n      return \"\\\\\";\n    }\n    if (hex !== undefined) {\n      return parseHexadecimalCode(hex);\n    }\n    if (codePoint !== undefined) {\n      return parseUnicodeCodePointCode(codePoint);\n    }\n    if (unicodeWithSurrogate !== undefined) {\n      return parseUnicodeCode(unicodeWithSurrogate, surrogate);\n    }\n    if (unicode !== undefined) {\n      return parseUnicodeCode(unicode);\n    }\n    if (octal === \"0\") {\n      return \"\\0\";\n    }\n    if (octal !== undefined) {\n      throw new SyntaxError('Octal Deprecation: ' + octal);\n    }\n    if (singleCharacter !== undefined) {\n      return parseSingleCharacterCode(singleCharacter);\n    }\n    throw new SyntaxError('End of string');\n  });\n}\nexport default unraw;","import unraw from \"./unraw.js\";\nexport type LispArray = Array<LispItem>&{lisp: boolean}\nexport type LispItem = Lisp|If|KeyVal|SpreadArray|SpreadObject|(LispArray)|{new(): any }|(new (...args: any[]) => any)|String|Number|Boolean|null|undefined;\nexport interface ILiteral extends Lisp {\n  op: 'literal';\n  a: string;\n  b: LispArray;\n}\n\nexport interface IRegEx {\n  regex: string,\n  flags: string,\n  length: number\n}\n\nexport interface IConstants {\n  strings: string[];\n  literals: ILiteral[];\n  regexes: IRegEx[];\n  eager: boolean;\n}\n\nexport interface IExecutionTree {\n  tree: LispArray, \n  constants: IConstants\n}\n\ntype LispCallback = (strings: IConstants, type: string, parts: string, res: string[], expect: string, ctx: {lispTree: LispItem}) => any\nlet lispTypes: Map<string, LispCallback> = new Map();\n\nexport class ParseError extends Error {\n  constructor(message: string, public code: string) {\n    super(message);\n  }\n}\n\nexport class Lisp {\n  op: string;\n  a?: LispItem;\n  b?: LispItem;\n  constructor(obj: Lisp) {\n    this.op = obj.op;\n    this.a = obj.a;\n    this.b = obj.b;\n  }\n}\n\nexport class If {\n  constructor(public t: any, public f: any) {}\n}\n\nexport class KeyVal {\n  constructor(public key: string, public val: any) {}\n}\n\nexport class SpreadObject {\n  constructor(public item: {[key: string]: any}) {}\n}\n\nexport class SpreadArray {\n  constructor(public item: any[]) {}\n}\n\nexport function toLispArray(arr: LispItem[]): LispArray {\n  (arr as LispArray).lisp = true;\n  return arr as LispArray;\n}\n\nconst inlineIfElse =  /^:/;\nconst space = /^\\s/;\n\nexport let expectTypes: {[type:string]: {types: {[type:string]: RegExp}, next: string[]}} = {\n  splitter: {\n    types: {\n      split: /^(&&|&(?!&)|\\|\\||\\|(?!\\|)|<=|>=|<(?!<)|>(?!>)|!==|!=(?!\\=)|===|==(?!\\=)|\\+(?!\\+)|\\-(?!\\-)|\\^|<<|>>(?!>)|>>>|instanceof(?![\\w\\$\\_])|in(?![\\w\\$\\_]))(?!\\=)/,\n      op: /^(\\/|\\*\\*|\\*(?!\\*)|\\%)(?!\\=)/,\n    },\n    next: [\n      'modifier',\n      'value', \n      'prop', \n      'incrementerBefore',\n    ]\n  },\n  inlineIf: {\n    types: {\n      inlineIf: /^\\?/,\n    },\n    next: [\n      'expEnd'\n    ]\n  },\n  assignment: {\n    types: {\n      assignModify: /^(\\-=|\\+=|\\/=|\\*\\*=|\\*=|%=|\\^=|\\&=|\\|=|>>>=|>>=|<<=)/,\n      assign: /^(=)(?!=)/\n    },\n    next: [\n      'modifier',\n      'value', \n      'prop', \n      'incrementerBefore',\n    ]\n  },\n  incrementerBefore: {\n    types: {incrementerBefore: /^(\\+\\+|\\-\\-)/},\n    next: [\n      'prop',\n    ]\n  },\n  expEdge: {\n    types: {\n      call: /^[\\(]/,\n      incrementerAfter: /^(\\+\\+|\\-\\-)/\n    },\n    next: [\n      'splitter',\n      'expEdge',\n      'inlineIf',\n      'dot',\n      'expEnd'\n    ]\n  },\n  modifier: {\n    types: {\n      not: /^!/,\n      inverse: /^~/,\n      negative: /^\\-(?!\\-)/,\n      positive: /^\\+(?!\\+)/,\n      typeof: /^typeof(?![\\w\\$\\_])/,\n      delete: /^delete(?![\\w\\$\\_])/,\n    },\n    next: [\n      'modifier', \n      'value',\n      'prop',\n      'incrementerBefore',\n    ]\n  },\n  dot: {\n    types: {\n      arrayProp: /^[\\[]/,\n      dot: /^\\.(?!\\.)/\n    },\n    next: [\n      'splitter',\n      'assignment',\n      'expEdge',\n      'inlineIf',\n      'dot',\n      'expEnd'\n    ]\n  },\n  prop: {\n    types: {\n      prop: /^[a-zA-Z\\$\\_][a-zA-Z\\d\\$\\_]*/,\n    },\n    next: [\n      'splitter',\n      'assignment',\n      'expEdge',\n      'inlineIf',\n      'dot',\n      'expEnd'\n    ]\n  },\n  value: {\n    types: {\n      createObject: /^\\{/,\n      createArray: /^\\[/,\n      number: /^(0x[\\da-f]+|\\d+(\\.\\d+)?(e[\\+\\-]?\\d+)?)(?![\\d])/i,\n      string: /^\"(\\d+)\"/,\n      literal: /^`(\\d+)`/,\n      regex: /^\\/(\\d+)\\/r(?![\\w\\$\\_])/,\n      boolean: /^(true|false)(?![\\w\\$\\_])/,\n      null: /^null(?![\\w\\$\\_])/,\n      und: /^undefined(?![\\w\\$\\_])/,\n      arrowFunctionSingle: /^(async\\s+)?([a-zA-Z\\$_][a-zA-Z\\d\\$_]*)\\s*=>\\s*({)?/,\n      arrowFunction: /^(async\\s*)?\\(\\s*((\\.\\.\\.)?\\s*[a-zA-Z\\$_][a-zA-Z\\d\\$_]*(\\s*,\\s*(\\.\\.\\.)?\\s*[a-zA-Z\\$_][a-zA-Z\\d\\$_]*)*)?\\s*\\)\\s*=>\\s*({)?/,\n      inlineFunction: /^(async\\s+)?function(\\s*[a-zA-Z\\$_][a-zA-Z\\d\\$_]*)?\\s*\\(\\s*((\\.\\.\\.)?\\s*[a-zA-Z\\$_][a-zA-Z\\d\\$_]*(\\s*,\\s*(\\.\\.\\.)?\\s*[a-zA-Z\\$_][a-zA-Z\\d\\$_]*)*)?\\s*\\)\\s*{/,\n      group: /^\\(/,\n      NaN: /^NaN(?![\\w\\$\\_])/,\n      Infinity: /^Infinity(?![\\w\\$\\_])/,\n      void: /^void(?![\\w\\$\\_])\\s*/,\n      await: /^await(?![\\w\\$\\_])\\s*/,\n      new: /^new(?![\\w\\$\\_])\\s*/,\n      throw: /^throw(?![\\w\\$\\_])\\s*/\n    },\n    next: [\n      'splitter',\n      'expEdge',\n      'inlineIf',\n      'dot',\n      'expEnd'\n    ]\n  },\n  initialize: {\n    types: {\n      initialize: /^(var|let|const)\\s+([a-zA-Z\\$_][a-zA-Z\\d\\$_]*)\\s*(=)?/,\n      return: /^return(?![\\w\\$\\_])/,\n    },\n    next: [\n      'modifier',\n      'value', \n      'prop', \n      'incrementerBefore',\n      'expEnd'\n    ]\n  },\n  spreadObject: {\n    types: {\n      spreadObject: /^\\.\\.\\./\n    },\n    next: [\n      'value',\n      'prop', \n    ]\n  },\n  spreadArray: {\n    types: {\n      spreadArray: /^\\.\\.\\./\n    },\n    next: [\n      'value', \n      'prop', \n    ]\n  },\n  expEnd: {types: {}, next: []},\n  expSingle: {\n    types: {\n      for: /^(([a-zA-Z\\$\\_][\\w\\$\\_]*)\\s*:)?\\s*for\\s*\\(/,\n      do: /^(([a-zA-Z\\$\\_][\\w\\$\\_]*)\\s*:)?\\s*do\\s*\\{/,\n      while: /^(([a-zA-Z\\$\\_][\\w\\$\\_]*)\\s*:)?\\s*while\\s*\\(/,\n      loopAction: /^(break|continue)(?![\\w\\$\\_])/,\n      if: /^if\\s*\\(/,\n      try: /^try\\s*{/,\n      // block: /^{/,\n      function: /^(async\\s+)?function(\\s*[a-zA-Z\\$_][a-zA-Z\\d\\$_]*)\\s*\\(\\s*((\\.\\.\\.)?\\s*[a-zA-Z\\$_][a-zA-Z\\d\\$_]*(\\s*,\\s*(\\.\\.\\.)?\\s*[a-zA-Z\\$_][a-zA-Z\\d\\$_]*)*)?\\s*\\)\\s*{/,\n      switch: /^(([a-zA-Z\\$\\_][\\w\\$\\_]*)\\s*:)?\\s*switch\\s*\\(/,\n    },\n    next: [\n      'expEnd'\n    ]\n  }\n};\n\nlet closings = {\n  \"(\": \")\",\n  \"[\": \"]\",\n  \"{\": \"}\",\n  \"'\": \"'\",\n  '\"': '\"',\n  \"`\": \"`\"\n}\n\nconst okFirstChars = /^[\\+\\-~ !]/;\nconst aChar = /^[\\w\\$]/\nconst aNumber = expectTypes.value.types.number;\nexport function restOfExp(constants: IConstants, \n                          part: string, \n                          tests?: RegExp[], \n                          quote?: string, \n                          firstOpening?: string, \n                          closingsTests?: RegExp[], \n                          details: {[k: string]: string} = {}, \n                          allChars?: boolean) {\n  let isStart = true;\n  tests = tests || [];\n  let escape = false;\n  let done = false;\n  let lastIsChar = false;\n  let currentIsChar = false;\n  let lastChar = \"\";\n  let word = \"\";\n  let i;\n  for (i = 0; i < part.length && !done; i++) {\n    let char = part[i];\n    lastIsChar = currentIsChar;\n    currentIsChar = aChar.test(char);\n    if (!currentIsChar && !space.test(char) && !closings[char]) word = \"\";\n    if (currentIsChar && closingsTests) word += char;\n    if (quote === '\"' || quote === \"'\" || quote === \"`\") {\n      if (quote === \"`\" && char === \"$\" && part[i+1] === \"{\" && !escape) {\n        let skip = restOfExp(constants, part.substring(i+2), [], \"{\");\n        i += skip.length + 2;\n      } else if (char === quote && !escape) {\n        return part.substring(0, i);\n      }\n      escape = !escape && char === \"\\\\\";\n    } else if (closings[char]) {\n      if (char === firstOpening) {\n        done = true;\n        break;\n      } else {\n        let skip = restOfExp(constants, part.substring(i+1), [], char);\n        i += skip.length + 1;\n        isStart = false;\n        if (closingsTests) {\n          let sub = part.substring(i);\n          for (let test of closingsTests) {\n            test.lastIndex = 0;\n            const found = test.exec(sub);\n            if (!found) continue;\n            i += found[1].length - 1;\n            details['word'] = word;\n            done = true;\n            if (done) break;\n          }\n        }\n      }\n    } else if (!quote) {\n      let sub = part.substring(i);\n      let foundNumber: RegExpExecArray;\n      if (foundNumber = aNumber.exec(sub)) {\n        i += foundNumber[0].length - 1;\n        sub = part.substring(i);\n      }\n      if (allChars || (!lastIsChar || !currentIsChar) && lastChar !== char) {\n        for (let test of tests) {\n          const found = test.exec(sub);\n          if (!found) continue;\n          if (closingsTests) {\n            i += found[1].length;\n          }\n          done = true;\n          break;\n        }\n      }\n      if (isStart) {\n        if (okFirstChars.test(sub)) {\n          done = false;\n        } else {\n          isStart = false;\n        }\n      }\n      if (done) break;\n    } else if(char === closings[quote]) {\n      return part.substring(0, i);\n    }\n    lastChar = char;\n  }\n  if (quote) {\n    throw new SyntaxError(\"Unclosed '\" + quote + \"': \" + quote + part.substring(0, Math.min(i, 40)));\n  }\n  return part.substring(0, i);\n}\nrestOfExp.next = [\n  'splitter',\n  'expEnd',\n  'inlineIf'\n];\n\nexport const setLispType = (types: string[], fn: LispCallback) => {\n  types.forEach((type) => {\n    lispTypes.set(type, fn);\n  })\n}\n\nconst closingsCreate: {[type:string]: RegExp} = {\n  'createArray': /^\\]/,\n  'createObject': /^\\}/,\n  'group': /^\\)/,\n  'arrayProp': /^\\]/,\n  'call': /^\\)/\n}\n\nsetLispType(['createArray', 'createObject', 'group', 'arrayProp','call'], (constants, type, part, res, expect, ctx) => {\n  let extract = \"\";\n  let arg: string[] = [];\n  let end = false;\n  let i = 1;\n  while (i < part.length && !end) {\n    extract = restOfExp(constants, part.substring(i), [\n      closingsCreate[type],\n      /^,/\n    ]);\n    i += extract.length;\n    if (extract) {\n      arg.push(extract);\n    }\n    if (part[i] !== ',') {\n      end = true;\n    } else {\n      i++;\n    }\n  }\n  const next = ['value', 'modifier', 'prop', 'incrementerBefore', 'expEnd'];\n  let l: LispItem;\n\n  let funcFound: RegExpExecArray;\n  switch(type) {\n    case 'group':\n    case 'arrayProp':\n      l = lispifyExpr(constants, arg.join(\",\"));\n      break;\n    case 'call':\n    case 'createArray':\n      // @TODO: support 'empty' values\n      l = toLispArray(arg.map((e) => lispify(constants, e, [...next, 'spreadArray'])));\n      break;\n    case 'createObject':\n      l = toLispArray(arg.map((str) => {\n        str = str.trimStart();\n        let value;\n        let key;\n        funcFound = expectTypes.expSingle.types.function.exec('function ' + str);\n        if (funcFound) {\n          key = funcFound[2].trimStart();\n          value = lispify(constants, 'function ' + str.replace(key, \"\"));\n        } else {\n          let extract = restOfExp(constants, str, [/^:/]);\n          key = lispify(constants, extract, [...next, 'spreadObject']);\n          if (key instanceof Lisp && key.op === 'prop') {\n            key = key.b;\n          }\n          if (extract.length === str.length) return key;\n          value = lispify(constants, str.substring(extract.length + 1));\n        }\n        return new Lisp({\n          op: 'keyVal',\n          a: key,\n          b: value\n        });\n      }));\n      break;\n  }\n  type = type === 'arrayProp' ? 'prop' : type;\n  ctx.lispTree = lispify(constants, part.substring(i + 1), expectTypes[expect].next, new Lisp({\n    op: type, \n    a: ctx.lispTree, \n    b: l,\n  }));\n});\n\nsetLispType(['inverse', 'not', 'negative', 'positive', 'typeof', 'delete', 'op'], (constants, type, part, res, expect, ctx) => {\n  let extract = restOfExp(constants, part.substring(res[0].length), [/^[^\\s\\.\\w\\d\\$]/]);\n  ctx.lispTree = lispify(constants, part.substring(extract.length + res[0].length), restOfExp.next, new Lisp({\n    op: ['positive', 'negative'].includes(type) ? '$' + res[0] : res[0],\n    a: ctx.lispTree, \n    b: lispify(constants, extract, expectTypes[expect].next), \n  }));\n});\n\nsetLispType(['incrementerBefore'], (constants, type, part, res, expect, ctx) => {\n  let extract = restOfExp(constants, part.substring(2), [/^[^\\s\\.\\w\\d\\$]/]);\n  ctx.lispTree = lispify(constants, part.substring(extract.length + 2), restOfExp.next, new Lisp({\n    op: res[0] + \"$\", \n    a: lispify(constants, extract, expectTypes[expect].next), \n  }));\n});\n\nsetLispType(['incrementerAfter'], (constants, type, part, res, expect, ctx) => {\n  ctx.lispTree = lispify(constants, part.substring(res[0].length), expectTypes[expect].next, new Lisp({\n    op: \"$\"  + res[0], \n    a: ctx.lispTree, \n  }));\n});\n\nsetLispType(['assign', 'assignModify'], (constants, type, part, res, expect, ctx) => {\n  ctx.lispTree = new Lisp({\n    op: res[0], \n    a: ctx.lispTree,\n    b: lispify(constants, part.substring(res[0].length), expectTypes[expect].next)\n  });\n});\n\nsetLispType(['split'], (constants, type, part, res, expect, ctx) => {\n  let extract = restOfExp(constants, part.substring(res[0].length),[\n    expectTypes.splitter.types.split,\n    expectTypes.inlineIf.types.inlineIf,\n    inlineIfElse\n  ]);\n  ctx.lispTree = lispify(constants, part.substring(extract.length + res[0].length).trim(), restOfExp.next, new Lisp({\n    op: res[0].trim(),\n    a: ctx.lispTree, \n    b: lispify(constants, extract, expectTypes[expect].next), \n  }));\n});\n\nsetLispType(['inlineIf'], (constants, type, part, res, expect, ctx) => {\n  let found = false;\n  let extract = \"\";\n  let quoteCount = 1;\n  while(!found && extract.length < part.length) {\n    extract += restOfExp(constants, part.substring(extract.length + 1), [\n      expectTypes.inlineIf.types.inlineIf,\n      inlineIfElse\n    ]);\n    if (part[extract.length + 1] === '?') {\n      quoteCount++\n    } else {\n      quoteCount--\n    }\n    if (!quoteCount) {\n      found = true;\n    } else {\n      extract += part[extract.length + 1];\n    }\n  }\n  ctx.lispTree = new Lisp({\n    op: '?',\n    a: ctx.lispTree, \n    b: new Lisp({\n      op: ':',\n      a: lispifyExpr(constants, extract),\n      b: lispifyExpr(constants, part.substring(res[0].length + extract.length + 1))\n    })\n  });\n});\n\nsetLispType(['if'], (constants, type, part, res, expect, ctx) => {\n  let condition = restOfExp(constants, part.substring(res[0].length), [], \"(\");\n  const isBlock = /^\\s*\\{/.exec(part.substring(res[0].length + condition.length + 1));\n  const startTrue = res[0].length + condition.length + 1 + (isBlock ? isBlock[0].length : 0);\n  let trueBlock = restOfExp(constants, part.substring(startTrue), isBlock ? [/^\\}/] : [/^else(?!\\w\\$)/]);\n  let elseBlock = \"\";\n  if (startTrue + trueBlock.length + (isBlock ? isBlock[0].length : 0) < part.length) {\n    const end = part.substring(startTrue + trueBlock.length + (isBlock ? isBlock[0].length : 0));\n    const foundElse = /\\s*else(?!\\w\\$\\s)\\s*/.exec(end);\n    if (foundElse) {\n      elseBlock = end.substring(foundElse[0].length);\n    }\n  }\n  \n  condition = condition.trim();\n  trueBlock = trueBlock.trim();\n  elseBlock = elseBlock.trim();\n  if (trueBlock[0] === \"{\") trueBlock = trueBlock.slice(1, -1);\n  if (elseBlock[0] === \"{\") elseBlock = elseBlock.slice(1, -1);\n  ctx.lispTree = new Lisp({\n    op: 'if',\n    a: lispifyExpr(constants, condition), \n    b: new If(lispifyBlock(trueBlock, constants), elseBlock ? lispifyBlock(elseBlock, constants) : undefined)\n  });\n});\n\nsetLispType(['switch'], (constants, type, part, res, expect, ctx) => {\n  const test = restOfExp(constants, part.substring(res[0].length), [], \"(\");\n  let start = part.indexOf(\"{\", res[0].length + test.length + 1);\n  if (start === -1) throw new SyntaxError(\"Invalid switch: \" + part);\n  let statement = insertSemicolons(constants, restOfExp(constants, part.substring(start + 1), [], \"{\"), false);\n  let caseFound: RegExpExecArray;\n  const caseTest = /^\\s*(case\\s|default)\\s*/;\n  let cases: Lisp[] = [];\n  let defaultFound = false;\n  while(caseFound = caseTest.exec(statement)) {\n    if (caseFound[1] === 'default') {\n      if (defaultFound) throw new SyntaxError(\"Only one default switch case allowed:\" + statement);\n      defaultFound = true;\n    }\n    let cond = restOfExp(constants, statement.substring(caseFound[0].length), [/^:/]);\n    let found = \"\";\n    let i = start = caseFound[0].length + cond.length + 1;\n    let bracketFound = /^\\s*\\{/.exec(statement.substring(i));\n    let exprs = [];\n    if (bracketFound) {\n      i += bracketFound[0].length;\n      found = restOfExp(constants, statement.substring(i), [], \"{\");\n      i += found.length + 1;\n      exprs = lispifyBlock(found, constants);\n    } else {\n      let notEmpty = restOfExp(constants, statement.substring(i), [caseTest]);\n      if (!notEmpty.trim()) {\n        exprs = undefined;\n        i += notEmpty.length;\n      } else {\n        let lines = [];\n        while(found = restOfExp(constants, statement.substring(i), [/^;/])) {\n          lines.push(found);\n          i += found.length + 1;\n          if (caseTest.test(statement.substring(i))) {\n            break;\n          }\n        }\n        exprs = lispifyBlock(lines.join(\";\"), constants);\n      }\n    }\n    statement = statement.substring(i);\n    cases.push(new Lisp({\n      op: \"case\",\n      a: caseFound[1] === \"default\" ? undefined : lispifyExpr(constants, cond),\n      b: toLispArray(exprs)\n    }));\n  }\n  ctx.lispTree = new Lisp({\n    op: 'switch',\n    a: lispifyExpr(constants, test),\n    b: toLispArray(cases)\n  });\n});\n\nsetLispType(['dot', 'prop'], (constants, type, part, res, expect, ctx) => {\n  let prop = res[0];\n  let index = res[0].length;\n  if (res[0] === '.') {\n    let matches = part.substring(res[0].length).match(expectTypes.prop.types.prop);\n    if (matches && matches.length) {\n      prop = matches[0];\n      index = prop.length + res[0].length\n    } else {\n      throw new SyntaxError('Hanging  dot:' + part);\n    }\n  }\n  ctx.lispTree = lispify(constants, part.substring(index), expectTypes[expect].next, new Lisp({\n    op: 'prop', \n    a: ctx.lispTree, \n    b: prop\n  }));\n});\n\nsetLispType(['spreadArray', 'spreadObject'], (constants, type, part, res, expect, ctx) => {\n  ctx.lispTree = new Lisp({\n    op: type,\n    b: lispify(constants, part.substring(res[0].length), expectTypes[expect].next)\n  });\n});\n\nsetLispType(['return'], (constants, type, part, res, expect, ctx) => {\n  ctx.lispTree = new Lisp({\n    op: type,\n    b: lispifyExpr(constants, part.substring(res[0].length))\n  });\n});\n\nconst primitives = {\n  \"true\": true,\n  \"false\": false,\n  \"null\": null,\n  Infinity,\n  NaN,\n  \"und\": undefined\n}\n\nsetLispType(['number', 'boolean', 'null', 'und', 'NaN', 'Infinity'], (constants, type, part, res, expect, ctx) => {\n  ctx.lispTree = lispify(constants, part.substring(res[0].length), expectTypes[expect].next, type === \"number\" ? Number(res[0]) : primitives[type === \"boolean\" ? res[0] : type]);\n});\n\nsetLispType(['string', 'literal', 'regex'], (constants, type, part, res, expect, ctx) => {\n  ctx.lispTree = lispify(constants, part.substring(res[0].length), expectTypes[expect].next, new Lisp({\n    op: type,\n    b: parseInt(JSON.parse(res[1]), 10),\n  }));\n});\n\nsetLispType(['initialize'], (constants, type, part, res, expect, ctx) => {\n  if (!res[3]) {\n    ctx.lispTree = lispify(constants, part.substring(res[0].length), expectTypes[expect].next, new Lisp({\n      op: res[1],\n      a: res[2]\n    }));\n  } else {\n    ctx.lispTree = new Lisp({\n      op: res[1],\n      a: res[2],\n      b: lispify(constants, part.substring(res[0].length), expectTypes[expect].next)\n    });\n  }\n});\n\nsetLispType(['function', 'inlineFunction', 'arrowFunction', 'arrowFunctionSingle'], (constants, type, part, res, expect, ctx) => {\n  const isArrow = type !== 'function' && type !== 'inlineFunction';\n  const isReturn = isArrow && !res[res.length - 1];\n  const argPos = isArrow ? 2 : 3;\n  const isAsync = !!res[1];\n  const args: any[] = res[argPos] ? res[argPos].replace(/\\s+/g, \"\").split(/,/g) : [];\n  if (!isArrow) {\n    args.unshift((res[2] || \"\").trimStart());\n  }\n  let ended = false;\n  args.forEach((arg) => {\n    if (ended) throw new SyntaxError('Rest parameter must be last formal parameter');\n    if (arg.startsWith('...')) ended = true;\n  });\n  args.unshift(isAsync);\n  const func = (isReturn ? 'return ' : '') + restOfExp(constants, part.substring(res[0].length), !isReturn ? [/^}/] : [/^[,;\\)\\}\\]]/]);\n  ctx.lispTree = lispify(constants, part.substring(res[0].length + func.length + 1), expectTypes[expect].next, new Lisp({\n    op: isArrow ? 'arrowFunc' : type,\n    a: toLispArray(args),\n    b: constants.eager ? lispifyFunction(func, constants) : func\n  }));\n});\n\nconst iteratorRegex = /^((let|var|const)\\s+)?\\s*([a-zA-Z\\$_][a-zA-Z\\d\\$_]*)\\s+(in|of)\\s+/\nsetLispType(['for', 'do', 'while'], (constants, type, part, res, expect, ctx) => {\n  let i = part.indexOf(\"(\") + 1;\n  let startStep: LispItem = true;\n  let startInternal: LispArray = toLispArray([]);\n  let beforeStep: LispItem = false;\n  let checkFirst = true;\n  let condition: LispItem;\n  let step: LispItem = true;\n  let body: string;\n  switch (type) {\n    case 'while':\n      let extract = restOfExp(constants, part.substring(i), [], \"(\");\n      condition = lispifyExpr(constants, extract);\n      body = restOfExp(constants, part.substring(i + extract.length + 1)).trim();\n      if (body[0] === \"{\") body = body.slice(1, -1);\n      break;\n    case 'for':\n      let args: string[] = [];\n      let extract2 = \"\";\n      for (let k = 0; k < 3; k++)  {\n        extract2 = restOfExp(constants, part.substring(i), [/^[;\\)]/]);\n        args.push(extract2.trim());\n        i += extract2.length + 1;\n        if (part[i - 1] === \")\") break;\n      }\n      let iterator: RegExpExecArray;\n      if (args.length === 1 && (iterator = iteratorRegex.exec(args[0]))) {\n        if (iterator[4] === 'of') {\n          startInternal = toLispArray([\n            lispify(constants, 'let $$obj = '+ args[0].substring(iterator[0].length), ['initialize']),\n            ofStart2, \n            ofStart3\n          ]);\n          condition = ofCondition;\n          step = ofStep;\n          beforeStep = lispify(constants, (iterator[1] || 'let ') + iterator[3]  + ' = $$next.value', ['initialize']);\n        } else {\n          startInternal = toLispArray([\n            lispify(constants, 'let $$obj = '+ args[0].substring(iterator[0].length), ['initialize']),\n            inStart2,\n            inStart3\n          ]);\n          step = inStep;\n          condition = inCondition;\n          beforeStep = lispify(constants, (iterator[1] || 'let ') + iterator[3] + ' = $$keys[$$keyIndex]', ['initialize']);\n        }\n      } else if (args.length === 3) {\n        startStep = lispifyExpr(constants, args.shift(), startingExecpted);\n        condition = lispifyExpr(constants, args.shift());\n        step = lispifyExpr(constants, args.shift());\n      } else {\n        throw new SyntaxError(\"Invalid for loop definition\");\n      }\n      body = restOfExp(constants, part.substring(i)).trim();\n      if (body[0] === \"{\") body = body.slice(1, -1);\n\n      break;\n    case 'do':\n      checkFirst = false;\n      const start = part.indexOf(\"{\") + 1;\n      body = restOfExp(constants, part.substring(start), [], \"{\");\n      condition = lispifyExpr(constants, restOfExp(constants, part.substring(part.indexOf(\"(\", start + body.length) + 1), [], \"(\"));\n      break;\n  }\n  const a = [checkFirst, startInternal, startStep, step, condition, beforeStep] as any;\n  a.lisp = true;\n  ctx.lispTree = new Lisp({\n    op: 'loop',\n    a,\n    b: lispifyBlock(body, constants)\n  });\n});\n\nsetLispType(['block'], (constants, type, part, res, expect, ctx) => {\n  ctx.lispTree = lispifyBlock(restOfExp(constants, part.substring(1), [], \"{\"), constants);\n});\n\nsetLispType(['loopAction'], (constants, type, part, res, expect, ctx) => {\n  ctx.lispTree = new Lisp({\n    op: 'loopAction',\n    a: res[1],\n  });\n});\n\nconst catchReg = /^\\s*(catch\\s*(\\(\\s*([a-zA-Z\\$_][a-zA-Z\\d\\$_]*)\\s*\\))?|finally)\\s*\\{/\nsetLispType(['try'], (constants, type, part, res, expect, ctx) => {\n  const body = restOfExp(constants, part.substring(res[0].length), [], \"{\");\n  let catchRes = catchReg.exec(part.substring(res[0].length + body.length + 1));\n  let finallyBody;\n  let exception;\n  let catchBody;\n  let offset = 0;\n  if (catchRes[1].startsWith('catch')) {\n    catchRes = catchReg.exec(part.substring(res[0].length + body.length + 1));\n    exception = catchRes[2];\n    catchBody = restOfExp(constants, part.substring(res[0].length + body.length + 1 + catchRes[0].length), [], \"{\");\n    offset = res[0].length + body.length + 1 + catchRes[0].length + catchBody.length + 1;\n    if ((catchRes = catchReg.exec(part.substring(offset))) && catchRes[1].startsWith('finally')) {\n      finallyBody = restOfExp(constants, part.substring(offset + catchRes[0].length), [], \"{\");\n    }\n  } else {\n    finallyBody = restOfExp(constants, part.substring(res[0].length + body.length + 1 + catchRes[0].length), [], \"{\");\n  }\n  const b = [\n    exception,\n    lispifyBlock(insertSemicolons(constants, catchBody || \"\", false), constants),\n    lispifyBlock(insertSemicolons(constants, finallyBody || \"\", false), constants),\n  ] as any;\n  b.lisp = true;\n  ctx.lispTree = new Lisp({\n    op: 'try',\n    a: lispifyBlock(insertSemicolons(constants, body, false), constants),\n    b\n  });\n});\n\nsetLispType(['void', 'await', 'throw'], (constants, type, part, res, expect, ctx) => {\n  const extract = restOfExp(constants, part.substring(res[0].length), [/^[^\\s\\.\\w\\d\\$]/]);\n  ctx.lispTree = lispify(constants, part.substring(res[0].length + extract.length), expectTypes[expect].next, new Lisp({\n    op: type,\n    a: lispify(constants, extract),\n  }));\n});\n\nsetLispType(['new'], (constants, type, part, res, expect, ctx) => {\n  let i = res[0].length;\n  const obj = restOfExp(constants, part.substring(i), [], undefined, \"(\");\n  i += obj.length + 1;\n  const args = [];\n  if (part[i - 1] === \"(\") {\n    const argsString = restOfExp(constants, part.substring(i), [], \"(\");\n    i += argsString.length + 1;\n    let found;\n    let j = 0;\n    while(found = restOfExp(constants, argsString.substring(j), [/^,/])) {\n      j += found.length + 1;\n      args.push(found.trim());\n    } \n  }\n  ctx.lispTree = lispify(constants, part.substring(i), expectTypes.expEdge.next, new Lisp({\n    op: type,\n    a: lispify(constants, obj, expectTypes.initialize.next),\n    b: toLispArray(args.map((arg) => lispify(constants, arg, expectTypes.initialize.next))),\n  }));\n});\n\nconst ofStart2 = lispify(undefined, 'let $$iterator = $$obj[Symbol.iterator]()', ['initialize']);\nconst ofStart3 = lispify(undefined, 'let $$next = $$iterator.next()', ['initialize']);\nconst ofCondition = lispify(undefined, 'return !$$next.done', ['initialize']);\nconst ofStep = lispify(undefined, '$$next = $$iterator.next()');\nconst inStart2 = lispify(undefined, 'let $$keys = Object.keys($$obj)', ['initialize']);\nconst inStart3 = lispify(undefined, 'let $$keyIndex = 0', ['initialize']);\nconst inStep = lispify(undefined, '$$keyIndex++');\nconst inCondition = lispify(undefined, 'return $$keyIndex < $$keys.length', ['initialize']);\n\nconst startingExecpted = ['initialize', 'expSingle', 'value', 'modifier', 'prop', 'incrementerBefore', 'expEnd'];\nvar lastType;\nvar lastPart;\n// var lastLastPart;\n// var lastLastLastPart;\n// var lastLastLastLastPart;\nfunction lispify(constants: IConstants, part: string, expected?: string[], lispTree?: LispItem): LispItem {\n  expected = expected || expectTypes.initialize.next;\n  if (part === undefined) return lispTree;\n\n  part = part.trimStart();\n\n  if (!part.length && !expected.includes('expEnd')) {\n    throw new SyntaxError(\"Unexpected end of expression: \" + lastPart);\n  }\n  \n  if (!part) return lispTree;\n\n  let ctx = {lispTree: lispTree};\n\n  let res: any;\n  for (let expect of expected) {\n    if (expect === 'expEnd') {\n      continue;\n    }\n    for (let type in expectTypes[expect].types) {\n      if (type === 'expEnd') {\n        continue;\n      }\n      if(res = expectTypes[expect].types[type].exec(part)) {\n        lastType = type;\n        // lastLastLastLastPart = lastLastLastPart;\n        // lastLastLastPart = lastLastPart;\n        // lastLastPart = lastPart;\n        lastPart = part;\n        lispTypes.get(type)(constants, type, part, res, expect, ctx);\n        break;\n      }\n    }\n    if (res) break;\n  }\n\n  if (!res && part.length) {\n    throw SyntaxError(`Unexpected token (${lastType}): ${part.substring(0, 40)}`);\n  }\n  return ctx.lispTree;\n}\n\nfunction lispifyExpr(constants: IConstants, str: string, expected?: string[]): LispItem {\n  if (!str.trim()) return undefined;\n  let subExpressions = [];\n  let sub: string;\n  let pos = 0;\n  expected = expected || expectTypes.initialize.next;\n  while ((sub = restOfExp(constants, str.substring(pos), [/^,/]))) {\n    subExpressions.push(sub.trimStart());\n    pos += sub.length + 1;\n  }\n  if (subExpressions.length === 1) {\n    return lispify(constants, str, expected);\n  }\n  if (expected === startingExecpted) {\n    let defined = expectTypes.initialize.types.initialize.exec(subExpressions[0]);\n    if (defined) {\n      return toLispArray(subExpressions.map((str, i) => lispify(constants, i ? defined[1] + ' ' + str : str, ['initialize'])));\n    } else if (expectTypes.initialize.types.return.exec(subExpressions[0])) {\n      return lispify(constants, str, expected);\n    }\n  }\n  const exprs = toLispArray(subExpressions.map((str, i) => lispify(constants, str, expected)));\n  return new Lisp({op: \"multi\", a: exprs});\n}\n\nexport function lispifyBlock(str: string, constants: IConstants): LispArray {\n  str = insertSemicolons(constants, str, false);\n  if (!str.trim()) return toLispArray([]);\n  let parts = [];\n  let part: string;\n  let pos = 0;\n  while ((part = restOfExp(constants, str.substring(pos), [/^;/]))) {\n    parts.push(part.trim());\n    pos += part.length + 1;\n  }\n  return toLispArray(parts.filter(Boolean).map((str, j) => {\n    return lispifyExpr(constants, str, startingExecpted);\n  }).flat());\n}\n\nexport function lispifyFunction(str: string, constants: IConstants): LispArray {\n  if (!str.trim()) return toLispArray([]);\n  const tree = lispifyBlock(str, constants);\n  let hoisted: LispArray = toLispArray([]);\n  hoist(tree, hoisted);\n  return toLispArray(hoisted.concat(tree));\n}\n\nfunction hoist(item: LispItem, res: LispArray): boolean {\n  if (Array.isArray(item)) {\n    const rep = [];\n    for (let it of item) {\n      if (!hoist(it, res)) {\n        rep.push(it);\n      }\n    }\n    if (rep.length !== item.length) {\n      item.length = 0;\n      item.push(...rep);\n    }\n  } else if (item instanceof Lisp) {\n    if (item.op === \"try\" || item.op === \"if\" || item.op === \"loop\" || item.op === \"switch\") {\n      hoist(item.a, res);\n      hoist(item.b, res);\n    } else if (item.op === \"var\") {\n      res.push(new Lisp({op: 'var', a: item.a}));\n    } else if (item.op === \"function\" && item.a[1]) {\n      res.push(item);\n      return true;\n    }\n  }\n  return false;\n}\n\nconst edgesForInsertion = [\n  /^([\\w\\$]|\\+\\+|\\-\\-)\\s*\\r?\\n\\s*([\\w\\$\\+\\-])/,\n  /^([^\\w\\$](return|continue|break|throw))\\s*\\r?\\n\\s*[^\\s]/\n];\nconst closingsForInsertion = [\n  /^([\\)\\]])\\s*\\r?\\n\\s*([\\w\\$\\{\\+\\-])/,\n  /^(\\})\\s*\\r?\\n?\\s*([\\(])/,\n  /^(\\})\\s*(\\r?\\n)?\\s*([\\w\\[\\+\\-])/,\n];\nconst closingsNoInsertion = /^(\\})\\s*(catch|finally|else|while|instanceof)(?![\\w\\$])/\nconst whileEnding = /^\\}\\s*while/\n\nexport function insertSemicolons(constants: IConstants, part: string, type: boolean) {\n  let rest = part;\n  let sub = \"\"\n  let res = [];\n  let details: any = {};\n  while (sub = restOfExp(constants, rest, edgesForInsertion, undefined, undefined, !type ? closingsForInsertion : undefined, details, true)) {\n    res.push(sub);\n    if (!closingsNoInsertion.test(rest.substring(sub.length - 1))) {\n      res.push(\";\");\n    } else if (details.word !== \"do\" && whileEnding.test(rest.substring(sub.length - 1))) {\n      res.push(\";\");\n    }\n    rest = rest.substring(sub.length);\n  }\n  res.pop();\n  return res.join(\"\");\n}\n\nconst oneLinerBlocks = /[^\\w\\$](if|do)(?![\\w\\$])/g;\nexport function convertOneLiners(constants: IConstants, str: string): string {\n  let res: RegExpExecArray;\n  let lastIndex = 0;\n  let parts: Array<string|string[]> = [];\n  while (res = oneLinerBlocks.exec(str)) {\n    let sub = str.substring(res.index + res[0].length);\n    let nextIndex = res.index + res[0].length;\n    if (res[1] === 'if') {\n      let c = sub.indexOf(\"(\") + 1;\n      nextIndex += c\n      let condition = restOfExp(constants, sub.substring(c), [], \"(\");\n      oneLinerBlocks.lastIndex = res.index + c + condition.length + 1;\n      parts.push(str.substring(lastIndex, nextIndex), [condition], ')');\n      nextIndex += condition.length + 1;\n    } else {\n      parts.push(str.substring(lastIndex, nextIndex));\n    }\n    const spaceCount = /^\\s*/.exec(str.substring(nextIndex));\n    nextIndex += spaceCount[0].length;\n    sub = str.substring(nextIndex);\n    if (sub[0] !== '{') {\n      let body = restOfExp(constants, sub, [/^([;\\)\\]\\}]|\\r?\\n)/]);\n      let semi = 0;\n      if (sub[body.length] === \";\") semi = 1;\n      parts.push(\"{\", body, \"}\");\n      let rest = sub.substring(body.length + semi);\n      if (res[1] === 'if' && !/^\\s*else(?![\\w\\$])/.test(rest)) {\n        parts.push(\";\");\n      }\n      lastIndex = nextIndex + body.length + semi;\n    } else {\n      lastIndex = nextIndex;\n    }\n  }\n  parts.push(str.substring(lastIndex));\n  for (let p of parts) {\n    if (p instanceof Array) {\n      let c = convertOneLiners(constants, p[0]);\n      p.length = 0;\n      p.push(c)\n    }\n  }\n  return parts.flat().join(\"\");\n}\n\nexport function checkRegex(str: string): IRegEx | null {\n  let i = 1;\n  let escape = false;\n  let done = false;\n  let cancel = false;\n  while (i < str.length && !done && !cancel) {\n    done = (str[i] === '/' && !escape);\n    escape = str[i] === '\\\\' && !escape;\n    cancel = str[i] === '\\n';\n    i++;\n  }\n  let after = str.substring(i);\n  cancel = (cancel || !done) || /^\\s*\\d/.test(after);\n  if (cancel) return null;\n  let flags = /^[a-z]*/.exec(after);\n  if(/^\\s+[\\w\\$]/.test(str.substring(i + flags[0].length))) {\n    return null;\n  }\n  return {\n    regex: str.substring(1, i-1),\n    flags: (flags && flags[0]) || \"\",\n    length: i + ((flags && flags[0].length) || 0)\n  }\n}\n\nconst notDivide = /(typeof|delete|instanceof|return|in|of|throw|new|void|do|if)$/\nconst possibleDivide = /^([\\w\\$\\]\\)]|\\+\\+|\\-\\-)[^\\w\\$\\]\\)\\+\\-]/;\nexport function extractConstants(constants: IConstants, str: string, currentEnclosure = \"\"): {str: string, length: number} {\n  let quote;\n  let extract: string[] = [];\n  let escape = false;\n  let regexFound: IRegEx;\n  let comment = \"\";\n  let commentStart = -1;\n  let currJs: LispArray = toLispArray([]);\n  let char: string = \"\";\n  const strRes: string[] = []\n  const enclosures: string[] = [];\n  let isPossibleDivide: RegExpExecArray;\n  for (var i = 0; i < str.length; i++) {\n    char = str[i];\n    if (comment) {\n      if (char === comment) {\n        if (comment === \"*\" && str[i + 1] ===\"/\") {\n          comment = \"\";\n          i++\n        } else if (comment === \"\\n\") {\n          comment = \"\";\n        }\n      }\n    } else {\n      if (escape) {\n        escape = false;\n        extract.push(char);\n        continue;\n      }\n\n      if (quote) {\n        if (quote === \"`\" && char === \"$\" && str[i+1] === \"{\") {\n          let skip = extractConstants(constants, str.substring(i+2), \"{\");\n          currJs.push(skip.str);\n          extract.push(`\\${${currJs.length - 1}}`);\n          i += skip.length + 2;\n        } else if (quote === char) {\n          if (quote === '`') {\n            constants.literals.push({\n              op: 'literal',\n              a:  unraw(extract.join(\"\")),\n              b: currJs\n            });\n            strRes.push(`\\`${constants.literals.length - 1}\\``);\n          } else {\n            constants.strings.push(unraw(extract.join(\"\")));\n            strRes.push( `\"${constants.strings.length - 1}\"`);\n          }\n          quote = null;\n          extract = [];\n        } else {\n          extract.push(char);\n        }\n      } else {\n        if ((char === \"'\"  || char === '\"'  || char === '`')) {\n          currJs = toLispArray([]);\n          quote = char;\n        } else if (closings[currentEnclosure] === char && !enclosures.length) {\n          return {str: strRes.join(\"\"), length: i}\n        } else if (closings[char]) {\n          enclosures.push(char);\n          strRes.push(char);\n        } else if (closings[enclosures[enclosures.length-1]] === char) {\n          enclosures.pop();\n          strRes.push(char);\n        } else if (char === \"/\" && (str[i+1] === \"*\" || str[i+1] === \"/\")) {\n          comment = str[i+1] === \"*\" ? \"*\" : \"\\n\";\n          commentStart = i;\n        } else if (char === '/' && !isPossibleDivide && (regexFound = checkRegex(str.substring(i)))) {\n          constants.regexes.push(regexFound);\n          strRes.push(`/${constants.regexes.length - 1}/r`);\n          i += regexFound.length - 1;\n        } else {\n          strRes.push(char);\n        }\n\n        if (!(isPossibleDivide && space.test(char))) {\n          if (isPossibleDivide = possibleDivide.exec(str.substring(i))) {\n            if (notDivide.test(str.substring(0, i + isPossibleDivide[1].length))) {\n              isPossibleDivide = null;\n            }\n          }\n        }\n      }\n      escape = quote && char === \"\\\\\";\n    }\n  }\n\n  if (comment) {\n    if (comment === \"*\") {\n      throw new SyntaxError(`Unclosed comment '/*': ${str.substring(commentStart)}`)\n    }\n  }\n  return {str: strRes.join(\"\"), length: i}\n}\nexport function parse(code: string, eager = false): IExecutionTree {\n  if (typeof code !== 'string') throw new ParseError(`Cannot parse ${code}`, code);\n  // console.log('parse', str);\n  let str = ' ' + code;\n  const constants: IConstants = {strings: [], literals: [], regexes: [], eager};\n  str = extractConstants(constants, str).str;\n  str = insertSemicolons(constants, str, true);\n  str = convertOneLiners(constants, str);\n  // console.log(str);\n\n  try {\n    for (let l of constants.literals) {\n      l.b = toLispArray(l.b.map((js: string) => lispifyExpr(constants, js)));\n    }\n    return {tree: lispifyFunction(str, constants), constants};\n  } catch (e) {\n    throw e;\n    throw new ParseError(e.message + \": \" + str.substring(0, 100) + '...', str);\n  }\n}\n","import { SpreadArray, LispItem, KeyVal, SpreadObject, If, Lisp, LispArray, toLispArray, parse, IRegEx, lispifyFunction } from \"./parser.js\";\nimport { IExecContext, IContext, Ticks } from \"./Sandbox.js\";\n\n\nexport type SandboxFunction = (code: string, ...args: any[]) => () => any;\nexport type sandboxedEval = (code: string) => any;\nexport type sandboxSetTimeout = (handler: TimerHandler, timeout?: any, ...args: any[]) => any;\nexport type sandboxSetInterval = (handler: TimerHandler, timeout?: any, ...args: any[]) => any;\nexport type Done = (err?: any, res?: any) => void\nexport class ExecReturn {\n  constructor(public auditReport: IAuditReport, public result: any, public returned: boolean, public breakLoop = false, public continueLoop = false) {}\n}\n\nexport interface IAuditReport {\n  globalsAccess: Set<any>;\n  prototypeAccess: {[name: string]: Set<string>}\n}\n\nexport interface IGlobals {\n  [key: string]: any\n}\n\nexport interface IChange {\n  type: string;\n}\n\nexport interface ICreate extends IChange {\n  type: \"create\";\n  prop: number|string;\n}\n\nexport interface IReplace extends IChange {\n  type: \"replace\";\n}\n\nexport interface IDelete extends IChange {\n  type: \"delete\";\n  prop: number|string;\n}\n\nexport interface IReverse extends IChange {\n  type: \"reverse\";\n}\n\nexport interface ISort extends IChange {\n  type: \"sort\";\n}\n\nexport interface IPush extends IChange {\n  type: \"push\";\n  added: unknown[];\n}\n\nexport interface IPop extends IChange {\n  type: \"pop\";\n  removed: unknown[];\n}\n\nexport interface IShift extends IChange {\n  type: \"shift\";\n  removed: unknown[];\n}\n\nexport interface IUnShift extends IChange {\n  type: \"unshift\";\n  added: unknown[];\n}\n\nexport interface ISplice extends IChange {\n  type: \"splice\";\n  startIndex: number;\n  deleteCount: number; \n  added: unknown[];\n  removed: unknown[];\n\n}\n\nexport interface ICopyWithin extends IChange {\n  type: \"copyWithin\";\n  startIndex: number;\n  endIndex: number;\n  added: unknown[];\n  removed: unknown[];\n}\n\nexport type Change = ICreate | IReplace | IDelete | IReverse | ISort | IPush | IPop | IUnShift | IShift | ISplice | ICopyWithin\n\nexport type replacementCallback = (obj: any, isStaticAccess: boolean) => any\n\nexport class Prop {\n  constructor(public context: {[key:string]: any}, public prop: string, public isConst = false, public isGlobal = false, public isVariable = false) {\n  }\n}\n\nconst reservedWords = new Set([\n  'instanceof',\n  'typeof',\n  'return',\n  'try',\n  'catch',\n  'if',\n  'finally',\n  'else',\n  'in',\n  'of',\n  'var',\n  'let',\n  'const',\n  'for',\n  'delete',\n  'false',\n  'true',\n  'while',\n  'do',\n  'break',\n  'continue',\n  'new',\n  'function',\n  'async',\n  'await',\n  'switch',\n  'case'\n]);\n\nenum VarType {\n  let = \"let\",\n  const = \"const\",\n  var = \"var\"\n}\n\nexport class Scope {\n  parent: Scope;\n  const = new Set<string>();\n  let = new Set<string>();\n  var: Set<string>;\n  globals: Set<string>;\n  allVars: {[key:string]: any} & Object;\n  functionThis?: any;\n  constructor(parent: Scope, vars = {}, functionThis?: any) {\n    const isFuncScope = functionThis !== undefined || parent === null;\n    this.parent = parent;\n    this.allVars = vars;\n    this.let = isFuncScope ? this.let : new Set(Object.keys(vars));\n    this.var = isFuncScope ? new Set(Object.keys(vars)) : this.var;\n    this.globals = parent === null ? new Set(Object.keys(vars)) : new Set();\n    this.functionThis = functionThis;\n  }\n\n  get(key: string, functionScope = false): any {\n    if (key === 'this' && this.functionThis !== undefined) {\n      return new Prop({this: this.functionThis}, key, true, false, true);\n    }\n    if (reservedWords.has(key)) throw new SyntaxError(\"Unexepected token '\" + key + \"'\");\n    if (this.parent === null || !functionScope || this.functionThis !== undefined) {\n      if (this.globals.has(key)) {\n        return new Prop(this.functionThis, key, false, true, true);\n      }\n      if (key in this.allVars && (!(key in {}) || this.allVars.hasOwnProperty(key))) {\n        return new Prop(this.allVars, key, this.const.has(key), this.globals.has(key), true);\n      }\n      if (this.parent === null) {\n        return new Prop(undefined, key);\n      }\n    }\n    return this.parent.get(key, functionScope)\n  }\n\n  set(key: string, val: any) {\n    if (key === 'this') throw new SyntaxError('\"this\" cannot be assigned')\n    if (reservedWords.has(key)) throw new SyntaxError(\"Unexepected token '\" + key + \"'\");\n    let prop = this.get(key);\n    if(prop.context === undefined) {\n      throw new ReferenceError(`Variable '${key}' was not declared.`);\n    }``\n    if (prop.isConst) {\n      throw new TypeError(`Cannot assign to const variable '${key}'`);\n    }\n    if (prop.isGlobal) {\n      throw new SandboxError(`Cannot override global variable '${key}'`);\n    }\n    prop.context[prop] = val;\n    return prop;\n  }\n\n  declare(key: string, type: VarType = null, value: any = undefined, isGlobal = false) {\n    if (key === 'this') throw new SyntaxError('\"this\" cannot be declared');\n    if (reservedWords.has(key)) throw new SyntaxError(\"Unexepected token '\" + key + \"'\");\n    if (type === 'var' && this.functionThis === undefined && this.parent !== null) {\n      return this.parent.declare(key, type, value, isGlobal)\n    } else if ((this[type].has(key) && type !== 'const' && !this.globals.has(key)) || !(key in this.allVars)) {\n      if (isGlobal) {\n        this.globals.add(key);\n      }\n      this[type].add(key);\n      this.allVars[key] = value;\n    } else {\n      throw new SandboxError(`Identifier '${key}' has already been declared`);\n    }\n    return new Prop(this.allVars, key, this.const.has(key), isGlobal);\n  }\n}\n\nexport class SandboxError extends Error {\n\n}\n\nlet currentTicks: Ticks;\n\nexport function sandboxFunction(context: IContext): SandboxFunction {\n  return SandboxFunction;\n  function SandboxFunction(...params: any[]) {\n    let code = params.pop() || \"\";\n    let parsed = parse(code);\n    return createFunction(params, parsed.tree, currentTicks, {\n      ctx: context,\n      constants: parsed.constants,\n    }, undefined, 'anonymous');\n  }\n}\n\nconst sandboxedFunctions = new WeakSet();\nexport function createFunction(argNames: string[], parsed: LispItem, ticks: Ticks, context: IExecContext, scope?: Scope, name?: string) {\n  let func = function sandboxedObject(...args) {\n    const vars: any = {};\n    argNames.forEach((arg, i) => {\n      if (arg.startsWith('...')) {\n        vars[arg.substring(3)] = args.slice(i);\n      } else {\n        vars[arg] = args[i];\n      }\n    });\n    const res = executeTree(ticks, context, parsed, scope === undefined ? [] : [new Scope(scope, vars, name === undefined ? undefined : this)])\n    return res.result;\n  };\n  sandboxedFunctions.add(func);\n  return func;\n}\n\nexport function createFunctionAsync(argNames: string[], parsed: LispItem, ticks: Ticks, context: IExecContext, scope?: Scope, name?: string) {\n  let func = async function sandboxedObject(...args) {\n    const vars: any = {};\n    argNames.forEach((arg, i) => {\n      if (arg.startsWith('...')) {\n        vars[arg.substring(3)] = args.slice(i);\n      } else {\n        vars[arg] = args[i];\n      }\n    });\n    const res = await executeTreeAsync(ticks, context, parsed, scope === undefined ? [] : [new Scope(scope, vars, name === undefined ? undefined : this)])\n    return res.result;\n  }\n  sandboxedFunctions.add(func);\n  return func;\n}\n\nexport function sandboxedEval(func: SandboxFunction): sandboxedEval {\n  return sandboxEval;\n  function sandboxEval(code: string) {\n    return func(code)();\n  }\n}\n\nexport function sandboxedSetTimeout(func: SandboxFunction): sandboxSetTimeout {\n  return function sandboxSetTimeout(handler, ...args) {\n    if (typeof handler !== 'string') return setTimeout(handler, ...args);\n    return setTimeout(func(handler), ...args);\n  }\n}\n\nexport function sandboxedSetInterval(func: SandboxFunction): sandboxSetInterval {\n  return function sandboxSetInterval(handler, ...args) {\n    if (typeof handler !== 'string') return setInterval(handler, ...args);\n    return setInterval(func(handler), ...args);\n  }\n}\n\nexport function assignCheck(obj: Prop, context: IExecContext, op = 'assign') {\n  if(obj.context === undefined) {\n    throw new ReferenceError(`Cannot ${op} value to undefined.`)\n  }\n  if(typeof obj.context !== 'object' && typeof obj.context !== 'function') {\n    throw new SyntaxError(`Cannot ${op} value to a primitive.`)\n  }\n  if (obj.isConst) {\n    throw new TypeError(`Cannot set value to const variable '${obj.prop}'`);\n  }\n  if (obj.isGlobal) {\n    throw new SandboxError(`Cannot ${op} property '${obj.prop}' of a global object`);\n  }\n  if (typeof obj.context[obj.prop] === 'function' && !obj.context.hasOwnProperty(obj.prop)) {\n    throw new SandboxError(`Override prototype property '${obj.prop}' not allowed`);\n  }\n  if (op === \"delete\") {\n    if (obj.context.hasOwnProperty(obj.prop)) {\n      context.ctx.changeSubscriptions.get(obj.context)?.forEach((cb) => cb({type: \"delete\", prop: obj.prop}));\n    }\n  } else if (obj.context.hasOwnProperty(obj.prop)) {\n    context.ctx.setSubscriptions.get(obj.context)?.get(obj.prop)?.forEach((cb) => cb({\n      type: \"replace\"\n    }));\n  } else {\n    context.ctx.changeSubscriptions.get(obj.context)?.forEach((cb) => cb({type: \"create\", prop: obj.prop}));\n  }\n}\nconst arrayChange = new Set([\n  [].push,\n  [].pop,\n  [].shift,\n  [].unshift,\n  [].splice,\n  [].reverse,\n  [].sort,\n  [].copyWithin\n]);\nconst literalRegex = /(\\$\\$)*(\\$)?\\${(\\d+)}/g;\ntype OpCallback = (exec: Execution, done: Done, ticks: Ticks, a: LispItem|string[], b: LispItem|Lisp[], obj: Prop|any|undefined, context: IExecContext, scope: Scope, bobj?: Prop|any|undefined, inLoopOrSwitch?: string) => void;\nlet ops2: {[op:string]: OpCallback} = {\n  'prop': (exec, done, ticks, a: LispItem|any, b: string, obj, context, scope) => {\n    if(a === null) {\n      throw new TypeError(`Cannot get property ${b} of null`);\n    }\n    const type = typeof a;\n    if (type === 'undefined' && obj === undefined) {\n      let prop = scope.get(b);\n      if (prop.context === undefined) throw new ReferenceError(`${b} is not defined`);\n      if (prop.context === context.ctx.sandboxGlobal) {\n        if (context.ctx.options.audit) {\n          context.ctx.auditReport.globalsAccess.add(b);\n        }\n        const rep = context.ctx.globalsWhitelist.has(context.ctx.sandboxGlobal[b]) ? context.ctx.evals.get(context.ctx.sandboxGlobal[b]) : undefined;\n        if (rep) {\n          done(undefined, rep);\n          return;\n        }\n      }\n      if (prop.context && prop.context[b] === globalThis) {\n        done(undefined, context.ctx.globalScope.get('this'));\n        return;\n      }\n\n      context.ctx.getSubscriptions.forEach((cb) => cb(prop.context, prop.prop));\n      done(undefined, prop);\n      return;\n    } else if (a === undefined) {\n      throw new SandboxError(\"Cannot get property '\" + b + \"' of undefined\")\n    }\n\n    if (type !== 'object') {\n      if(type === 'number') {\n        a = new Number(a);\n      } else if(type === 'string') {\n        a = new String(a);\n      } else if(type === 'boolean') {\n        a = new Boolean(a);\n      }\n    } else if (typeof a.hasOwnProperty === 'undefined') {\n      done(undefined, new Prop(undefined, b));\n      return;\n    }\n\n    const isFunction = type === 'function';\n    let prototypeAccess = isFunction || !(a.hasOwnProperty(b) || typeof b === 'number');\n\n    if (context.ctx.options.audit && prototypeAccess) {\n      if (typeof b === 'string') {\n        let prot = a.constructor.prototype;\n        do {\n          if (prot.hasOwnProperty(b)) {\n            if(!context.ctx.auditReport.prototypeAccess[prot.constructor.name]) {\n              context.ctx.auditReport.prototypeAccess[prot.constructor.name] = new Set();\n            }\n            context.ctx.auditReport.prototypeAccess[prot.constructor.name].add(b);\n          }\n        } while(prot = Object.getPrototypeOf(prot))\n      }\n    }\n\n    if (prototypeAccess) {\n      if (isFunction) {\n        if (!['name', 'length', 'constructor'].includes(b) && a.hasOwnProperty(b)) {\n          const whitelist = context.ctx.options.prototypeWhitelist.get(a);\n          const replace = context.ctx.options.prototypeReplacements.get(a);\n          if (replace) {\n            done(undefined, new Prop(replace(a, true), b));\n            return;\n          }\n          if (whitelist && (!whitelist.size || whitelist.has(b))) {\n          } else {\n            throw new SandboxError(`Static method or property access not permitted: ${a.name}.${b}`);\n          }\n        }\n      } else if (b !== 'constructor') {\n        let prot = a.constructor.prototype;\n        do {\n          if (prot.hasOwnProperty(b)) {\n            const whitelist = context.ctx.options.prototypeWhitelist.get(prot.constructor);\n            const replace = context.ctx.options.prototypeReplacements.get(prot.constuctor);\n            if (replace) {\n              done(undefined, new Prop(replace(a, false), b));\n              return;\n            }\n            if (whitelist && (!whitelist.size || whitelist.has(b))) {\n              break;\n            }\n            throw new SandboxError(`Method or property access not permitted: ${prot.constructor.name}.${b}`);\n          }\n        } while(prot = Object.getPrototypeOf(prot));\n      }\n    }\n\n    if (context.ctx.evals.has(a[b])) {\n      done(undefined, context.ctx.evals.get(a[b]));\n      return;\n    }\n    if (a[b] === globalThis) {\n      done(undefined, context.ctx.globalScope.get('this'));\n      return;\n    }\n\n    let g = obj.isGlobal || (isFunction && !sandboxedFunctions.has(a)) || context.ctx.globalsWhitelist.has(a);\n\n    if (!g) {\n      context.ctx.getSubscriptions.forEach((cb) => cb(a, b));\n    }\n    done(undefined, new Prop(a, b, false, g));\n  },\n  'call': (exec, done, ticks, a, b: LispArray, obj, context, scope) => {\n    if (context.ctx.options.forbidMethodCalls) throw new SandboxError(\"Method calls are not allowed\");\n    if (typeof a !== 'function') {\n      throw new TypeError(`${obj.prop} is not a function`);\n    }\n    const args = b.map((item) => {\n      if (item instanceof SpreadArray) {\n        return [...item.item];\n      } else {\n        return [item];\n      }\n    }).flat();\n    execMany(ticks, exec, toLispArray(args), (err, vals) => {\n      if (err) {\n        done(err);\n        return;\n      }\n      if (typeof obj === 'function') {\n        done(undefined, obj(...vals));\n        return;\n      }\n      if (obj.context[obj.prop] === JSON.stringify && context.ctx.getSubscriptions.size) {\n        const cache = new Set<any>();\n        const recurse = (x: any) => {\n          if (!x || !(typeof x === 'object') || cache.has(x)) return;\n          cache.add(x);\n          for (let y in x) {\n            context.ctx.getSubscriptions.forEach((cb) => cb(x, y));\n            recurse(x[y]);\n          }\n        };\n        recurse(vals[0]);\n      }\n  \n      if (obj.context instanceof Array && arrayChange.has(obj.context[obj.prop]) && context.ctx.changeSubscriptions.get(obj.context)) {\n        let change: Change;\n        let changed = false;\n        if (obj.prop === \"push\") {\n          change = {\n            type: \"push\",\n            added: vals\n          }\n          changed = !!vals.length;\n        } else if (obj.prop === \"pop\") {\n          change = {\n            type: \"pop\",\n            removed: obj.context.slice(-1)\n          }\n          changed = !!change.removed.length;\n        }  else if (obj.prop === \"shift\") {\n          change = {\n            type: \"shift\",\n            removed: obj.context.slice(0, 1)\n          }\n          changed = !!change.removed.length;\n        } else if (obj.prop === \"unshift\") {\n          change = {\n            type: \"unshift\",\n            added: vals\n          }\n          changed = !!vals.length;\n        } else if (obj.prop === \"splice\") {\n          change = {\n            type: \"splice\",\n            startIndex: vals[0],\n            deleteCount: vals[1] === undefined ? obj.context.length : vals[1],\n            added: vals.slice(2),\n            removed: obj.context.slice(vals[0], vals[1] === undefined ? undefined : vals[0] + vals[1])\n          }\n          changed = !!change.added.length || !!change.removed.length;\n        } else if (obj.prop === \"reverse\" || obj.prop === \"sort\") {\n          change = {type: obj.prop}\n          changed = !!obj.context.length;\n        } else if (obj.prop === \"copyWithin\") {\n          let len = vals[2] === undefined ? obj.context.length - vals[1] : Math.min(obj.context.length, vals[2] - vals[1]);\n          change = {\n            type: \"copyWithin\",\n            startIndex: vals[0],\n            endIndex: vals[0] + len,\n            added: obj.context.slice(vals[1], vals[1] + len),\n            removed: obj.context.slice(vals[0], vals[0] + len)\n          }\n          changed = !!change.added.length || !!change.removed.length;\n        }\n        if (changed) {\n          context.ctx.changeSubscriptions.get(obj.context)?.forEach((cb) => cb(change));\n        }\n      }\n      done(undefined, obj.context[obj.prop](...vals));\n    }, scope, context);\n  },\n  'createObject': (exec, done, ticks, a, b: LispArray, obj, context, scope) => {\n    let res = {} as any;\n    for (let item of b as (KeyVal|SpreadObject)[]) {\n      if (item instanceof SpreadObject) {\n        res = {...res, ...item.item};\n      } else {\n        res[item.key] = item.val;\n      }\n    }\n    done(undefined, res);\n  },\n  'keyVal': (exec, done, ticks, a: string, b: LispItem) => done(undefined, new KeyVal(a, b)),\n  'createArray': (exec, done, ticks, a, b: LispArray, obj, context, scope) => {\n    const items = b.map((item) => {\n      if (item instanceof SpreadArray) {\n        return [...item.item];\n      } else {\n        return [item];\n      }\n    }).flat()\n    execMany(ticks, exec, toLispArray(items), done, scope, context);\n  },\n  'group': (exec, done, ticks, a, b) => done(undefined, b),\n  'string': (exec, done, ticks, a, b: string, obj, context) => done(undefined, context.constants.strings[b]),\n  'regex': (exec, done, ticks, a, b: string, obj, context) => {\n    const reg: IRegEx = context.constants.regexes[b];\n    if (!context.ctx.globalsWhitelist.has(RegExp)) {\n      throw new SandboxError(\"Regex not permitted\");\n    } else {\n      done(undefined, new RegExp(reg.regex, reg.flags));\n    }\n  },\n  'literal': (exec, done, ticks, a, b: number, obj, context, scope) => {\n    let name: string = context.constants.literals[b].a;\n    let found = toLispArray([]);\n    let f;\n    let resnums = [];\n    while(f = literalRegex.exec(name)) {\n      if (!f[2]) {\n        found.push(context.constants.literals[b].b[parseInt(f[3], 10)]);\n        resnums.push(f[3]);\n      }\n    }\n\n    execMany(ticks, exec, found, (err, processed) => {\n      const reses = {};\n      if(err) {\n        done(err);\n        return;\n      }\n      for (let i in resnums) {\n        const num = resnums[i];\n        reses[num] = processed[i];\n      }\n      done(undefined, name.replace(/(\\\\\\\\)*(\\\\)?\\${(\\d+)}/g, (match, $$, $, num) => {\n        if ($) return match;\n        let res = reses[num]\n        res =  res instanceof Prop ? res.context[res.prop] : res;\n        return ($$ ? $$ : '') + `${res}`;\n      }));\n    }, scope, context)\n  },\n  'spreadArray': (exec, done, ticks, a, b: LispItem, obj, context, scope) => {\n    exec(ticks, b, scope, context, (err, res) => {\n      if (err) {\n        done(err);\n        return;\n      }\n      done(undefined, new SpreadArray(res));\n    });\n  },\n  'spreadObject': (exec, done, ticks, a, b: LispItem, obj, context, scope) => {\n    exec(ticks, b, scope, context, (err, res) => {\n      if (err) {\n        done(err);\n        return;\n      }\n      done(undefined, new SpreadObject(res));\n    });\n  },\n  '!': (exec, done, ticks, a, b) => done(undefined, !b),\n  '~': (exec, done, ticks, a, b) => done(undefined, ~b),\n  '++$': (exec, done, ticks, a, b, obj, context) => {\n    assignCheck(obj, context);\n    done(undefined, ++obj.context[obj.prop]);\n  },\n  '$++': (exec, done, ticks, a, b, obj, context) => {\n    assignCheck(obj, context);\n    done(undefined, obj.context[obj.prop]++);\n  },\n  '--$': (exec, done, ticks, a, b, obj, context) => {\n    assignCheck(obj, context);\n    done(undefined, --obj.context[obj.prop]);\n  },\n  '$--': (exec, done, ticks, a, b, obj, context) => {\n    assignCheck(obj, context);\n    done(undefined, obj.context[obj.prop]--);\n  },\n  '=': (exec, done, ticks, a, b, obj, context) => {\n    assignCheck(obj, context);\n    obj.context[obj.prop] = b;\n    done(undefined, new Prop(obj.context, obj.prop, false, obj.isGlobal));\n  },\n  '+=': (exec, done, ticks, a, b, obj, context) => {\n    assignCheck(obj, context);\n    done(undefined, obj.context[obj.prop] += b);\n  },\n  '-=': (exec, done, ticks, a, b: number, obj, context) => {\n    assignCheck(obj, context);\n    done(undefined, obj.context[obj.prop] -= b);\n  },\n  '/=': (exec, done, ticks, a, b: number, obj, context) => {\n    assignCheck(obj, context);\n    done(undefined, obj.context[obj.prop] /= b);\n  },\n  '*=': (exec, done, ticks, a, b: number, obj, context) => {\n    assignCheck(obj, context);\n    done(undefined, obj.context[obj.prop] *= b);\n  },\n  '**=': (exec, done, ticks, a, b: number, obj, context) => {\n    assignCheck(obj, context);\n    done(undefined, obj.context[obj.prop] **= b);\n  },\n  '%=': (exec, done, ticks, a, b: number, obj, context) => {\n    assignCheck(obj, context);\n    done(undefined, obj.context[obj.prop] %= b);\n  },\n  '^=': (exec, done, ticks, a, b: number, obj, context) => {\n    assignCheck(obj, context);\n    done(undefined, obj.context[obj.prop] ^= b);\n  },\n  '&=': (exec, done, ticks, a, b: number, obj, context) => {\n    assignCheck(obj, context);\n    done(undefined, obj.context[obj.prop] &= b);\n  },\n  '|=': (exec, done, ticks, a, b: number, obj, context) => {\n    assignCheck(obj, context);\n    done(undefined, obj.context[obj.prop] |= b);\n  },\n  '<<=': (exec, done, ticks, a, b: number, obj, context) => {\n    assignCheck(obj, context);\n    done(undefined, obj.context[obj.prop] <<= b);\n  },\n  '>>=': (exec, done, ticks, a, b: number, obj, context) => {\n    assignCheck(obj, context);\n    done(undefined, obj.context[obj.prop] >>= b);\n  },\n  '>>>=': (exec, done, ticks, a, b: number, obj, context) => {\n    assignCheck(obj, context);\n    done(undefined, obj.context[obj.prop] >>= b);\n  },\n  '?': (exec, done, ticks, a, b) => {\n    if (!(b instanceof If)) {\n      throw new SyntaxError('Invalid inline if')\n    }\n    done(undefined, a ? (b as any).t : (b as any).f);\n  },\n  '>': (exec, done, ticks, a, b) => done(undefined, a > b),\n  '<': (exec, done, ticks, a, b) => done(undefined, a < b),\n  '>=': (exec, done, ticks, a, b) => done(undefined, a >= b),\n  '<=': (exec, done, ticks, a, b) => done(undefined, a <= b),\n  '==': (exec, done, ticks, a, b) => done(undefined, a == b),\n  '===': (exec, done, ticks, a, b) => done(undefined, a === b),\n  '!=': (exec, done, ticks, a, b) => done(undefined, a != b),\n  '!==': (exec, done, ticks, a, b) => done(undefined, a !== b),\n  '&&': (exec, done, ticks, a, b) => done(undefined, a && b),\n  '||': (exec, done, ticks, a, b) => done(undefined, a || b),\n  '&': (exec, done, ticks, a: number, b: number) => done(undefined, a & b),\n  '|': (exec, done, ticks, a: number, b: number) => done(undefined, a | b),\n  ':': (exec, done, ticks, a, b) => done(undefined, new If(a, b)),\n  '+': (exec, done, ticks, a: number, b: number) => done(undefined, a + b),\n  '-': (exec, done, ticks, a: number, b: number) => done(undefined, a - b),\n  '$+': (exec, done, ticks, a, b) => done(undefined, +b),\n  '$-': (exec, done, ticks, a, b) => done(undefined, -b),\n  '/': (exec, done, ticks, a: number, b: number) => done(undefined, a / b),\n  '^': (exec, done, ticks, a: number, b: number) => done(undefined, a ^ b),\n  '*': (exec, done, ticks, a: number, b: number) => done(undefined, a * b),\n  '%': (exec, done, ticks, a: number, b: number) => done(undefined, a % b),\n  '<<': (exec, done, ticks, a: number, b: number) => done(undefined, a << b),\n  '>>': (exec, done, ticks, a: number, b: number) => done(undefined, a >> b),\n  '>>>': (exec, done, ticks, a: number, b: number) => done(undefined, a >>> b),\n  'typeof': (exec, done, ticks, a, b) => done(undefined, typeof b),\n  'instanceof': (exec, done, ticks, a, b:  { new(): any }) => done(undefined, a instanceof b),\n  'in': (exec, done, ticks, a: string, b) => done(undefined, a in b),\n  'delete': (exec, done, ticks, a, b, obj, context, scope, bobj: Prop) => {\n    if (bobj.context === undefined) {\n      done(undefined, true);\n      return;\n    }\n    assignCheck(bobj, context, 'delete');\n    if (bobj.isVariable) {\n      done(undefined, false);\n      return;\n    }\n    done(undefined, delete bobj.context[bobj.prop]);\n  },\n  'return': (exec, done, ticks, a, b, obj, context) => done(undefined, b),\n  'var': (exec, done, ticks, a: string, b: LispItem, obj, context, scope, bobj) => {\n    exec(ticks, b, scope, context, (err, res) => {\n      if (err) {\n        done(err);\n        return;\n      }\n      done(undefined, scope.declare(a, VarType.var, res));\n    });\n  },\n  'let': (exec, done, ticks, a: string, b: LispItem, obj, context, scope, bobj) => {\n    exec(ticks, b, scope, context, (err, res) => {\n      if (err) {\n        done(err);\n        return;\n      }\n      done(undefined, scope.declare(a, VarType.let, res, bobj && bobj.isGlobal));\n    });\n  },\n  'const': (exec, done, ticks, a: string, b: LispItem, obj, context, scope, bobj) => {\n    exec(ticks, b, scope, context, (err, res) => {\n      if (err) {\n        done(err);\n        return;\n      }\n      done(undefined, scope.declare(a, VarType.const, res));\n    });\n  },\n  'arrowFunc': (exec, done, ticks, a: string[], b: LispItem, obj: Lisp, context, scope) => {\n    a = [...a];\n    if (typeof obj.b === \"string\") {\n      obj.b = b = lispifyFunction(obj.b, context.constants);\n    }\n    if (a.shift()) {\n      done(undefined, createFunctionAsync(a, b, ticks, context, scope));\n    } else {\n      done(undefined, createFunction(a, b, ticks, context, scope));\n    }\n  },\n  'function': (exec, done, ticks, a: string[]&LispArray, b: LispItem, obj: Lisp, context, scope) => {\n    if (typeof obj.b === \"string\") {\n      obj.b = b = lispifyFunction(obj.b, context.constants);\n    }\n    let isAsync = a.shift();\n    let name = a.shift();\n    let func;\n    if (isAsync) {\n      func = createFunctionAsync(a, b, ticks, context, scope, name);\n    } else {\n      func = createFunction(a, b, ticks, context, scope, name);\n    }\n    if (name) {\n      scope.declare(name, VarType.var, func);\n    }\n    done(undefined, func);\n  },\n  'inlineFunction': (exec, done, ticks, a: string[]&LispArray, b: LispItem, obj: Lisp, context, scope) => {\n    if (typeof obj.b === \"string\") {\n      obj.b = b = lispifyFunction(obj.b, context.constants);\n    }\n    let isAsync = a.shift();\n    let name = a.shift();\n    if (name) {\n      scope = new Scope(scope, {})\n    }\n    let func;\n    if (isAsync) {\n      func = createFunctionAsync(a, b, ticks, context, scope, name);\n    } else {\n      func = createFunction(a, b, ticks, context, scope, name);\n    }\n    if (name) {\n      scope.declare(name, VarType.let, func);\n    }\n    done(undefined, func);\n  },\n  'loop': (exec, done, ticks, a: LispArray, b: LispItem, obj, context, scope) => {\n    const [checkFirst, startInternal, startStep, step, condition, beforeStep] = a;\n    let loop = true;\n    const loopScope = new Scope(scope, {});\n    const interalScope = new Scope(loopScope, {});\n    if (exec === execAsync) {\n      (async() => {\n        await asyncDone((d) => exec(ticks, startStep, loopScope, context, d));\n        await asyncDone((d) => exec(ticks, startInternal, interalScope, context, d));\n        if (checkFirst) loop = (await asyncDone((d) => exec(ticks, condition, interalScope, context, d))).result;\n        while (loop) {\n          let innerLoopVars = {};\n          await asyncDone((d) => exec(ticks, beforeStep, new Scope(interalScope, innerLoopVars), context, d));\n          let res = await executeTreeAsync(ticks, context, b, [new Scope(loopScope, innerLoopVars)], \"loop\");\n          if (res instanceof ExecReturn && res.returned) {\n            done(undefined, res);\n            return;\n          }\n          if (res instanceof ExecReturn && res.breakLoop) {\n            break;\n          }\n          await asyncDone((d) => exec(ticks, step, interalScope, context, d));\n          loop = (await asyncDone((d) => exec(ticks, condition, interalScope, context, d))).result;\n        }\n        done();\n      })().catch(done);\n    } else {\n      syncDone((d) => exec(ticks, startStep, loopScope, context, d));\n      syncDone((d) => exec(ticks, startInternal, interalScope, context, d));\n      if (checkFirst) loop = (syncDone((d) => exec(ticks, condition, interalScope, context, d))).result;\n      while (loop) {\n        let innerLoopVars = {};\n        syncDone((d) => exec(ticks, beforeStep, new Scope(interalScope, innerLoopVars), context, d));\n        let res = executeTree(ticks, context, b, [new Scope(loopScope, innerLoopVars)], \"loop\");\n        if (res instanceof ExecReturn && res.returned) {\n          done(undefined, res);\n          return;\n        }\n        if (res instanceof ExecReturn && res.breakLoop) {\n          break;\n        }\n        syncDone((d) => exec(ticks, step, interalScope, context, d));\n        loop = (syncDone((d) => exec(ticks, condition, interalScope, context, d))).result;\n      }\n      done();\n    }\n  },\n  'loopAction': (exec, done, ticks, a: LispItem, b: LispItem, obj, context, scope, bobj, inLoopOrSwitch) => {\n    if ((inLoopOrSwitch === \"switch\" && a === \"continue\") || !inLoopOrSwitch) {\n      throw new SandboxError(\"Illegal \" + a + \" statement\");\n    }\n    done(undefined, new ExecReturn(context.ctx.auditReport, undefined, false, a === \"break\", a === \"continue\"));\n  },\n  'if': (exec, done, ticks, a: LispItem, b: If, obj, context, scope, bobj, inLoopOrSwitch) => {\n    if (!(b instanceof If)) {\n      throw new SyntaxError('Invalid if')\n    }\n    exec(ticks, a, scope, context, (err, res) => {\n      if (err) {\n        done(err);\n        return;\n      }\n      executeTreeWithDone(exec, done, ticks, context, res ? b.t : b.f, [new Scope(scope)], inLoopOrSwitch);\n    });\n  },\n  'switch': (exec, done, ticks, a: LispItem, b: Lisp[], obj, context, scope) => {\n    exec(ticks, a, scope, context, (err, toTest) => {\n      if (err) {\n        done(err);\n        return;\n      }\n      if (exec === execSync) {\n        let res: ExecReturn;\n        let isTrue = false;\n        for (let caseItem of b) {\n          if (isTrue || (isTrue = !caseItem.a || toTest === valueOrProp((syncDone((d) => exec(ticks, caseItem.a, scope, context, d))).result))) {\n            if (!caseItem.b) continue;\n            res = executeTree(ticks, context, caseItem.b, [scope], \"switch\");\n            if (res.breakLoop) break;\n            if (res.returned) {\n              done(undefined, res);\n              return;\n            }\n            if (!caseItem.a) { // default case\n              break;\n            }\n          }\n        }\n        done();\n      } else {\n        (async () => {\n          let res: ExecReturn;\n          let isTrue = false;\n          for (let caseItem of b) {\n            if (isTrue || (isTrue = !caseItem.a || toTest === valueOrProp((await asyncDone((d) => exec(ticks, caseItem.a, scope, context, d))).result))) {\n              if (!caseItem.b) continue;\n              res = await executeTreeAsync(ticks, context, caseItem.b, [scope], \"switch\");\n              if (res.breakLoop) break;\n              if (res.returned) {\n                done(undefined, res);\n                return;\n              }\n              if (!caseItem.a) { // default case\n                break;\n              }\n            }\n          }\n          done();\n        })().catch(done)\n      }\n    });\n  },\n  'try': (exec, done, ticks, a: LispItem, b: [string, LispItem, LispItem]&LispArray, obj, context, scope, bobj, inLoopOrSwitch) => {\n    const [exception, catchBody, finallyBody] = b;\n    executeTreeWithDone(exec, (err, res) => {\n      executeTreeWithDone(exec, (e) => {\n        if (e) done(e);\n        else  if (err) {\n          let sc = {};\n          if (exception) sc[exception] = err;\n          executeTreeWithDone(exec, done, ticks, context, catchBody, [new Scope(scope)], inLoopOrSwitch);\n        } else {\n          done(undefined, res);\n        }\n      }, ticks, context, finallyBody, [new Scope(scope, {})]);\n    }, ticks, context, a, [new Scope(scope)], inLoopOrSwitch);\n  },\n  'void': (exec, done, ticks, a) => {done()},\n  'new': (exec, done, ticks, a: new (...args: any[]) => any, b: any, obj, context) => {\n    if (!context.ctx.globalsWhitelist.has(a) && !sandboxedFunctions.has(a)) {\n      throw new SandboxError(`Object construction not allowed: ${a.constructor.name}`)\n    }\n    done(undefined, new a(...b))\n  },\n  'throw': (exec, done, ticks, a) => { done(a) },\n  'multi': (exec, done, ticks, a: any, b, obj, context, scope) => done(undefined, a.pop())\n}\n\nexport let ops = new Map<string, OpCallback>();\nfor (let op in ops2) {\n  ops.set(op, ops2[op]);\n}\n\nfunction valueOrProp(a: any) {\n  if (a instanceof Prop) return a.context[a.prop];\n  return a;\n}\n\nexport function execMany(ticks: Ticks, exec: Execution, tree: LispArray, done: Done, scope: Scope, context: IExecContext, inLoopOrSwitch?: string) {\n  if (exec === execSync) {\n    _execManySync(ticks, exec, tree, done, scope, context, inLoopOrSwitch);\n  } else {\n    _execManyAsync(ticks, exec, tree, done, scope, context, inLoopOrSwitch).catch(done);\n  }\n}\n\nfunction _execManySync(ticks: Ticks, exec: Execution, tree: LispArray, done: Done, scope: Scope, context: IExecContext, inLoopOrSwitch?: string) {\n  let ret = [];\n  for (let i = 0; i < tree.length; i++) {\n    let res;\n    try {\n      res = syncDone((d) => exec(ticks, tree[i], scope, context, d, inLoopOrSwitch)).result;\n    } catch(e) {\n      done(e);\n      return;\n    }\n    if (res instanceof ExecReturn && (res.returned || res.breakLoop || res.continueLoop)) {\n      done(undefined, res);\n      return;\n    }\n    ret.push(res);\n  }\n  done(undefined, ret);\n}\n\nasync function _execManyAsync(ticks: Ticks, exec: Execution, tree: LispArray, done: Done, scope: Scope, context: IExecContext, inLoopOrSwitch?: string) {\n  let ret = [];\n  for (let i = 0; i < tree.length; i++) {\n    let res;\n    try {\n      res = (await asyncDone((d) => exec(ticks, tree[i], scope, context, d, inLoopOrSwitch))).result;\n    } catch(e) {\n      done(e);\n      return;\n    }\n    if (res instanceof ExecReturn && (res.returned || res.breakLoop || res.continueLoop)) {\n      done(undefined, res);\n      return;\n    }\n    ret.push(res);\n  }\n  done(undefined, ret);\n}\n\ntype Execution = (ticks: Ticks, tree: LispItem, scope: Scope, context: IExecContext, done: Done, inLoopOrSwitch?: string) => void\n\nexport function asyncDone(callback: (done: Done) => void): Promise<{result: any}> {\n  return new Promise((resolve, reject) => {\n    callback((err, result) => {\n      if (err) reject(err);\n      else resolve({result});\n    });\n  });\n}\n\nexport function syncDone(callback: (done: Done) => void): {result: any} {\n  let result;\n  let err;\n  callback((e, r) => {\n    err = e;\n    result = r;\n  });\n  if (err) throw err;\n  return {result};\n}\n\nexport function execAsync(ticks: Ticks, tree: LispItem, scope: Scope, context: IExecContext, done: Done, inLoopOrSwitch?: string): Promise<void> {\n  return new Promise((resolve, reject) => {\n    execWithDone(ticks, tree, scope, context, (e, r) => {\n      done(e, r);\n      resolve();\n    }, true, inLoopOrSwitch);\n  });\n}\n\n\nexport function execSync(ticks: Ticks, tree: LispItem, scope: Scope, context: IExecContext, done: Done, inLoopOrSwitch?: string): void {\n  execWithDone(ticks, tree, scope, context, done, false, inLoopOrSwitch);\n}\n\nfunction execWithDone(ticks: Ticks, tree: LispItem, scope: Scope, context: IExecContext, done: Done, isAsync: boolean, inLoopOrSwitch?: string): void {\n  const exec = isAsync ? execAsync : execSync;\n  if (tree instanceof Prop) {\n    done(undefined, tree.context[tree.prop]);\n  } else if (Array.isArray(tree) && tree.lisp) {\n    execMany(ticks, exec, tree, done, scope, context, inLoopOrSwitch);\n  } else if (!(tree instanceof Lisp)) {\n    done(undefined, tree);\n  } else if (['arrowFunc', 'function', 'inlineFunction', 'loop', 'try', 'switch', 'if'].includes(tree.op)) {\n    try {\n      ops.get(tree.op)(exec, done, ticks, tree.a, tree.b, tree, context, scope, undefined, inLoopOrSwitch);\n    } catch (err) {\n      done(err);\n    }\n  } else if (tree.op === 'await') {\n    if (!isAsync) {\n      done(new SandboxError(\"Illegal use of 'await', must be inside async function\"));\n    } else {\n      execAsync(ticks, tree.a, scope, context, async (e, r) => {\n        if (e) done(e);\n        else done(undefined, await r);\n      }, inLoopOrSwitch);\n    }\n  } else {\n    execWithDone(ticks, tree.a, scope, context, (e, obj) => {\n      if (e) {\n        done(e);\n        return;\n      }\n      let a = obj instanceof Prop ? (obj.context ? obj.context[obj.prop] : undefined) : obj;\n      execWithDone(ticks, tree.b, scope, context, (e, bobj) => {\n        if (e) {\n          done(e);\n          return;\n        }\n        let b = bobj instanceof Prop ? (bobj.context ? bobj.context[bobj.prop] : undefined) : bobj;\n        if (ops.has(tree.op)) {\n          try {\n            ops.get(tree.op)(exec, done, ticks, a, b, obj, context, scope, bobj, inLoopOrSwitch);\n          } catch (err) {\n            done(err);\n          }\n        } else {\n          done(new SyntaxError('Unknown operator: ' + tree.op));\n        }\n      }, isAsync, inLoopOrSwitch);\n    }, isAsync, inLoopOrSwitch);\n  }\n}\n\nexport function executeTree(ticks: Ticks, context: IExecContext, executionTree: LispItem, scopes: ({[key:string]: any}|Scope)[] = [], inLoopOrSwitch?: string): ExecReturn {\n  return syncDone((done) => executeTreeWithDone(execSync, done, ticks, context, executionTree, scopes, inLoopOrSwitch)).result;\n}\n\nexport async function executeTreeAsync(ticks: Ticks, context: IExecContext, executionTree: LispItem, scopes: ({[key:string]: any}|Scope)[] = [], inLoopOrSwitch?: string): Promise<ExecReturn> {\n  return (await asyncDone((done) => executeTreeWithDone(execAsync, done, ticks, context, executionTree, scopes, inLoopOrSwitch))).result;\n}\n\nfunction executeTreeWithDone(exec: Execution, done: Done, ticks: Ticks, context: IExecContext, executionTree: LispItem, scopes: ({[key:string]: any}|Scope)[] = [], inLoopOrSwitch?: string) {\n  if (!executionTree)  {\n    done();\n    return;\n  }\n  if (!(executionTree instanceof Array)) throw new SyntaxError('Bad execution tree');\n  currentTicks = ticks;\n  let scope = context.ctx.globalScope;\n  let s;\n  while (s = scopes.shift()) {\n    if (typeof s !== \"object\") continue;\n    if (s instanceof Scope) {\n      scope = s;\n    } else {\n      scope = new Scope(scope, s, null);\n    }\n  }\n  if (context.ctx.options.audit && !context.ctx.auditReport) {\n    context.ctx.auditReport = {\n      globalsAccess: new Set(),\n      prototypeAccess: {},\n    }\n  }\n  if (exec === execSync) {\n    _executeWithDoneSync(done, ticks, context, executionTree, scope, inLoopOrSwitch);\n  } else {\n    _executeWithDoneAsync(done, ticks, context, executionTree, scope, inLoopOrSwitch).catch(done);\n  }\n}\n\nfunction _executeWithDoneSync(done: Done, ticks: Ticks, context: IExecContext, executionTree: LispItem, scope: Scope, inLoopOrSwitch?: string) {\n  if (!(executionTree instanceof Array)) throw new SyntaxError('Bad execution tree');\n  let i = 0;\n  for (i = 0; i < executionTree.length; i++) {\n    let res;\n    let err;\n    const current = executionTree[i];\n    try {\n      execSync(ticks, current, scope, context, (e, r) => {\n        err = e;\n        res = r;\n      }, inLoopOrSwitch);\n    } catch (e) {\n      err = e;\n    }\n    if (err) {\n      done(err);\n      return;\n    }\n    if (res instanceof ExecReturn) {\n      done(undefined, res);\n      return;\n    }\n    if (current instanceof Lisp && current.op === 'return') {\n      done(undefined, new ExecReturn(context.ctx.auditReport, res, true))\n      return;\n    }\n  }\n  done(undefined, new ExecReturn(context.ctx.auditReport, undefined, false));\n}\n\nasync function _executeWithDoneAsync(done: Done, ticks: Ticks, context: IExecContext, executionTree: LispItem, scope: Scope, inLoopOrSwitch?: string) {\n  if (!(executionTree instanceof Array)) throw new SyntaxError('Bad execution tree');\n  let i = 0;\n  for (i = 0; i < executionTree.length; i++) {\n    let res;\n    let err;\n    const current = executionTree[i];\n    try {\n      await execAsync(ticks, current, scope, context, (e, r) => {\n        err = e;\n        res = r;\n      }, inLoopOrSwitch);\n    } catch (e) {\n      err = e;\n    }\n    if (err) {\n      done(err);\n      return;\n    }\n    if (res instanceof ExecReturn) {\n      done(undefined, res);\n      return;\n    }\n    if (current instanceof Lisp && current.op === 'return') {\n      done(undefined, new ExecReturn(context.ctx.auditReport, res, true))\n      return;\n    }\n  }\n  done(undefined, new ExecReturn(context.ctx.auditReport, undefined, false));\n}\n","import { \n  IGlobals, \n  replacementCallback, \n  IAuditReport, \n  Scope, \n  Change, \n  sandboxFunction,\n  sandboxedEval,\n  sandboxedSetTimeout,\n  sandboxedSetInterval,\n  ExecReturn,\n  executeTree,\n  executeTreeAsync\n} from \"./executor.js\";\nimport { IConstants, parse, IExecutionTree } from \"./parser.js\";\n\nexport interface IOptions {\n  audit?: boolean;\n  forbidMethodCalls?: boolean;\n  prototypeReplacements?: Map<new () => any, replacementCallback>;\n  prototypeWhitelist?: Map<new () => any, Set<string>>;\n  globals: IGlobals;\n  ticksThreshhold?: bigint;\n  executionQuota?: bigint;\n  executionPause?: Promise<void>;\n  onExecutionQuotaReached?: () => boolean|void;\n}\n\nexport interface IContext {\n  sandbox: Sandbox;\n  globalScope: Scope;\n  sandboxGlobal: SandboxGlobal;\n  globalsWhitelist?: Set<any>;\n  options: IOptions;\n  evals: Map<any, any>;\n  getSubscriptions: Set<(obj: object, name: string) => void>;\n  setSubscriptions: WeakMap<object, Map<string, Set<(modification: Change) => void>>>;\n  changeSubscriptions: WeakMap<object, Set<(modification: Change) => void>>;\n  auditReport?: IAuditReport;\n}\n\nexport interface Ticks {\n  ticks: bigint;\n}\n\nexport interface IExecContext {\n  ctx: IContext\n  constants: IConstants;\n}\n\nexport class SandboxGlobal {\n  constructor(globals: IGlobals) {\n    if (globals === globalThis) return globalThis;\n    for (let i in globals) {\n      (this as any)[i] = globals[i];\n    }\n  }\n}\n\nexport default class Sandbox {\n  context: IContext\n  constructor(options?: IOptions) {\n    options = Object.assign({\n      audit: false,\n      forbidMethodCalls: false,\n      globals: Sandbox.SAFE_GLOBALS,\n      prototypeWhitelist: Sandbox.SAFE_PROTOTYPES, \n      prototypeReplacements: new Map<new() => any, replacementCallback>(),\n      executionPause: Promise.resolve()\n    }, options || {});\n    const sandboxGlobal = new SandboxGlobal(options.globals);\n    this.context = {\n      sandbox: this,\n      globalsWhitelist: new Set(Object.values(options.globals)),\n      options,\n      globalScope: new Scope(null, options.globals, sandboxGlobal),\n      sandboxGlobal,\n      evals: new Map(),\n      getSubscriptions: new Set<(obj: object, name: string) => void>(),\n      setSubscriptions: new WeakMap<object, Map<string, Set<() => void>>>(),\n      changeSubscriptions: new WeakMap()\n    };\n    const func = sandboxFunction(this.context);\n    this.context.evals.set(Function, func);\n    this.context.evals.set(eval, sandboxedEval(func));\n    this.context.evals.set(setTimeout, sandboxedSetTimeout(func));\n    this.context.evals.set(setInterval, sandboxedSetInterval(func));\n  }\n\n  static get SAFE_GLOBALS(): IGlobals {\n    return {\n      Function,\n      console: {\n        debug: console.debug, \n        error: console.error, \n        info: console.info, \n        log: console.log, \n        table: console.table, \n        warn: console.warn\n      },\n      isFinite,\n      isNaN,\n      parseFloat,\n      parseInt,\n      decodeURI,\n      decodeURIComponent,\n      encodeURI,\n      encodeURIComponent,\n      escape,\n      unescape,\n      Boolean,\n      Number,\n      String,\n      Object,\n      Array,\n      Symbol,\n      Error,\n      EvalError,\n      RangeError,\n      ReferenceError,\n      SyntaxError,\n      TypeError,\n      URIError,\n      Int8Array,\n      Uint8Array,\n      Uint8ClampedArray,\n      Int16Array,\n      Uint16Array,\n      Int32Array,\n      Uint32Array,\n      Float32Array,\n      Float64Array,\n      Map,\n      Set,\n      WeakMap,\n      WeakSet,\n      Promise,\n      Intl,\n      JSON,\n      Math,\n      Date,\n      RegExp\n    }\n  }\n\n  \n  static get SAFE_PROTOTYPES(): Map<any, Set<string>> {\n    let protos = [\n      SandboxGlobal,\n      Function,\n      Boolean,\n      Number,\n      String,\n      Date,\n      Error,\n      Array,\n      Int8Array,\n      Uint8Array,\n      Uint8ClampedArray,\n      Int16Array,\n      Uint16Array,\n      Int32Array,\n      Uint32Array,\n      Float32Array,\n      Float64Array,\n      Map,\n      Set,\n      WeakMap,\n      WeakSet,\n      Promise,\n      Symbol,\n      Date,\n      RegExp\n    ]\n    let map = new Map<any, Set<string>>();\n    protos.forEach((proto) => {\n      map.set(proto, new Set());\n    });\n    map.set(Object, new Set([\n      'entries',\n      'fromEntries',\n      'getOwnPropertyNames',\n      'is',\n      'keys',\n      'hasOwnProperty',\n      'isPrototypeOf',\n      'propertyIsEnumerable',\n      'toLocaleString',\n      'toString',\n      'valueOf',\n      'values'\n    ]));\n    return map;\n  }\n  \n  subscribeGet(callback: (obj: object, name: string) => void): {unsubscribe: () => void} {\n    this.context.getSubscriptions.add(callback);\n    return {unsubscribe: () => this.context.getSubscriptions.delete(callback)}\n  }\n\n  subscribeSet(obj: object, name: string, callback: (modification: Change) => void): {unsubscribe: () => void} {\n    const names = this.context.setSubscriptions.get(obj) || new Map<string, Set<(modification: Change) => void>>();\n    this.context.setSubscriptions.set(obj, names);\n    const callbacks = names.get(name) || new Set();\n    names.set(name, callbacks);\n    callbacks.add(callback);\n    let changeCbs: Set<(modification: Change) => void>;\n    if (obj && obj[name] && typeof obj[name] === \"object\") {\n      changeCbs = this.context.changeSubscriptions.get(obj[name]) || new Set();\n      changeCbs.add(callback);\n      this.context.changeSubscriptions.set(obj[name], changeCbs);\n    }\n    return {unsubscribe: () => {\n      callbacks.delete(callback);\n      if (changeCbs) changeCbs.delete(callback);\n    }}\n  }\n\n  static audit(code: string, scopes: ({[prop: string]: any}|Scope)[] = []): ExecReturn {\n    const globals = {};\n    for (let i of Object.getOwnPropertyNames(globalThis)) {\n      globals[i] = globalThis[i];\n    }\n    return new Sandbox({\n      globals,\n      audit: true,\n    }).executeTree(parse(code), scopes);\n  }\n\n  static parse(code: string) {\n    return parse(code);\n  }\n\n  executeTree(executionTree: IExecutionTree, scopes: ({[key:string]: any}|Scope)[] = [], maxExecutionTicks = BigInt(0)): ExecReturn {\n    return executeTree({\n      ticks: BigInt(0),\n    }, {\n      ctx: this.context,\n      constants: executionTree.constants\n    }, executionTree.tree, scopes);\n  }\n\n  executeTreeAsync(executionTree: IExecutionTree, scopes: ({[key:string]: any}|Scope)[] = [], maxExecutionTicks = BigInt(0)): Promise<ExecReturn> {\n    return executeTreeAsync({\n      ticks: BigInt(0),\n    }, {\n      ctx: this.context,\n      constants: executionTree.constants,\n    }, executionTree.tree, scopes);\n  }\n  \n  compile(code: string, optimize = false): (...scopes: ({[prop: string]: any}|Scope)[]) => any {\n    const executionTree = parse(code, optimize);\n    return (...scopes: ({[prop: string]: any}|Scope)[]) => {\n      return this.executeTree(executionTree, scopes).result;\n    };\n  };\n  \n  compileAsync(code: string, optimize = false): (...scopes: ({[prop: string]: any}|Scope)[]) => Promise<any> {\n    const executionTree = parse(code, optimize);\n    return async (...scopes: ({[prop: string]: any}|Scope)[]) => {\n      return (await this.executeTreeAsync(executionTree, scopes)).result;\n    };\n  };\n}\n"],"names":["parseHexToInt","hex","match","parseInt","NaN","validateAndParseHex","errorName","enforcedLength","parsedHex","Number","isNaN","undefined","length","SyntaxError","parseHexadecimalCode","code","parsedCode","String","fromCharCode","parseUnicodeCode","surrogateCode","parsedSurrogateCode","isCurlyBraced","text","charAt","parseUnicodeCodePointCode","codePoint","slice","fromCodePoint","err","RangeError","singleCharacterEscapes","Map","parseSingleCharacterCode","get","escapeMatch","unraw","raw","replace","_","backslash","unicodeWithSurrogate","surrogate","unicode","octal","singleCharacter","lispTypes","ParseError","Error","[object Object]","message","super","this","Lisp","obj","op","a","b","If","t","f","KeyVal","key","val","SpreadObject","item","SpreadArray","toLispArray","arr","lisp","inlineIfElse","space","expectTypes","splitter","types","split","next","inlineIf","assignment","assignModify","assign","incrementerBefore","expEdge","call","incrementerAfter","modifier","not","inverse","negative","positive","typeof","delete","dot","arrayProp","prop","value","createObject","createArray","number","string","literal","regex","boolean","null","und","arrowFunctionSingle","arrowFunction","inlineFunction","group","Infinity","void","await","new","throw","initialize","return","spreadObject","spreadArray","expEnd","expSingle","for","do","while","loopAction","if","try","function","switch","closings","(","[","{","'","\"","`","okFirstChars","aChar","aNumber","restOfExp","constants","part","tests","quote","firstOpening","closingsTests","details","allChars","isStart","i","escape","done","lastIsChar","currentIsChar","lastChar","word","char","test","substring","sub","lastIndex","found","exec","foundNumber","Math","min","setLispType","fn","forEach","type","set","closingsCreate","res","expect","ctx","extract","arg","end","push","l","funcFound","lispifyExpr","join","map","e","lispify","str","trimStart","lispTree","includes","trim","quoteCount","condition","isBlock","startTrue","trueBlock","elseBlock","foundElse","lispifyBlock","start","indexOf","caseFound","statement","insertSemicolons","caseTest","cases","defaultFound","cond","bracketFound","exprs","notEmpty","lines","index","matches","primitives","true","false","JSON","parse","isArrow","isReturn","argPos","isAsync","args","unshift","ended","startsWith","func","eager","lispifyFunction","iteratorRegex","body","startStep","startInternal","beforeStep","checkFirst","step","iterator","extract2","k","ofStart2","ofStart3","ofCondition","ofStep","inStart2","inStart3","inStep","inCondition","shift","startingExecpted","catchReg","finallyBody","exception","catchBody","catchRes","offset","argsString","j","lastType","lastPart","expected","subExpressions","pos","defined","parts","filter","Boolean","flat","tree","hoisted","hoist","concat","Array","isArray","rep","it","edgesForInsertion","closingsForInsertion","closingsNoInsertion","whileEnding","rest","pop","oneLinerBlocks","convertOneLiners","nextIndex","c","semi","p","checkRegex","cancel","after","flags","notDivide","possibleDivide","extractConstants","currentEnclosure","regexFound","comment","commentStart","currJs","strRes","enclosures","isPossibleDivide","skip","literals","strings","regexes","js","ExecReturn","auditReport","result","returned","breakLoop","continueLoop","Prop","context","isConst","isGlobal","isVariable","reservedWords","Set","VarType","Scope","parent","vars","functionThis","isFuncScope","allVars","let","Object","keys","var","globals","functionScope","has","hasOwnProperty","const","ReferenceError","TypeError","SandboxError","declare","add","currentTicks","sandboxFunction","SandboxFunction","params","parsed","createFunction","sandboxedFunctions","WeakSet","argNames","ticks","scope","name","executeTree","createFunctionAsync","async","executeTreeAsync","sandboxedEval","sandboxedSetTimeout","handler","setTimeout","sandboxedSetInterval","setInterval","assignCheck","changeSubscriptions","cb","setSubscriptions","arrayChange","splice","reverse","sort","copyWithin","literalRegex","ops2","sandboxGlobal","options","audit","globalsAccess","globalsWhitelist","evals","globalThis","globalScope","getSubscriptions","isFunction","prototypeAccess","prot","constructor","prototype","getPrototypeOf","whitelist","prototypeWhitelist","prototypeReplacements","size","constuctor","g","forbidMethodCalls","execMany","vals","stringify","cache","recurse","x","y","change","changed","added","removed","startIndex","deleteCount","len","endIndex","keyVal","reg","RegExp","resnums","processed","reses","num","$$","$","!","~","++$","$++","--$","$--","=","+=","-=","/=","*=","**=","%=","^=","&=","|=","<<=",">>=",">>>=","?",">","<",">=","<=","==","===","!=","!==","&&","||","&","|",":","+","-","$+","$-","/","^","*","%","<<",">>",">>>","instanceof","in","bobj","arrowFunc","loop","loopScope","interalScope","execAsync","asyncDone","d","innerLoopVars","catch","syncDone","inLoopOrSwitch","executeTreeWithDone","toTest","execSync","isTrue","caseItem","valueOrProp","multi","ops","_execManySync","_execManyAsync","ret","callback","Promise","resolve","reject","r","execWithDone","executionTree","scopes","s","_executeWithDoneSync","_executeWithDoneAsync","current","SandboxGlobal","Sandbox","SAFE_GLOBALS","SAFE_PROTOTYPES","executionPause","sandbox","values","WeakMap","Function","eval","console","debug","error","info","log","table","warn","isFinite","parseFloat","decodeURI","decodeURIComponent","encodeURI","encodeURIComponent","unescape","Symbol","EvalError","URIError","Int8Array","Uint8Array","Uint8ClampedArray","Int16Array","Uint16Array","Int32Array","Uint32Array","Float32Array","Float64Array","Intl","Date","protos","proto","unsubscribe","names","callbacks","changeCbs","getOwnPropertyNames","maxExecutionTicks","BigInt","optimize"],"mappings":"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"}