{"version":3,"file":"Sandbox.min.js","sources":["../src/unraw.ts","../src/parser.ts","../src/executor.ts","../src/Sandbox.ts"],"sourcesContent":["/**\n * Parse a string as a base-16 number. This is more strict than `parseInt` as it\n * will not allow any other characters, including (for example) \"+\", \"-\", and\n * \".\".\n * @param hex A string containing a hexadecimal number.\n * @returns The parsed integer, or `NaN` if the string is not a valid hex\n * number.\n */\nfunction parseHexToInt(hex: string): number {\n  const isOnlyHexChars = !hex.match(/[^a-f0-9]/i);\n  return isOnlyHexChars ? parseInt(hex, 16) : NaN;\n}\n\n/**\n * Check the validity and length of a hexadecimal code and optionally enforces\n * a specific number of hex digits.\n * @param hex The string to validate and parse.\n * @param errorName The name of the error message to throw a `SyntaxError` with\n * if `hex` is invalid. This is used to index `errorMessages`.\n * @param enforcedLength If provided, will throw an error if `hex` is not\n * exactly this many characters.\n * @returns The parsed hex number as a normal number.\n * @throws {SyntaxError} If the code is not valid.\n */\nfunction validateAndParseHex(\n  hex: string,\n  errorName: string,\n  enforcedLength?: number\n): number {\n  const parsedHex = parseHexToInt(hex);\n  if (\n    Number.isNaN(parsedHex) ||\n    (enforcedLength !== undefined && enforcedLength !== hex.length)\n  ) {\n    throw new SyntaxError(errorName + ': ' + hex);\n  }\n  return parsedHex;\n}\n\n/**\n * Parse a two-digit hexadecimal character escape code.\n * @param code The two-digit hexadecimal number that represents the character to\n * output.\n * @returns The single character represented by the code.\n * @throws {SyntaxError} If the code is not valid hex or is not the right\n * length.\n */\nfunction parseHexadecimalCode(code: string): string {\n  const parsedCode = validateAndParseHex(\n    code,\n    'Malformed Hexadecimal',\n    2\n  );\n  return String.fromCharCode(parsedCode);\n}\n\n/**\n * Parse a four-digit Unicode character escape code.\n * @param code The four-digit unicode number that represents the character to\n * output.\n * @param surrogateCode Optional four-digit unicode surrogate that represents\n * the other half of the character to output.\n * @returns The single character represented by the code.\n * @throws {SyntaxError} If the codes are not valid hex or are not the right\n * length.\n */\nfunction parseUnicodeCode(code: string, surrogateCode?: string): string {\n  const parsedCode = validateAndParseHex(code, 'Malformed Unicode', 4);\n\n  if (surrogateCode !== undefined) {\n    const parsedSurrogateCode = validateAndParseHex(\n      surrogateCode,\n      'Malformed Unicode',\n      4\n    );\n    return String.fromCharCode(parsedCode, parsedSurrogateCode);\n  }\n\n  return String.fromCharCode(parsedCode);\n}\n\n/**\n * Test if the text is surrounded by curly braces (`{}`).\n * @param text Text to check.\n * @returns `true` if the text is in the form `{*}`.\n */\nfunction isCurlyBraced(text: string): boolean {\n  return text.charAt(0) === \"{\" && text.charAt(text.length - 1) === \"}\";\n}\n\n/**\n * Parse a Unicode code point character escape code.\n * @param codePoint A unicode escape code point, including the surrounding curly\n * braces.\n * @returns The single character represented by the code.\n * @throws {SyntaxError} If the code is not valid hex or does not have the\n * surrounding curly braces.\n */\nfunction parseUnicodeCodePointCode(codePoint: string): string {\n  if (!isCurlyBraced(codePoint)) {\n    throw new SyntaxError('Malformed Unicode: +' + codePoint);\n  }\n  const withoutBraces = codePoint.slice(1, -1);\n  const parsedCode = validateAndParseHex(\n    withoutBraces,\n    'Malformed Unicode'\n  );\n\n  try {\n    return String.fromCodePoint(parsedCode);\n  } catch (err) {\n    throw err instanceof RangeError\n      ? new SyntaxError('Code Point Limit:' + parsedCode)\n      : err;\n  }\n}\n\n/**\n * Map of unescaped letters to their corresponding special JS escape characters.\n * Intentionally does not include characters that map to themselves like \"\\'\".\n */\nconst singleCharacterEscapes = new Map<string, string>([\n  [\"b\", \"\\b\"],\n  [\"f\", \"\\f\"],\n  [\"n\", \"\\n\"],\n  [\"r\", \"\\r\"],\n  [\"t\", \"\\t\"],\n  [\"v\", \"\\v\"],\n  [\"0\", \"\\0\"]\n]);\n\n/**\n * Parse a single character escape sequence and return the matching character.\n * If none is matched, defaults to `code`.\n * @param code A single character code.\n */\nfunction parseSingleCharacterCode(code: string): string {\n  return singleCharacterEscapes.get(code) || code;\n}\n\n/**\n * Matches every escape sequence possible, including invalid ones.\n *\n * All capture groups (described below) are unique (only one will match), except\n * for 4, which can only potentially match if 3 does.\n *\n * **Capture Groups:**\n * 0. A single backslash\n * 1. Hexadecimal code\n * 2. Unicode code point code with surrounding curly braces\n * 3. Unicode escape code with surrogate\n * 4. Surrogate code\n * 5. Unicode escape code without surrogate\n * 6. Octal code _NOTE: includes \"0\"._\n * 7. A single character (will never be \\, x, u, or 0-3)\n */\nconst escapeMatch = /\\\\(?:(\\\\)|x([\\s\\S]{0,2})|u(\\{[^}]*\\}?)|u([\\s\\S]{4})\\\\u([^{][\\s\\S]{0,3})|u([\\s\\S]{0,4})|([0-3]?[0-7]{1,2})|([\\s\\S])|$)/g;\n\n/**\n * Replace raw escape character strings with their escape characters.\n * @param raw A string where escape characters are represented as raw string\n * values like `\\'` rather than `'`.\n * @param allowOctals If `true`, will process the now-deprecated octal escape\n * sequences (ie, `\\111`).\n * @returns The processed string, with escape characters replaced by their\n * respective actual Unicode characters.\n */\nexport function unraw(raw: string): string {\n  return raw.replace(escapeMatch, function(\n    _,\n    backslash?: string,\n    hex?: string,\n    codePoint?: string,\n    unicodeWithSurrogate?: string,\n    surrogate?: string,\n    unicode?: string,\n    octal?: string,\n    singleCharacter?: string\n  ): string {\n    // Compare groups to undefined because empty strings mean different errors\n    // Otherwise, `\\u` would fail the same as `\\` which is wrong.\n    if (backslash !== undefined) {\n      return \"\\\\\";\n    }\n    if (hex !== undefined) {\n      return parseHexadecimalCode(hex);\n    }\n    if (codePoint !== undefined) {\n      return parseUnicodeCodePointCode(codePoint);\n    }\n    if (unicodeWithSurrogate !== undefined) {\n      return parseUnicodeCode(unicodeWithSurrogate, surrogate);\n    }\n    if (unicode !== undefined) {\n      return parseUnicodeCode(unicode);\n    }\n    if (octal === \"0\") {\n      return \"\\0\";\n    }\n    if (octal !== undefined) {\n      throw new SyntaxError('Octal Deprecation: ' + octal);\n    }\n    if (singleCharacter !== undefined) {\n      return parseSingleCharacterCode(singleCharacter);\n    }\n    throw new SyntaxError('End of string');\n  });\n}\nexport default unraw;","import unraw from \"./unraw.js\";\nexport type LispArray = Array<LispItem>&{lisp: boolean}\nexport type LispItem = Lisp|If|KeyVal|SpreadArray|SpreadObject|(LispArray)|{new(): any }|(new (...args: any[]) => any)|String|Number|Boolean|null|undefined;\nexport interface ILiteral extends Lisp {\n  op: 'literal';\n  a: string;\n  b: LispArray;\n}\n\nexport interface IRegEx {\n  regex: string,\n  flags: string,\n  length: number\n}\n\nexport interface IConstants {\n  strings: string[];\n  literals: ILiteral[];\n  regexes: IRegEx[];\n  eager: boolean;\n}\n\nexport interface IExecutionTree {\n  tree: LispArray, \n  constants: IConstants\n}\n\ntype LispCallback = (strings: IConstants, type: string, parts: string, res: string[], expect: string, ctx: {lispTree: LispItem}) => any\nlet lispTypes: Map<string, LispCallback> = new Map();\n\nexport class ParseError extends Error {\n  constructor(message: string, public code: string) {\n    super(message);\n  }\n}\n\nexport class Lisp {\n  op: string;\n  a?: LispItem;\n  b?: LispItem;\n  constructor(obj: Lisp) {\n    this.op = obj.op;\n    this.a = obj.a;\n    this.b = obj.b;\n  }\n}\n\nexport class If {\n  constructor(public t: any, public f: any) {}\n}\n\nexport class KeyVal {\n  constructor(public key: string, public val: any) {}\n}\n\nexport class SpreadObject {\n  constructor(public item: {[key: string]: any}) {}\n}\n\nexport class SpreadArray {\n  constructor(public item: any[]) {}\n}\n\nexport function toLispArray(arr: LispItem[]): LispArray {\n  (arr as LispArray).lisp = true;\n  return arr as LispArray;\n}\n\nconst inlineIfElse =  /^:/;\nconst space = /^\\s/;\n\nexport let expectTypes: {[type:string]: {types: {[type:string]: RegExp}, next: string[]}} = {\n  splitter: {\n    types: {\n      split: /^(&(?!&)|<=|>=|<(?!<)|>(?!>)|!==|!=(?!\\=)|===|==|\\|(?!\\|)|\\+(?!(\\+))|\\-(?!(\\-))|\\^|<<|>>(?!>)|>>>|instanceof(?![\\w\\$])|in(?![\\w\\$]))(?!\\=)/,\n      op: /^(\\/|\\*\\*|\\*(?!\\*)|\\%)(?!\\=)/,\n      boolOp: /^(&&|\\|\\|)/\n    },\n    next: [\n      'modifier',\n      'value', \n      'prop', \n      'incrementerBefore',\n    ]\n  },\n  inlineIf: {\n    types: {\n      inlineIf: /^\\?(?!\\.)/,\n    },\n    next: [\n      'expEnd'\n    ]\n  },\n  assignment: {\n    types: {\n      assignModify: /^(\\-=|\\+=|\\/=|\\*\\*=|\\*=|%=|\\^=|\\&=|\\|=|>>>=|>>=|<<=)/,\n      assign: /^(=)(?!=)/\n    },\n    next: [\n      'modifier',\n      'value', \n      'prop', \n      'incrementerBefore',\n    ]\n  },\n  incrementerBefore: {\n    types: {incrementerBefore: /^(\\+\\+|\\-\\-)/},\n    next: [\n      'prop',\n    ]\n  },\n  expEdge: {\n    types: {\n      call: /^(\\?\\.)?[\\(]/,\n      incrementerAfter: /^(\\+\\+|\\-\\-)/\n    },\n    next: [\n      'splitter',\n      'expEdge',\n      'inlineIf',\n      'dot',\n      'expEnd'\n    ]\n  },\n  modifier: {\n    types: {\n      not: /^!/,\n      inverse: /^~/,\n      negative: /^\\-(?!\\-)/,\n      positive: /^\\+(?!\\+)/,\n      typeof: /^typeof(?![\\w\\$\\_])/,\n      delete: /^delete(?![\\w\\$\\_])/,\n    },\n    next: [\n      'modifier', \n      'value',\n      'prop',\n      'incrementerBefore',\n    ]\n  },\n  dot: {\n    types: {\n      arrayProp: /^(\\?\\.)?\\[/,\n      dot: /^(\\?)?\\.(?!\\()/,\n    },\n    next: [\n      'splitter',\n      'assignment',\n      'expEdge',\n      'inlineIf',\n      'dot',\n      'expEnd'\n    ]\n  },\n  prop: {\n    types: {\n      prop: /^[a-zA-Z\\$\\_][a-zA-Z\\d\\$\\_]*/,\n    },\n    next: [\n      'splitter',\n      'assignment',\n      'expEdge',\n      'inlineIf',\n      'dot',\n      'expEnd'\n    ]\n  },\n  value: {\n    types: {\n      createObject: /^\\{/,\n      createArray: /^\\[/,\n      number: /^(0x[\\da-f]+(_[\\da-f]+)*|(\\d+(_\\d+)*(\\.\\d+(_\\d+)*)?|\\.\\d+(_\\d+)*))(e[\\+\\-]?\\d+(_\\d+)*)?(n)?(?!\\d)/i,\n      string: /^\"(\\d+)\"/,\n      literal: /^`(\\d+)`/,\n      regex: /^\\/(\\d+)\\/r(?![\\w\\$\\_])/,\n      boolean: /^(true|false)(?![\\w\\$\\_])/,\n      null: /^null(?![\\w\\$\\_])/,\n      und: /^undefined(?![\\w\\$\\_])/,\n      arrowFunctionSingle: /^(async\\s+)?([a-zA-Z\\$_][a-zA-Z\\d\\$_]*)\\s*=>\\s*({)?/,\n      arrowFunction: /^(async\\s*)?\\(\\s*((\\.\\.\\.)?\\s*[a-zA-Z\\$_][a-zA-Z\\d\\$_]*(\\s*,\\s*(\\.\\.\\.)?\\s*[a-zA-Z\\$_][a-zA-Z\\d\\$_]*)*)?\\s*\\)\\s*=>\\s*({)?/,\n      inlineFunction: /^(async\\s+)?function(\\s*[a-zA-Z\\$_][a-zA-Z\\d\\$_]*)?\\s*\\(\\s*((\\.\\.\\.)?\\s*[a-zA-Z\\$_][a-zA-Z\\d\\$_]*(\\s*,\\s*(\\.\\.\\.)?\\s*[a-zA-Z\\$_][a-zA-Z\\d\\$_]*)*)?\\s*\\)\\s*{/,\n      group: /^\\(/,\n      NaN: /^NaN(?![\\w\\$\\_])/,\n      Infinity: /^Infinity(?![\\w\\$\\_])/,\n      void: /^void(?![\\w\\$\\_])\\s*/,\n      await: /^await(?![\\w\\$\\_])\\s*/,\n      new: /^new(?![\\w\\$\\_])\\s*/,\n      throw: /^throw(?![\\w\\$\\_])\\s*/\n    },\n    next: [\n      'splitter',\n      'expEdge',\n      'inlineIf',\n      'dot',\n      'expEnd'\n    ]\n  },\n  initialize: {\n    types: {\n      initialize: /^(var|let|const)\\s+([a-zA-Z\\$_][a-zA-Z\\d\\$_]*)\\s*(=)?/,\n      return: /^return(?![\\w\\$\\_])/,\n    },\n    next: [\n      'modifier',\n      'value', \n      'prop', \n      'incrementerBefore',\n      'expEnd'\n    ]\n  },\n  spreadObject: {\n    types: {\n      spreadObject: /^\\.\\.\\./\n    },\n    next: [\n      'value',\n      'prop', \n    ]\n  },\n  spreadArray: {\n    types: {\n      spreadArray: /^\\.\\.\\./\n    },\n    next: [\n      'value', \n      'prop', \n    ]\n  },\n  expEnd: {types: {}, next: []},\n  expSingle: {\n    types: {\n      for: /^(([a-zA-Z\\$\\_][\\w\\$\\_]*)\\s*:)?\\s*for\\s*\\(/,\n      do: /^(([a-zA-Z\\$\\_][\\w\\$\\_]*)\\s*:)?\\s*do(?![\\w\\$])\\s*(\\{)?/,\n      while: /^(([a-zA-Z\\$\\_][\\w\\$\\_]*)\\s*:)?\\s*while\\s*\\(/,\n      loopAction: /^(break|continue)(?![\\w\\$\\_])/,\n      if: /^if\\s*\\(/,\n      try: /^try\\s*{/,\n      block: /^{/,\n      function: /^(async\\s+)?function(\\s*[a-zA-Z\\$_][a-zA-Z\\d\\$_]*)\\s*\\(\\s*((\\.\\.\\.)?\\s*[a-zA-Z\\$_][a-zA-Z\\d\\$_]*(\\s*,\\s*(\\.\\.\\.)?\\s*[a-zA-Z\\$_][a-zA-Z\\d\\$_]*)*)?\\s*\\)\\s*{/,\n      switch: /^(([a-zA-Z\\$\\_][\\w\\$\\_]*)\\s*:)?\\s*switch\\s*\\(/,\n    },\n    next: [\n      'expEnd'\n    ]\n  }\n};\n\nlet closings = {\n  \"(\": \")\",\n  \"[\": \"]\",\n  \"{\": \"}\",\n  \"'\": \"'\",\n  '\"': '\"',\n  \"`\": \"`\"\n}\n\nexport function testMultiple(str: string, tests: RegExp[]) {\n  let found: RegExpExecArray;\n  for (let i = 0; i < tests.length; i++) {\n    const test = tests[i];\n    found = test.exec(str);\n    if (found) break;\n  }\n  return found;\n}\n\nconst okFirstChars = /^[\\+\\-~ !]/;\nconst aChar = /^[\\w\\$]/\nconst aNumber = expectTypes.value.types.number;\nconst wordReg = /^((if|for|while|do|function)(?![\\w\\$])|[\\w\\$]+)/;\nexport interface restDetails {oneliner?: boolean, words?: string[], lastWord?: string, lastAnyWord?: string, regRes?: RegExpExecArray}\nexport function restOfExp(constants: IConstants, \n                          part: string, \n                          tests?: RegExp[], \n                          quote?: string, \n                          firstOpening?: string, \n                          closingsTests?: RegExp[], \n                          details: restDetails = {}) {\n  details.words = details.words || [];\n  let isStart = true;\n  tests = tests || [];\n  let escape = false;\n  let done = false;\n  let lastIsChar = false;\n  let currentIsChar = false;\n  let lastChar = \"\";\n  let isOneLiner = false;\n  let i;\n  for (i = 0; i < part.length && !done; i++) {\n    let char = part[i];\n    lastIsChar = currentIsChar;\n    currentIsChar = aChar.test(char);\n    if (quote === '\"' || quote === \"'\" || quote === \"`\") {\n      if (quote === \"`\" && char === \"$\" && part[i+1] === \"{\" && !escape) {\n        let skip = restOfExp(constants, part.substring(i+2), [], \"{\");\n        i += skip.length + 2;\n      } else if (char === quote && !escape) {\n        return part.substring(0, i);\n      }\n      escape = !escape && char === \"\\\\\";\n    } else if (closings[char]) {\n      if (isOneLiner && char === \"{\") {\n        isOneLiner = false;\n      }\n      if (char === firstOpening) {\n        done = true;\n        break;\n      } else {;\n        let skip = restOfExp(constants, part.substring(i+1), [], char);\n        i += skip.length + 1;\n        isStart = false;\n        if (closingsTests) {\n          let sub = part.substring(i);\n          let found: RegExpExecArray;\n          if (found = testMultiple(sub, closingsTests)) {\n            details.regRes = found;\n            done = true;\n          }\n        }\n      }\n    } else if (!quote) {\n      let sub = part.substring(i);\n      let foundWord: RegExpExecArray;\n      let foundNumber: RegExpExecArray;\n      if (closingsTests) {\n        let found: RegExpExecArray;\n        if (found = testMultiple(sub, closingsTests)) {\n          details.regRes = found;\n          done = true;\n        }\n      }\n      if (foundNumber = aNumber.exec(sub)) {\n        i += foundNumber[0].length - 1;\n        sub = part.substring(i);\n      } else if (foundWord = wordReg.exec(sub)) {\n        isOneLiner = true;\n        if (foundWord[2]) {\n          details.words.push(foundWord[1]);\n          details.lastAnyWord = foundWord[1];\n          details.lastWord = foundWord[2];\n        }\n        let found = testMultiple(sub, tests);\n        if (found) {\n          if(closingsTests && found[1].length) {\n            i += found[1].length - 1;\n          }\n          done = true;\n        }\n        if (!done && foundWord[0].length > 2) {\n          i += foundWord[0].length - 2;\n        }\n      } else if (lastChar != char) {\n        let found = testMultiple(sub, tests);\n        if (found) {\n          if(closingsTests) {\n            i += found[1].length - 1;\n          }\n          done = true;\n        }\n      }\n      if (isStart) {\n        if (okFirstChars.test(sub)) {\n          done = false;\n        } else {\n          isStart = false;\n        }\n      }\n      if (done) break;\n    } else if(char === closings[quote]) {\n      return part.substring(0, i);\n    }\n    lastChar = char;\n  }\n  if (quote) {\n    throw new SyntaxError(\"Unclosed '\" + quote + \"': \" + quote + part.substring(0, Math.min(i, 40)));\n  }\n  if (details) {\n    details.oneliner = isOneLiner;\n  }\n  return part.substring(0, i);\n}\nrestOfExp.next = [\n  'splitter',\n  'expEnd',\n  'inlineIf'\n];\n\nconst startingExecpted = ['initialize', 'expSingle', 'value', 'modifier', 'prop', 'incrementerBefore', 'expEnd'];\n\nexport const setLispType = (types: string[], fn: LispCallback) => {\n  types.forEach((type) => {\n    lispTypes.set(type, fn);\n  })\n}\n\nconst closingsCreate: {[type:string]: RegExp} = {\n  'createArray': /^\\]/,\n  'createObject': /^\\}/,\n  'group': /^\\)/,\n  'arrayProp': /^\\]/,\n  'call': /^\\)/\n}\n\nsetLispType(['createArray', 'createObject', 'group', 'arrayProp','call'], (constants, type, part, res, expect, ctx) => {\n  let extract = \"\";\n  let arg: string[] = [];\n  let end = false;\n  let i = res[0].length;\n  while (i < part.length && !end) {\n    extract = restOfExp(constants, part.substring(i), [\n      closingsCreate[type],\n      /^,/\n    ]);\n    i += extract.length;\n    if (extract) {\n      arg.push(extract);\n    }\n    if (part[i] !== ',') {\n      end = true;\n    } else {\n      i++;\n    }\n  }\n  const next = ['value', 'modifier', 'prop', 'incrementerBefore', 'expEnd'];\n  let l: LispItem;\n\n  let funcFound: RegExpExecArray;\n  switch(type) {\n    case 'group':\n    case 'arrayProp':\n      l = lispifyExpr(constants, arg.join(\",\"));\n      break;\n    case 'call':\n    case 'createArray':\n      // @TODO: support 'empty' values\n      l = toLispArray(arg.map((e) => lispify(constants, e, [...next, 'spreadArray'])));\n      break;\n    case 'createObject':\n      l = toLispArray(arg.map((str) => {\n        str = str.trimStart();\n        let value;\n        let key;\n        funcFound = expectTypes.expSingle.types.function.exec('function ' + str);\n        if (funcFound) {\n          key = funcFound[2].trimStart();\n          value = lispify(constants, 'function ' + str.replace(key, \"\"));\n        } else {\n          let extract = restOfExp(constants, str, [/^:/]);\n          key = lispify(constants, extract, [...next, 'spreadObject']);\n          if (key instanceof Lisp && key.op === 'prop') {\n            key = key.b;\n          }\n          if (extract.length === str.length) return key;\n          value = lispify(constants, str.substring(extract.length + 1));\n        }\n        return new Lisp({\n          op: 'keyVal',\n          a: key,\n          b: value\n        });\n      }));\n      break;\n  }\n  type = type === 'arrayProp' ? (res[1] ? '?prop' : 'prop') : (type === 'call' ? (res[1] ? '?call' : 'call') : type);\n  ctx.lispTree = lispify(constants, part.substring(i + 1), expectTypes[expect].next, new Lisp({\n    op: type, \n    a: ctx.lispTree, \n    b: l,\n  }));\n});\n\nsetLispType(['inverse', 'not', 'negative', 'positive', 'typeof', 'delete', 'op'], (constants, type, part, res, expect, ctx) => {\n  let extract = restOfExp(constants, part.substring(res[0].length), [/^[^\\s\\.\\w\\$]/]);\n  ctx.lispTree = lispify(constants, part.substring(extract.length + res[0].length), restOfExp.next, new Lisp({\n    op: ['positive', 'negative'].includes(type) ? '$' + res[0] : res[0],\n    a: ctx.lispTree, \n    b: lispify(constants, extract, expectTypes[expect].next), \n  }));\n});\n\nsetLispType(['incrementerBefore'], (constants, type, part, res, expect, ctx) => {\n  let extract = restOfExp(constants, part.substring(2), [/^[^\\s\\.\\w\\d\\$]/]);\n  ctx.lispTree = lispify(constants, part.substring(extract.length + 2), restOfExp.next, new Lisp({\n    op: res[0] + \"$\", \n    a: lispify(constants, extract, expectTypes[expect].next), \n  }));\n});\n\nsetLispType(['incrementerAfter'], (constants, type, part, res, expect, ctx) => {\n  ctx.lispTree = lispify(constants, part.substring(res[0].length), expectTypes[expect].next, new Lisp({\n    op: \"$\"  + res[0], \n    a: ctx.lispTree, \n  }));\n});\n\nsetLispType(['assign', 'assignModify', 'boolOp'], (constants, type, part, res, expect, ctx) => {\n  ctx.lispTree = new Lisp({\n    op: res[0], \n    a: ctx.lispTree,\n    b: lispify(constants, part.substring(res[0].length), expectTypes[expect].next)\n  });\n});\n\nsetLispType(['split'], (constants, type, part, res, expect, ctx) => {\n  let extract = restOfExp(constants, part.substring(res[0].length),[\n    expectTypes.splitter.types.split,\n    expectTypes.splitter.types.boolOp,\n    expectTypes.inlineIf.types.inlineIf,\n    inlineIfElse\n  ]);\n  ctx.lispTree = lispify(constants, part.substring(extract.length + res[0].length), restOfExp.next, new Lisp({\n    op: res[0],\n    a: ctx.lispTree, \n    b: lispify(constants, extract, expectTypes[expect].next), \n  }));\n});\n\nsetLispType(['inlineIf'], (constants, type, part, res, expect, ctx) => {\n  let found = false;\n  let extract = \"\";\n  let quoteCount = 1;\n  while(!found && extract.length < part.length) {\n    extract += restOfExp(constants, part.substring(extract.length + 1), [\n      expectTypes.inlineIf.types.inlineIf,\n      inlineIfElse\n    ]);\n    if (part[extract.length + 1] === '?') {\n      quoteCount++\n    } else {\n      quoteCount--\n    }\n    if (!quoteCount) {\n      found = true;\n    } else {\n      extract += part[extract.length + 1];\n    }\n  }\n  ctx.lispTree = new Lisp({\n    op: '?',\n    a: ctx.lispTree, \n    b: new Lisp({\n      op: ':',\n      a: lispifyExpr(constants, extract),\n      b: lispifyExpr(constants, part.substring(res[0].length + extract.length + 1))\n    })\n  });\n});\n\nsetLispType(['if'], (constants, type, part, res, expect, ctx) => {\n  let condition = restOfExp(constants, part.substring(res[0].length), [], \"(\");\n  const isBlock = /^\\s*\\{/.exec(part.substring(res[0].length + condition.length + 1));\n  const startTrue = res[0].length + condition.length + 1 + (isBlock ? isBlock[0].length : 0);\n  let trueBlock = restOfExp(constants, part.substring(startTrue), isBlock ? [/^\\}/] : [/^;/]);\n  let elseBlock = \"\";\n  if (startTrue + trueBlock.length + (isBlock ? isBlock[0].length : 0) < part.length) {\n    const end = part.substring(startTrue + trueBlock.length + (isBlock ? isBlock[0].length : 1));\n    const foundElse = /^;?\\s*else(?![\\w\\$])\\s*/.exec(end);\n    if (foundElse) {\n      elseBlock = end.substring(foundElse[0].length);\n    }\n  }\n  \n  condition = condition.trim();\n  trueBlock = trueBlock.trim();\n  elseBlock = elseBlock.trim();\n  // console.log({condition, trueBlock, elseBlock})\n  if (trueBlock[0] === \"{\") trueBlock = trueBlock.slice(1, -1);\n  if (elseBlock[0] === \"{\") elseBlock = elseBlock.slice(1, -1);\n  ctx.lispTree = new Lisp({\n    op: 'if',\n    a: lispifyExpr(constants, condition), \n    b: new If(lispifyBlock(trueBlock, constants), elseBlock ? lispifyBlock(elseBlock, constants) : undefined)\n  });\n});\n\nsetLispType(['switch'], (constants, type, part, res, expect, ctx) => {\n  const test = restOfExp(constants, part.substring(res[0].length), [], \"(\");\n  let start = part.indexOf(\"{\", res[0].length + test.length + 1);\n  if (start === -1) throw new SyntaxError(\"Invalid switch: \" + part);\n  let statement = insertSemicolons(constants, restOfExp(constants, part.substring(start + 1), [], \"{\"));\n  let caseFound: RegExpExecArray;\n  const caseTest = /^\\s*(case\\s|default)\\s*/;\n  let cases: Lisp[] = [];\n  let defaultFound = false;\n  while(caseFound = caseTest.exec(statement)) {\n    if (caseFound[1] === 'default') {\n      if (defaultFound) throw new SyntaxError(\"Only one default switch case allowed:\" + statement);\n      defaultFound = true;\n    }\n    let cond = restOfExp(constants, statement.substring(caseFound[0].length), [/^:/]);\n    let found = \"\";\n    let i = start = caseFound[0].length + cond.length + 1;\n    let bracketFound = /^\\s*\\{/.exec(statement.substring(i));\n    let exprs = [];\n    if (bracketFound) {\n      i += bracketFound[0].length;\n      found = restOfExp(constants, statement.substring(i), [], \"{\");\n      i += found.length + 1;\n      exprs = lispifyBlock(found, constants);\n    } else {\n      let notEmpty = restOfExp(constants, statement.substring(i), [caseTest]);\n      if (!notEmpty.trim()) {\n        exprs = [];\n        i += notEmpty.length;\n      } else {\n        let lines = [];\n        while(found = restOfExp(constants, statement.substring(i), [/^;/])) {\n          lines.push(found);\n          i += found.length + 1;\n          if (caseTest.test(statement.substring(i))) {\n            break;\n          }\n        }\n        exprs = lispifyBlock(lines.join(\";\"), constants);\n      }\n    }\n    statement = statement.substring(i);\n    cases.push(new Lisp({\n      op: \"case\",\n      a: caseFound[1] === \"default\" ? undefined : lispifyExpr(constants, cond),\n      b: toLispArray(exprs)\n    }));\n  }\n  ctx.lispTree = new Lisp({\n    op: 'switch',\n    a: lispifyExpr(constants, test),\n    b: toLispArray(cases)\n  });\n});\n\nsetLispType(['dot', 'prop'], (constants, type, part, res, expect, ctx) => {\n  let prop = res[0];\n  let index = res[0].length;\n  let op = 'prop';\n  if (type === 'dot') {\n    if (res[1]) {\n      op = '?prop';\n    }\n    let matches = part.substring(res[0].length).match(expectTypes.prop.types.prop);\n    if (matches && matches.length) {\n      prop = matches[0];\n      index = prop.length + res[0].length\n    } else {\n      throw new SyntaxError('Hanging  dot:' + part);\n    }\n  }\n  ctx.lispTree = lispify(constants, part.substring(index), expectTypes[expect].next, new Lisp({\n    op: op, \n    a: ctx.lispTree, \n    b: prop\n  }));\n});\n\nsetLispType(['spreadArray', 'spreadObject'], (constants, type, part, res, expect, ctx) => {\n  ctx.lispTree = new Lisp({\n    op: type,\n    b: lispify(constants, part.substring(res[0].length), expectTypes[expect].next)\n  });\n});\n\nsetLispType(['return'], (constants, type, part, res, expect, ctx) => {\n  ctx.lispTree = new Lisp({\n    op: type,\n    b: lispifyExpr(constants, part.substring(res[0].length))\n  });\n});\n\nconst primitives = {\n  \"true\": true,\n  \"false\": false,\n  \"null\": null,\n  Infinity,\n  NaN,\n  \"und\": undefined\n}\n\nsetLispType(['number', 'boolean', 'null', 'und', 'NaN', 'Infinity'], (constants, type, part, res, expect, ctx) => {\n  ctx.lispTree = lispify(constants, part.substring(res[0].length), expectTypes[expect].next, type === \"number\" ? (res[10] ? BigInt(res[1]) : Number(res[0])) : primitives[type === \"boolean\" ? res[0] : type]);\n});\n\nsetLispType(['string', 'literal', 'regex'], (constants, type, part, res, expect, ctx) => {\n  ctx.lispTree = lispify(constants, part.substring(res[0].length), expectTypes[expect].next, new Lisp({\n    op: type,\n    b: parseInt(JSON.parse(res[1]), 10),\n  }));\n});\n\nsetLispType(['initialize'], (constants, type, part, res, expect, ctx) => {\n  if (!res[3]) {\n    ctx.lispTree = lispify(constants, part.substring(res[0].length), expectTypes[expect].next, new Lisp({\n      op: res[1],\n      a: res[2]\n    }));\n  } else {\n    ctx.lispTree = new Lisp({\n      op: res[1],\n      a: res[2],\n      b: lispify(constants, part.substring(res[0].length), expectTypes[expect].next)\n    });\n  }\n});\n\nsetLispType(['function', 'inlineFunction', 'arrowFunction', 'arrowFunctionSingle'], (constants, type, part, res, expect, ctx) => {\n  const isArrow = type !== 'function' && type !== 'inlineFunction';\n  const isReturn = isArrow && !res[res.length - 1];\n  const argPos = isArrow ? 2 : 3;\n  const isAsync = !!res[1];\n  const args: any[] = res[argPos] ? res[argPos].replace(/\\s+/g, \"\").split(/,/g) : [];\n  if (!isArrow) {\n    args.unshift((res[2] || \"\").trimStart());\n  }\n  let ended = false;\n  args.forEach((arg) => {\n    if (ended) throw new SyntaxError('Rest parameter must be last formal parameter');\n    if (arg.startsWith('...')) ended = true;\n  });\n  args.unshift(isAsync);\n  const func = (isReturn ? 'return ' : '') + restOfExp(constants, part.substring(res[0].length), !isReturn ? [/^}/] : [/^[,;\\)\\}\\]]/]);\n  ctx.lispTree = lispify(constants, part.substring(res[0].length + func.length + 1), expectTypes[expect].next, new Lisp({\n    op: isArrow ? 'arrowFunc' : type,\n    a: toLispArray(args),\n    b: constants.eager ? lispifyFunction(func, constants) : func\n  }));\n});\n\nconst iteratorRegex = /^((let|var|const)\\s+)?\\s*([a-zA-Z\\$_][a-zA-Z\\d\\$_]*)\\s+(in|of)(?![\\w\\$])/\nsetLispType(['for', 'do', 'while'], (constants, type, part, res, expect, ctx) => {\n  let i = 0;\n  let startStep: LispItem = true;\n  let startInternal: LispArray = toLispArray([]);\n  let getIterator: LispItem;\n  let beforeStep: LispItem = false;\n  let checkFirst = true;\n  let condition: LispItem;\n  let step: LispItem = true;\n  let body: string;\n  switch (type) {\n    case 'while':\n      i = part.indexOf(\"(\") + 1;\n      let extract = restOfExp(constants, part.substring(i), [], \"(\");\n      condition = lispifyExpr(constants, extract);\n      body = restOfExp(constants, part.substring(i + extract.length + 1)).trim();\n      if (body[0] === \"{\") body = body.slice(1, -1);\n      break;\n    case 'for':\n      i = part.indexOf(\"(\") + 1;\n      let args: string[] = [];\n      let extract2 = \"\";\n      for (let k = 0; k < 3; k++)  {\n        extract2 = restOfExp(constants, part.substring(i), [/^[;\\)]/]);\n        args.push(extract2.trim());\n        i += extract2.length + 1;\n        if (part[i - 1] === \")\") break;\n      }\n      let iterator: RegExpExecArray;\n      if (args.length === 1 && (iterator = iteratorRegex.exec(args[0]))) {\n        if (iterator[4] === 'of') {\n          getIterator = lispifyExpr(constants, args[0].substring(iterator[0].length)),\n          startInternal = toLispArray([\n            ofStart2, \n            ofStart3\n          ]);\n          condition = ofCondition;\n          step = ofStep;\n          beforeStep = lispify(constants, (iterator[1] || 'let ') + iterator[3]  + ' = $$next.value', ['initialize']);\n        } else {\n          getIterator = lispifyExpr(constants, args[0].substring(iterator[0].length)),\n          startInternal = toLispArray([\n            inStart2,\n            inStart3\n          ]);\n          step = inStep;\n          condition = inCondition;\n          beforeStep = lispify(constants, (iterator[1] || 'let ') + iterator[3] + ' = $$keys[$$keyIndex]', ['initialize']);\n        }\n      } else if (args.length === 3) {\n        startStep = lispifyExpr(constants, args.shift(), startingExecpted);\n        condition = lispifyExpr(constants, args.shift());\n        step = lispifyExpr(constants, args.shift());\n      } else {\n        throw new SyntaxError(\"Invalid for loop definition: \" + args.join(\";\"));\n      }\n      body = restOfExp(constants, part.substring(i)).trim();\n      if (body[0] === \"{\") body = body.slice(1, -1);\n\n      break;\n    case 'do':\n      checkFirst = false;\n      const isBlock = !!res[3];\n      body = restOfExp(constants, part.substring(res[0].length), isBlock ? [/^\\}/] : [/^;/]);\n      condition = lispifyExpr(constants, restOfExp(constants, part.substring(part.indexOf(\"(\", res[0].length + body.length) + 1), [], \"(\"));\n      break;\n  }\n  const a = [checkFirst, startInternal, getIterator, startStep, step, condition, beforeStep] as any;\n  a.lisp = true;\n  ctx.lispTree = new Lisp({\n    op: 'loop',\n    a,\n    b: lispifyBlock(body, constants)\n  });\n});\n\nsetLispType(['block'], (constants, type, part, res, expect, ctx) => {\n  ctx.lispTree = lispifyBlock(restOfExp(constants, part.substring(1), [], \"{\"), constants);\n});\n\nsetLispType(['loopAction'], (constants, type, part, res, expect, ctx) => {\n  ctx.lispTree = new Lisp({\n    op: 'loopAction',\n    a: res[1],\n  });\n});\n\nconst catchReg = /^\\s*(catch\\s*(\\(\\s*([a-zA-Z\\$_][a-zA-Z\\d\\$_]*)\\s*\\))?|finally)\\s*\\{/\nsetLispType(['try'], (constants, type, part, res, expect, ctx) => {\n  const body = restOfExp(constants, part.substring(res[0].length), [], \"{\");\n  let catchRes = catchReg.exec(part.substring(res[0].length + body.length + 1));\n  let finallyBody;\n  let exception;\n  let catchBody;\n  let offset = 0;\n  if (catchRes[1].startsWith('catch')) {\n    catchRes = catchReg.exec(part.substring(res[0].length + body.length + 1));\n    exception = catchRes[2];\n    catchBody = restOfExp(constants, part.substring(res[0].length + body.length + 1 + catchRes[0].length), [], \"{\");\n    offset = res[0].length + body.length + 1 + catchRes[0].length + catchBody.length + 1;\n    if ((catchRes = catchReg.exec(part.substring(offset))) && catchRes[1].startsWith('finally')) {\n      finallyBody = restOfExp(constants, part.substring(offset + catchRes[0].length), [], \"{\");\n    }\n  } else {\n    finallyBody = restOfExp(constants, part.substring(res[0].length + body.length + 1 + catchRes[0].length), [], \"{\");\n  }\n  const b = [\n    exception,\n    lispifyBlock(insertSemicolons(constants, catchBody || \"\"), constants),\n    lispifyBlock(insertSemicolons(constants, finallyBody || \"\"), constants),\n  ] as any;\n  b.lisp = true;\n  ctx.lispTree = new Lisp({\n    op: 'try',\n    a: lispifyBlock(insertSemicolons(constants, body), constants),\n    b\n  });\n});\n\nsetLispType(['void', 'await', 'throw'], (constants, type, part, res, expect, ctx) => {\n  const extract = restOfExp(constants, part.substring(res[0].length), [/^[^\\s\\.\\w\\d\\$]/]);\n  ctx.lispTree = lispify(constants, part.substring(res[0].length + extract.length), expectTypes[expect].next, new Lisp({\n    op: type,\n    a: lispify(constants, extract),\n  }));\n});\n\nsetLispType(['new'], (constants, type, part, res, expect, ctx) => {\n  let i = res[0].length;\n  const obj = restOfExp(constants, part.substring(i), [], undefined, \"(\");\n  i += obj.length + 1;\n  const args = [];\n  if (part[i - 1] === \"(\") {\n    const argsString = restOfExp(constants, part.substring(i), [], \"(\");\n    i += argsString.length + 1;\n    let found;\n    let j = 0;\n    while(found = restOfExp(constants, argsString.substring(j), [/^,/])) {\n      j += found.length + 1;\n      args.push(found.trim());\n    } \n  }\n  ctx.lispTree = lispify(constants, part.substring(i), expectTypes.expEdge.next, new Lisp({\n    op: type,\n    a: lispify(constants, obj, expectTypes.initialize.next),\n    b: toLispArray(args.map((arg) => lispify(constants, arg, expectTypes.initialize.next))),\n  }));\n});\n\nconst ofStart2 = lispify(undefined, 'let $$iterator = $$obj[Symbol.iterator]()', ['initialize']);\nconst ofStart3 = lispify(undefined, 'let $$next = $$iterator.next()', ['initialize']);\nconst ofCondition = lispify(undefined, 'return !$$next.done', ['initialize']);\nconst ofStep = lispify(undefined, '$$next = $$iterator.next()');\nconst inStart2 = lispify(undefined, 'let $$keys = Object.keys($$obj)', ['initialize']);\nconst inStart3 = lispify(undefined, 'let $$keyIndex = 0', ['initialize']);\nconst inStep = lispify(undefined, '$$keyIndex++');\nconst inCondition = lispify(undefined, 'return $$keyIndex < $$keys.length', ['initialize']);\n\nvar lastType;\nvar lastPart;\nvar lastLastPart;\nvar lastLastLastPart;\nvar lastLastLastLastPart;\nfunction lispify(constants: IConstants, part: string, expected?: string[], lispTree?: LispItem): LispItem {\n  expected = expected || expectTypes.initialize.next;\n  if (part === undefined) return lispTree;\n\n  part = part.trim();\n\n  if (!part.length && !expected.includes('expEnd')) {\n    throw new SyntaxError(\"Unexpected end of expression: \" + lastLastLastPart);\n  }\n  \n  if (!part) return lispTree;\n\n  let ctx = {lispTree: lispTree};\n\n  let res: any;\n  for (let expect of expected) {\n    if (expect === 'expEnd') {\n      continue;\n    }\n    for (let type in expectTypes[expect].types) {\n      if (type === 'expEnd') {\n        continue;\n      }\n      if(res = expectTypes[expect].types[type].exec(part)) {\n        lastType = type;\n        // console.log(type, part)\n        lastLastLastLastPart = lastLastLastPart;\n        lastLastLastPart = lastLastPart;\n        lastLastPart = lastPart;\n        lastPart = part;\n        lispTypes.get(type)(constants, type, part, res, expect, ctx);\n        break;\n      }\n    }\n    if (res) break;\n  }\n\n  if (!res && part.length) {\n    throw SyntaxError(`Unexpected token (${lastType}): ${lastPart.substring(0, 100)}`);\n  }\n  return ctx.lispTree;\n}\n\nconst startingExpectedWithoutSingle = startingExecpted.filter((r) => r !== 'expSingle');\n\nfunction lispifyExpr(constants: IConstants, str: string, expected?: string[]): LispItem {\n  if (!str.trim()) return undefined;\n  let subExpressions = [];\n  let sub: string;\n  let pos = 0;\n  expected = expected || expectTypes.initialize.next;\n  if (expected.includes('expSingle')) {\n    if (testMultiple(str, Object.values(expectTypes.expSingle.types))) {\n      return lispify(constants, str, ['expSingle']);\n    }\n  }\n  if (expected === startingExecpted) expected = startingExpectedWithoutSingle;\n  while ((sub = restOfExp(constants, str.substring(pos), [/^,/]))) {\n    subExpressions.push(sub.trimStart());\n    pos += sub.length + 1;\n  }\n  if (subExpressions.length === 1) {\n    return lispify(constants, str, expected);\n  }\n  if (expected.includes('initialize')) {\n    let defined = expectTypes.initialize.types.initialize.exec(subExpressions[0]);\n    if (defined) {\n      return toLispArray(subExpressions.map((str, i) => lispify(constants, i ? defined[1] + ' ' + str : str, ['initialize'])));\n    } else if (expectTypes.initialize.types.return.exec(subExpressions[0])) {\n      return lispify(constants, str, expected);\n    }\n  }\n  const exprs = toLispArray(subExpressions.map((str, i) => lispify(constants, str, expected)));\n  return new Lisp({op: \"multi\", a: exprs});\n}\n\nexport function lispifyBlock(str: string, constants: IConstants): LispArray {\n  // console.log({str})\n  str = insertSemicolons(constants, str);\n  // console.log({str})\n  if (!str.trim()) return toLispArray([]);\n  let parts = [];\n  let part: string;\n  let pos = 0;\n  let details: restDetails = {};\n  let oneliner: string[] = [];\n  while ((part = restOfExp(constants, str.substring(pos), [/^;/], undefined, undefined, undefined, details))) {\n    if (details.words.includes('if') && /^\\s*else(?![\\w\\$])/.test(str.substring(pos + part.length + 1))) {\n      oneliner.push(part, \";\");\n    } else if (details.words.includes('do') && /^\\s*while(?![\\w\\$])/.test(str.substring(pos + part.length + 1))) {\n      oneliner.push(part, \";\");\n    } else {\n      parts.push(oneliner.join(\"\") + part);\n      oneliner = [];\n    }\n    details = {};\n    pos += part.length + 1;\n  }\n  if (oneliner.length) {\n    parts.push(oneliner.join(\"\"));\n  }\n  // console.log({part, str})\n  return toLispArray(parts.filter(Boolean).map((str, j) => {\n    return lispifyExpr(constants, str.trimStart(), startingExecpted);\n  }).flat());\n}\n\nexport function lispifyFunction(str: string, constants: IConstants): LispArray {\n  if (!str.trim()) return toLispArray([]);\n  const tree = lispifyBlock(str, constants);\n  let hoisted: LispArray = toLispArray([]);\n  hoist(tree, hoisted);\n  return toLispArray(hoisted.concat(tree));\n}\n\nfunction hoist(item: LispItem, res: LispArray): boolean {\n  if (Array.isArray(item)) {\n    const rep = [];\n    for (let it of item) {\n      if (!hoist(it, res)) {\n        rep.push(it);\n      }\n    }\n    if (rep.length !== item.length) {\n      item.length = 0;\n      item.push(...rep);\n    }\n  } else if (item instanceof Lisp) {\n    if (item.op === \"try\" || item.op === \"if\" || item.op === \"loop\" || item.op === \"switch\") {\n      hoist(item.a, res);\n      hoist(item.b, res);\n    } else if (item.op === \"var\") {\n      res.push(new Lisp({op: 'var', a: item.a}));\n    } else if (item.op === \"function\" && item.a[1]) {\n      res.push(item);\n      return true;\n    }\n  }\n  return false;\n}\n\nconst edgesForInsertion = [\n  /^([\\w\\$]|\\+\\+|\\-\\-)\\s*\\r?\\n\\s*([\\w\\$\\+\\-])/,\n  /^([^\\w\\$](return|continue|break|throw))\\s*\\r?\\n\\s*[^\\s]/\n];\nconst closingsForInsertion = [\n  /^([\\)\\]])\\s*\\r?\\n\\s*([\\w\\$\\{\\+\\-])/,\n  /^(\\})\\s*\\r?\\n?\\s*([\\(])/,\n  /^(\\})\\s*(\\r?\\n)?\\s*([\\w\\[\\+\\-])/,\n];\nconst closingsNoInsertion = /^(\\})\\s*(catch|finally|else|while|instanceof)(?![\\w\\$])/\nconst whileEnding = /^\\}\\s*while/\n                    //  \\w|)|] \\n \\w = 2                                  // \\} \\w|\\{ = 5 \nconst colonsRegex = /^((([\\w\\$\\]\\)]|\\+\\+|\\-\\-)\\s*\\r?\\n\\s*([\\w\\$\\+\\-\\!~]))|(\\}\\s*[\\w\\$\\!~\\+\\-\\{\\(]))/\n\n// if () \\w \\n; \\w              == \\w \\n \\w    | last === if             a\n// if () { }; \\w                == \\} ^else    | last === if             b\n// if () \\w \\n; else \\n \\w \\n;  == \\w \\n \\w    | last === else           a\n// if () {} else {}; \\w         == \\} \\w       | last === else           b\n// while () \\n \\w \\n; \\w        == \\w \\n \\w    | last === while          a\n// while () { }; \\w             == \\} \\w       | last === while          b\n// do \\w \\n; while (); \\w       == \\w \\n while | last === do             a\n// do { } while (); \\w          == \\) \\w       | last === while          c\n// try {} catch () {}; \\w       == \\} \\w       | last === catch|finally  b\n// \\w \\n; \\w                    == \\w \\n \\w    | last === none           a\n// cb() \\n \\w                   == \\) \\n \\w    | last === none           a\n// obj[a] \\n \\w                 == \\] \\n \\w    | last === none           a\n// {} {}                        == \\} \\{       | last === none           b\n\nexport function insertSemicolons(constants: IConstants, str: string) {\n  let rest = str;\n  let sub = \"\"\n  let res = [];\n  let details: restDetails = {};\n  while (sub = restOfExp(constants, rest, [], undefined, undefined, [colonsRegex], details)) {\n    let valid = false;\n    let part = sub;\n    let edge = sub.length;\n    if (details.regRes) {\n      valid = true;\n      const [,, a,,, b] = details.regRes;\n      edge = details.regRes[3] === \"++\" || details.regRes[3] === \"--\" ? sub.length + 1 : sub.length;\n      part = rest.substring(0,  edge);\n      if (b) {\n        let res = closingsNoInsertion.exec(rest.substring(sub.length - 1));\n        if (res) {\n          if (res[2] === 'while') {\n            valid = details.lastWord === 'do';\n          } else {\n            valid = false;\n          }\n        } else if (details.lastWord === 'function' && details.regRes[5][0] === \"}\" && details.regRes[5].slice(-1) === '(') {\n          valid = false;\n        } \n\n      } else if (a) {\n        if (details.lastWord === 'if' || details.lastWord === 'while') {\n          valid = false;\n        }\n      }\n      // console.log({details})\n    }\n    res.push(part);\n    if (valid) {\n      res.push(\";\");\n    }\n    // console.log({res})\n    rest = rest.substring(edge);\n    details = {};\n  }\n  // console.log({res})\n  return res.join(\"\");\n}\n\nexport function checkRegex(str: string): IRegEx | null {\n  let i = 1;\n  let escape = false;\n  let done = false;\n  let cancel = false;\n  while (i < str.length && !done && !cancel) {\n    done = (str[i] === '/' && !escape);\n    escape = str[i] === '\\\\' && !escape;\n    cancel = str[i] === '\\n';\n    i++;\n  }\n  let after = str.substring(i);\n  cancel = (cancel || !done) || /^\\s*\\d/.test(after);\n  if (cancel) return null;\n  let flags = /^[a-z]*/.exec(after);\n  if(/^\\s+[\\w\\$]/.test(str.substring(i + flags[0].length))) {\n    return null;\n  }\n  return {\n    regex: str.substring(1, i-1),\n    flags: (flags && flags[0]) || \"\",\n    length: i + ((flags && flags[0].length) || 0)\n  }\n}\n\nconst notDivide = /(typeof|delete|instanceof|return|in|of|throw|new|void|do|if)$/\nconst possibleDivide = /^([\\w\\$\\]\\)]|\\+\\+|\\-\\-)[^\\w\\$\\]\\)\\+\\-]/;\nexport function extractConstants(constants: IConstants, str: string, currentEnclosure = \"\"): {str: string, length: number} {\n  let quote;\n  let extract: string[] = [];\n  let escape = false;\n  let regexFound: IRegEx;\n  let comment = \"\";\n  let commentStart = -1;\n  let currJs: LispArray = toLispArray([]);\n  let char: string = \"\";\n  const strRes: string[] = [];\n  const enclosures: string[] = [];\n  let isPossibleDivide: RegExpExecArray;\n  for (var i = 0; i < str.length; i++) {\n    char = str[i];\n    if (comment) {\n      if (char === comment) {\n        if (comment === \"*\" && str[i + 1] ===\"/\") {\n          comment = \"\";\n          i++\n        } else if (comment === \"\\n\") {\n          comment = \"\";\n        }\n      }\n    } else {\n      if (escape) {\n        escape = false;\n        extract.push(char);\n        continue;\n      }\n\n      if (quote) {\n        if (quote === \"`\" && char === \"$\" && str[i+1] === \"{\") {\n          let skip = extractConstants(constants, str.substring(i+2), \"{\");\n          currJs.push(skip.str);\n          extract.push(`\\${${currJs.length - 1}}`);\n          i += skip.length + 2;\n        } else if (quote === char) {\n          if (quote === '`') {\n            constants.literals.push({\n              op: 'literal',\n              a:  unraw(extract.join(\"\")),\n              b: currJs\n            });\n            strRes.push(`\\`${constants.literals.length - 1}\\``);\n          } else {\n            constants.strings.push(unraw(extract.join(\"\")));\n            strRes.push( `\"${constants.strings.length - 1}\"`);\n          }\n          quote = null;\n          extract = [];\n        } else {\n          extract.push(char);\n        }\n      } else {\n        if ((char === \"'\"  || char === '\"'  || char === '`')) {\n          currJs = toLispArray([]);\n          quote = char;\n        } else if (closings[currentEnclosure] === char && !enclosures.length) {\n          return {str: strRes.join(\"\"), length: i}\n        } else if (closings[char]) {\n          enclosures.push(char);\n          strRes.push(char);\n        } else if (closings[enclosures[enclosures.length-1]] === char) {\n          enclosures.pop();\n          strRes.push(char);\n        } else if (char === \"/\" && (str[i+1] === \"*\" || str[i+1] === \"/\")) {\n          comment = str[i+1] === \"*\" ? \"*\" : \"\\n\";\n          commentStart = i;\n        } else if (char === '/' && !isPossibleDivide && (regexFound = checkRegex(str.substring(i)))) {\n          constants.regexes.push(regexFound);\n          strRes.push(`/${constants.regexes.length - 1}/r`);\n          i += regexFound.length - 1;\n        } else {\n          strRes.push(char);\n        }\n\n        if (!(isPossibleDivide && space.test(char))) {\n          if (isPossibleDivide = possibleDivide.exec(str.substring(i))) {\n            if (notDivide.test(str.substring(0, i + isPossibleDivide[1].length))) {\n              isPossibleDivide = null;\n            }\n          }\n        }\n      }\n      escape = quote && char === \"\\\\\";\n    }\n  }\n\n  if (comment) {\n    if (comment === \"*\") {\n      throw new SyntaxError(`Unclosed comment '/*': ${str.substring(commentStart)}`)\n    }\n  }\n  return {str: strRes.join(\"\"), length: i}\n}\nexport function parse(code: string, eager = false): IExecutionTree {\n  if (typeof code !== 'string') throw new ParseError(`Cannot parse ${code}`, code);\n  // console.log('parse', str);\n  let str = ' ' + code;\n  const constants: IConstants = {strings: [], literals: [], regexes: [], eager};\n  str = extractConstants(constants, str).str;\n  // console.log(str);\n\n  try {\n    for (let l of constants.literals) {\n      l.b = toLispArray(l.b.map((js: string) => lispifyExpr(constants, js)));\n    }\n    return {tree: lispifyFunction(str, constants), constants};\n  } catch (e) {\n    throw e;\n    throw new ParseError(e.message + \": \" + str.substring(0, 100) + '...', str);\n  }\n}\n","import { SpreadArray, LispItem, KeyVal, SpreadObject, If, Lisp, LispArray, toLispArray, parse, IRegEx, lispifyFunction } from \"./parser.js\";\nimport { IExecContext, IContext, Ticks } from \"./Sandbox.js\";\n\n\nexport type SandboxFunction = (code: string, ...args: any[]) => () => any;\nexport type sandboxedEval = (code: string) => any;\nexport type sandboxSetTimeout = (handler: TimerHandler, timeout?: any, ...args: any[]) => any;\nexport type sandboxSetInterval = (handler: TimerHandler, timeout?: any, ...args: any[]) => any;\nexport type Done = (err?: any, res?: any) => void\nexport class ExecReturn {\n  constructor(public auditReport: IAuditReport, public result: any, public returned: boolean, public breakLoop = false, public continueLoop = false) {}\n}\n\nexport interface IAuditReport {\n  globalsAccess: Set<any>;\n  prototypeAccess: {[name: string]: Set<string>}\n}\n\nexport interface IGlobals {\n  [key: string]: any\n}\n\nexport interface IChange {\n  type: string;\n}\n\nexport interface ICreate extends IChange {\n  type: \"create\";\n  prop: number|string;\n}\n\nexport interface IReplace extends IChange {\n  type: \"replace\";\n}\n\nexport interface IDelete extends IChange {\n  type: \"delete\";\n  prop: number|string;\n}\n\nexport interface IReverse extends IChange {\n  type: \"reverse\";\n}\n\nexport interface ISort extends IChange {\n  type: \"sort\";\n}\n\nexport interface IPush extends IChange {\n  type: \"push\";\n  added: unknown[];\n}\n\nexport interface IPop extends IChange {\n  type: \"pop\";\n  removed: unknown[];\n}\n\nexport interface IShift extends IChange {\n  type: \"shift\";\n  removed: unknown[];\n}\n\nexport interface IUnShift extends IChange {\n  type: \"unshift\";\n  added: unknown[];\n}\n\nexport interface ISplice extends IChange {\n  type: \"splice\";\n  startIndex: number;\n  deleteCount: number; \n  added: unknown[];\n  removed: unknown[];\n\n}\n\nexport interface ICopyWithin extends IChange {\n  type: \"copyWithin\";\n  startIndex: number;\n  endIndex: number;\n  added: unknown[];\n  removed: unknown[];\n}\n\nexport type Change = ICreate | IReplace | IDelete | IReverse | ISort | IPush | IPop | IUnShift | IShift | ISplice | ICopyWithin\n\nexport type replacementCallback = (obj: any, isStaticAccess: boolean) => any\n\nexport class Prop {\n  constructor(public context: {[key:string]: any}, public prop: string, public isConst = false, public isGlobal = false, public isVariable = false) {\n  }\n}\n\nconst optional = Symbol('optional');\n\nconst reservedWords = new Set([\n  'instanceof',\n  'typeof',\n  'return',\n  'try',\n  'catch',\n  'if',\n  'finally',\n  'else',\n  'in',\n  'of',\n  'var',\n  'let',\n  'const',\n  'for',\n  'delete',\n  'false',\n  'true',\n  'while',\n  'do',\n  'break',\n  'continue',\n  'new',\n  'function',\n  'async',\n  'await',\n  'switch',\n  'case'\n]);\n\nenum VarType {\n  let = \"let\",\n  const = \"const\",\n  var = \"var\"\n}\n\nexport class Scope {\n  parent: Scope;\n  const = new Set<string>();\n  let = new Set<string>();\n  var: Set<string>;\n  globals: Set<string>;\n  allVars: {[key:string]: any} & Object;\n  functionThis?: any;\n  constructor(parent: Scope, vars = {}, functionThis?: any) {\n    const isFuncScope = functionThis !== undefined || parent === null;\n    this.parent = parent;\n    this.allVars = vars;\n    this.let = isFuncScope ? this.let : new Set(Object.keys(vars));\n    this.var = isFuncScope ? new Set(Object.keys(vars)) : this.var;\n    this.globals = parent === null ? new Set(Object.keys(vars)) : new Set();\n    this.functionThis = functionThis;\n  }\n\n  get(key: string, functionScope = false): any {\n    if (key === 'this' && this.functionThis !== undefined) {\n      return new Prop({this: this.functionThis}, key, true, false, true);\n    }\n    if (reservedWords.has(key)) throw new SyntaxError(\"Unexepected token '\" + key + \"'\");\n    if (this.parent === null || !functionScope || this.functionThis !== undefined) {\n      if (this.globals.has(key)) {\n        return new Prop(this.functionThis, key, false, true, true);\n      }\n      if (key in this.allVars && (!(key in {}) || this.allVars.hasOwnProperty(key))) {\n        return new Prop(this.allVars, key, this.const.has(key), this.globals.has(key), true);\n      }\n      if (this.parent === null) {\n        return new Prop(undefined, key);\n      }\n    }\n    return this.parent.get(key, functionScope)\n  }\n\n  set(key: string, val: any) {\n    if (key === 'this') throw new SyntaxError('\"this\" cannot be assigned')\n    if (reservedWords.has(key)) throw new SyntaxError(\"Unexepected token '\" + key + \"'\");\n    let prop = this.get(key);\n    if(prop.context === undefined) {\n      throw new ReferenceError(`Variable '${key}' was not declared.`);\n    }``\n    if (prop.isConst) {\n      throw new TypeError(`Cannot assign to const variable '${key}'`);\n    }\n    if (prop.isGlobal) {\n      throw new SandboxError(`Cannot override global variable '${key}'`);\n    }\n    prop.context[prop] = val;\n    return prop;\n  }\n\n  declare(key: string, type: VarType = null, value: any = undefined, isGlobal = false) {\n    if (key === 'this') throw new SyntaxError('\"this\" cannot be declared');\n    if (reservedWords.has(key)) throw new SyntaxError(\"Unexepected token '\" + key + \"'\");\n    if (type === 'var' && this.functionThis === undefined && this.parent !== null) {\n      return this.parent.declare(key, type, value, isGlobal)\n    } else if ((this[type].has(key) && type !== 'const' && !this.globals.has(key)) || !(key in this.allVars)) {\n      if (isGlobal) {\n        this.globals.add(key);\n      }\n      this[type].add(key);\n      this.allVars[key] = value;\n    } else {\n      throw new SandboxError(`Identifier '${key}' has already been declared`);\n    }\n    return new Prop(this.allVars, key, this.const.has(key), isGlobal);\n  }\n}\n\nexport class SandboxError extends Error {\n\n}\n\nlet currentTicks: Ticks;\n\nexport function sandboxFunction(context: IContext): SandboxFunction {\n  return SandboxFunction;\n  function SandboxFunction(...params: any[]) {\n    let code = params.pop() || \"\";\n    let parsed = parse(code);\n    return createFunction(params, parsed.tree, currentTicks, {\n      ctx: context,\n      constants: parsed.constants,\n      tree: parsed.tree\n    }, undefined, 'anonymous');\n  }\n}\n\nconst sandboxedFunctions = new WeakSet();\nexport function createFunction(argNames: string[], parsed: LispItem, ticks: Ticks, context: IExecContext, scope?: Scope, name?: string) {\n  if (context.ctx.options.forbidFunctionCreation) {\n    throw new SandboxError(\"Function creation is forbidden\");\n  }\n  let func = function sandboxedObject(...args) {\n    const vars: any = {};\n    argNames.forEach((arg, i) => {\n      if (arg.startsWith('...')) {\n        vars[arg.substring(3)] = args.slice(i);\n      } else {\n        vars[arg] = args[i];\n      }\n    });\n    const res = executeTree(ticks, context, parsed, scope === undefined ? [] : [new Scope(scope, vars, name === undefined ? undefined : this)])\n    return res.result;\n  };\n  sandboxedFunctions.add(func);\n  return func;\n}\n\nexport function createFunctionAsync(argNames: string[], parsed: LispItem, ticks: Ticks, context: IExecContext, scope?: Scope, name?: string) {\n  if (context.ctx.options.forbidFunctionCreation) {\n    throw new SandboxError(\"Function creation is forbidden\");\n  }\n  if (!context.ctx.options.prototypeWhitelist?.has(Promise)) {\n    throw new SandboxError(\"Async/await not permitted\");\n  }\n  let func = async function sandboxedObject(...args) {\n    const vars: any = {};\n    argNames.forEach((arg, i) => {\n      if (arg.startsWith('...')) {\n        vars[arg.substring(3)] = args.slice(i);\n      } else {\n        vars[arg] = args[i];\n      }\n    });\n    const res = await executeTreeAsync(ticks, context, parsed, scope === undefined ? [] : [new Scope(scope, vars, name === undefined ? undefined : this)])\n    return res.result;\n  }\n  sandboxedFunctions.add(func);\n  return func;\n}\n\nexport function sandboxedEval(func: SandboxFunction): sandboxedEval {\n  return sandboxEval;\n  function sandboxEval(code: string) {\n    return func(code)();\n  }\n}\n\nexport function sandboxedSetTimeout(func: SandboxFunction): sandboxSetTimeout {\n  return function sandboxSetTimeout(handler, ...args) {\n    if (typeof handler !== 'string') return setTimeout(handler, ...args);\n    return setTimeout(func(handler), ...args);\n  }\n}\n\nexport function sandboxedSetInterval(func: SandboxFunction): sandboxSetInterval {\n  return function sandboxSetInterval(handler, ...args) {\n    if (typeof handler !== 'string') return setInterval(handler, ...args);\n    return setInterval(func(handler), ...args);\n  }\n}\n\nexport function assignCheck(obj: Prop, context: IExecContext, op = 'assign') {\n  if(obj.context === undefined) {\n    throw new ReferenceError(`Cannot ${op} value to undefined.`)\n  }\n  if(typeof obj.context !== 'object' && typeof obj.context !== 'function') {\n    throw new SyntaxError(`Cannot ${op} value to a primitive.`)\n  }\n  if (obj.isConst) {\n    throw new TypeError(`Cannot set value to const variable '${obj.prop}'`);\n  }\n  if (obj.isGlobal) {\n    throw new SandboxError(`Cannot ${op} property '${obj.prop}' of a global object`);\n  }\n  if (typeof obj.context[obj.prop] === 'function' && !obj.context.hasOwnProperty(obj.prop)) {\n    throw new SandboxError(`Override prototype property '${obj.prop}' not allowed`);\n  }\n  if (op === \"delete\") {\n    if (obj.context.hasOwnProperty(obj.prop)) {\n      context.ctx.changeSubscriptions.get(obj.context)?.forEach((cb) => cb({type: \"delete\", prop: obj.prop}));\n    }\n  } else if (obj.context.hasOwnProperty(obj.prop)) {\n    context.ctx.setSubscriptions.get(obj.context)?.get(obj.prop)?.forEach((cb) => cb({\n      type: \"replace\"\n    }));\n  } else {\n    context.ctx.changeSubscriptions.get(obj.context)?.forEach((cb) => cb({type: \"create\", prop: obj.prop}));\n  }\n}\nconst arrayChange = new Set([\n  [].push,\n  [].pop,\n  [].shift,\n  [].unshift,\n  [].splice,\n  [].reverse,\n  [].sort,\n  [].copyWithin\n]);\nconst literalRegex = /(\\$\\$)*(\\$)?\\${(\\d+)}/g;\ntype OpCallback = (exec: Execution, done: Done, ticks: Ticks, a: LispItem|string[], b: LispItem|Lisp[], obj: Prop|any|undefined, context: IExecContext, scope: Scope, bobj?: Prop|any|undefined, inLoopOrSwitch?: string) => void;\nlet ops2: {[op:string]: OpCallback} = {\n  'prop': (exec, done, ticks, a: LispItem|any, b: string, obj, context, scope) => {\n    if(a === null) {\n      throw new TypeError(`Cannot get property ${b} of null`);\n    }\n    const type = typeof a;\n    if (type === 'undefined' && obj === undefined) {\n      let prop = scope.get(b);\n      if (prop.context === undefined) throw new ReferenceError(`${b} is not defined`);\n      if (prop.context === context.ctx.sandboxGlobal) {\n        if (context.ctx.options.audit) {\n          context.ctx.auditReport.globalsAccess.add(b);\n        }\n        const rep = context.ctx.globalsWhitelist.has(context.ctx.sandboxGlobal[b]) ? context.ctx.evals.get(context.ctx.sandboxGlobal[b]) : undefined;\n        if (rep) {\n          done(undefined, rep);\n          return;\n        }\n      }\n      if (prop.context && prop.context[b] === globalThis) {\n        done(undefined, context.ctx.globalScope.get('this'));\n        return;\n      }\n\n      context.ctx.getSubscriptions.forEach((cb) => cb(prop.context, prop.prop));\n      done(undefined, prop);\n      return;\n    } else if (a === undefined) {\n      throw new SandboxError(\"Cannot get property '\" + b + \"' of undefined\")\n    }\n\n    if (type !== 'object') {\n      if(type === 'number') {\n        a = new Number(a);\n      } else if(type === 'string') {\n        a = new String(a);\n      } else if(type === 'boolean') {\n        a = new Boolean(a);\n      }\n    } else if (typeof a.hasOwnProperty === 'undefined') {\n      done(undefined, new Prop(undefined, b));\n      return;\n    }\n\n    const isFunction = type === 'function';\n    let prototypeAccess = isFunction || !(a.hasOwnProperty(b) || typeof b === 'number');\n\n    if (context.ctx.options.audit && prototypeAccess) {\n      if (typeof b === 'string') {\n        let prot = a.constructor.prototype;\n        do {\n          if (prot.hasOwnProperty(b)) {\n            if(!context.ctx.auditReport.prototypeAccess[prot.constructor.name]) {\n              context.ctx.auditReport.prototypeAccess[prot.constructor.name] = new Set();\n            }\n            context.ctx.auditReport.prototypeAccess[prot.constructor.name].add(b);\n          }\n        } while(prot = Object.getPrototypeOf(prot))\n      }\n    }\n\n    if (prototypeAccess) {\n      if (isFunction) {\n        if (!['name', 'length', 'constructor'].includes(b) && a.hasOwnProperty(b)) {\n          const whitelist = context.ctx.options.prototypeWhitelist.get(a);\n          const replace = context.ctx.options.prototypeReplacements.get(a);\n          if (replace) {\n            done(undefined, new Prop(replace(a, true), b));\n            return;\n          }\n          if (whitelist && (!whitelist.size || whitelist.has(b))) {\n          } else {\n            throw new SandboxError(`Static method or property access not permitted: ${a.name}.${b}`);\n          }\n        }\n      } else if (b !== 'constructor') {\n        let prot = a.constructor.prototype;\n        do {\n          if (prot.hasOwnProperty(b)) {\n            const whitelist = context.ctx.options.prototypeWhitelist.get(prot.constructor);\n            const replace = context.ctx.options.prototypeReplacements.get(prot.constuctor);\n            if (replace) {\n              done(undefined, new Prop(replace(a, false), b));\n              return;\n            }\n            if (whitelist && (!whitelist.size || whitelist.has(b))) {\n              break;\n            }\n            throw new SandboxError(`Method or property access not permitted: ${prot.constructor.name}.${b}`);\n          }\n        } while(prot = Object.getPrototypeOf(prot));\n      }\n    }\n\n    if (context.ctx.evals.has(a[b])) {\n      done(undefined, context.ctx.evals.get(a[b]));\n      return;\n    }\n    if (a[b] === globalThis) {\n      done(undefined, context.ctx.globalScope.get('this'));\n      return;\n    }\n\n    let g = obj.isGlobal || (isFunction && !sandboxedFunctions.has(a)) || context.ctx.globalsWhitelist.has(a);\n\n    if (!g) {\n      context.ctx.getSubscriptions.forEach((cb) => cb(a, b));\n    }\n    done(undefined, new Prop(a, b, false, g));\n  },\n  'call': (exec, done, ticks, a, b: LispArray, obj, context, scope) => {\n    if (context.ctx.options.forbidFunctionCalls) throw new SandboxError(\"Method calls are not allowed\");\n    if (typeof a !== 'function') {\n      throw new TypeError(`${obj.prop} is not a function`);\n    }\n    const args = b.map((item) => {\n      if (item instanceof SpreadArray) {\n        return [...item.item];\n      } else {\n        return [item];\n      }\n    }).flat();\n    execMany(ticks, exec, toLispArray(args), (err, vals) => {\n      if (err) {\n        done(err);\n        return;\n      }\n      if (typeof obj === 'function') {\n        done(undefined, obj(...vals));\n        return;\n      }\n      if (obj.context[obj.prop] === JSON.stringify && context.ctx.getSubscriptions.size) {\n        const cache = new Set<any>();\n        const recurse = (x: any) => {\n          if (!x || !(typeof x === 'object') || cache.has(x)) return;\n          cache.add(x);\n          for (let y in x) {\n            context.ctx.getSubscriptions.forEach((cb) => cb(x, y));\n            recurse(x[y]);\n          }\n        };\n        recurse(vals[0]);\n      }\n  \n      if (obj.context instanceof Array && arrayChange.has(obj.context[obj.prop]) && context.ctx.changeSubscriptions.get(obj.context)) {\n        let change: Change;\n        let changed = false;\n        if (obj.prop === \"push\") {\n          change = {\n            type: \"push\",\n            added: vals\n          }\n          changed = !!vals.length;\n        } else if (obj.prop === \"pop\") {\n          change = {\n            type: \"pop\",\n            removed: obj.context.slice(-1)\n          }\n          changed = !!change.removed.length;\n        }  else if (obj.prop === \"shift\") {\n          change = {\n            type: \"shift\",\n            removed: obj.context.slice(0, 1)\n          }\n          changed = !!change.removed.length;\n        } else if (obj.prop === \"unshift\") {\n          change = {\n            type: \"unshift\",\n            added: vals\n          }\n          changed = !!vals.length;\n        } else if (obj.prop === \"splice\") {\n          change = {\n            type: \"splice\",\n            startIndex: vals[0],\n            deleteCount: vals[1] === undefined ? obj.context.length : vals[1],\n            added: vals.slice(2),\n            removed: obj.context.slice(vals[0], vals[1] === undefined ? undefined : vals[0] + vals[1])\n          }\n          changed = !!change.added.length || !!change.removed.length;\n        } else if (obj.prop === \"reverse\" || obj.prop === \"sort\") {\n          change = {type: obj.prop}\n          changed = !!obj.context.length;\n        } else if (obj.prop === \"copyWithin\") {\n          let len = vals[2] === undefined ? obj.context.length - vals[1] : Math.min(obj.context.length, vals[2] - vals[1]);\n          change = {\n            type: \"copyWithin\",\n            startIndex: vals[0],\n            endIndex: vals[0] + len,\n            added: obj.context.slice(vals[1], vals[1] + len),\n            removed: obj.context.slice(vals[0], vals[0] + len)\n          }\n          changed = !!change.added.length || !!change.removed.length;\n        }\n        if (changed) {\n          context.ctx.changeSubscriptions.get(obj.context)?.forEach((cb) => cb(change));\n        }\n      }\n      done(undefined, obj.context[obj.prop](...vals));\n    }, scope, context);\n  },\n  'createObject': (exec, done, ticks, a, b: LispArray, obj, context, scope) => {\n    let res = {} as any;\n    for (let item of b as (KeyVal|SpreadObject)[]) {\n      if (item instanceof SpreadObject) {\n        res = {...res, ...item.item};\n      } else {\n        res[item.key] = item.val;\n      }\n    }\n    done(undefined, res);\n  },\n  'keyVal': (exec, done, ticks, a: string, b: LispItem) => done(undefined, new KeyVal(a, b)),\n  'createArray': (exec, done, ticks, a, b: LispArray, obj, context, scope) => {\n    const items = b.map((item) => {\n      if (item instanceof SpreadArray) {\n        return [...item.item];\n      } else {\n        return [item];\n      }\n    }).flat()\n    execMany(ticks, exec, toLispArray(items), done, scope, context);\n  },\n  'group': (exec, done, ticks, a, b) => done(undefined, b),\n  'string': (exec, done, ticks, a, b: string, obj, context) => done(undefined, context.constants.strings[b]),\n  'regex': (exec, done, ticks, a, b: string, obj, context) => {\n    const reg: IRegEx = context.constants.regexes[b];\n    if (!context.ctx.globalsWhitelist.has(RegExp)) {\n      throw new SandboxError(\"Regex not permitted\");\n    } else {\n      done(undefined, new RegExp(reg.regex, reg.flags));\n    }\n  },\n  'literal': (exec, done, ticks, a, b: number, obj, context, scope) => {\n    let name: string = context.constants.literals[b].a;\n    let found = toLispArray([]);\n    let f;\n    let resnums = [];\n    while(f = literalRegex.exec(name)) {\n      if (!f[2]) {\n        found.push(context.constants.literals[b].b[parseInt(f[3], 10)]);\n        resnums.push(f[3]);\n      }\n    }\n\n    execMany(ticks, exec, found, (err, processed) => {\n      const reses = {};\n      if(err) {\n        done(err);\n        return;\n      }\n      for (let i in resnums) {\n        const num = resnums[i];\n        reses[num] = processed[i];\n      }\n      done(undefined, name.replace(/(\\\\\\\\)*(\\\\)?\\${(\\d+)}/g, (match, $$, $, num) => {\n        if ($) return match;\n        let res = reses[num]\n        res =  res instanceof Prop ? res.context[res.prop] : res;\n        return ($$ ? $$ : '') + `${res}`;\n      }));\n    }, scope, context)\n  },\n  'spreadArray': (exec, done, ticks, a, b: LispItem, obj, context, scope) => {\n    exec(ticks, b, scope, context, (err, res) => {\n      if (err) {\n        done(err);\n        return;\n      }\n      done(undefined, new SpreadArray(res));\n    });\n  },\n  'spreadObject': (exec, done, ticks, a, b: LispItem, obj, context, scope) => {\n    exec(ticks, b, scope, context, (err, res) => {\n      if (err) {\n        done(err);\n        return;\n      }\n      done(undefined, new SpreadObject(res));\n    });\n  },\n  '!': (exec, done, ticks, a, b) => done(undefined, !b),\n  '~': (exec, done, ticks, a, b) => done(undefined, ~b),\n  '++$': (exec, done, ticks, a, b, obj, context) => {\n    assignCheck(obj, context);\n    done(undefined, ++obj.context[obj.prop]);\n  },\n  '$++': (exec, done, ticks, a, b, obj, context) => {\n    assignCheck(obj, context);\n    done(undefined, obj.context[obj.prop]++);\n  },\n  '--$': (exec, done, ticks, a, b, obj, context) => {\n    assignCheck(obj, context);\n    done(undefined, --obj.context[obj.prop]);\n  },\n  '$--': (exec, done, ticks, a, b, obj, context) => {\n    assignCheck(obj, context);\n    done(undefined, obj.context[obj.prop]--);\n  },\n  '=': (exec, done, ticks, a, b, obj, context) => {\n    assignCheck(obj, context);\n    obj.context[obj.prop] = b;\n    done(undefined, new Prop(obj.context, obj.prop, false, obj.isGlobal));\n  },\n  '+=': (exec, done, ticks, a, b, obj, context) => {\n    assignCheck(obj, context);\n    done(undefined, obj.context[obj.prop] += b);\n  },\n  '-=': (exec, done, ticks, a, b: number, obj, context) => {\n    assignCheck(obj, context);\n    done(undefined, obj.context[obj.prop] -= b);\n  },\n  '/=': (exec, done, ticks, a, b: number, obj, context) => {\n    assignCheck(obj, context);\n    done(undefined, obj.context[obj.prop] /= b);\n  },\n  '*=': (exec, done, ticks, a, b: number, obj, context) => {\n    assignCheck(obj, context);\n    done(undefined, obj.context[obj.prop] *= b);\n  },\n  '**=': (exec, done, ticks, a, b: number, obj, context) => {\n    assignCheck(obj, context);\n    done(undefined, obj.context[obj.prop] **= b);\n  },\n  '%=': (exec, done, ticks, a, b: number, obj, context) => {\n    assignCheck(obj, context);\n    done(undefined, obj.context[obj.prop] %= b);\n  },\n  '^=': (exec, done, ticks, a, b: number, obj, context) => {\n    assignCheck(obj, context);\n    done(undefined, obj.context[obj.prop] ^= b);\n  },\n  '&=': (exec, done, ticks, a, b: number, obj, context) => {\n    assignCheck(obj, context);\n    done(undefined, obj.context[obj.prop] &= b);\n  },\n  '|=': (exec, done, ticks, a, b: number, obj, context) => {\n    assignCheck(obj, context);\n    done(undefined, obj.context[obj.prop] |= b);\n  },\n  '<<=': (exec, done, ticks, a, b: number, obj, context) => {\n    assignCheck(obj, context);\n    done(undefined, obj.context[obj.prop] <<= b);\n  },\n  '>>=': (exec, done, ticks, a, b: number, obj, context) => {\n    assignCheck(obj, context);\n    done(undefined, obj.context[obj.prop] >>= b);\n  },\n  '>>>=': (exec, done, ticks, a, b: number, obj, context) => {\n    assignCheck(obj, context);\n    done(undefined, obj.context[obj.prop] >>= b);\n  },\n  '?': (exec, done, ticks, a, b) => {\n    if (!(b instanceof If)) {\n      throw new SyntaxError('Invalid inline if')\n    }\n    done(undefined, a ? (b as any).t : (b as any).f);\n  },\n  '>': (exec, done, ticks, a, b) => done(undefined, a > b),\n  '<': (exec, done, ticks, a, b) => done(undefined, a < b),\n  '>=': (exec, done, ticks, a, b) => done(undefined, a >= b),\n  '<=': (exec, done, ticks, a, b) => done(undefined, a <= b),\n  '==': (exec, done, ticks, a, b) => done(undefined, a == b),\n  '===': (exec, done, ticks, a, b) => done(undefined, a === b),\n  '!=': (exec, done, ticks, a, b) => done(undefined, a != b),\n  '!==': (exec, done, ticks, a, b) => done(undefined, a !== b),\n  '&&': (exec, done, ticks, a, b) => done(undefined, a && b),\n  '||': (exec, done, ticks, a, b) => done(undefined, a || b),\n  '&': (exec, done, ticks, a: number, b: number) => done(undefined, a & b),\n  '|': (exec, done, ticks, a: number, b: number) => done(undefined, a | b),\n  ':': (exec, done, ticks, a, b) => done(undefined, new If(a, b)),\n  '+': (exec, done, ticks, a: number, b: number) => done(undefined, a + b),\n  '-': (exec, done, ticks, a: number, b: number) => done(undefined, a - b),\n  '$+': (exec, done, ticks, a, b) => done(undefined, +b),\n  '$-': (exec, done, ticks, a, b) => done(undefined, -b),\n  '/': (exec, done, ticks, a: number, b: number) => done(undefined, a / b),\n  '^': (exec, done, ticks, a: number, b: number) => done(undefined, a ^ b),\n  '*': (exec, done, ticks, a: number, b: number) => done(undefined, a * b),\n  '%': (exec, done, ticks, a: number, b: number) => done(undefined, a % b),\n  '<<': (exec, done, ticks, a: number, b: number) => done(undefined, a << b),\n  '>>': (exec, done, ticks, a: number, b: number) => done(undefined, a >> b),\n  '>>>': (exec, done, ticks, a: number, b: number) => done(undefined, a >>> b),\n  'typeof': (exec, done, ticks, a, b) => done(undefined, typeof b),\n  'instanceof': (exec, done, ticks, a, b:  { new(): any }) => done(undefined, a instanceof b),\n  'in': (exec, done, ticks, a: string, b) => done(undefined, a in b),\n  'delete': (exec, done, ticks, a, b, obj, context, scope, bobj: Prop) => {\n    if (bobj.context === undefined) {\n      done(undefined, true);\n      return;\n    }\n    assignCheck(bobj, context, 'delete');\n    if (bobj.isVariable) {\n      done(undefined, false);\n      return;\n    }\n    done(undefined, delete bobj.context[bobj.prop]);\n  },\n  'return': (exec, done, ticks, a, b, obj, context) => done(undefined, b),\n  'var': (exec, done, ticks, a: string, b: LispItem, obj, context, scope, bobj) => {\n    exec(ticks, b, scope, context, (err, res) => {\n      if (err) {\n        done(err);\n        return;\n      }\n      done(undefined, scope.declare(a, VarType.var, res));\n    });\n  },\n  'let': (exec, done, ticks, a: string, b: LispItem, obj, context, scope, bobj) => {\n    exec(ticks, b, scope, context, (err, res) => {\n      if (err) {\n        done(err);\n        return;\n      }\n      done(undefined, scope.declare(a, VarType.let, res, bobj && bobj.isGlobal));\n    });\n  },\n  'const': (exec, done, ticks, a: string, b: LispItem, obj, context, scope, bobj) => {\n    exec(ticks, b, scope, context, (err, res) => {\n      if (err) {\n        done(err);\n        return;\n      }\n      done(undefined, scope.declare(a, VarType.const, res));\n    });\n  },\n  'arrowFunc': (exec, done, ticks, a: string[], b: LispItem, obj: Lisp, context, scope) => {\n    a = [...a];\n    if (typeof obj.b === \"string\") {\n      obj.b = b = lispifyFunction(obj.b, context.constants);\n    }\n    if (a.shift()) {\n      done(undefined, createFunctionAsync(a, b, ticks, context, scope));\n    } else {\n      done(undefined, createFunction(a, b, ticks, context, scope));\n    }\n  },\n  'function': (exec, done, ticks, a: string[]&LispArray, b: LispItem, obj: Lisp, context, scope) => {\n    if (typeof obj.b === \"string\") {\n      obj.b = b = lispifyFunction(obj.b, context.constants);\n    }\n    let isAsync = a.shift();\n    let name = a.shift();\n    let func;\n    if (isAsync) {\n      func = createFunctionAsync(a, b, ticks, context, scope, name);\n    } else {\n      func = createFunction(a, b, ticks, context, scope, name);\n    }\n    if (name) {\n      scope.declare(name, VarType.var, func);\n    }\n    done(undefined, func);\n  },\n  'inlineFunction': (exec, done, ticks, a: string[]&LispArray, b: LispItem, obj: Lisp, context, scope) => {\n    if (typeof obj.b === \"string\") {\n      obj.b = b = lispifyFunction(obj.b, context.constants);\n    }\n    let isAsync = a.shift();\n    let name = a.shift();\n    if (name) {\n      scope = new Scope(scope, {})\n    }\n    let func;\n    if (isAsync) {\n      func = createFunctionAsync(a, b, ticks, context, scope, name);\n    } else {\n      func = createFunction(a, b, ticks, context, scope, name);\n    }\n    if (name) {\n      scope.declare(name, VarType.let, func);\n    }\n    done(undefined, func);\n  },\n  'loop': (exec, done, ticks, a: LispArray, b: LispItem, obj, context, scope) => {\n    const [checkFirst, startInternal, getIterator, startStep, step, condition, beforeStep] = a;\n    let loop = true;\n    const loopScope = new Scope(scope, {});\n    let internalVars = {\n      '$$obj': undefined\n    };\n    const interalScope = new Scope(loopScope, internalVars);\n    if (exec === execAsync) {\n      (async() => {\n        await asyncDone((d) => exec(ticks, startStep, loopScope, context, d));\n        internalVars['$$obj'] = (await asyncDone((d) => exec(ticks, getIterator, loopScope, context, d))).result;\n        await asyncDone((d) => exec(ticks, startInternal, interalScope, context, d));\n        if (checkFirst) loop = (await asyncDone((d) => exec(ticks, condition, interalScope, context, d))).result;\n        while (loop) {\n          let innerLoopVars = {};\n          await asyncDone((d) => exec(ticks, beforeStep, new Scope(interalScope, innerLoopVars), context, d));\n          let res = await executeTreeAsync(ticks, context, b, [new Scope(loopScope, innerLoopVars)], \"loop\");\n          if (res instanceof ExecReturn && res.returned) {\n            done(undefined, res);\n            return;\n          }\n          if (res instanceof ExecReturn && res.breakLoop) {\n            break;\n          }\n          await asyncDone((d) => exec(ticks, step, interalScope, context, d));\n          loop = (await asyncDone((d) => exec(ticks, condition, interalScope, context, d))).result;\n        }\n        done();\n      })().catch(done);\n    } else {\n      syncDone((d) => exec(ticks, startStep, loopScope, context, d));\n      internalVars['$$obj'] = syncDone((d) => exec(ticks, getIterator, loopScope, context, d)).result;\n      syncDone((d) => exec(ticks, startInternal, interalScope, context, d));\n      if (checkFirst) loop = (syncDone((d) => exec(ticks, condition, interalScope, context, d))).result;\n      while (loop) {\n        let innerLoopVars = {};\n        syncDone((d) => exec(ticks, beforeStep, new Scope(interalScope, innerLoopVars), context, d));\n        let res = executeTree(ticks, context, b, [new Scope(loopScope, innerLoopVars)], \"loop\");\n        if (res instanceof ExecReturn && res.returned) {\n          done(undefined, res);\n          return;\n        }\n        if (res instanceof ExecReturn && res.breakLoop) {\n          break;\n        }\n        syncDone((d) => exec(ticks, step, interalScope, context, d));\n        loop = (syncDone((d) => exec(ticks, condition, interalScope, context, d))).result;\n      }\n      done();\n    }\n  },\n  'loopAction': (exec, done, ticks, a: LispItem, b: LispItem, obj, context, scope, bobj, inLoopOrSwitch) => {\n    if ((inLoopOrSwitch === \"switch\" && a === \"continue\") || !inLoopOrSwitch) {\n      throw new SandboxError(\"Illegal \" + a + \" statement\");\n    }\n    done(undefined, new ExecReturn(context.ctx.auditReport, undefined, false, a === \"break\", a === \"continue\"));\n  },\n  'if': (exec, done, ticks, a: LispItem, b: If, obj, context, scope, bobj, inLoopOrSwitch) => {\n    if (!(b instanceof If)) {\n      throw new SyntaxError('Invalid if')\n    }\n    exec(ticks, a, scope, context, (err, res) => {\n      if (err) {\n        done(err);\n        return;\n      }\n      executeTreeWithDone(exec, done, ticks, context, res ? b.t : b.f, [new Scope(scope)], inLoopOrSwitch);\n    });\n  },\n  'switch': (exec, done, ticks, a: LispItem, b: Lisp[], obj, context, scope) => {\n    exec(ticks, a, scope, context, (err, toTest) => {\n      if (err) {\n        done(err);\n        return;\n      }\n      if (exec === execSync) {\n        let res: ExecReturn;\n        let isTrue = false;\n        for (let caseItem of b) {\n          if (isTrue || (isTrue = !caseItem.a || toTest === valueOrProp((syncDone((d) => exec(ticks, caseItem.a, scope, context, d))).result))) {\n            if (!caseItem.b) continue;\n            res = executeTree(ticks, context, caseItem.b, [scope], \"switch\");\n            if (res.breakLoop) break;\n            if (res.returned) {\n              done(undefined, res);\n              return;\n            }\n            if (!caseItem.a) { // default case\n              break;\n            }\n          }\n        }\n        done();\n      } else {\n        (async () => {\n          let res: ExecReturn;\n          let isTrue = false;\n          for (let caseItem of b) {\n            if (isTrue || (isTrue = !caseItem.a || toTest === valueOrProp((await asyncDone((d) => exec(ticks, caseItem.a, scope, context, d))).result))) {\n              if (!caseItem.b) continue;\n              res = await executeTreeAsync(ticks, context, caseItem.b, [scope], \"switch\");\n              if (res.breakLoop) break;\n              if (res.returned) {\n                done(undefined, res);\n                return;\n              }\n              if (!caseItem.a) { // default case\n                break;\n              }\n            }\n          }\n          done();\n        })().catch(done)\n      }\n    });\n  },\n  'try': (exec, done, ticks, a: LispItem, b: [string, LispItem, LispItem]&LispArray, obj, context, scope, bobj, inLoopOrSwitch) => {\n    const [exception, catchBody, finallyBody] = b;\n    executeTreeWithDone(exec, (err, res) => {\n      executeTreeWithDone(exec, (e) => {\n        if (e) done(e);\n        else  if (err) {\n          let sc = {};\n          if (exception) sc[exception] = err;\n          executeTreeWithDone(exec, done, ticks, context, catchBody, [new Scope(scope)], inLoopOrSwitch);\n        } else {\n          done(undefined, res);\n        }\n      }, ticks, context, finallyBody, [new Scope(scope, {})]);\n    }, ticks, context, a, [new Scope(scope)], inLoopOrSwitch);\n  },\n  'void': (exec, done, ticks, a) => {done()},\n  'new': (exec, done, ticks, a: new (...args: any[]) => any, b: any, obj, context) => {\n    if (!context.ctx.globalsWhitelist.has(a) && !sandboxedFunctions.has(a)) {\n      throw new SandboxError(`Object construction not allowed: ${a.constructor.name}`)\n    }\n    done(undefined, new a(...b))\n  },\n  'throw': (exec, done, ticks, a) => { done(a) },\n  'multi': (exec, done, ticks, a: any[]) => done(undefined, a.pop())\n}\n\nexport let ops = new Map<string, OpCallback>();\nfor (let op in ops2) {\n  ops.set(op, ops2[op]);\n}\n\nfunction valueOrProp(a: any) {\n  if (a instanceof Prop) return a.context[a.prop];\n  return a;\n}\n\nexport function execMany(ticks: Ticks, exec: Execution, tree: LispArray, done: Done, scope: Scope, context: IExecContext, inLoopOrSwitch?: string) {\n  if (exec === execSync) {\n    _execManySync(ticks, tree, done, scope, context, inLoopOrSwitch);\n  } else {\n    _execManyAsync(ticks, tree, done, scope, context, inLoopOrSwitch).catch(done);\n  }\n}\n\nfunction _execManySync(ticks: Ticks, tree: LispArray, done: Done, scope: Scope, context: IExecContext, inLoopOrSwitch?: string) {\n  let ret = [];\n  for (let i = 0; i < tree.length; i++) {\n    let res;\n    try {\n      res = syncDone((d) => execSync(ticks, tree[i], scope, context, d, inLoopOrSwitch)).result;\n    } catch(e) {\n      done(e);\n      return;\n    }\n    if (res instanceof ExecReturn && (res.returned || res.breakLoop || res.continueLoop)) {\n      done(undefined, res);\n      return;\n    }\n    ret.push(res);\n  }\n  done(undefined, ret);\n}\n\nasync function _execManyAsync(ticks: Ticks, tree: LispArray, done: Done, scope: Scope, context: IExecContext, inLoopOrSwitch?: string) {\n  let ret = [];\n  for (let i = 0; i < tree.length; i++) {\n    let res;\n    try {\n      res = (await asyncDone((d) => execAsync(ticks, tree[i], scope, context, d, inLoopOrSwitch))).result;\n    } catch(e) {\n      done(e);\n      return;\n    }\n    if (res instanceof ExecReturn && (res.returned || res.breakLoop || res.continueLoop)) {\n      done(undefined, res);\n      return;\n    }\n    ret.push(res);\n  }\n  done(undefined, ret);\n}\n\ntype Execution = (ticks: Ticks, tree: LispItem, scope: Scope, context: IExecContext, done: Done, inLoopOrSwitch?: string) => void\n\nexport function asyncDone(callback: (done: Done) => void): Promise<{result: any}> {\n  return new Promise((resolve, reject) => {\n    callback((err, result) => {\n      if (err) reject(err);\n      else resolve({result});\n    });\n  });\n}\n\nexport function syncDone(callback: (done: Done) => void): {result: any} {\n  let result;\n  let err;\n  callback((e, r) => {\n    err = e;\n    result = r;\n  });\n  if (err) throw err;\n  return {result};\n}\n\nexport function execAsync(ticks: Ticks, tree: LispItem, scope: Scope, context: IExecContext, done: Done, inLoopOrSwitch?: string): Promise<void> {\n  return new Promise((resolve, reject) => {\n    execWithDone(ticks, tree, scope, context, (e, r) => {\n      done(e, r);\n      resolve();\n    }, true, inLoopOrSwitch);\n  });\n}\n\n\nexport function execSync(ticks: Ticks, tree: LispItem, scope: Scope, context: IExecContext, done: Done, inLoopOrSwitch?: string): void {\n  execWithDone(ticks, tree, scope, context, done, false, inLoopOrSwitch);\n}\n\nfunction execWithDone(ticks: Ticks, tree: LispItem, scope: Scope, context: IExecContext, done: Done, isAsync: boolean, inLoopOrSwitch?: string): void {\n  const exec = isAsync ? execAsync : execSync;\n\n  if (context.ctx.options.executionQuota <= ticks.ticks) {\n    if (typeof context.ctx.options.onExecutionQuotaReached === 'function' && context.ctx.options.onExecutionQuotaReached(ticks, scope, context, tree)) {\n      \n    } else {\n      throw new SandboxError(\"Execution quota exceeded\");\n    }\n  }\n  ticks.ticks++;\n  currentTicks = ticks;\n\n  if (tree instanceof Prop) {\n    done(undefined, tree.context[tree.prop]);\n  } else if (Array.isArray(tree) && tree.lisp) {\n    execMany(ticks, exec, tree, done, scope, context, inLoopOrSwitch);\n  } else if (!(tree instanceof Lisp)) {\n    done(undefined, tree);\n  } else if (['arrowFunc', 'function', 'inlineFunction', 'loop', 'try', 'switch', 'if'].includes(tree.op)) {\n    try {\n      ops.get(tree.op)(exec, done, ticks, tree.a, tree.b, tree, context, scope, undefined, inLoopOrSwitch);\n    } catch (err) {\n      done(err);\n    }\n  } else if (tree.op === 'await') {\n    if (!isAsync) {\n      done(new SandboxError(\"Illegal use of 'await', must be inside async function\"));\n    } else if (context.ctx.options.prototypeWhitelist?.has(Promise)) {\n      execAsync(ticks, tree.a, scope, context, async (e, r) => {\n        if (e) done(e);\n        else done(undefined, await r);\n      }, inLoopOrSwitch).catch(done);\n    } else {\n      done(new SandboxError('Async/await is not permitted'))\n    }\n  } else {\n    execWithDone(ticks, tree.a, scope, context, (e, obj) => {\n      if (e) {\n        done(e);\n        return;\n      }\n      let a = obj instanceof Prop ? (obj.context ? obj.context[obj.prop] : undefined) : obj;\n      let op = tree.op;\n      if (op === '?prop' || op === '?call') {\n        if (a === undefined || a === null) {\n          done(undefined, optional);\n          return;\n        }\n        op = op.slice(1);\n      }\n      if (a === optional) {\n        if (op === 'prop' || op === 'call') {\n          done(undefined, a);\n          return;\n        } else {\n          a = undefined;\n        }\n      }\n      execWithDone(ticks, tree.b, scope, context, (e, bobj) => {\n        if (e) {\n          done(e);\n          return;\n        }\n        let b = bobj instanceof Prop ? (bobj.context ? bobj.context[bobj.prop] : undefined) : bobj;\n        if (b === optional) {\n          b = undefined;\n        }\n        if (ops.has(op)) {\n          try {\n            ops.get(op)(exec, done, ticks, a, b, obj, context, scope, bobj, inLoopOrSwitch);\n          } catch (err) {\n            done(err);\n          }\n        } else {\n          done(new SyntaxError('Unknown operator: ' + op));\n        }\n      }, isAsync, inLoopOrSwitch);\n    }, isAsync, inLoopOrSwitch);\n  }\n}\n\nexport function executeTree(ticks: Ticks, context: IExecContext, executionTree: LispItem, scopes: ({[key:string]: any}|Scope)[] = [], inLoopOrSwitch?: string): ExecReturn {\n  return syncDone((done) => executeTreeWithDone(execSync, done, ticks, context, executionTree, scopes, inLoopOrSwitch)).result;\n}\n\nexport async function executeTreeAsync(ticks: Ticks, context: IExecContext, executionTree: LispItem, scopes: ({[key:string]: any}|Scope)[] = [], inLoopOrSwitch?: string): Promise<ExecReturn> {\n  return (await asyncDone((done) => executeTreeWithDone(execAsync, done, ticks, context, executionTree, scopes, inLoopOrSwitch))).result;\n}\n\nfunction executeTreeWithDone(exec: Execution, done: Done, ticks: Ticks, context: IExecContext, executionTree: LispItem, scopes: ({[key:string]: any}|Scope)[] = [], inLoopOrSwitch?: string) {\n  if (!executionTree)  {\n    done();\n    return;\n  }\n  if (!(executionTree instanceof Array)) throw new SyntaxError('Bad execution tree');\n  let scope = context.ctx.globalScope;\n  let s;\n  while (s = scopes.shift()) {\n    if (typeof s !== \"object\") continue;\n    if (s instanceof Scope) {\n      scope = s;\n    } else {\n      scope = new Scope(scope, s, null);\n    }\n  }\n  if (context.ctx.options.audit && !context.ctx.auditReport) {\n    context.ctx.auditReport = {\n      globalsAccess: new Set(),\n      prototypeAccess: {},\n    }\n  }\n  if (exec === execSync) {\n    _executeWithDoneSync(done, ticks, context, executionTree, scope, inLoopOrSwitch);\n  } else {\n    _executeWithDoneAsync(done, ticks, context, executionTree, scope, inLoopOrSwitch).catch(done);\n  }\n}\n\nfunction _executeWithDoneSync(done: Done, ticks: Ticks, context: IExecContext, executionTree: LispItem, scope: Scope, inLoopOrSwitch?: string) {\n  if (!(executionTree instanceof Array)) throw new SyntaxError('Bad execution tree');\n  let i = 0;\n  for (i = 0; i < executionTree.length; i++) {\n    let res;\n    let err;\n    const current = executionTree[i];\n    try {\n      execSync(ticks, current, scope, context, (e, r) => {\n        err = e;\n        res = r;\n      }, inLoopOrSwitch);\n    } catch (e) {\n      err = e;\n    }\n    if (err) {\n      done(err);\n      return;\n    }\n    if (res instanceof ExecReturn) {\n      done(undefined, res);\n      return;\n    }\n    if (current instanceof Lisp && current.op === 'return') {\n      done(undefined, new ExecReturn(context.ctx.auditReport, res, true))\n      return;\n    }\n  }\n  done(undefined, new ExecReturn(context.ctx.auditReport, undefined, false));\n}\n\nasync function _executeWithDoneAsync(done: Done, ticks: Ticks, context: IExecContext, executionTree: LispItem, scope: Scope, inLoopOrSwitch?: string) {\n  if (!(executionTree instanceof Array)) throw new SyntaxError('Bad execution tree');\n  let i = 0;\n  for (i = 0; i < executionTree.length; i++) {\n    let res;\n    let err;\n    const current = executionTree[i];\n    try {\n      await execAsync(ticks, current, scope, context, (e, r) => {\n        err = e;\n        res = r;\n      }, inLoopOrSwitch);\n    } catch (e) {\n      err = e;\n    }\n    if (err) {\n      done(err);\n      return;\n    }\n    if (res instanceof ExecReturn) {\n      done(undefined, res);\n      return;\n    }\n    if (current instanceof Lisp && current.op === 'return') {\n      done(undefined, new ExecReturn(context.ctx.auditReport, res, true))\n      return;\n    }\n  }\n  done(undefined, new ExecReturn(context.ctx.auditReport, undefined, false));\n}\n","import { \n  IGlobals, \n  replacementCallback, \n  IAuditReport, \n  Scope, \n  Change, \n  sandboxFunction,\n  sandboxedEval,\n  sandboxedSetTimeout,\n  sandboxedSetInterval,\n  ExecReturn,\n  executeTree,\n  executeTreeAsync,\n  ops,\n  assignCheck,\n  execMany,\n  execAsync,\n  execSync,\n  asyncDone,\n  syncDone\n} from \"./executor.js\";\nimport { parse, IExecutionTree, expectTypes, setLispType, LispItem } from \"./parser.js\";\n\n\nexport const extend = () => ({\n  expectTypes,\n  setLispType,\n  executionOps: ops,\n  assignCheck,\n  execMany,\n  execAsync,\n  execSync,\n  asyncDone,\n  syncDone,\n  executeTree,\n  executeTreeAsync,\n});\n\nexport interface IOptions {\n  audit?: boolean;\n  forbidFunctionCalls?: boolean;\n  forbidFunctionCreation?: boolean;\n  prototypeReplacements?: Map<new () => any, replacementCallback>;\n  prototypeWhitelist?: Map<any, Set<string>>;\n  globals: IGlobals;\n  executionQuota?: bigint;\n  onExecutionQuotaReached?: (ticks: Ticks, scope: Scope, context: IExecutionTree, tree: LispItem) => boolean|void;\n}\n\nexport interface IContext {\n  sandbox: Sandbox;\n  globalScope: Scope;\n  sandboxGlobal: SandboxGlobal;\n  globalsWhitelist?: Set<any>;\n  options: IOptions;\n  evals: Map<any, any>;\n  getSubscriptions: Set<(obj: object, name: string) => void>;\n  setSubscriptions: WeakMap<object, Map<string, Set<(modification: Change) => void>>>;\n  changeSubscriptions: WeakMap<object, Set<(modification: Change) => void>>;\n  auditReport?: IAuditReport;\n}\n\nexport interface Ticks {\n  ticks: bigint;\n}\n\nexport interface IExecContext extends IExecutionTree {\n  ctx: IContext\n}\n\nexport class SandboxGlobal {\n  constructor(globals: IGlobals) {\n    if (globals === globalThis) return globalThis;\n    for (let i in globals) {\n      (this as any)[i] = globals[i];\n    }\n  }\n}\n\nexport default class Sandbox {\n  context: IContext\n  constructor(options?: IOptions) {\n    options = Object.assign({\n      audit: false,\n      forbidFunctionCalls: false,\n      forbidFunctionCreation: false,\n      globals: Sandbox.SAFE_GLOBALS,\n      prototypeWhitelist: Sandbox.SAFE_PROTOTYPES, \n      prototypeReplacements: new Map<new() => any, replacementCallback>(),\n    }, options || {});\n    const sandboxGlobal = new SandboxGlobal(options.globals);\n    this.context = {\n      sandbox: this,\n      globalsWhitelist: new Set(Object.values(options.globals)),\n      options,\n      globalScope: new Scope(null, options.globals, sandboxGlobal),\n      sandboxGlobal,\n      evals: new Map(),\n      getSubscriptions: new Set<(obj: object, name: string) => void>(),\n      setSubscriptions: new WeakMap<object, Map<string, Set<() => void>>>(),\n      changeSubscriptions: new WeakMap()\n    };\n    const func = sandboxFunction(this.context);\n    this.context.evals.set(Function, func);\n    this.context.evals.set(eval, sandboxedEval(func));\n    this.context.evals.set(setTimeout, sandboxedSetTimeout(func));\n    this.context.evals.set(setInterval, sandboxedSetInterval(func));\n  }\n\n  static get SAFE_GLOBALS(): IGlobals {\n    return {\n      Function,\n      console: {\n        debug: console.debug, \n        error: console.error, \n        info: console.info, \n        log: console.log, \n        table: console.table, \n        warn: console.warn\n      },\n      isFinite,\n      isNaN,\n      parseFloat,\n      parseInt,\n      decodeURI,\n      decodeURIComponent,\n      encodeURI,\n      encodeURIComponent,\n      escape,\n      unescape,\n      Boolean,\n      Number,\n      BigInt,\n      String,\n      Object,\n      Array,\n      Symbol,\n      Error,\n      EvalError,\n      RangeError,\n      ReferenceError,\n      SyntaxError,\n      TypeError,\n      URIError,\n      Int8Array,\n      Uint8Array,\n      Uint8ClampedArray,\n      Int16Array,\n      Uint16Array,\n      Int32Array,\n      Uint32Array,\n      Float32Array,\n      Float64Array,\n      Map,\n      Set,\n      WeakMap,\n      WeakSet,\n      Promise,\n      Intl,\n      JSON,\n      Math,\n      Date,\n      RegExp\n    }\n  }\n\n  \n  static get SAFE_PROTOTYPES(): Map<any, Set<string>> {\n    let protos = [\n      SandboxGlobal,\n      Function,\n      Boolean,\n      Number,\n      BigInt,\n      String,\n      Date,\n      Error,\n      Array,\n      Int8Array,\n      Uint8Array,\n      Uint8ClampedArray,\n      Int16Array,\n      Uint16Array,\n      Int32Array,\n      Uint32Array,\n      Float32Array,\n      Float64Array,\n      Map,\n      Set,\n      WeakMap,\n      WeakSet,\n      Promise,\n      Symbol,\n      Date,\n      RegExp\n    ]\n    let map = new Map<any, Set<string>>();\n    protos.forEach((proto) => {\n      map.set(proto, new Set());\n    });\n    map.set(Object, new Set([\n      'entries',\n      'fromEntries',\n      'getOwnPropertyNames',\n      'is',\n      'keys',\n      'hasOwnProperty',\n      'isPrototypeOf',\n      'propertyIsEnumerable',\n      'toLocaleString',\n      'toString',\n      'valueOf',\n      'values'\n    ]));\n    return map;\n  }\n  \n  subscribeGet(callback: (obj: object, name: string) => void): {unsubscribe: () => void} {\n    this.context.getSubscriptions.add(callback);\n    return {unsubscribe: () => this.context.getSubscriptions.delete(callback)}\n  }\n\n  subscribeSet(obj: object, name: string, callback: (modification: Change) => void): {unsubscribe: () => void} {\n    const names = this.context.setSubscriptions.get(obj) || new Map<string, Set<(modification: Change) => void>>();\n    this.context.setSubscriptions.set(obj, names);\n    const callbacks = names.get(name) || new Set();\n    names.set(name, callbacks);\n    callbacks.add(callback);\n    let changeCbs: Set<(modification: Change) => void>;\n    if (obj && obj[name] && typeof obj[name] === \"object\") {\n      changeCbs = this.context.changeSubscriptions.get(obj[name]) || new Set();\n      changeCbs.add(callback);\n      this.context.changeSubscriptions.set(obj[name], changeCbs);\n    }\n    return {unsubscribe: () => {\n      callbacks.delete(callback);\n      if (changeCbs) changeCbs.delete(callback);\n    }}\n  }\n\n  static audit(code: string, scopes: ({[prop: string]: any}|Scope)[] = []): ExecReturn {\n    const globals = {};\n    for (let i of Object.getOwnPropertyNames(globalThis)) {\n      globals[i] = globalThis[i];\n    }\n    return new Sandbox({\n      globals,\n      audit: true,\n    }).executeTree(parse(code), scopes);\n  }\n\n  static parse(code: string) {\n    return parse(code);\n  }\n\n  executeTree(executionTree: IExecutionTree, scopes: ({[key:string]: any}|Scope)[] = []): ExecReturn {\n    return executeTree({\n      ticks: BigInt(0),\n    }, {\n      ctx: this.context,\n      constants: executionTree.constants,\n      tree: executionTree.tree\n    }, executionTree.tree, scopes);\n  }\n\n  executeTreeAsync(executionTree: IExecutionTree, scopes: ({[key:string]: any}|Scope)[] = []): Promise<ExecReturn> {\n    return executeTreeAsync({\n      ticks: BigInt(0),\n    }, {\n      ctx: this.context,\n      constants: executionTree.constants,\n      tree: executionTree.tree\n    }, executionTree.tree, scopes);\n  }\n  \n  compile(code: string, optimize = false): (...scopes: ({[prop: string]: any}|Scope)[]) => any {\n    const executionTree = parse(code, optimize);\n    return (...scopes: ({[prop: string]: any}|Scope)[]) => {\n      return this.executeTree(executionTree, scopes).result;\n    };\n  };\n  \n  compileAsync(code: string, optimize = false): (...scopes: ({[prop: string]: any}|Scope)[]) => Promise<any> {\n    const executionTree = parse(code, optimize);\n    return async (...scopes: ({[prop: string]: any}|Scope)[]) => {\n      return (await this.executeTreeAsync(executionTree, scopes)).result;\n    };\n  };\n\n  compileExpression(code: string, optimize = false): (...scopes: ({[prop: string]: any}|Scope)[]) => any {\n    const executionTree = parse(code, optimize);\n    executionTree.tree.length = 1;\n    return (...scopes: ({[prop: string]: any}|Scope)[]) => {\n      return this.executeTree(executionTree, scopes).result;\n    };\n  }\n\n  compileExpressionAsync(code: string, optimize = false): (...scopes: ({[prop: string]: any}|Scope)[]) => Promise<any> {\n    const executionTree = parse(code, optimize);\n    executionTree.tree.length = 1;\n    return async (...scopes: ({[prop: string]: any}|Scope)[]) => {\n      return (await this.executeTreeAsync(executionTree, scopes)).result;\n    };\n  }\n}\n"],"names":["parseHexToInt","hex","match","parseInt","NaN","validateAndParseHex","errorName","enforcedLength","parsedHex","Number","isNaN","undefined","length","SyntaxError","parseHexadecimalCode","code","parsedCode","String","fromCharCode","parseUnicodeCode","surrogateCode","parsedSurrogateCode","isCurlyBraced","text","charAt","parseUnicodeCodePointCode","codePoint","slice","fromCodePoint","err","RangeError","singleCharacterEscapes","Map","parseSingleCharacterCode","get","escapeMatch","unraw","raw","replace","_","backslash","unicodeWithSurrogate","surrogate","unicode","octal","singleCharacter","lispTypes","ParseError","Error","[object Object]","message","super","this","Lisp","obj","op","a","b","If","t","f","KeyVal","key","val","SpreadObject","item","SpreadArray","toLispArray","arr","lisp","inlineIfElse","space","expectTypes","splitter","types","split","boolOp","next","inlineIf","assignment","assignModify","assign","incrementerBefore","expEdge","call","incrementerAfter","modifier","not","inverse","negative","positive","typeof","delete","dot","arrayProp","prop","value","createObject","createArray","number","string","literal","regex","boolean","null","und","arrowFunctionSingle","arrowFunction","inlineFunction","group","Infinity","void","await","new","throw","initialize","return","spreadObject","spreadArray","expEnd","expSingle","for","do","while","loopAction","if","try","block","function","switch","closings","(","[","{","'","\"","`","testMultiple","str","tests","found","i","exec","okFirstChars","aChar","aNumber","wordReg","restOfExp","constants","part","quote","firstOpening","closingsTests","details","words","isStart","escape","done","currentIsChar","lastChar","isOneLiner","char","test","substring","regRes","foundWord","foundNumber","sub","push","lastAnyWord","lastWord","Math","min","oneliner","startingExecpted","setLispType","fn","forEach","type","set","closingsCreate","res","expect","ctx","extract","arg","end","l","funcFound","lispifyExpr","join","map","e","lispify","trimStart","lispTree","includes","quoteCount","condition","isBlock","startTrue","trueBlock","elseBlock","foundElse","trim","lispifyBlock","start","indexOf","caseFound","statement","insertSemicolons","caseTest","cases","defaultFound","cond","bracketFound","exprs","notEmpty","lines","index","matches","primitives","true","false","BigInt","JSON","parse","isArrow","isReturn","argPos","isAsync","args","unshift","ended","startsWith","func","eager","lispifyFunction","iteratorRegex","getIterator","body","startStep","startInternal","beforeStep","checkFirst","step","iterator","extract2","k","ofStart2","ofStart3","ofCondition","ofStep","inStart2","inStart3","inStep","inCondition","shift","catchReg","finallyBody","exception","catchBody","catchRes","offset","argsString","j","lastType","lastPart","lastLastPart","lastLastLastPart","expected","startingExpectedWithoutSingle","filter","r","subExpressions","pos","Object","values","defined","parts","Boolean","flat","tree","hoisted","hoist","concat","Array","isArray","rep","it","closingsNoInsertion","colonsRegex","rest","valid","edge","checkRegex","cancel","after","flags","notDivide","possibleDivide","extractConstants","currentEnclosure","regexFound","comment","commentStart","currJs","strRes","enclosures","isPossibleDivide","skip","literals","strings","pop","regexes","js","ExecReturn","auditReport","result","returned","breakLoop","continueLoop","Prop","context","isConst","isGlobal","isVariable","optional","Symbol","reservedWords","Set","VarType","Scope","parent","vars","functionThis","isFuncScope","allVars","let","keys","var","globals","functionScope","has","hasOwnProperty","const","ReferenceError","TypeError","SandboxError","declare","add","currentTicks","sandboxFunction","SandboxFunction","params","parsed","createFunction","sandboxedFunctions","WeakSet","argNames","ticks","scope","name","options","forbidFunctionCreation","executeTree","createFunctionAsync","prototypeWhitelist","Promise","async","executeTreeAsync","sandboxedEval","sandboxedSetTimeout","handler","setTimeout","sandboxedSetInterval","setInterval","assignCheck","changeSubscriptions","cb","setSubscriptions","arrayChange","splice","reverse","sort","copyWithin","literalRegex","ops2","sandboxGlobal","audit","globalsAccess","globalsWhitelist","evals","globalThis","globalScope","getSubscriptions","isFunction","prototypeAccess","prot","constructor","prototype","getPrototypeOf","whitelist","prototypeReplacements","size","constuctor","g","forbidFunctionCalls","execMany","vals","stringify","cache","recurse","x","y","change","changed","added","removed","startIndex","deleteCount","len","endIndex","keyVal","reg","RegExp","resnums","processed","reses","num","$$","$","!","~","++$","$++","--$","$--","=","+=","-=","/=","*=","**=","%=","^=","&=","|=","<<=",">>=",">>>=","?",">","<",">=","<=","==","===","!=","!==","&&","||","&","|",":","+","-","$+","$-","/","^","*","%","<<",">>",">>>","instanceof","in","bobj","arrowFunc","loop","loopScope","internalVars","$$obj","interalScope","execAsync","asyncDone","d","innerLoopVars","catch","syncDone","inLoopOrSwitch","executeTreeWithDone","toTest","execSync","isTrue","caseItem","valueOrProp","multi","ops","_execManySync","_execManyAsync","ret","callback","resolve","reject","execWithDone","executionQuota","onExecutionQuotaReached","executionTree","scopes","s","_executeWithDoneSync","_executeWithDoneAsync","current","extend","executionOps","SandboxGlobal","Sandbox","SAFE_GLOBALS","SAFE_PROTOTYPES","sandbox","WeakMap","Function","eval","console","debug","error","info","log","table","warn","isFinite","parseFloat","decodeURI","decodeURIComponent","encodeURI","encodeURIComponent","unescape","EvalError","URIError","Int8Array","Uint8Array","Uint8ClampedArray","Int16Array","Uint16Array","Int32Array","Uint32Array","Float32Array","Float64Array","Intl","Date","protos","proto","unsubscribe","names","callbacks","changeCbs","getOwnPropertyNames","optimize"],"mappings":"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"}