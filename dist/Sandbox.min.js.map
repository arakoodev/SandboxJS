{"version":3,"file":"Sandbox.min.js","sources":["../src/utils.ts","../src/executor.ts","../src/unraw.ts","../src/parser.ts","../src/eval.ts","../src/SandboxExec.ts","../src/Sandbox.ts"],"sourcesContent":["import { IEvalContext } from \"./eval\";\nimport { Change, Unknown } from \"./executor\";\nimport { IConstants, IExecutionTree, Lisp, LispItem } from \"./parser\";\nimport SandboxExec from \"./SandboxExec\";\n\nexport type replacementCallback = (obj: any, isStaticAccess: boolean) => any\n\nexport interface IOptionParams {\n  audit?: boolean;\n  forbidFunctionCalls?: boolean;\n  forbidFunctionCreation?: boolean;\n  prototypeReplacements?: Map<new () => any, replacementCallback>;\n  prototypeWhitelist?: Map<any, Set<string>>;\n  globals: IGlobals;\n  executionQuota?: bigint;\n  onExecutionQuotaReached?: (ticks: Ticks, scope: Scope, context: IExecutionTree, tree: LispItem) => boolean|void;\n}\n\nexport interface IOptions {\n  audit: boolean;\n  forbidFunctionCalls: boolean;\n  forbidFunctionCreation: boolean;\n  prototypeReplacements: Map<new () => any, replacementCallback>;\n  prototypeWhitelist: Map<any, Set<string>>;\n  globals: IGlobals;\n  executionQuota?: bigint;\n  onExecutionQuotaReached?: (ticks: Ticks, scope: Scope, context: IExecutionTree, tree: LispItem) => boolean|void;\n}\n\nexport interface IContext {\n  sandbox: SandboxExec;\n  globalScope: Scope;\n  sandboxGlobal: ISandboxGlobal;\n  globalsWhitelist: Set<any>;\n  prototypeWhitelist: Map<any, Set<string>>;\n  options: IOptions;\n  auditReport?: IAuditReport;\n}\n\nexport interface IAuditReport {\n  globalsAccess: Set<unknown>;\n  prototypeAccess: {[name: string]: Set<string>}\n}\n\nexport interface Ticks {\n  ticks: bigint;\n}\n\nexport type SubscriptionSubject = object;\n\nexport interface IExecContext extends IExecutionTree {\n  ctx: IContext,\n  getSubscriptions: Set<(obj: SubscriptionSubject, name: string) => void>;\n  setSubscriptions: WeakMap<SubscriptionSubject, Map<string, Set<(modification: Change) => void>>>;\n  changeSubscriptions: WeakMap<SubscriptionSubject, Set<(modification: Change) => void>>;\n  setSubscriptionsGlobal: WeakMap<SubscriptionSubject, Map<string, Set<(modification: Change) => void>>>;\n  changeSubscriptionsGlobal: WeakMap<SubscriptionSubject, Set<(modification: Change) => void>>;\n  registerSandboxFunction: (fn: (...args: any[]) => any) => void;\n  evals: Map<any, any>;\n  allowJit: boolean;\n  evalContext?: IEvalContext\n}\n\nexport interface ISandboxGlobal {[key: string]: unknown}\ninterface SandboxGlobalConstructor {\n  new(globals: IGlobals): ISandboxGlobal;\n}\n\nexport const SandboxGlobal = function SandboxGlobal(this: ISandboxGlobal, globals: IGlobals) {\n  if (globals === (globalThis as any)) return globalThis;\n  for (let i in globals) {\n    this[i] = globals[i];\n  }\n} as any as SandboxGlobalConstructor\n\nexport type IGlobals = ISandboxGlobal \n\nexport class ExecContext implements IExecContext {\n  constructor(\n    public ctx: IContext,\n    public constants: IConstants,\n    public tree: Lisp[],\n    public getSubscriptions: Set<(obj: SubscriptionSubject, name: string) => void>,\n    public setSubscriptions: WeakMap<SubscriptionSubject, Map<string, Set<(modification: Change) => void>>>,\n    public changeSubscriptions: WeakMap<SubscriptionSubject, Set<(modification: Change) => void>>,\n    public setSubscriptionsGlobal: WeakMap<SubscriptionSubject, Map<string, Set<(modification: Change) => void>>>,\n    public changeSubscriptionsGlobal: WeakMap<SubscriptionSubject, Set<(modification: Change) => void>>,\n    public evals: Map<any, any>,\n    public registerSandboxFunction: (fn: (...args: any[]) => any) => void,\n    public allowJit: boolean,\n    public evalContext?: IEvalContext\n  ) {\n\n  }\n}\n\nexport function createContext(sandbox: SandboxExec, options: IOptions, evalContext?: IEvalContext): IContext {\n  const sandboxGlobal = new SandboxGlobal(options.globals);\n  const context = {\n    sandbox: sandbox,\n    globalsWhitelist: new Set(Object.values(options.globals)),\n    prototypeWhitelist: new Map([...options.prototypeWhitelist].map((a) => [a[0].prototype, a[1]])),\n    options,\n    globalScope: new Scope(null, options.globals, sandboxGlobal),\n    sandboxGlobal\n  };\n  context.prototypeWhitelist.set(Object.getPrototypeOf([][Symbol.iterator]()) as Object, new Set());\n  return context;\n}\n\nexport function createExecContext(sandbox: {\n  setSubscriptions: WeakMap<SubscriptionSubject, Map<string, Set<(modification: Change) => void>>>, \n  changeSubscriptions: WeakMap<SubscriptionSubject, Set<(modification: Change) => void>>,\n  sandboxFunctions: WeakMap<(...args: any[]) => any, IExecContext>,\n  context: IContext\n}, executionTree: IExecutionTree, evalContext?: IEvalContext): IExecContext  {\n  const evals = new Map();\n  const execContext: IExecContext = new ExecContext(\n    sandbox.context,\n    executionTree.constants,\n    executionTree.tree,\n    new Set<(obj: SubscriptionSubject, name: string) => void>(),\n    new WeakMap<SubscriptionSubject, Map<string, Set<(modification: Change) => void>>>(),\n    new WeakMap<SubscriptionSubject, Set<(modification: Change) => void>>(),\n    sandbox.setSubscriptions,\n    sandbox.changeSubscriptions,\n    evals,\n    (fn) => sandbox.sandboxFunctions.set(fn, execContext),\n    !!evalContext,\n    evalContext\n  );\n  if (evalContext) {\n    const func = evalContext.sandboxFunction(execContext);\n    evals.set(Function, func);\n    evals.set(eval, evalContext.sandboxedEval(func));\n    evals.set(setTimeout, evalContext.sandboxedSetTimeout(func));\n    evals.set(setInterval, evalContext.sandboxedSetInterval(func));\n  }\n  return execContext;\n}\n\nexport class CodeString {\n  \n  start: number;\n  end: number;\n  ref: {str: string};\n  constructor(str: string|CodeString) {\n    this.ref = {str: \"\"};\n    if (str instanceof CodeString) {\n      this.ref = str.ref;\n      this.start = str.start\n      this.end = str.end;\n    } else {\n      this.ref.str = str;\n      this.start = 0;\n      this.end = str.length;\n    }\n  }\n\n  substring(start: number, end?: number): CodeString {\n    if (!this.length) return this;\n    start = this.start + start;\n    if (start < 0) {\n      start = 0;\n    }\n    if (start > this.end) {\n      start = this.end;\n    }\n    end = end === undefined ? this.end : this.start + end;\n    if (end < 0) {\n      end = 0;\n    }\n    if (end > this.end) {\n      end = this.end;\n    }\n    const code = new CodeString(this);\n    code.start = start;\n    code.end = end;\n    return code;\n  }\n\n  get length () {\n    const len = this.end - this.start;\n    return len < 0 ? 0 : len;\n  }\n\n  char(i: number) {\n    if (this.start === this.end) return undefined;\n    return this.ref.str[this.start + i];\n  }\n\n  toString() {\n    return this.ref.str.substring(this.start, this.end);\n  }\n\n  trimStart() {\n    const found = /^\\s+/.exec(this.toString());\n    const code = new CodeString(this);\n    if (found) {\n      code.start += found[0].length;\n    }\n    return code;\n  }\n\n  slice(start: number, end?: number) {\n    if (start < 0) {\n      start = this.end - this.start + start;\n    }\n    if (start < 0) {\n      start = 0;\n    }\n    if (end === undefined) {\n      end = this.end - this.start;\n    }\n\n    if (end < 0) {\n      end = this.end - this.start + end;\n    }\n    if (end < 0) {\n      end = 0;\n    }\n    return this.substring(start, end);\n  }\n\n  trim() {\n    const code = this.trimStart();\n    const found = /\\s+$/.exec(code.toString());\n    if (found) {\n      code.end -= found[0].length;\n    }\n    return code;\n  }\n\n  valueOf() {\n    return this.toString();\n  }\n}\n\nfunction keysOnly(obj: unknown): Record<string, true> {\n  const ret: Record<string, true> = Object.assign({}, obj);\n  for (let key in ret) {\n    ret[key] = true;\n  }\n  return ret;\n}\n\nconst reservedWords = new Set([\n  'instanceof',\n  'typeof',\n  'return',\n  'try',\n  'catch',\n  'if',\n  'finally',\n  'else',\n  'in',\n  'of',\n  'var',\n  'let',\n  'const',\n  'for',\n  'delete',\n  'false',\n  'true',\n  'while',\n  'do',\n  'break',\n  'continue',\n  'new',\n  'function',\n  'async',\n  'await',\n  'switch',\n  'case'\n]);\n\nexport const enum VarType {\n  let = \"let\",\n  const = \"const\",\n  var = \"var\"\n}\n\nexport class Scope {\n  parent: Scope|null;\n  const: {[key: string]: true} = {};\n  let: {[key: string]: true} = {};\n  var: {[key: string]: true} = {};\n  globals: {[key: string]: true};\n  allVars: {[key:string]: unknown} & Object;\n  functionThis?: Unknown;\n  constructor(parent: Scope|null, vars = {}, functionThis?: Unknown) {\n    const isFuncScope = functionThis !== undefined || parent === null;\n    this.parent = parent;\n    this.allVars = vars;\n    this.let = isFuncScope ? this.let : keysOnly(vars);\n    this.var = isFuncScope ? keysOnly(vars) : this.var;\n    this.globals = parent === null ? keysOnly(vars) : {};\n    this.functionThis = functionThis;\n  }\n\n  get(key: string, functionScope = false): Prop {\n    const functionThis = this.functionThis;\n    if (key === 'this' && functionThis !== undefined) {\n      return new Prop({this: functionThis}, key, true, false, true);\n    }\n    if (reservedWords.has(key)) throw new SyntaxError(\"Unexepected token '\" + key + \"'\");\n    if (this.parent === null || !functionScope || functionThis !== undefined) {\n      if (this.globals.hasOwnProperty(key)) {\n        return new Prop(functionThis, key, false, true, true);\n      }\n      if (key in this.allVars && (!(key in {}) || this.allVars.hasOwnProperty(key))) {\n        return new Prop(this.allVars, key, this.const.hasOwnProperty(key), this.globals.hasOwnProperty(key), true);\n      }\n      if (this.parent === null) {\n        return new Prop(undefined, key);\n      }\n    }\n    return this.parent.get(key, functionScope)\n  }\n\n  set(key: string, val: unknown) {\n    if (key === 'this') throw new SyntaxError('\"this\" cannot be assigned')\n    if (reservedWords.has(key)) throw new SyntaxError(\"Unexepected token '\" + key + \"'\");\n    let prop = this.get(key);\n    if(prop.context === undefined) {\n      throw new ReferenceError(`Variable '${key}' was not declared.`);\n    }\n    if (prop.isConst) {\n      throw new TypeError(`Cannot assign to const variable '${key}'`);\n    }\n    if (prop.isGlobal) {\n      throw new SandboxError(`Cannot override global variable '${key}'`);\n    }\n    if (!(prop.context instanceof Object)) throw new SandboxError('Scope is not an object');\n    prop.context[prop.prop] = val;\n    return prop;\n  }\n\n  declare(key: string, type: VarType, value: unknown = undefined, isGlobal = false): Prop {\n    if (key === 'this') throw new SyntaxError('\"this\" cannot be declared');\n    if (reservedWords.has(key)) throw new SyntaxError(\"Unexepected token '\" + key + \"'\");\n    if (type === 'var' && this.functionThis === undefined && this.parent !== null) {\n      return this.parent.declare(key, type, value, isGlobal)\n    } else if ((this[type].hasOwnProperty(key) && type !== 'const' && !this.globals.hasOwnProperty(key)) || !(key in this.allVars)) {\n      if (isGlobal) {\n        this.globals[key] = true;\n      }\n      this[type][key] = true;\n      this.allVars[key] = value;\n    } else {\n      throw new SandboxError(`Identifier '${key}' has already been declared`);\n    }\n    return new Prop(this.allVars, key, this.const.hasOwnProperty(key), isGlobal);\n  }\n}\n\nexport interface IScope {\n  [key: string]: any;\n}\n\nexport class FunctionScope implements IScope {}\n\nexport class LocalScope implements IScope {}\n\nexport class SandboxError extends Error {}\n\nexport function isLisp<Type extends Lisp = Lisp>(item: LispItem|LispItem): item is Type {\n  return Array.isArray(item) && typeof item[0] === 'number' && item[0] !== LispType.None && item[0] !== LispType.True;\n}\n\nexport const enum LispType {\n  None,\n  Prop,\n  StringIndex,\n  Let,\n  Const,\n  Call,\n  KeyVal,\n  Number,\n  Return,\n  Assign,\n  InlineFunction,\n  ArrowFunction,\n  CreateArray,\n  If,\n  IfCase,\n  InlineIf,\n  InlineIfCase,\n  SpreadObject,\n  SpreadArray,\n  ArrayProp,\n  PropOptional,\n  CallOptional,\n  CreateObject,\n  Group,\n  Not,\n  IncrementBefore,\n  IncrementAfter,\n  DecrementBefore,\n  DecrementAfter,\n  And,\n  Or,\n  StrictNotEqual,\n  StrictEqual,\n  Plus,\n  Var,\n  GlobalSymbol,\n  Literal,\n  Function,\n  Loop,\n  Try,\n  Switch,\n  SwitchCase,\n  Block,\n  Expression,\n  Await,\n  New,\n  Throw,\n  Minus,\n  Divide,\n  Power,\n  Multiply,\n  Modulus,\n  Equal,\n  NotEqual,\n  SmallerEqualThan,\n  LargerEqualThan,\n  SmallerThan,\n  LargerThan,\n  Negative,\n  Positive,\n  Typeof,\n  Delete,\n  Instanceof,\n  In,\n  Inverse,\n  SubractEquals,\n  AddEquals,\n  DivideEquals,\n  PowerEquals,\n  MultiplyEquals,\n  ModulusEquals,\n  BitNegateEquals,\n  BitAndEquals,\n  BitOrEquals,\n  UnsignedShiftRightEquals,\n  ShiftRightEquals,\n  ShiftLeftEquals,\n  BitAnd,\n  BitOr,\n  BitNegate,\n  BitShiftLeft,\n  BitShiftRight,\n  BitUnsignedShiftRight,\n  BigInt,\n  LiteralIndex,\n  RegexIndex,\n  LoopAction,\n  Void,\n  True,\n\n  LispEnumSize\n}\n\nexport class Prop {\n  constructor(public context: Unknown, public prop: string, public isConst = false, public isGlobal = false, public isVariable = false) {\n  }\n\n  get<T = unknown>(context: IExecContext): T {\n    const ctx = this.context;\n    if (ctx === undefined) throw new ReferenceError(`${this.prop} is not defined`);\n    if (ctx === null) throw new TypeError(`Cannot read properties of null, (reading '${this.prop}')`);\n    context.getSubscriptions.forEach((cb) => cb(ctx, this.prop))\n    return (ctx as any)[this.prop] as T;\n  }\n}","import { LispItem, Lisp, IRegEx, LispFamily, ExtractLispOp, SwitchCase } from \"./parser.js\";\nimport { CodeString, IAuditReport, IExecContext, IScope, isLisp, LispType, LocalScope, Prop, SandboxError, Scope, Ticks, VarType } from \"./utils.js\";\n\nexport type Done<T = any> = (err?: any, res?: T|typeof optional) => void;\n\nexport class ExecReturn<T> {\n  constructor(public auditReport: IAuditReport|undefined, public result: T, public returned: boolean, public breakLoop = false, public continueLoop = false) {}\n}\n\nexport type Unknown = undefined|null|Record<string|number, unknown>;\n\n\nexport interface IChange {\n  type: string;\n}\n\nexport interface ICreate extends IChange {\n  type: \"create\";\n  prop: number|string;\n}\n\nexport interface IReplace extends IChange {\n  type: \"replace\";\n}\n\nexport interface IDelete extends IChange {\n  type: \"delete\";\n  prop: number|string;\n}\n\nexport interface IReverse extends IChange {\n  type: \"reverse\";\n}\n\nexport interface ISort extends IChange {\n  type: \"sort\";\n}\n\nexport interface IPush extends IChange {\n  type: \"push\";\n  added: unknown[];\n}\n\nexport interface IPop extends IChange {\n  type: \"pop\";\n  removed: unknown[];\n}\n\nexport interface IShift extends IChange {\n  type: \"shift\";\n  removed: unknown[];\n}\n\nexport interface IUnShift extends IChange {\n  type: \"unshift\";\n  added: unknown[];\n}\n\nexport interface ISplice extends IChange {\n  type: \"splice\";\n  startIndex: number;\n  deleteCount: number; \n  added: unknown[];\n  removed: unknown[];\n\n}\n\nexport interface ICopyWithin extends IChange {\n  type: \"copyWithin\";\n  startIndex: number;\n  endIndex: number;\n  added: unknown[];\n  removed: unknown[];\n}\n\nexport type Change = ICreate | IReplace | IDelete | IReverse | ISort | IPush | IPop | IUnShift | IShift | ISplice | ICopyWithin\n\nconst optional = {};\n\n\nfunction generateArgs(argNames: string[], args: unknown[]) {\n  const vars: Record<string, unknown> = {};\n  argNames.forEach((arg, i) => {\n    if (arg.startsWith('...')) {\n      vars[arg.substring(3)] = args.slice(i);\n    } else {\n      vars[arg] = args[i];\n    }\n  });\n  return vars;\n}\n\nexport const sandboxedFunctions = new WeakSet();\nexport function createFunction(argNames: string[], parsed: Lisp[], ticks: Ticks, context: IExecContext, scope?: Scope, name?: string) {\n  if (context.ctx.options.forbidFunctionCreation) {\n    throw new SandboxError(\"Function creation is forbidden\");\n  }\n  let func;\n  if (name === undefined) {\n    func = (...args: unknown[]) => {\n      const vars = generateArgs(argNames, args);\n      const res = executeTree(ticks, context, parsed, scope === undefined ? [] : [new Scope(scope, vars)])\n      return res.result;\n    }\n  } else {\n    func = function sandboxedObject(this: Unknown, ...args: unknown[]) {\n      const vars = generateArgs(argNames, args);\n      const res = executeTree(ticks, context, parsed, scope === undefined ? [] : [new Scope(scope, vars, this)])\n      return res.result;\n    }\n  }\n  context.registerSandboxFunction(func);\n  sandboxedFunctions.add(func);\n  return func;\n}\n\nexport function createFunctionAsync(argNames: string[], parsed: Lisp[], ticks: Ticks, context: IExecContext, scope?: Scope, name?: string) {\n  if (context.ctx.options.forbidFunctionCreation) {\n    throw new SandboxError(\"Function creation is forbidden\");\n  }\n  if (!context.ctx.prototypeWhitelist?.has(Promise.prototype)) {\n    throw new SandboxError(\"Async/await not permitted\");\n  }\n  let func;\n  if (name === undefined) {\n    func = async (...args: unknown[]) => {\n      const vars = generateArgs(argNames, args);\n      const res = await executeTreeAsync(ticks, context, parsed, scope === undefined ? [] : [new Scope(scope, vars)])\n      return res.result;\n    }\n  } else {\n    func = async function sandboxedObject(this: Unknown, ...args: unknown[]) {\n      const vars = generateArgs(argNames, args);\n      const res = await executeTreeAsync(ticks, context, parsed, scope === undefined ? [] : [new Scope(scope, vars, this)])\n      return res.result;\n    }\n  }\n  context.registerSandboxFunction(func);\n  sandboxedFunctions.add(func);\n  return func;\n}\n\nexport function assignCheck(obj: Prop, context: IExecContext, op = 'assign') {\n  if(obj.context === undefined) {\n    throw new ReferenceError(`Cannot ${op} value to undefined.`)\n  }\n  if(typeof obj.context !== 'object' && typeof obj.context !== 'function') {\n    throw new SyntaxError(`Cannot ${op} value to a primitive.`)\n  }\n  if (obj.isConst) {\n    throw new TypeError(`Cannot set value to const variable '${obj.prop}'`);\n  }\n  if (obj.isGlobal) {\n    throw new SandboxError(`Cannot ${op} property '${obj.prop}' of a global object`);\n  }\n  if (obj.context === null) {\n    throw new TypeError('Cannot set properties of null');\n  }\n  if (typeof obj.context[obj.prop] === 'function' && !obj.context.hasOwnProperty(obj.prop)) {\n    throw new SandboxError(`Override prototype property '${obj.prop}' not allowed`);\n  }\n  if (op === \"delete\") {\n    if (obj.context.hasOwnProperty(obj.prop)) {\n      context.changeSubscriptions.get(obj.context)?.forEach((cb) => cb({type: \"delete\", prop: obj.prop}));\n      context.changeSubscriptionsGlobal.get(obj.context)?.forEach((cb) => cb({type: \"delete\", prop: obj.prop}));\n    }\n  } else if (obj.context.hasOwnProperty(obj.prop)) {\n    context.setSubscriptions.get(obj.context)?.get(obj.prop)?.forEach((cb) => cb({\n      type: \"replace\"\n    }));\n    context.setSubscriptionsGlobal.get(obj.context)?.get(obj.prop)?.forEach((cb) => cb({\n      type: \"replace\"\n    }));\n  } else {\n    context.changeSubscriptions.get(obj.context)?.forEach((cb) => cb({type: \"create\", prop: obj.prop}));\n    context.changeSubscriptionsGlobal.get(obj.context)?.forEach((cb) => cb({type: \"create\", prop: obj.prop}));\n  }\n}\nconst arrayChange = new Set([\n  [].push,\n  [].pop,\n  [].shift,\n  [].unshift,\n  [].splice,\n  [].reverse,\n  [].sort,\n  [].copyWithin\n]);\n\nexport class KeyVal {\n  constructor(public key: string|SpreadObject, public val: unknown) {}\n}\n\nexport class SpreadObject {\n  constructor(public item: {[key: string]: unknown}) {}\n}\n\nexport class SpreadArray {\n  constructor(public item: unknown[]) {}\n}\n\nexport class If {\n  constructor(public t: Lisp, public f: Lisp) {}\n}\n\nconst literalRegex = /(\\$\\$)*(\\$)?\\${(\\d+)}/g;\ntype OpCallback = (exec: Execution, done: Done, ticks: Ticks, a: any, b: any, obj: any, context: IExecContext, scope: Scope, bobj?: any, inLoopOrSwitch?: string) => void;\n\nexport const ops = new Map<LispType, OpCallback>();\nexport function addOps<Type extends LispFamily>(type: ExtractLispOp<Type>, cb: OpCallback) {\n  ops.set(type, cb);\n}\n\naddOps(LispType.Prop, (exec, done, ticks, a, b: string, obj, context, scope) => {\n    if(a === null) {\n      throw new TypeError(`Cannot get property ${b} of null`);\n    }\n    const type = typeof a;\n    if (type === 'undefined' && obj === undefined) {\n      let prop = scope.get(b);\n      if (prop.context === context.ctx.sandboxGlobal) {\n        if (context.ctx.options.audit) {\n          context.ctx.auditReport?.globalsAccess.add(b);\n        }\n        const rep = context.ctx.globalsWhitelist.has(context.ctx.sandboxGlobal[b]) ? context.evals.get(context.ctx.sandboxGlobal[b]) : undefined;\n        if (rep) {\n          done(undefined, rep);\n          return;\n        }\n      }\n      if (prop.context && prop.context[b] === globalThis) {\n        done(undefined, context.ctx.globalScope.get('this'));\n        return;\n      }\n\n      done(undefined, prop);\n      return;\n    } else if (a === undefined) {\n      throw new SandboxError(\"Cannot get property '\" + b + \"' of undefined\")\n    }\n\n    if (type !== 'object') {\n      if(type === 'number') {\n        a = new Number(a);\n      } else if(type === 'string') {\n        a = new String(a);\n      } else if(type === 'boolean') {\n        a = new Boolean(a);\n      }\n    } else if (typeof a.hasOwnProperty === 'undefined') {\n      done(undefined, new Prop(undefined, b));\n      return;\n    }\n\n    const isFunction = type === 'function';\n    let prototypeAccess = isFunction || !(a.hasOwnProperty(b) || typeof b === 'number');\n\n    if (context.ctx.options.audit && prototypeAccess) {\n      if (typeof b === 'string') {\n        let prot = Object.getPrototypeOf(a);\n        do {\n          if (prot.hasOwnProperty(b)) {\n            if(context.ctx.auditReport && !context.ctx.auditReport.prototypeAccess[prot.constructor.name]) {\n              context.ctx.auditReport.prototypeAccess[prot.constructor.name] = new Set();\n            }\n            context.ctx.auditReport?.prototypeAccess[prot.constructor.name].add(b);\n          }\n        } while(prot = Object.getPrototypeOf(prot))\n      }\n    }\n\n    if (prototypeAccess) {\n      if (isFunction) {\n        if (!['name', 'length', 'constructor'].includes(b) && a.hasOwnProperty(b)) {\n          const whitelist = context.ctx.prototypeWhitelist.get(a.prototype);\n          const replace = context.ctx.options.prototypeReplacements.get(a);\n          if (replace) {\n            done(undefined, new Prop(replace(a, true), b));\n            return;\n          }\n          if (whitelist && (!whitelist.size || whitelist.has(b))) {\n          } else {\n            throw new SandboxError(`Static method or property access not permitted: ${a.name}.${b}`);\n          }\n        }\n      } else if (b !== 'constructor') {\n        let prot = a;\n        while(prot = Object.getPrototypeOf(prot)) {\n          if (prot.hasOwnProperty(b)) {\n            const whitelist = context.ctx.prototypeWhitelist.get(prot);\n            const replace = context.ctx.options.prototypeReplacements.get(prot.constuctor);\n            if (replace) {\n              done(undefined, new Prop(replace(a, false), b));\n              return;\n            }\n            if (whitelist && (!whitelist.size || whitelist.has(b))) {\n              break;\n            }\n            throw new SandboxError(`Method or property access not permitted: ${prot.constructor.name}.${b}`);\n          }\n        };\n      }\n    }\n\n    if (context.evals.has(a[b])) {\n      done(undefined, context.evals.get(a[b]));\n      return;\n    }\n    if (a[b] === globalThis) {\n      done(undefined, context.ctx.globalScope.get('this'));\n      return;\n    }\n\n    let g = obj.isGlobal || (isFunction && !sandboxedFunctions.has(a)) || context.ctx.globalsWhitelist.has(a);\n\n    done(undefined, new Prop(a, b, false, g));\n  });\n\naddOps(LispType.Call, (exec, done, ticks, a, b: Lisp[], obj, context, scope) => {\n  if (context.ctx.options.forbidFunctionCalls) throw new SandboxError(\"Function invocations are not allowed\");\n  if (typeof a !== 'function') {\n    throw new TypeError(`${typeof obj.prop === 'symbol' ? 'Symbol' : obj.prop} is not a function`);\n  }\n  const vals = b.map((item) => {\n    if (item instanceof SpreadArray) {\n      return [...item.item];\n    } else {\n      return [item];\n    }\n  }).flat().map((item) => valueOrProp(item, context));\n\n  if (typeof obj === 'function') {\n    done(undefined, obj(...vals));\n    return;\n  }\n  if (obj.context[obj.prop] === JSON.stringify && context.getSubscriptions.size) {\n    const cache = new Set<any>();\n    const recurse = (x: unknown) => {\n      if (!x || !(typeof x === 'object') || cache.has(x)) return;\n      cache.add(x);\n      for (let y of Object.keys(x) as (keyof typeof x)[]) {\n        context.getSubscriptions.forEach((cb) => cb(x, y));\n        recurse(x[y]);\n      }\n    };\n    recurse(vals[0]);\n  }\n\n  if (obj.context instanceof Array && arrayChange.has(obj.context[obj.prop]) && (context.changeSubscriptions.get(obj.context) || context.changeSubscriptionsGlobal.get(obj.context))) {\n    let change: Change;\n    let changed = false;\n    if (obj.prop === \"push\") {\n      change = {\n        type: \"push\",\n        added: vals\n      }\n      changed = !!vals.length;\n    } else if (obj.prop === \"pop\") {\n      change = {\n        type: \"pop\",\n        removed: obj.context.slice(-1)\n      }\n      changed = !!change.removed.length;\n    }  else if (obj.prop === \"shift\") {\n      change = {\n        type: \"shift\",\n        removed: obj.context.slice(0, 1)\n      }\n      changed = !!change.removed.length;\n    } else if (obj.prop === \"unshift\") {\n      change = {\n        type: \"unshift\",\n        added: vals\n      }\n      changed = !!vals.length;\n    } else if (obj.prop === \"splice\") {\n      change = {\n        type: \"splice\",\n        startIndex: vals[0],\n        deleteCount: vals[1] === undefined ? obj.context.length : vals[1],\n        added: vals.slice(2),\n        removed: obj.context.slice(vals[0], vals[1] === undefined ? undefined : vals[0] + vals[1])\n      }\n      changed = !!change.added.length || !!change.removed.length;\n    } else if (obj.prop === \"reverse\" || obj.prop === \"sort\") {\n      change = {type: obj.prop}\n      changed = !!obj.context.length;\n    } else if (obj.prop === \"copyWithin\") {\n      let len = vals[2] === undefined ? obj.context.length - vals[1] : Math.min(obj.context.length, vals[2] - vals[1]);\n      change = {\n        type: \"copyWithin\",\n        startIndex: vals[0],\n        endIndex: vals[0] + len,\n        added: obj.context.slice(vals[1], vals[1] + len),\n        removed: obj.context.slice(vals[0], vals[0] + len)\n      }\n      changed = !!change.added.length || !!change.removed.length;\n    }\n    if (changed) {\n      context.changeSubscriptions.get(obj.context)?.forEach((cb) => cb(change));\n      context.changeSubscriptionsGlobal.get(obj.context)?.forEach((cb) => cb(change));\n    }\n  }\n  obj.get(context);\n  done(undefined, obj.context[obj.prop](...vals));\n});\n\naddOps(LispType.CreateObject, (exec, done, ticks, a, b: KeyVal[], obj, context, scope) => {\n  let res = {} as any;\n  for (let item of b) {\n    if (item.key instanceof SpreadObject) {\n      res = {...res, ...item.key.item};\n    } else {\n      res[item.key] = item.val;\n    }\n  }\n  done(undefined, res);\n});\n\naddOps(LispType.KeyVal, (exec, done, ticks, a: string, b: LispItem) => done(undefined, new KeyVal(a, b)));\n\naddOps(LispType.CreateArray, (exec, done, ticks, a, b: Lisp[], obj, context, scope) => {\n  const items = b.map((item) => {\n    if (item instanceof SpreadArray) {\n      return [...item.item];\n    } else {\n      return [item];\n    }\n  }).flat().map((item) => valueOrProp(item, context))\n  done(undefined, items)\n});\n\naddOps(LispType.Group, (exec, done, ticks, a, b) => done(undefined, b));\n\naddOps(LispType.GlobalSymbol, (exec, done, ticks, a, b: string) => {\n  switch (b) {\n    case 'true': return done(undefined, true);\n    case 'false': return done(undefined, false);\n    case 'null': return done(undefined, null);\n    case 'undefined': return done(undefined, undefined);\n    case 'NaN': return done(undefined, NaN);\n    case 'Infinity': return done(undefined, Infinity);\n  }\n  done(new Error('Unknown symbol: ' + b))\n})\n\naddOps(LispType.Number, (exec, done, ticks, a, b) => done(undefined, Number(b)));\naddOps(LispType.BigInt, (exec, done, ticks, a, b) => done(undefined, BigInt(b)));\naddOps(LispType.StringIndex, (exec, done, ticks, a, b: string, obj, context) => done(undefined, context.constants.strings[parseInt(b)]));\n\naddOps(LispType.RegexIndex, (exec, done, ticks, a, b: string, obj, context) => {\n  const reg: IRegEx = context.constants.regexes[parseInt(b)];\n  if (!context.ctx.globalsWhitelist.has(RegExp)) {\n    throw new SandboxError(\"Regex not permitted\");\n  } else {\n    done(undefined, new RegExp(reg.regex, reg.flags));\n  }\n});\n\naddOps(LispType.LiteralIndex, (exec, done, ticks, a, b: string, obj, context, scope) => {\n  let item = context.constants.literals[parseInt(b)];\n  const [,name,js] = item;\n  let found: Lisp[] = [];\n  let f: RegExpExecArray|null;\n  let resnums: string[] = [];\n  while(f = literalRegex.exec(name)) {\n    if (!f[2]) {\n      found.push(js[parseInt(f[3], 10)]);\n      resnums.push(f[3]);\n    }\n  }\n\n  exec<unknown[]>(ticks, found, scope, context, (err, processed) => {\n    const reses: Record<string, unknown> = {};\n    if(err) {\n      done(err);\n      return;\n    }\n    for (let i of Object.keys(processed!) as (keyof typeof processed)[]) {\n      const num = resnums[i];\n      reses[num] = processed![i];\n    }\n    done(undefined, name.replace(/(\\\\\\\\)*(\\\\)?\\${(\\d+)}/g, (match, $$, $, num) => {\n      if ($) return match;\n      let res = reses[num];\n      return ($$ ? $$ : '') + `${valueOrProp(res, context)}`;\n    }));\n  })\n});\n\naddOps(LispType.SpreadArray, (exec, done, ticks, a, b, obj, context, scope) => {\n  done(undefined, new SpreadArray(b));\n});\n\naddOps(LispType.SpreadObject, (exec, done, ticks, a, b, obj, context, scope) => {\n  done(undefined, new SpreadObject(b));\n});\n\naddOps(LispType.Not, (exec, done, ticks, a, b) => done(undefined, !b));\naddOps(LispType.Inverse, (exec, done, ticks, a, b) => done(undefined, ~b));\n\naddOps(LispType.IncrementBefore, (exec, done, ticks, a, b, obj, context) => {\n  assignCheck(obj, context);\n  done(undefined, ++obj.context[obj.prop]);\n});\n\naddOps(LispType.IncrementAfter, (exec, done, ticks, a, b, obj, context) => {\n  assignCheck(obj, context);\n  done(undefined, obj.context[obj.prop]++);\n});\n\naddOps(LispType.DecrementBefore, (exec, done, ticks, a, b, obj, context) => {\n  assignCheck(obj, context);\n  done(undefined, --obj.context[obj.prop]);\n});\n\naddOps(LispType.DecrementAfter, (exec, done, ticks, a, b, obj, context) => {\n  assignCheck(obj, context);\n  done(undefined, obj.context[obj.prop]--);\n});\n\naddOps(LispType.Assign, (exec, done, ticks, a, b, obj, context) => {\n  assignCheck(obj, context);\n  done(undefined, obj.context[obj.prop] = b);\n});\n\naddOps(LispType.AddEquals, (exec, done, ticks, a, b, obj, context) => {\n  assignCheck(obj, context);\n  done(undefined, obj.context[obj.prop] += b);\n});\n\naddOps(LispType.SubractEquals, (exec, done, ticks, a, b: number, obj, context) => {\n  assignCheck(obj, context);\n  done(undefined, obj.context[obj.prop] -= b);\n});\n\naddOps(LispType.DivideEquals, (exec, done, ticks, a, b: number, obj, context) => {\n  assignCheck(obj, context);\n  done(undefined, obj.context[obj.prop] /= b);\n});\n\naddOps(LispType.MultiplyEquals, (exec, done, ticks, a, b: number, obj, context) => {\n  assignCheck(obj, context);\n  done(undefined, obj.context[obj.prop] *= b);\n});\n\naddOps(LispType.PowerEquals, (exec, done, ticks, a, b: number, obj, context) => {\n  assignCheck(obj, context);\n  done(undefined, obj.context[obj.prop] **= b);\n});\n\naddOps(LispType.ModulusEquals, (exec, done, ticks, a, b: number, obj, context) => {\n  assignCheck(obj, context);\n  done(undefined, obj.context[obj.prop] %= b);\n});\n\naddOps(LispType.BitNegateEquals, (exec, done, ticks, a, b: number, obj, context) => {\n  assignCheck(obj, context);\n  done(undefined, obj.context[obj.prop] ^= b);\n});\n\naddOps(LispType.BitAndEquals, (exec, done, ticks, a, b: number, obj, context) => {\n  assignCheck(obj, context);\n  done(undefined, obj.context[obj.prop] &= b);\n});\n\naddOps(LispType.BitOrEquals, (exec, done, ticks, a, b: number, obj, context) => {\n  assignCheck(obj, context);\n  done(undefined, obj.context[obj.prop] |= b);\n});\n\naddOps(LispType.ShiftLeftEquals, (exec, done, ticks, a, b: number, obj, context) => {\n  assignCheck(obj, context);\n  done(undefined, obj.context[obj.prop] <<= b);\n});\n\naddOps(LispType.ShiftRightEquals, (exec, done, ticks, a, b: number, obj, context) => {\n  assignCheck(obj, context);\n  done(undefined, obj.context[obj.prop] >>= b);\n});\n\naddOps(LispType.UnsignedShiftRightEquals, (exec, done, ticks, a, b: number, obj, context) => {\n  assignCheck(obj, context);\n  done(undefined, obj.context[obj.prop] >>= b);\n});\n\naddOps(LispType.LargerThan, (exec, done, ticks, a, b) => done(undefined, a > b));\naddOps(LispType.SmallerThan, (exec, done, ticks, a, b) => done(undefined, a < b));\naddOps(LispType.LargerEqualThan, (exec, done, ticks, a, b) => done(undefined, a >= b));\naddOps(LispType.SmallerEqualThan, (exec, done, ticks, a, b) => done(undefined, a <= b));\naddOps(LispType.Equal, (exec, done, ticks, a, b) => done(undefined, a == b));\naddOps(LispType.StrictEqual, (exec, done, ticks, a, b) => done(undefined, a === b));\naddOps(LispType.NotEqual, (exec, done, ticks, a, b) => done(undefined, a != b));\naddOps(LispType.StrictNotEqual, (exec, done, ticks, a, b) => done(undefined, a !== b));\naddOps(LispType.And, (exec, done, ticks, a, b) => done(undefined, a && b));\naddOps(LispType.Or, (exec, done, ticks, a, b) => done(undefined, a || b));\naddOps(LispType.BitAnd, (exec, done, ticks, a: number, b: number) => done(undefined, a & b));\naddOps(LispType.BitOr, (exec, done, ticks, a: number, b: number) => done(undefined, a | b));\naddOps(LispType.Plus, (exec, done, ticks, a: number, b: number) => done(undefined, a + b));\naddOps(LispType.Minus, (exec, done, ticks, a: number, b: number) => done(undefined, a - b));\naddOps(LispType.Positive, (exec, done, ticks, a, b) => done(undefined, +b));\naddOps(LispType.Negative, (exec, done, ticks, a, b) => done(undefined, -b));\naddOps(LispType.Divide, (exec, done, ticks, a: number, b: number) => done(undefined, a / b));\naddOps(LispType.BitNegate, (exec, done, ticks, a: number, b: number) => done(undefined, a ^ b));\naddOps(LispType.Multiply, (exec, done, ticks, a: number, b: number) => done(undefined, a * b));\naddOps(LispType.Modulus, (exec, done, ticks, a: number, b: number) => done(undefined, a % b));\naddOps(LispType.BitShiftLeft, (exec, done, ticks, a: number, b: number) => done(undefined, a << b));\naddOps(LispType.BitShiftRight, (exec, done, ticks, a: number, b: number) => done(undefined, a >> b));\naddOps(LispType.BitUnsignedShiftRight, (exec, done, ticks, a: number, b: number) => done(undefined, a >>> b));\naddOps(LispType.Typeof, (exec, done, ticks, a, b: LispItem, obj, context, scope) => {\n    exec(ticks, b, scope, context, (e, prop) => {\n      done(undefined, typeof valueOrProp(prop, context));\n    });\n  });\n\naddOps(LispType.Instanceof, (exec, done, ticks, a, b:  { new(): unknown }) => done(undefined, a instanceof b));\naddOps(LispType.In, (exec, done, ticks, a: string, b) => done(undefined, a in b));\n\naddOps(LispType.Delete, (exec, done, ticks, a, b, obj, context, scope, bobj: Prop) => {\n  if (bobj.context === undefined) {\n    done(undefined, true);\n    return;\n  }\n  assignCheck(bobj, context, 'delete');\n  if (bobj.isVariable) {\n    done(undefined, false);\n    return;\n  }\n  done(undefined, delete bobj.context?.[bobj.prop]);\n});\n\naddOps(LispType.Return, (exec, done, ticks, a, b, obj, context) => done(undefined, b));\n\naddOps(LispType.Var, (exec, done, ticks, a: string, b: LispItem, obj, context, scope, bobj) => {\n  done(undefined, scope.declare(a, VarType.var, b));\n});\n\naddOps(LispType.Let, (exec, done, ticks, a: string, b: LispItem, obj, context, scope, bobj) => {\n  done(undefined, scope.declare(a, VarType.let, b, bobj && bobj.isGlobal));\n});\n\naddOps(LispType.Const, (exec, done, ticks, a: string, b: LispItem, obj, context, scope, bobj) => {\n  done(undefined, scope.declare(a, VarType.const, b));\n});\n\naddOps(LispType.ArrowFunction, (exec, done, ticks, a: string[], b: Lisp[], obj: Lisp, context, scope) => {\n  a = [...a];\n    if (typeof obj[2] === \"string\" || obj[2] instanceof CodeString) {\n      if (context.allowJit && context.evalContext) {\n        obj[2] = b = context.evalContext.lispifyFunction(new CodeString(obj[2]), context.constants);\n      } else {\n        throw new SandboxError('Unevaluated code detected, JIT not allowed')\n      }\n    }\n    if (a.shift()) {\n      done(undefined, createFunctionAsync(a, b, ticks, context, scope));\n    } else {\n      done(undefined, createFunction(a, b, ticks, context, scope));\n    }\n});\n\naddOps(LispType.Function, (exec, done, ticks, a: (string|LispType)[], b: Lisp[], obj: Lisp, context, scope) => {   \n  if (typeof obj[2] === \"string\" || obj[2] instanceof CodeString) {\n    if (context.allowJit && context.evalContext) {\n      obj[2] = b = context.evalContext.lispifyFunction(new CodeString(obj[2]), context.constants);\n    } else {\n      throw new SandboxError('Unevaluated code detected, JIT not allowed')\n    }\n  }\n  let isAsync = a.shift();\n  let name = a.shift() as string;\n  let func;\n  if (isAsync === LispType.True) {\n    func = createFunctionAsync(a as string[], b, ticks, context, scope, name);\n  } else {\n    func = createFunction(a as string[], b, ticks, context, scope, name);\n  }\n  if (name) {\n    scope.declare(name, VarType.var, func);\n  }\n  done(undefined, func);\n});\n\naddOps(LispType.InlineFunction, (exec, done, ticks, a: (string|LispType)[], b: Lisp[], obj: Lisp, context, scope) => {\n  if (typeof obj[2] === \"string\" || obj[2] instanceof CodeString) {\n    if (context.allowJit && context.evalContext) {\n      obj[2] = b = context.evalContext.lispifyFunction(new CodeString(obj[2]), context.constants);\n    } else {\n      throw new SandboxError('Unevaluated code detected, JIT not allowed')\n    }\n  }\n  let isAsync = a.shift();\n  let name = a.shift() as string;\n  if (name) {\n    scope = new Scope(scope, {})\n  }\n  let func;\n  if (isAsync === LispType.True) {\n    func = createFunctionAsync(a as string[], b, ticks, context, scope, name);\n  } else {\n    func = createFunction(a as string[], b, ticks, context, scope, name);\n  }\n  if (name) {\n    scope.declare(name, VarType.let, func);\n  }\n  done(undefined, func);\n});\n\naddOps(LispType.Loop, (exec, done, ticks, a: Lisp[], b: Lisp[], obj, context, scope) => {\n  const [checkFirst, startInternal, getIterator, startStep, step, condition, beforeStep] = a;\n  let loop = true;\n  const loopScope = new Scope(scope, {});\n  let internalVars = {\n    '$$obj': undefined\n  };\n  const interalScope = new Scope(loopScope, internalVars);\n  if (exec === execAsync) {\n    (async() => {\n      let ad: AsyncDoneRet;\n      ad = asyncDone((d) => exec(ticks, startStep, loopScope, context, d));\n      internalVars['$$obj'] = (ad = asyncDone((d) => exec(ticks, getIterator, loopScope, context, d))).isInstant === true ? ad.instant : (await ad.p).result;\n      ad = asyncDone((d) => exec(ticks, startInternal, interalScope, context, d));\n      if (checkFirst) loop = (ad = asyncDone((d) => exec(ticks, condition, interalScope, context, d))).isInstant === true ? ad.instant : (await ad.p).result;\n      while (loop) {\n        let innerLoopVars = {};\n        ad = asyncDone((d) => exec(ticks, beforeStep, new Scope(interalScope, innerLoopVars), context, d));\n        ad.isInstant === true ? ad.instant : (await ad.p).result;\n        let res = await executeTreeAsync(ticks, context, b, [new Scope(loopScope, innerLoopVars)], \"loop\");\n        if (res instanceof ExecReturn && res.returned) {\n          done(undefined, res);\n          return;\n        }\n        if (res instanceof ExecReturn && res.breakLoop) {\n          break;\n        }\n        ad = asyncDone((d) => exec(ticks, step, interalScope, context, d));\n        loop = (ad = asyncDone((d) => exec(ticks, condition, interalScope, context, d))).isInstant === true ? ad.instant : (await ad.p).result;\n      }\n      done();\n    })().catch(done);\n  } else {\n    syncDone((d) => exec(ticks, startStep, loopScope, context, d));\n    internalVars['$$obj'] = syncDone((d) => exec(ticks, getIterator, loopScope, context, d)).result;\n    syncDone((d) => exec(ticks, startInternal, interalScope, context, d));\n    if (checkFirst) loop = (syncDone((d) => exec(ticks, condition, interalScope, context, d))).result;\n    while (loop) {\n      let innerLoopVars = {};\n      syncDone((d) => exec(ticks, beforeStep, new Scope(interalScope, innerLoopVars), context, d));\n      let res = executeTree(ticks, context, b, [new Scope(loopScope, innerLoopVars)], \"loop\");\n      if (res instanceof ExecReturn && res.returned) {\n        done(undefined, res);\n        return;\n      }\n      if (res instanceof ExecReturn && res.breakLoop) {\n        break;\n      }\n      syncDone((d) => exec(ticks, step, interalScope, context, d));\n      loop = (syncDone((d) => exec(ticks, condition, interalScope, context, d))).result;\n    }\n    done();\n  }\n});\n\naddOps(LispType.LoopAction, (exec, done, ticks, a: LispItem, b: LispItem, obj, context, scope, bobj, inLoopOrSwitch) => {\n  if ((inLoopOrSwitch === \"switch\" && a === \"continue\") || !inLoopOrSwitch) {\n    throw new SandboxError(\"Illegal \" + a + \" statement\");\n  }\n  done(undefined, new ExecReturn(context.ctx.auditReport, undefined, false, a === \"break\", a === \"continue\"));\n});\n\naddOps(LispType.If, (exec, done, ticks, a: LispItem, b:If, obj, context, scope, bobj, inLoopOrSwitch) => {\n  exec(ticks, valueOrProp(a, context) ? b.t : b.f, scope, context, done);\n});\n\naddOps(LispType.InlineIf, (exec, done, ticks, a: LispItem, b: If, obj, context, scope) => {\n  exec(ticks, valueOrProp(a, context) ? b.t : b.f, scope, context, done);\n});\naddOps(LispType.InlineIfCase, (exec, done, ticks, a, b) => done(undefined, new If(a, b)));\naddOps(LispType.IfCase, (exec, done, ticks, a, b) => done(undefined, new If(a, b)));\n\naddOps(LispType.Switch, (exec, done, ticks, a: LispItem, b: SwitchCase[], obj, context, scope) => {\n  exec(ticks, a, scope, context, (err, toTest) => {\n    if (err) {\n      done(err);\n      return;\n    }\n    toTest = valueOrProp(toTest, context);\n    if (exec === execSync) {\n      let res: ExecReturn<unknown>;\n      let isTrue = false;\n      for (let caseItem of b) {\n        if (isTrue || (isTrue = !caseItem[1] || toTest === valueOrProp((syncDone((d) => exec(ticks, caseItem[1], scope, context, d))).result, context))) {\n          if (!caseItem[2]) continue;\n          res = executeTree(ticks, context, caseItem[2], [scope], \"switch\");\n          if (res.breakLoop) break;\n          if (res.returned) {\n            done(undefined, res);\n            return;\n          }\n          if (!caseItem[1]) { // default case\n            break;\n          }\n        }\n      }\n      done();\n    } else {\n      (async () => {\n        let res: ExecReturn<unknown>;\n        let isTrue = false;\n        for (let caseItem of b) {\n          let ad: AsyncDoneRet;\n          if (isTrue || (isTrue = !caseItem[1] || toTest === valueOrProp((ad = asyncDone((d) => exec(ticks, caseItem[1], scope, context, d))).isInstant === true ? ad.instant : (await ad.p).result, context))) {\n            if (!caseItem[2]) continue;\n            res = await executeTreeAsync(ticks, context, caseItem[2], [scope], \"switch\");\n            if (res.breakLoop) break;\n            if (res.returned) {\n              done(undefined, res);\n              return;\n            }\n            if (!caseItem[1]) { // default case\n              break;\n            }\n          }\n        }\n        done();\n      })().catch(done)\n    }\n  });\n});\n\naddOps(LispType.Try, (exec, done, ticks, a: Lisp[], b: [string, Lisp[], Lisp[]], obj, context, scope, bobj, inLoopOrSwitch) => {\n  const [exception, catchBody, finallyBody] = b;\n  executeTreeWithDone(exec, (err, res) => {\n    executeTreeWithDone(exec, (e) => {\n      if (e) done(e);\n      else  if (err) {\n        let sc: Record<string, unknown> = {};\n        if (exception) sc[exception] = err;\n        executeTreeWithDone(exec, done, ticks, context, catchBody, [new Scope(scope)], inLoopOrSwitch);\n      } else {\n        done(undefined, res);\n      }\n    }, ticks, context, finallyBody, [new Scope(scope, {})]);\n  }, ticks, context, a, [new Scope(scope)], inLoopOrSwitch);\n});\n\naddOps(LispType.Void, (exec, done, ticks, a) => {done()});\naddOps(LispType.New, (exec, done, ticks, a: new (...args: unknown[]) => unknown, b: unknown[], obj, context) => {\n  if (!context.ctx.globalsWhitelist.has(a) && !sandboxedFunctions.has(a)) {\n    throw new SandboxError(`Object construction not allowed: ${a.constructor.name}`)\n  }\n  done(undefined, new a(...b))\n});\n\naddOps(LispType.Throw, (exec, done, ticks, a, b) => { done(b) });\naddOps(LispType.Expression, (exec, done, ticks, a: unknown[]) => done(undefined, a.pop()));\naddOps(LispType.None, (exec, done, ticks, a: unknown[]) => done());\n\nfunction valueOrProp(a: unknown, context: IExecContext): any {\n  if (a instanceof Prop) return a.get(context);\n  if (a === optional) return undefined;\n  return a;\n}\n\nexport function execMany(ticks: Ticks, exec: Execution, tree: Lisp[], done: Done, scope: Scope, context: IExecContext, inLoopOrSwitch?: string) {\n  if (exec === execSync) {\n    _execManySync(ticks, tree, done, scope, context, inLoopOrSwitch);\n  } else {\n    _execManyAsync(ticks, tree, done, scope, context, inLoopOrSwitch).catch(done);\n  }\n}\n\nfunction _execManySync(ticks: Ticks, tree: Lisp[], done: Done, scope: Scope, context: IExecContext, inLoopOrSwitch?: string) {\n  let ret = [];\n  for (let i = 0; i < tree.length; i++) {\n    let res;\n    try {\n      res = syncDone((d) => execSync(ticks, tree[i], scope, context, d, inLoopOrSwitch)).result;\n    } catch(e) {\n      done(e);\n      return;\n    }\n    if (res instanceof ExecReturn && (res.returned || res.breakLoop || res.continueLoop)) {\n      done(undefined, res);\n      return;\n    }\n    if (isLisp(tree[i]) && tree[i][0] === LispType.Return) {\n      done(undefined, new ExecReturn(context.ctx.auditReport, res, true))\n      return;\n    }\n    ret.push(res);\n  }\n  done(undefined, ret);\n}\n\nasync function _execManyAsync(ticks: Ticks, tree: Lisp[], done: Done, scope: Scope, context: IExecContext, inLoopOrSwitch?: string) {\n  let ret = [];\n  for (let i = 0; i < tree.length; i++) {\n    let res;\n    try {\n      let ad: AsyncDoneRet;\n      res = (ad = asyncDone((d) => execAsync(ticks, tree[i], scope, context, d, inLoopOrSwitch))).isInstant === true ? ad.instant : (await ad.p).result;\n    } catch(e) {\n      done(e);\n      return;\n    }\n    if (res instanceof ExecReturn && (res.returned || res.breakLoop || res.continueLoop)) {\n      done(undefined, res);\n      return;\n    }\n    if (isLisp(tree[i]) && tree[i][0] === LispType.Return) {\n      done(undefined, new ExecReturn(context.ctx.auditReport, res, true))\n      return;\n    }\n    ret.push(res);\n  }\n  done(undefined, ret);\n}\n\ntype Execution = <T = any>(ticks: Ticks, tree: LispItem, scope: Scope, context: IExecContext, done: Done<T>, inLoopOrSwitch?: string) => void\n\nexport interface AsyncDoneRet {\n  isInstant: boolean,\n  instant: any,\n  p: Promise<{result: any}>\n}\n\nexport function asyncDone(callback: (done: Done) => void): AsyncDoneRet {\n  let isInstant = false;\n  let instant: unknown;\n  const p = new Promise<any>((resolve, reject) => {\n    callback((err, result) => {\n      if (err) reject(err);\n      else {\n        isInstant = true;\n        instant = result;\n        resolve({result})\n      };\n    });\n  });\n  return {\n    isInstant,\n    instant,\n    p\n  }\n}\n\nexport function syncDone(callback: (done: Done) => void): {result: any} {\n  let result;\n  let err;\n  callback((e, r) => {\n    err = e;\n    result = r;\n  });\n  if (err) throw err;\n  return {result};\n}\n\nexport async function execAsync<T = any>(ticks: Ticks, tree: LispItem, scope: Scope, context: IExecContext, doneOriginal: Done<T>, inLoopOrSwitch?: string): Promise<void> {\n  let done: Done<T> = doneOriginal;\n  const p = new Promise<void>((resolve) => {\n    done = (e, r?) => {\n      doneOriginal(e, r);\n      resolve();\n    }\n  });\n  if(_execNoneRecurse(ticks, tree, scope, context, done, true, inLoopOrSwitch)) {\n  } else if (isLisp(tree)) {\n    let op = tree[0];\n    let obj;\n    try {\n      let ad: AsyncDoneRet;\n      obj = (ad = asyncDone((d) => execAsync(ticks, tree[1], scope, context, d, inLoopOrSwitch))).isInstant === true ? ad.instant : (await ad.p).result;\n    } catch (e) {\n      done(e);\n      return;\n    }\n    let a = obj;\n    try {\n      a = obj instanceof Prop ? obj.get(context) : obj;\n    } catch (e) {\n      done(e);\n      return;\n    }\n    if (op === LispType.PropOptional || op === LispType.CallOptional) {\n      if (a === undefined || a === null) {\n        done(undefined, optional);\n        return;\n      }\n      op = op === LispType.PropOptional ? LispType.Prop : LispType.Call;\n    }\n    if (a === optional) {\n      if (op === LispType.Prop || op === LispType.Call) {\n        done(undefined, a);\n        return;\n      } else {\n        a = undefined;\n      }\n    }\n    let bobj;\n    try {\n      let ad: AsyncDoneRet;\n      bobj = (ad = asyncDone((d) => execAsync(ticks, tree[2], scope, context, d, inLoopOrSwitch))).isInstant === true ? ad.instant : (await ad.p).result;\n    } catch (e) {\n      done(e);\n      return;\n    }\n    let b = bobj;\n    try {\n      b = bobj instanceof Prop ? bobj.get(context) : bobj;\n    } catch (e) {\n      done(e);\n      return;\n    }\n    if (b === optional) {\n      b = undefined;\n    }\n    if (ops.has(op)) {\n      try {\n        ops.get(op)?.(execAsync, done, ticks, a, b, obj, context, scope, bobj, inLoopOrSwitch);\n      } catch (err) {\n        done(err);\n      }\n    } else {\n      done(new SyntaxError('Unknown operator: ' + op));\n    }\n  }\n  await p;\n}\n\n\nexport function execSync<T = any>(ticks: Ticks, tree: LispItem, scope: Scope, context: IExecContext, done: Done<T>, inLoopOrSwitch?: string) {\n  if(_execNoneRecurse(ticks, tree, scope, context, done, false, inLoopOrSwitch)) {\n  } else if (isLisp(tree)) {\n    let op = tree[0];\n    let obj;\n    try {\n      obj = syncDone((d) => execSync(ticks, tree[1], scope, context, d, inLoopOrSwitch)).result;\n    } catch (e) {\n      done(e);\n      return;\n    }\n    let a = obj;\n    try {\n      a = obj instanceof Prop ? obj.get(context) : obj;\n    } catch (e) {\n      done(e);\n      return;\n    }\n    if (op === LispType.PropOptional || op === LispType.CallOptional) {\n      if (a === undefined || a === null) {\n        done(undefined, optional);\n        return;\n      }\n      op = op === LispType.PropOptional ? LispType.Prop : LispType.Call;\n    }\n    if (a === optional) {\n      if (op === LispType.Prop || op === LispType.Call) {\n        done(undefined, a);\n        return;\n      } else {\n        a = undefined;\n      }\n    }\n    let bobj;\n    try {\n      bobj = syncDone((d) => execSync(ticks, tree[2], scope, context, d, inLoopOrSwitch)).result;\n    } catch (e) {\n      done(e);\n      return;\n    }\n    let b = bobj;\n    try {\n      b = bobj instanceof Prop ? bobj.get(context) : bobj;\n    } catch (e) {\n      done(e);\n      return;\n    }\n    if (b === optional) {\n      b = undefined;\n    }\n    if (ops.has(op)) {\n      try {\n        ops.get(op)?.(execSync, done, ticks, a, b, obj, context, scope, bobj, inLoopOrSwitch);\n      } catch (err) {\n        done(err);\n      }\n    } else {\n      done(new SyntaxError('Unknown operator: ' + op));\n    }\n  }\n}\n\nconst unexecTypes = new Set([\n  LispType.ArrowFunction,\n  LispType.Function,\n  LispType.InlineFunction,\n  LispType.Loop,\n  LispType.Try,\n  LispType.Switch,\n  LispType.IfCase,\n  LispType.InlineIfCase,\n  LispType.Typeof\n]);\n\nexport const currentTicks = { current: { ticks: BigInt(0) } as Ticks };\n\nfunction _execNoneRecurse<T = any>(ticks: Ticks, tree: LispItem, scope: Scope, context: IExecContext, done: Done<T>, isAsync: boolean, inLoopOrSwitch?: string): boolean {\n  const exec = isAsync ? execAsync : execSync;\n  if (context.ctx.options.executionQuota && context.ctx.options.executionQuota <= ticks.ticks) {\n    if (typeof context.ctx.options.onExecutionQuotaReached === 'function' && context.ctx.options.onExecutionQuotaReached(ticks, scope, context, tree)) {\n    } else {\n      done(new SandboxError(\"Execution quota exceeded\"));\n      return true;\n    }\n  }\n  ticks.ticks++;\n  currentTicks.current = ticks;\n  if (tree instanceof Prop) {\n    try {\n      done(undefined, tree.get(context));\n    } catch (err) {\n      done(err);\n    }\n  } else if (tree === optional) {\n    done();\n  } else if (Array.isArray(tree) && !isLisp(tree)) {\n    if (tree[0] === LispType.None) {\n      done();\n    } else {\n      execMany(ticks, exec, tree as Lisp[], done, scope, context, inLoopOrSwitch);\n    }\n  } else if (!isLisp(tree)) {\n    done(undefined, tree);\n  } else if (tree[0] === LispType.Block) {\n    execMany(ticks, exec, tree[1] as Lisp[], done, scope, context, inLoopOrSwitch);\n  } else if (tree[0] === LispType.Await) {\n    if (!isAsync) {\n      done(new SandboxError(\"Illegal use of 'await', must be inside async function\"));\n    } else if (context.ctx.prototypeWhitelist?.has(Promise.prototype)) {\n      execAsync(ticks, tree[1], scope, context, async (e, r) => {\n        if (e) done(e);\n        else try {\n          done(undefined, await valueOrProp(r, context));\n        } catch(err) {\n          done(err);\n        }\n      }, inLoopOrSwitch).catch(done);\n    } else {\n      done(new SandboxError('Async/await is not permitted'))\n    }\n  } else if (unexecTypes.has(tree[0])) {\n    try {\n      ops.get(tree[0])?.(exec, done, ticks, tree[1], tree[2], tree, context, scope, undefined, inLoopOrSwitch);\n    } catch (err) {\n      done(err);\n    }\n  } else {\n    return false;\n  }\n  return true;\n}\nexport function executeTree<T>(ticks: Ticks, context: IExecContext, executionTree: Lisp[], scopes: (IScope)[] = [], inLoopOrSwitch?: string): ExecReturn<T> {\n  return syncDone((done) => executeTreeWithDone(execSync, done, ticks, context, executionTree, scopes, inLoopOrSwitch)).result;\n}\n\nexport async function executeTreeAsync<T>(ticks: Ticks, context: IExecContext, executionTree: Lisp[], scopes: (IScope)[] = [], inLoopOrSwitch?: string): Promise<ExecReturn<T>> {\n  let ad: AsyncDoneRet;\n  return (ad = asyncDone((done) => executeTreeWithDone(execAsync, done, ticks, context, executionTree, scopes, inLoopOrSwitch))).isInstant === true ? ad.instant : (await ad.p).result;\n}\n\nfunction executeTreeWithDone(exec: Execution, done: Done, ticks: Ticks, context: IExecContext, executionTree: Lisp[], scopes: (IScope)[] = [], inLoopOrSwitch?: string) {\n  if (!executionTree)  {\n    done();\n    return;\n  }\n  if (!(executionTree instanceof Array)) {\n    throw new SyntaxError('Bad execution tree');\n  }\n  let scope = context.ctx.globalScope;\n  let s;\n  while (s = scopes.shift()) {\n    if (typeof s !== \"object\") continue;\n    if (s instanceof Scope) {\n      scope = s;\n    } else {\n      scope = new Scope(scope, s, s instanceof LocalScope ? undefined : null);\n    }\n  }\n  if (context.ctx.options.audit && !context.ctx.auditReport) {\n    context.ctx.auditReport = {\n      globalsAccess: new Set(),\n      prototypeAccess: {},\n    }\n  }\n  if (exec === execSync) {\n    _executeWithDoneSync(done, ticks, context, executionTree, scope, inLoopOrSwitch);\n  } else {\n    _executeWithDoneAsync(done, ticks, context, executionTree, scope, inLoopOrSwitch).catch(done);\n  }\n}\n\nfunction _executeWithDoneSync(done: Done, ticks: Ticks, context: IExecContext, executionTree: Lisp[], scope: Scope, inLoopOrSwitch?: string) {\n  if (!(executionTree instanceof Array)) throw new SyntaxError('Bad execution tree');\n  let i = 0;\n  for (i = 0; i < executionTree.length; i++) {\n    let res: unknown;\n    let err: unknown;\n    const current = executionTree[i];\n    try {\n      execSync(ticks, current, scope, context, (e, r) => {\n        err = e;\n        res = r;\n      }, inLoopOrSwitch);\n    } catch (e) {\n      err = e;\n    }\n    if (err) {\n      done(err);\n      return;\n    }\n    if (res instanceof ExecReturn) {\n      done(undefined, res);\n      return;\n    }\n    if (isLisp(current) && current[0] === LispType.Return) {\n      done(undefined, new ExecReturn(context.ctx.auditReport, res, true))\n      return;\n    }\n  }\n  done(undefined, new ExecReturn(context.ctx.auditReport, undefined, false));\n}\n\nasync function _executeWithDoneAsync(done: Done, ticks: Ticks, context: IExecContext, executionTree: Lisp[], scope: Scope, inLoopOrSwitch?: string) {\n  if (!(executionTree instanceof Array)) throw new SyntaxError('Bad execution tree');\n  let i = 0;\n  for (i = 0; i < executionTree.length; i++) {\n    let res: unknown;\n    let err: unknown;\n    const current = executionTree[i];\n    try {\n      await execAsync(ticks, current, scope, context, (e, r) => {\n        err = e;\n        res = r;\n      }, inLoopOrSwitch);\n    } catch (e) {\n      err = e;\n    }\n    if (err) {\n      done(err);\n      return;\n    }\n    if (res instanceof ExecReturn) {\n      done(undefined, res);\n      return;\n    }\n    if (isLisp(current) && current[0] === LispType.Return) {\n      done(undefined, new ExecReturn(context.ctx.auditReport, res, true))\n      return;\n    }\n  }\n  done(undefined, new ExecReturn(context.ctx.auditReport, undefined, false));\n}\n","/**\n * Parse a string as a base-16 number. This is more strict than `parseInt` as it\n * will not allow any other characters, including (for example) \"+\", \"-\", and\n * \".\".\n * @param hex A string containing a hexadecimal number.\n * @returns The parsed integer, or `NaN` if the string is not a valid hex\n * number.\n */\nfunction parseHexToInt(hex: string): number {\n  const isOnlyHexChars = !hex.match(/[^a-f0-9]/i);\n  return isOnlyHexChars ? parseInt(hex, 16) : NaN;\n}\n\n/**\n * Check the validity and length of a hexadecimal code and optionally enforces\n * a specific number of hex digits.\n * @param hex The string to validate and parse.\n * @param errorName The name of the error message to throw a `SyntaxError` with\n * if `hex` is invalid. This is used to index `errorMessages`.\n * @param enforcedLength If provided, will throw an error if `hex` is not\n * exactly this many characters.\n * @returns The parsed hex number as a normal number.\n * @throws {SyntaxError} If the code is not valid.\n */\nfunction validateAndParseHex(\n  hex: string,\n  errorName: string,\n  enforcedLength?: number\n): number {\n  const parsedHex = parseHexToInt(hex);\n  if (\n    Number.isNaN(parsedHex) ||\n    (enforcedLength !== undefined && enforcedLength !== hex.length)\n  ) {\n    throw new SyntaxError(errorName + ': ' + hex);\n  }\n  return parsedHex;\n}\n\n/**\n * Parse a two-digit hexadecimal character escape code.\n * @param code The two-digit hexadecimal number that represents the character to\n * output.\n * @returns The single character represented by the code.\n * @throws {SyntaxError} If the code is not valid hex or is not the right\n * length.\n */\nfunction parseHexadecimalCode(code: string): string {\n  const parsedCode = validateAndParseHex(\n    code,\n    'Malformed Hexadecimal',\n    2\n  );\n  return String.fromCharCode(parsedCode);\n}\n\n/**\n * Parse a four-digit Unicode character escape code.\n * @param code The four-digit unicode number that represents the character to\n * output.\n * @param surrogateCode Optional four-digit unicode surrogate that represents\n * the other half of the character to output.\n * @returns The single character represented by the code.\n * @throws {SyntaxError} If the codes are not valid hex or are not the right\n * length.\n */\nfunction parseUnicodeCode(code: string, surrogateCode?: string): string {\n  const parsedCode = validateAndParseHex(code, 'Malformed Unicode', 4);\n\n  if (surrogateCode !== undefined) {\n    const parsedSurrogateCode = validateAndParseHex(\n      surrogateCode,\n      'Malformed Unicode',\n      4\n    );\n    return String.fromCharCode(parsedCode, parsedSurrogateCode);\n  }\n\n  return String.fromCharCode(parsedCode);\n}\n\n/**\n * Test if the text is surrounded by curly braces (`{}`).\n * @param text Text to check.\n * @returns `true` if the text is in the form `{*}`.\n */\nfunction isCurlyBraced(text: string): boolean {\n  return text.charAt(0) === \"{\" && text.charAt(text.length - 1) === \"}\";\n}\n\n/**\n * Parse a Unicode code point character escape code.\n * @param codePoint A unicode escape code point, including the surrounding curly\n * braces.\n * @returns The single character represented by the code.\n * @throws {SyntaxError} If the code is not valid hex or does not have the\n * surrounding curly braces.\n */\nfunction parseUnicodeCodePointCode(codePoint: string): string {\n  if (!isCurlyBraced(codePoint)) {\n    throw new SyntaxError('Malformed Unicode: +' + codePoint);\n  }\n  const withoutBraces = codePoint.slice(1, -1);\n  const parsedCode = validateAndParseHex(\n    withoutBraces,\n    'Malformed Unicode'\n  );\n\n  try {\n    return String.fromCodePoint(parsedCode);\n  } catch (err) {\n    throw err instanceof RangeError\n      ? new SyntaxError('Code Point Limit:' + parsedCode)\n      : err;\n  }\n}\n\n/**\n * Map of unescaped letters to their corresponding special JS escape characters.\n * Intentionally does not include characters that map to themselves like \"\\'\".\n */\nconst singleCharacterEscapes = new Map<string, string>([\n  [\"b\", \"\\b\"],\n  [\"f\", \"\\f\"],\n  [\"n\", \"\\n\"],\n  [\"r\", \"\\r\"],\n  [\"t\", \"\\t\"],\n  [\"v\", \"\\v\"],\n  [\"0\", \"\\0\"]\n]);\n\n/**\n * Parse a single character escape sequence and return the matching character.\n * If none is matched, defaults to `code`.\n * @param code A single character code.\n */\nfunction parseSingleCharacterCode(code: string): string {\n  return singleCharacterEscapes.get(code) || code;\n}\n\n/**\n * Matches every escape sequence possible, including invalid ones.\n *\n * All capture groups (described below) are unique (only one will match), except\n * for 4, which can only potentially match if 3 does.\n *\n * **Capture Groups:**\n * 0. A single backslash\n * 1. Hexadecimal code\n * 2. Unicode code point code with surrounding curly braces\n * 3. Unicode escape code with surrogate\n * 4. Surrogate code\n * 5. Unicode escape code without surrogate\n * 6. Octal code _NOTE: includes \"0\"._\n * 7. A single character (will never be \\, x, u, or 0-3)\n */\nconst escapeMatch = /\\\\(?:(\\\\)|x([\\s\\S]{0,2})|u(\\{[^}]*\\}?)|u([\\s\\S]{4})\\\\u([^{][\\s\\S]{0,3})|u([\\s\\S]{0,4})|([0-3]?[0-7]{1,2})|([\\s\\S])|$)/g;\n\n/**\n * Replace raw escape character strings with their escape characters.\n * @param raw A string where escape characters are represented as raw string\n * values like `\\'` rather than `'`.\n * @param allowOctals If `true`, will process the now-deprecated octal escape\n * sequences (ie, `\\111`).\n * @returns The processed string, with escape characters replaced by their\n * respective actual Unicode characters.\n */\nexport function unraw(raw: string): string {\n  return raw.replace(escapeMatch, function(\n    _,\n    backslash?: string,\n    hex?: string,\n    codePoint?: string,\n    unicodeWithSurrogate?: string,\n    surrogate?: string,\n    unicode?: string,\n    octal?: string,\n    singleCharacter?: string\n  ): string {\n    // Compare groups to undefined because empty strings mean different errors\n    // Otherwise, `\\u` would fail the same as `\\` which is wrong.\n    if (backslash !== undefined) {\n      return \"\\\\\";\n    }\n    if (hex !== undefined) {\n      return parseHexadecimalCode(hex);\n    }\n    if (codePoint !== undefined) {\n      return parseUnicodeCodePointCode(codePoint);\n    }\n    if (unicodeWithSurrogate !== undefined) {\n      return parseUnicodeCode(unicodeWithSurrogate, surrogate);\n    }\n    if (unicode !== undefined) {\n      return parseUnicodeCode(unicode);\n    }\n    if (octal === \"0\") {\n      return \"\\0\";\n    }\n    if (octal !== undefined) {\n      throw new SyntaxError('Octal Deprecation: ' + octal);\n    }\n    if (singleCharacter !== undefined) {\n      return parseSingleCharacterCode(singleCharacter);\n    }\n    throw new SyntaxError('End of string');\n  });\n}\nexport default unraw;","import unraw from \"./unraw.js\";\nimport { CodeString, isLisp, LispType } from \"./utils.js\";\n\nexport type DefineLisp<op extends LispType, a extends LispItem|LispItem, b extends LispItem|LispItem> = [op, a, b];\n\nexport type ExtractLispOp<L> = L extends DefineLisp<infer i, any, any> ? i : never;\nexport type ExtractLispA<L> = L extends DefineLisp<any, infer i, any> ? i : never;\nexport type ExtractLispB<L> = L extends DefineLisp<any, any, infer i> ? i : never;\n\nexport type LispItemSingle = LispType.None|LispType.True|string|Lisp;\nexport type LispItem = LispItemSingle|LispItemSingle[];\nexport type Lisp = [LispType, LispItem, LispItem];\n\nfunction createLisp<L extends Lisp>(obj: {op: ExtractLispOp<L>, a: ExtractLispA<L>, b: ExtractLispB<L>}) {\n  return [obj.op, obj.a, obj.b] as L;\n}\n\nconst NullLisp = createLisp<None>({op: LispType.None, a: LispType.None, b: LispType.None});\n\nexport type Literal = DefineLisp<LispType.Literal, string, Lisp[]> & {tempJsStrings?: string[]}\nexport type If = DefineLisp<LispType.If, Lisp, IfCase>\nexport type InlineIf = DefineLisp<LispType.InlineIf, Lisp, InlineIfCase>\nexport type IfCase = DefineLisp<LispType.IfCase, Lisp[], Lisp[]>\nexport type InlineIfCase = DefineLisp<LispType.InlineIfCase, Lisp, Lisp>\nexport type KeyVal = DefineLisp<LispType.KeyVal, string|Lisp, Lisp>\nexport type SpreadObject = DefineLisp<LispType.SpreadObject, LispType.None, Lisp>;\nexport type SpreadArray = DefineLisp<LispType.SpreadArray, LispType.None, Lisp>;\nexport type ArrayProp = DefineLisp<LispType.ArrayProp, Lisp, Lisp>;\nexport type Prop = DefineLisp<LispType.Prop, Lisp, string|Lisp>;\nexport type PropOptional = DefineLisp<LispType.PropOptional, Lisp, Lisp[]>;\nexport type Call = DefineLisp<LispType.Call, Lisp, Lisp[]>;\nexport type CallOptional = DefineLisp<LispType.CallOptional, Lisp, Lisp[]>;\nexport type CreateArray = DefineLisp<LispType.CreateArray, Lisp, Lisp[]>;\nexport type CreateObject = DefineLisp<LispType.CreateObject, Lisp, Lisp[]>;\nexport type Group = DefineLisp<LispType.Group, Lisp, Lisp[]>;\nexport type Inverse = DefineLisp<LispType.Inverse, Lisp, Lisp>;\nexport type Not = DefineLisp<LispType.Not, Lisp, Lisp>;\nexport type Negative = DefineLisp<LispType.Negative, Lisp, Lisp>;\nexport type Positive = DefineLisp<LispType.Positive, Lisp, Lisp>;\nexport type Typeof = DefineLisp<LispType.Typeof, Lisp, Lisp>;\nexport type Delete = DefineLisp<LispType.Delete, Lisp, Lisp>;\nexport type IncrementBefore = DefineLisp<LispType.IncrementBefore, Lisp, LispType.None>;\nexport type IncrementAfter = DefineLisp<LispType.IncrementAfter, Lisp, LispType.None>;\nexport type DecrementBefore = DefineLisp<LispType.DecrementBefore, Lisp, LispType.None>;\nexport type DecrementAfter = DefineLisp<LispType.DecrementAfter, Lisp, LispType.None>;\n\nexport type And = DefineLisp<LispType.And, Lisp, Lisp>;\nexport type Or = DefineLisp<LispType.Or, Lisp, Lisp>;\nexport type Instanceof = DefineLisp<LispType.Instanceof, Lisp, Lisp>;\nexport type In = DefineLisp<LispType.In, Lisp, Lisp>;\nexport type Assigns = DefineLisp<LispType.Assign, Lisp, Lisp>;\nexport type SubractEquals = DefineLisp<LispType.SubractEquals, Lisp, Lisp>;\nexport type AddEquals = DefineLisp<LispType.AddEquals, Lisp, Lisp>;\nexport type DivideEquals = DefineLisp<LispType.DivideEquals, Lisp, Lisp>;\nexport type PowerEquals = DefineLisp<LispType.PowerEquals, Lisp, Lisp>;\nexport type MultiplyEquals = DefineLisp<LispType.MultiplyEquals, Lisp, Lisp>;\nexport type ModulusEquals = DefineLisp<LispType.ModulusEquals, Lisp, Lisp>;\nexport type BitNegateEquals = DefineLisp<LispType.BitNegateEquals, Lisp, Lisp>;\nexport type BitAndEquals = DefineLisp<LispType.BitAndEquals, Lisp, Lisp>;\nexport type BitOrEquals = DefineLisp<LispType.BitOrEquals, Lisp, Lisp>;\nexport type UnsignedShiftRightEquals = DefineLisp<LispType.UnsignedShiftRightEquals, Lisp, Lisp>;\nexport type ShiftLeftEquals = DefineLisp<LispType.ShiftLeftEquals, Lisp, Lisp>;\nexport type ShiftRightEquals = DefineLisp<LispType.ShiftRightEquals, Lisp, Lisp>;\n\nexport type BitAnd = DefineLisp<LispType.BitAnd, Lisp, Lisp>;\nexport type BitOr = DefineLisp<LispType.BitOr, Lisp, Lisp>;\nexport type BitNegate = DefineLisp<LispType.BitNegate, Lisp, Lisp>;\nexport type BitShiftLeft = DefineLisp<LispType.BitShiftLeft, Lisp, Lisp>;\nexport type BitShiftRight = DefineLisp<LispType.BitShiftRight, Lisp, Lisp>;\nexport type BitUnsignedShiftRight = DefineLisp<LispType.BitUnsignedShiftRight, Lisp, Lisp>;\nexport type SmallerEqualThan = DefineLisp<LispType.SmallerEqualThan, Lisp, Lisp>;\nexport type LargerEqualThan = DefineLisp<LispType.LargerEqualThan, Lisp, Lisp>;\nexport type SmallerThan = DefineLisp<LispType.SmallerThan, Lisp, Lisp>;\nexport type LargerThan = DefineLisp<LispType.LargerThan, Lisp, Lisp>;\nexport type StrictNotEqual = DefineLisp<LispType.StrictNotEqual, Lisp, Lisp>;\nexport type NotEqual = DefineLisp<LispType.NotEqual, Lisp, Lisp>;\nexport type StrictEqual = DefineLisp<LispType.StrictEqual, Lisp, Lisp>;\nexport type Equal = DefineLisp<LispType.Equal, Lisp, Lisp>;\nexport type Plus = DefineLisp<LispType.Plus, Lisp, Lisp>;\nexport type Minus = DefineLisp<LispType.Minus, Lisp, Lisp>;\nexport type Divide = DefineLisp<LispType.Divide, Lisp, Lisp>;\nexport type Power = DefineLisp<LispType.Power, Lisp, Lisp>;\nexport type Multiply = DefineLisp<LispType.Multiply, Lisp, Lisp>;\nexport type Modulus = DefineLisp<LispType.Modulus, Lisp, Lisp>;\n\nexport type Block = DefineLisp<LispType.Block, Lisp[], LispType.None>;\nexport type Expression = DefineLisp<LispType.Expression, Lisp[], LispType.None>;\nexport type Return = DefineLisp<LispType.Return, LispType.None, Lisp>;\nexport type Throw = DefineLisp<LispType.Throw, LispType.None, Lisp>;\nexport type Switch = DefineLisp<LispType.Switch, Lisp, SwitchCase[]>;\nexport type SwitchCase = DefineLisp<LispType.SwitchCase, LispType.None|Lisp, Lisp[]>;\nexport type Var = DefineLisp<LispType.Var, string, Lisp|LispType.None>;\nexport type Let = DefineLisp<LispType.Let, string, Lisp|LispType.None>;\nexport type Const = DefineLisp<LispType.Const, string, Lisp|LispType.None>;\n\nexport type Number = DefineLisp<LispType.Number, LispType.None, string>;\nexport type BigInt = DefineLisp<LispType.BigInt, LispType.None, string>;\nexport type GlobalSymbol = DefineLisp<LispType.GlobalSymbol, LispType.None, string>;\nexport type LiteralIndex = DefineLisp<LispType.LiteralIndex, LispType.None, string>;\nexport type StringIndex = DefineLisp<LispType.StringIndex, LispType.None, string>;\nexport type RegexIndex = DefineLisp<LispType.RegexIndex, LispType.None, string>;\n\nexport type Function = DefineLisp<LispType.Function, (string|LispType.None|LispType.True)[], string|Lisp[]>;\nexport type InlineFunction = DefineLisp<LispType.InlineFunction, string[], string|Lisp[]>;\nexport type ArrowFunction = DefineLisp<LispType.ArrowFunction, string[], string|Lisp[]>;\nexport type Loop = DefineLisp<LispType.Loop, LispItem, Lisp[]>;\nexport type LoopAction = DefineLisp<LispType.LoopAction, string, LispType.None>;\nexport type Try = DefineLisp<LispType.Try, Lisp[], LispItem>;\n\nexport type Void = DefineLisp<LispType.Void, Lisp, LispType.None>;\nexport type Await = DefineLisp<LispType.Await, Lisp, LispType.None>;\nexport type New = DefineLisp<LispType.New, Lisp, Lisp[]>;\nexport type None = DefineLisp<LispType.None, LispType.None, LispType.None>;\n\nexport type LispFamily = \n  Literal\n  |If\n  |InlineIf\n  |IfCase\n  |InlineIfCase\n  |KeyVal\n  |SpreadObject\n  |SpreadArray\n  |ArrayProp\n  |Prop\n  |PropOptional\n  |Call\n  |CallOptional\n  |CreateArray\n  |CreateObject\n  |Group\n  |Inverse\n  |Not\n  |Negative\n  |Positive\n  |Typeof\n  |Delete\n  |IncrementBefore\n  |IncrementAfter\n  |DecrementBefore\n  |DecrementAfter\n  |And\n  |Or\n  |Instanceof\n  |In\n  |Assigns\n  |SubractEquals\n  |AddEquals\n  |DivideEquals\n  |PowerEquals\n  |MultiplyEquals\n  |ModulusEquals\n  |BitNegateEquals\n  |BitAndEquals\n  |BitOrEquals\n  |UnsignedShiftRightEquals\n  |ShiftLeftEquals\n  |ShiftRightEquals\n  |BitAnd\n  |BitOr\n  |BitNegate\n  |BitShiftLeft\n  |BitShiftRight\n  |BitUnsignedShiftRight\n  |SmallerEqualThan\n  |LargerEqualThan\n  |SmallerThan\n  |LargerThan\n  |StrictNotEqual\n  |NotEqual\n  |StrictEqual\n  |Equal\n  |Plus\n  |Minus\n  |Divide\n  |Power\n  |Multiply\n  |Modulus\n  |Block\n  |Expression\n  |Return\n  |Throw\n  |Switch\n  |SwitchCase\n  |Var\n  |Let\n  |Const\n  |Number\n  |BigInt\n  |GlobalSymbol\n  |LiteralIndex\n  |StringIndex\n  |RegexIndex\n  |Function\n  |InlineFunction\n  |ArrowFunction\n  |Loop\n  |LoopAction\n  |Try\n  |Void\n  |Await\n  |New\n  |None;\n\nexport interface IRegEx {\n  regex: string,\n  flags: string,\n  length: number\n}\n\nexport interface IConstants {\n  strings: string[];\n  literals: Literal[];\n  regexes: IRegEx[];\n  eager: boolean;\n}\n\nexport interface IExecutionTree {\n  tree: Lisp[], \n  constants: IConstants\n}\n\ntype LispCallback<T> = (strings: IConstants, type: T, part: CodeString, res: string[], expect: string, ctx: {lispTree: Lisp}) => any\nlet lispTypes: Map<string, LispCallback<string>> = new Map();\n\nexport class ParseError extends Error {\n  constructor(message: string, public code: string) {\n    super(message + \": \" + code.substring(0, 40));\n  }\n}\n\nconst inlineIfElse =  /^:/;\nconst elseIf = /^else(?![\\w\\$])/\nconst ifElse = /^if(?![\\w\\$])/\nconst space = /^\\s/;\n\nexport const expectTypes = {\n  splitter: {\n    types: {\n      opHigh: /^(\\/|\\*\\*|\\*(?!\\*)|\\%)(?!\\=)/,\n      op: /^(\\+(?!(\\+))|\\-(?!(\\-)))(?!\\=)/,\n      comparitor: /^(<=|>=|<(?!<)|>(?!>)|!==|!=(?!\\=)|===|==)/,\n      boolOp: /^(&&|\\|\\||instanceof(?![\\w\\$])|in(?![\\w\\$]))/,\n      bitwise: /^(&(?!&)|\\|(?!\\|)|\\^|<<|>>(?!>)|>>>)(?!\\=)/,\n    },\n    next: [\n      'modifier',\n      'value', \n      'prop', \n      'incrementerBefore',\n    ]\n  },\n  inlineIf: {\n    types: {\n      inlineIf: /^\\?(?!\\.(?!\\d))/,\n    },\n    next: [\n      'expEnd'\n    ]\n  },\n  assignment: {\n    types: {\n      assignModify: /^(\\-=|\\+=|\\/=|\\*\\*=|\\*=|%=|\\^=|\\&=|\\|=|>>>=|>>=|<<=)/,\n      assign: /^(=)(?!=)/\n    },\n    next: [\n      'modifier',\n      'value', \n      'prop', \n      'incrementerBefore',\n    ]\n  },\n  incrementerBefore: {\n    types: {incrementerBefore: /^(\\+\\+|\\-\\-)/},\n    next: [\n      'prop',\n    ]\n  },\n  expEdge: {\n    types: {\n      call: /^(\\?\\.)?[\\(]/,\n      incrementerAfter: /^(\\+\\+|\\-\\-)/\n    },\n    next: [\n      'splitter',\n      'expEdge',\n      'dot',\n      'inlineIf',\n      'expEnd'\n    ]\n  },\n  modifier: {\n    types: {\n      not: /^!/,\n      inverse: /^~/,\n      negative: /^\\-(?!\\-)/,\n      positive: /^\\+(?!\\+)/,\n      typeof: /^typeof(?![\\w\\$])/,\n      delete: /^delete(?![\\w\\$])/,\n    },\n    next: [\n      'modifier', \n      'value',\n      'prop',\n      'incrementerBefore',\n    ]\n  },\n  dot: {\n    types: {\n      arrayProp: /^(\\?\\.)?\\[/,\n      dot: /^(\\?)?\\.(?=\\s*[a-zA-Z\\$\\_])/,\n    },\n    next: [\n      'splitter',\n      'assignment',\n      'expEdge',\n      'dot',\n      'inlineIf',\n      'expEnd'\n    ]\n  },\n  prop: {\n    types: {\n      prop: /^[a-zA-Z\\$\\_][a-zA-Z\\d\\$\\_]*/,\n    },\n    next: [\n      'splitter',\n      'assignment',\n      'expEdge',\n      'dot',\n      'inlineIf',\n      'expEnd'\n    ]\n  },\n  value: {\n    types: {\n      createObject: /^\\{/,\n      createArray: /^\\[/,\n      number: /^(0x[\\da-f]+(_[\\da-f]+)*|(\\d+(_\\d+)*(\\.\\d+(_\\d+)*)?|\\.\\d+(_\\d+)*))(e[\\+\\-]?\\d+(_\\d+)*)?(n)?(?!\\d)/i,\n      string: /^\"(\\d+)\"/,\n      literal: /^`(\\d+)`/,\n      regex: /^\\/(\\d+)\\/r(?![\\w\\$])/,\n      boolean: /^(true|false)(?![\\w\\$])/,\n      null: /^null(?![\\w\\$])/,\n      und: /^undefined(?![\\w\\$])/,\n      arrowFunctionSingle: /^(async\\s+)?([a-zA-Z\\$_][a-zA-Z\\d\\$_]*)\\s*=>\\s*({)?/,\n      arrowFunction: /^(async\\s*)?\\(\\s*((\\.\\.\\.)?\\s*[a-zA-Z\\$_][a-zA-Z\\d\\$_]*(\\s*,\\s*(\\.\\.\\.)?\\s*[a-zA-Z\\$_][a-zA-Z\\d\\$_]*)*)?\\s*\\)\\s*=>\\s*({)?/,\n      inlineFunction: /^(async\\s+)?function(\\s*[a-zA-Z\\$_][a-zA-Z\\d\\$_]*)?\\s*\\(\\s*((\\.\\.\\.)?\\s*[a-zA-Z\\$_][a-zA-Z\\d\\$_]*(\\s*,\\s*(\\.\\.\\.)?\\s*[a-zA-Z\\$_][a-zA-Z\\d\\$_]*)*)?\\s*\\)\\s*{/,\n      group: /^\\(/,\n      NaN: /^NaN(?![\\w\\$])/,\n      Infinity: /^Infinity(?![\\w\\$])/,\n      void: /^void(?![\\w\\$])\\s*/,\n      await: /^await(?![\\w\\$])\\s*/,\n      new: /^new(?![\\w\\$])\\s*/,\n    },\n    next: [\n      'splitter',\n      'expEdge',\n      'dot',\n      'inlineIf',\n      'expEnd'\n    ]\n  },\n  initialize: {\n    types: {\n      initialize: /^(var|let|const)\\s+([a-zA-Z\\$_][a-zA-Z\\d\\$_]*)\\s*(=)?/,\n      return: /^return(?![\\w\\$])/,\n      throw: /^throw(?![\\w\\$])\\s*/\n    },\n    next: [\n      'modifier',\n      'value', \n      'prop', \n      'incrementerBefore',\n      'expEnd'\n    ]\n  },\n  spreadObject: {\n    types: {\n      spreadObject: /^\\.\\.\\./\n    },\n    next: [\n      'value',\n      'prop', \n    ]\n  },\n  spreadArray: {\n    types: {\n      spreadArray: /^\\.\\.\\./\n    },\n    next: [\n      'value', \n      'prop', \n    ]\n  },\n  expEnd: {types: {}, next: []},\n  expFunction: {\n    types: {\n      function: /^(async\\s+)?function(\\s*[a-zA-Z\\$_][a-zA-Z\\d\\$_]*)\\s*\\(\\s*((\\.\\.\\.)?\\s*[a-zA-Z\\$_][a-zA-Z\\d\\$_]*(\\s*,\\s*(\\.\\.\\.)?\\s*[a-zA-Z\\$_][a-zA-Z\\d\\$_]*)*)?\\s*\\)\\s*{/,\n    },\n    next: [\n      'expEdge',\n      'expEnd'\n    ]\n  },\n  expSingle: {\n    types: {\n      for: /^(([a-zA-Z\\$\\_][\\w\\$]*)\\s*:)?\\s*for\\s*\\(/,\n      do: /^(([a-zA-Z\\$\\_][\\w\\$]*)\\s*:)?\\s*do(?![\\w\\$])\\s*(\\{)?/,\n      while: /^(([a-zA-Z\\$\\_][\\w\\$]*)\\s*:)?\\s*while\\s*\\(/,\n      loopAction: /^(break|continue)(?![\\w\\$])\\s*([a-zA-Z\\$\\_][\\w\\$]*)?/,\n      if: /^((([a-zA-Z\\$\\_][\\w\\$]*)\\s*:)?\\s*)if\\s*\\(/,\n      try: /^try\\s*{/,\n      block: /^{/,\n      switch: /^(([a-zA-Z\\$\\_][\\w\\$]*)\\s*:)?\\s*switch\\s*\\(/,\n    },\n    next: [\n      'expEnd'\n    ]\n  }\n} as Record<string, {types: Record<string, RegExp>, next: string[]}>;\n\nlet closings = {\n  \"(\": \")\",\n  \"[\": \"]\",\n  \"{\": \"}\",\n  \"'\": \"'\",\n  '\"': '\"',\n  \"`\": \"`\"\n} as Record<string, string>;\n\nexport function testMultiple(str: string, tests: RegExp[]) {\n  let found: RegExpExecArray|null = null;\n  for (let i = 0; i < tests.length; i++) {\n    const test = tests[i];\n    found = test.exec(str);\n    if (found) break;\n  }\n  return found;\n}\n\n\nconst emptyString = new CodeString(\"\")\n\nconst okFirstChars = /^[\\+\\-~ !]/;\nconst aChar = /^[\\w\\$]/\nconst aNumber = expectTypes.value.types.number;\nconst wordReg = /^((if|for|else|while|do|function)(?![\\w\\$])|[\\w\\$]+)/;\nconst semiColon = /^;/\nconst insertedSemicolons: WeakMap<{str: string}, Array<number>> = new WeakMap();\nconst quoteCache: WeakMap<{str: string}, Map<number, number>> = new WeakMap();\nexport interface restDetails {oneliner?: boolean, words?: string[], lastWord?: string, lastAnyWord?: string, regRes?: RegExpExecArray}\nexport function restOfExp(constants: IConstants, \n                          part: CodeString, \n                          tests?: RegExp[], \n                          quote?: string, \n                          firstOpening?: string, \n                          closingsTests?: RegExp[], \n                          details: restDetails = {}): CodeString {\n  if (!part.length) {\n    return part;\n  }\n  details.words = details.words || [];\n  let isStart = true;\n  tests = tests || [];\n  const hasSemiTest = tests.includes(semiColon);\n  if (hasSemiTest) {\n    tests = tests.filter((a) => a !== semiColon);\n  }\n  const insertedSemis = insertedSemicolons.get(part.ref) || [];\n  const cache = quoteCache.get(part.ref) || new Map<number, number>();\n  quoteCache.set(part.ref, cache);\n  if (quote && cache.has(part.start - 1)) {\n    return part.substring(0, cache.get(part.start - 1)! - part.start);\n  }\n  let escape = false;\n  let done = false;\n  let lastChar = \"\";\n  let isOneLiner = false;\n  let i;\n  let lastInertedSemi = false;\n  for (i = 0; i < part.length && !done; i++) {\n    let char = part.char(i)!;\n    if (quote === '\"' || quote === \"'\" || quote === \"`\") {\n      if (quote === \"`\" && char === \"$\" && part.char(i+1) === \"{\" && !escape) {\n        let skip = restOfExp(constants, part.substring(i+2), [], \"{\");\n        i += skip.length + 2;\n      } else if (char === quote && !escape) {\n        return part.substring(0, i);\n      }\n      escape = !escape && char === \"\\\\\";\n    } else if (closings[char]) {\n      if (!lastInertedSemi && insertedSemis[i + part.start]) {\n        lastInertedSemi = true\n        if (hasSemiTest) {\n          break;\n        }\n        i--;\n        lastChar = ';';\n        continue;\n      }\n      if (isOneLiner && char === \"{\") {\n        isOneLiner = false;\n      }\n      if (char === firstOpening) {\n        done = true;\n        break;\n      } else {\n        let skip = restOfExp(constants, part.substring(i+1), [], char);\n        cache.set(skip.start - 1, skip.end);\n        i += skip.length + 1;\n        isStart = false;\n        if (closingsTests) {\n          let sub = part.substring(i);\n          let found: RegExpExecArray|null;\n          if (found = testMultiple(sub.toString(), closingsTests)) {\n            details.regRes = found;\n            done = true;\n          }\n        }\n      }\n    } else if (!quote) {\n      let sub = part.substring(i).toString();\n      let foundWord: RegExpExecArray|null;\n      let foundNumber: RegExpExecArray|null;\n      if (closingsTests) {\n        let found: RegExpExecArray|null;\n        if (found = testMultiple(sub, closingsTests)) {\n          details.regRes = found;\n          i++;\n          done = true;\n          break;\n        }\n      }\n      if (foundNumber = aNumber.exec(sub)) {\n        i += foundNumber[0].length - 1;\n        sub = part.substring(i).toString();\n      } else if (lastChar != char) {\n        let found: [string]|RegExpExecArray|null = null;\n        if (char === ';' || (insertedSemis[i + part.start] && !isStart && !lastInertedSemi)) {\n          if (hasSemiTest) {\n            found = [\";\"];\n          } else if (insertedSemis[i + part.start]) {\n            lastInertedSemi = true\n            i--;\n            lastChar = ';';\n            continue;\n          }\n          char = sub = ';';\n        } else {\n          lastInertedSemi = false;\n        }\n        if (!found) {\n          found = testMultiple(sub, tests);\n        }\n        if (found) {\n          done = true;\n        }\n        if (!done && (foundWord = wordReg.exec(sub))) {\n          isOneLiner = true;\n          if (foundWord[0].length > 1) {\n            details.words.push(foundWord[1]);\n            details.lastAnyWord = foundWord[1];\n            if (foundWord[2]) {\n              details.lastWord = foundWord[2];\n            }\n          }\n          if(foundWord[0].length > 2) {\n            i += foundWord[0].length - 2;\n          }\n        }\n      }\n      if (isStart) {\n        if (okFirstChars.test(sub)) {\n          done = false;\n        } else {\n          isStart = false;\n        }\n      }\n      if (done) break;\n    } else if(char === closings[quote]) {\n      return part.substring(0, i);\n    }\n    lastChar = char;\n  }\n  if (quote) {\n    throw new SyntaxError(\"Unclosed '\" + quote + \"'\");\n  }\n  if (details) {\n    details.oneliner = isOneLiner;\n  }\n  return part.substring(0, i);\n}\nrestOfExp.next = [\n  'splitter',\n  'expEnd',\n  'inlineIf'\n];\n\nconst startingExecpted = ['initialize', 'expSingle', 'expFunction', 'value', 'modifier', 'prop', 'incrementerBefore', 'expEnd'];\n\nexport const setLispType = <T extends readonly string[]>(types: T, fn: LispCallback<T[number]>) => {\n  types.forEach((type) => {\n    lispTypes.set(type, fn);\n  })\n}\n\nconst closingsCreate: {[type:string]: RegExp} = {\n  'createArray': /^\\]/,\n  'createObject': /^\\}/,\n  'group': /^\\)/,\n  'arrayProp': /^\\]/,\n  'call': /^\\)/\n}\n\nconst typesCreate = {\n  'createArray': LispType.CreateArray,\n  'createObject': LispType.CreateObject,\n  'group': LispType.Group,\n  'arrayProp': LispType.ArrayProp,\n  'call': LispType.Call,\n  'prop': LispType.Prop,\n  '?prop': LispType.PropOptional,\n  '?call': LispType.CallOptional,\n} as any\n\nsetLispType(['createArray', 'createObject', 'group', 'arrayProp','call'] as const, (constants, type, part, res, expect, ctx) => {\n  let extract = emptyString;\n  let arg: CodeString[] = [];\n  let end = false;\n  let i = res[0].length;\n  const start = i;\n  while (i < part.length && !end) {\n    extract = restOfExp(constants, part.substring(i), [\n      closingsCreate[type],\n      /^,/\n    ]);\n    i += extract.length;\n    if (extract.trim().length) {\n      arg.push(extract);\n    }\n    if (part.char(i) !== ',') {\n      end = true;\n    } else {\n      i++;\n    }\n  }\n  const next = ['value', 'modifier', 'prop', 'incrementerBefore', 'expEnd'];\n  let l: Lisp|Lisp[];\n\n  let funcFound: RegExpExecArray|null;\n  switch(type) {\n    case 'group':\n    case 'arrayProp':\n      l = lispifyExpr(constants, part.substring(start, i));\n      break;\n    case 'call':\n    case 'createArray':\n      // @TODO: support 'empty' values\n      l = arg.map((e) => lispify(constants, e, [...next, 'spreadArray']));\n      break;\n    case 'createObject':\n      l = arg.map((str) => {\n        str = str.trimStart();\n        let value: Lisp;\n        let key: string|Lisp = '';\n        funcFound = expectTypes.expFunction.types.function.exec('function ' + str);\n        if (funcFound) {\n          key = funcFound[2].trimStart();\n          value = lispify(constants, new CodeString('function ' + str.toString().replace(key, \"\")));\n        } else {\n          let extract = restOfExp(constants, str, [/^:/]);\n          key = lispify(constants, extract, [...next, 'spreadObject']) as Prop;\n          if (key[0] === LispType.Prop) {\n            key = (key as Prop)[2];\n          }\n          value = lispify(constants, str.substring(extract.length + 1));\n        }\n        return createLisp<KeyVal>({\n          op: LispType.KeyVal,\n          a: key,\n          b: value\n        });\n      });\n      break;\n  }\n  let lisptype = (type === 'arrayProp' ? (res[1] ? LispType.PropOptional : LispType.Prop) : (type === 'call' ? (res[1] ? LispType.CallOptional : LispType.Call) : typesCreate[type])) as (typeof typesCreate)[keyof typeof typesCreate];\n  ctx.lispTree = lispify(constants, part.substring(i + 1), expectTypes[expect].next, createLisp<ArrayProp|Prop|Call|CreateObject|CreateArray|Group|PropOptional|CallOptional>({\n    op: lisptype, \n    a: ctx.lispTree, \n    b: l,\n  }));\n});\n\nconst modifierTypes = {\n  'inverse': LispType.Inverse,\n  'not': LispType.Not,\n  'positive': LispType.Positive,\n  'negative': LispType.Negative,\n  'typeof': LispType.Typeof,  \n  'delete': LispType.Delete\n} as const\n\nsetLispType(['inverse', 'not', 'negative', 'positive', 'typeof', 'delete'] as const, (constants, type, part, res, expect, ctx) => {\n  let extract = restOfExp(constants, part.substring(res[0].length), [/^([^\\s\\.\\?\\w\\$]|\\?[^\\.])/]);\n  ctx.lispTree = lispify(constants, part.substring(extract.length + res[0].length), restOfExp.next, createLisp<Inverse|Not|Negative|Positive|Typeof|Delete>({\n    op: modifierTypes[type],\n    a: ctx.lispTree, \n    b: lispify(constants, extract, expectTypes[expect].next), \n  }));\n});\n\nconst incrementTypes = {\n  '++$': LispType.IncrementBefore,\n  '--$': LispType.DecrementBefore,\n  '$++': LispType.IncrementAfter,\n  '$--': LispType.DecrementAfter\n} as any\n\nsetLispType(['incrementerBefore'] as const, (constants, type, part, res, expect, ctx) => {\n  let extract = restOfExp(constants, part.substring(2), [/^[^\\s\\.\\w\\$]/]);\n  ctx.lispTree = lispify(constants, part.substring(extract.length + 2), restOfExp.next, createLisp<IncrementBefore|DecrementBefore>({\n    op: incrementTypes[res[0] + \"$\"], \n    a: lispify(constants, extract, expectTypes[expect].next),\n    b: LispType.None\n  }));\n});\n\nsetLispType(['incrementerAfter'] as const, (constants, type, part, res, expect, ctx) => {\n  ctx.lispTree = lispify(constants, part.substring(res[0].length), expectTypes[expect].next, createLisp<IncrementAfter|DecrementAfter>({\n    op: incrementTypes[\"$\"  + res[0]], \n    a: ctx.lispTree, \n    b: LispType.None\n  }));\n});\n\nconst adderTypes = {\n  '&&': LispType.And,\n  '||': LispType.Or,\n  'instanceof': LispType.Instanceof,\n  'in': LispType.In,\n  '=': LispType.Assign,\n  '-=': LispType.SubractEquals,\n  '+=': LispType.AddEquals,\n  '/=': LispType.DivideEquals,\n  '**=': LispType.PowerEquals,\n  '*=': LispType.MultiplyEquals,\n  '%=': LispType.ModulusEquals,\n  '^=': LispType.BitNegateEquals,\n  '&=': LispType.BitAndEquals,\n  '|=': LispType.BitOrEquals,\n  '>>>=': LispType.UnsignedShiftRightEquals,\n  '<<=': LispType.ShiftLeftEquals,\n  '>>=': LispType.ShiftRightEquals,\n} as any;\n\nsetLispType(['assign', 'assignModify', 'boolOp'] as const, (constants, type, part, res, expect, ctx) => {\n  ctx.lispTree = createLisp<And|Or|Instanceof|In|Assigns|SubractEquals|AddEquals|DivideEquals|PowerEquals|MultiplyEquals|ModulusEquals|BitNegateEquals|BitAndEquals|BitOrEquals|UnsignedShiftRightEquals|ShiftLeftEquals|ShiftRightEquals>({\n    op: adderTypes[res[0]], \n    a: ctx.lispTree,\n    b: lispify(constants, part.substring(res[0].length), expectTypes[expect].next)\n  });\n});\n\nconst opTypes = {\n  '&': LispType.BitAnd,\n  '|': LispType.BitOr,\n  '^': LispType.BitNegate,\n  '<<': LispType.BitShiftLeft,\n  '>>': LispType.BitShiftRight,\n  '>>>': LispType.BitUnsignedShiftRight,\n  '<=': LispType.SmallerEqualThan,\n  '>=': LispType.LargerEqualThan,\n  '<': LispType.SmallerThan,\n  '>': LispType.LargerThan,\n  '!==': LispType.StrictNotEqual,\n  '!=': LispType.NotEqual,\n  '===': LispType.StrictEqual,\n  '==': LispType.Equal,\n  '+': LispType.Plus,\n  '-': LispType.Minus,\n  '/': LispType.Divide,\n  '**': LispType.Power,\n  '*': LispType.Multiply,\n  '%': LispType.Modulus,\n} as any\n\nsetLispType(['opHigh', 'op', 'comparitor', 'bitwise'] as const, (constants, type, part, res, expect, ctx) => {\n  const next = [\n    expectTypes.inlineIf.types.inlineIf,\n    inlineIfElse\n  ];\n  switch (type) {\n    case 'opHigh':\n      next.push(expectTypes.splitter.types.opHigh);\n    case 'op':\n      next.push(expectTypes.splitter.types.op);\n    case 'comparitor':\n      next.push(expectTypes.splitter.types.comparitor);\n    case 'bitwise':\n      next.push(expectTypes.splitter.types.bitwise);\n      next.push(expectTypes.splitter.types.boolOp);\n  }\n  let extract = restOfExp(constants, part.substring(res[0].length), next);\n  ctx.lispTree = lispify(constants, part.substring(extract.length + res[0].length), restOfExp.next, createLisp<BitAnd|BitOr|BitNegate|BitShiftLeft|BitShiftRight|BitUnsignedShiftRight|SmallerEqualThan|LargerEqualThan|SmallerThan|LargerThan|StrictNotEqual|NotEqual|StrictEqual|Equal|Plus|Minus|Divide|Power|Multiply|Modulus>  ({\n    op: opTypes[res[0]],\n    a: ctx.lispTree, \n    b: lispify(constants, extract, expectTypes[expect].next), \n  }));\n});\n\nsetLispType(['inlineIf'] as const, (constants, type, part, res, expect, ctx) => {\n  let found = false;\n  let extract = part.substring(0, 0);\n  let quoteCount = 1;\n  while(!found && extract.length < part.length) {\n    extract.end = restOfExp(constants, part.substring(extract.length + 1), [\n      expectTypes.inlineIf.types.inlineIf,\n      inlineIfElse\n    ]).end;\n    if (part.char(extract.length) === '?') {\n      quoteCount++\n    } else {\n      quoteCount--\n    }\n    if (!quoteCount) {\n      found = true;\n    }\n  }\n  extract.start = part.start + 1;\n  ctx.lispTree = createLisp<InlineIf>({\n    op: LispType.InlineIf,\n    a: ctx.lispTree, \n    b: createLisp<InlineIfCase>({\n      op: LispType.InlineIfCase,\n      a: lispifyExpr(constants, extract),\n      b: lispifyExpr(constants, part.substring(res[0].length + extract.length + 1))\n    })\n  });\n});\n\n\nfunction extractIfElse(constants: IConstants, part: CodeString) {\n  let count = 0;\n  let found = part.substring(0, 0);\n  let foundElse = emptyString;\n  let foundTrue: CodeString|undefined;\n  let first = true;\n  let elseReg: RegExpExecArray|null;\n  let details: restDetails = {}\n  while((found = restOfExp(constants, part.substring(found.end - part.start), [elseIf, ifElse, semiColon], undefined, undefined , undefined, details)).length || first) {\n    first = false;\n    const f = part.substring(found.end - part.start).toString();\n    \n    if (f.startsWith(\"if\")) {\n      found.end++;\n      count++;\n    } else if (f.startsWith('else')) {\n      foundTrue = part.substring(0, found.end - part.start);\n      found.end++;\n      count--;\n      if (!count) {\n        found.end--;\n      }\n    } else if (elseReg = /^;?\\s*else(?![\\w\\$])/.exec(f)) {\n      foundTrue = part.substring(0, found.end - part.start);\n      found.end += elseReg[0].length - 1;\n      count--;\n      if (!count) {\n        found.end -= elseReg[0].length - 1;\n      }\n    } else {\n      foundTrue = foundElse.length ? foundTrue : part.substring(0, found.end - part.start);\n      break;\n    }\n    if (!count) {\n      let ie = extractIfElse(constants, part.substring(found.end - part.start + (/^;?\\s*else(?![\\w\\$])/.exec(f)?.[0].length || 0)));\n      foundElse = ie.all;\n      break;\n    }\n    details = {};\n  }\n  foundTrue = foundTrue || part.substring(0, found.end - part.start);\n  return {all: part.substring(0, Math.max(foundTrue.end, foundElse.end) - part.start), true: foundTrue, false: foundElse};\n}\n\nsetLispType(['if'] as const, (constants, type, part, res, expect, ctx) => {\n  let condition = restOfExp(constants, part.substring(res[0].length), [], \"(\");\n  const ie = extractIfElse(constants, part.substring(res[1].length));\n  const isBlock = /^\\s*\\{/.exec(part.substring(res[0].length + condition.length + 1).toString());\n  const startTrue = res[0].length - res[1].length + condition.length + 1;\n  \n  let trueBlock = ie.true.substring(startTrue);\n  let elseBlock = ie.false;\n  \n  condition = condition.trim();\n  trueBlock = trueBlock.trim();\n  elseBlock = elseBlock.trim();\n\n  if (trueBlock.char(0) === \"{\") trueBlock = trueBlock.slice(1, -1);\n  if (elseBlock.char(0) === \"{\") elseBlock = elseBlock.slice(1, -1);\n  ctx.lispTree = createLisp<If>({\n    op: LispType.If,\n    a: lispifyExpr(constants, condition), \n    b: createLisp<IfCase>({\n      op: LispType.IfCase,\n      a: lispifyBlock(trueBlock, constants),\n      b: lispifyBlock(elseBlock, constants)\n    })\n  });\n});\n\nsetLispType(['switch'] as const, (constants, type, part, res, expect, ctx) => {\n  const test = restOfExp(constants, part.substring(res[0].length), [], \"(\");\n  let start = part.toString().indexOf(\"{\", res[0].length + test.length + 1);\n  if (start === -1) throw new SyntaxError(\"Invalid switch\");\n  let statement = insertSemicolons(constants, restOfExp(constants, part.substring(start + 1), [], \"{\"));\n  let caseFound: RegExpExecArray|null;\n  const caseTest = /^\\s*(case\\s|default)\\s*/;\n  let cases: SwitchCase[] = [];\n  let defaultFound = false;\n  while(caseFound = caseTest.exec(statement.toString())) {\n    if (caseFound[1] === 'default') {\n      if (defaultFound) throw new SyntaxError(\"Only one default switch case allowed\");\n      defaultFound = true;\n    }\n    let cond = restOfExp(constants, statement.substring(caseFound[0].length), [/^:/]);\n    let found = emptyString;\n    let i = start = caseFound[0].length + cond.length + 1;\n    let bracketFound = /^\\s*\\{/.exec(statement.substring(i).toString());\n    let exprs: Lisp[] = [];\n    if (bracketFound) {\n      i += bracketFound[0].length;\n      found = restOfExp(constants, statement.substring(i), [], \"{\");\n      i += found.length + 1;\n      exprs = lispifyBlock(found, constants);\n    } else {\n      let notEmpty = restOfExp(constants, statement.substring(i), [caseTest]);\n      if (!notEmpty.trim().length) {\n        exprs = [];\n        i += notEmpty.length;\n      } else {\n        while((found = restOfExp(constants, statement.substring(i), [semiColon])).length) {\n          i += found.length + (statement.char(i + found.length) === ';' ? 1 : 0);\n          if (caseTest.test(statement.substring(i).toString())) {\n            break;\n          }\n        }\n        exprs = lispifyBlock(statement.substring(start, found.end - statement.start), constants);\n      }\n    }\n    statement = statement.substring(i);\n    cases.push(createLisp<SwitchCase>({\n      op: LispType.SwitchCase,\n      a: caseFound[1] === \"default\" ? LispType.None : lispifyExpr(constants, cond),\n      b: exprs\n    }));\n  }\n  ctx.lispTree = createLisp<Switch>({\n    op: LispType.Switch,\n    a: lispifyExpr(constants, test),\n    b: cases\n  });\n});\n\nsetLispType(['dot', 'prop'] as const, (constants, type, part, res, expect, ctx) => {\n  let prop = res[0];\n  let index = res[0].length;\n  let op = 'prop';\n  if (type === 'dot') {\n    if (res[1]) {\n      op = '?prop';\n    }\n    let matches = part.substring(res[0].length).toString().match(expectTypes.prop.types.prop);\n    if (matches && matches.length) {\n      prop = matches[0];\n      index = prop.length + res[0].length\n    } else {\n      throw new SyntaxError('Hanging  dot');\n    }\n  }\n  ctx.lispTree = lispify(constants, part.substring(index), expectTypes[expect].next, createLisp<Prop|PropOptional>({\n    op: typesCreate[op], \n    a: ctx.lispTree, \n    b: prop\n  }));\n});\n\nsetLispType(['spreadArray', 'spreadObject'] as const, (constants, type, part, res, expect, ctx) => {\n  ctx.lispTree = createLisp<SpreadArray|SpreadObject>({\n    op: type === 'spreadArray' ? LispType.SpreadArray : LispType.SpreadObject,\n    a: LispType.None,\n    b: lispify(constants, part.substring(res[0].length), expectTypes[expect].next)\n  });\n});\n\nsetLispType(['return', 'throw'] as const, (constants, type, part, res, expect, ctx) => {\n  ctx.lispTree = createLisp<Return|Throw>({\n    op: type === 'return' ? LispType.Return : LispType.Throw,\n    a: LispType.None,\n    b: lispifyExpr(constants, part.substring(res[0].length))\n  });\n});\n\nsetLispType(['number', 'boolean', 'null', 'und', 'NaN', 'Infinity'] as const, (constants, type, part, res, expect, ctx) => {\n  ctx.lispTree = lispify(constants, part.substring(res[0].length), expectTypes[expect].next, createLisp<Number|BigInt|GlobalSymbol>({\n    op: type === \"number\" ? res[10] ? LispType.BigInt : LispType.Number : LispType.GlobalSymbol,\n    a: LispType.None,\n    b: res[10] ? res[1] : res[0]\n  }));\n});\n\nsetLispType(['string', 'literal', 'regex'] as const, (constants, type, part, res, expect, ctx) => {\n  ctx.lispTree = lispify(constants, part.substring(res[0].length), expectTypes[expect].next, createLisp<StringIndex|LiteralIndex|RegexIndex>({\n    op: type === 'string' ? LispType.StringIndex : type === 'literal' ? LispType.LiteralIndex : LispType.RegexIndex,\n    a: LispType.None,\n    b: res[1],\n  }));\n});\n\nsetLispType(['initialize'] as const, (constants, type, part, res, expect, ctx) => {\n  const lt = res[1] === 'var' ? LispType.Var : res[1] === 'let' ? LispType.Let : LispType.Const;\n  if (!res[3]) {\n    ctx.lispTree = lispify(constants, part.substring(res[0].length), expectTypes[expect].next, createLisp<Var|Let|Const>({\n      op: lt,\n      a: res[2],\n      b: LispType.None\n    }));\n  } else {\n    ctx.lispTree = createLisp<Var|Let|Const>({\n      op: lt,\n      a: res[2],\n      b: lispify(constants, part.substring(res[0].length), expectTypes[expect].next)\n    });\n  }\n});\n\nsetLispType(['function', 'inlineFunction', 'arrowFunction', 'arrowFunctionSingle'] as const, (constants, type, part, res, expect, ctx) => {\n  const isArrow = type !== 'function' && type !== 'inlineFunction';\n  const isReturn = isArrow && !res[res.length - 1];\n  const argPos = isArrow ? 2 : 3;\n  const isAsync = res[1] ? LispType.True : LispType.None;\n  const args: (string)[] = res[argPos] ? res[argPos].replace(/\\s+/g, \"\").split(/,/g) : [];\n  if (!isArrow) {\n    args.unshift((res[2] || \"\").trimStart());\n  }\n  let ended = false;\n  args.forEach((arg: string) => {\n    if (ended) throw new SyntaxError('Rest parameter must be last formal parameter');\n    if (arg.startsWith('...')) ended = true;\n  });\n  const f = restOfExp(constants, part.substring(res[0].length), !isReturn ? [/^}/] : [/^[,\\)\\}\\]]/, semiColon])\n  const func = (isReturn ? 'return ' + f : f.toString());\n  ctx.lispTree = lispify(constants, part.substring(res[0].length + func.length + 1), expectTypes[expect].next, createLisp<Function|InlineFunction|ArrowFunction>({\n    op: isArrow ? LispType.ArrowFunction : type === 'function' ? LispType.Function : LispType.InlineFunction,\n    a: [isAsync, ...args],\n    b: constants.eager ? lispifyFunction(new CodeString(func), constants) : func\n  }));\n});\n\nconst iteratorRegex = /^((let|var|const)\\s+)?\\s*([a-zA-Z\\$_][a-zA-Z\\d\\$_]*)\\s+(in|of)(?![\\w\\$])/\nsetLispType(['for', 'do', 'while'] as const, (constants, type, part, res, expect, ctx) => {\n  let i = 0;\n  let startStep: LispItem = LispType.True;\n  let startInternal: Lisp[] = [];\n  let getIterator: Lisp|LispType.None = LispType.None;\n  let beforeStep: LispItem = LispType.None;\n  let checkFirst = LispType.True;\n  let condition: LispItem;\n  let step: LispItem = LispType.True;\n  let body: CodeString;\n  switch (type) {\n    case 'while':\n      i = part.toString().indexOf(\"(\") + 1;\n      let extract = restOfExp(constants, part.substring(i), [], \"(\");\n      condition = lispifyReturnExpr(constants, extract);\n      body = restOfExp(constants, part.substring(i + extract.length + 1)).trim();\n      if (body.char(0) === \"{\") body = body.slice(1, -1);\n      break;\n    case 'for':\n      i = part.toString().indexOf(\"(\") + 1;\n      let args: CodeString[] = [];\n      let extract2 = emptyString;\n      for (let k = 0; k < 3; k++)  {\n        extract2 = restOfExp(constants, part.substring(i), [/^[;\\)]/]);\n        args.push(extract2.trim());\n        i += extract2.length + 1;\n        if (part.char(i - 1) === \")\") break;\n      }\n      let iterator: RegExpExecArray|null;\n      if (args.length === 1 && (iterator = iteratorRegex.exec(args[0].toString()))) {\n        if (iterator[4] === 'of') {\n          getIterator = lispifyReturnExpr(constants, args[0].substring(iterator[0].length)),\n          startInternal = [\n            ofStart2, \n            ofStart3\n          ];\n          condition = ofCondition;\n          step = ofStep;\n          beforeStep = lispify(constants, new CodeString((iterator[1] || 'let ') + iterator[3]  + ' = $$next.value'), ['initialize']);\n        } else {\n          getIterator = lispifyReturnExpr(constants, args[0].substring(iterator[0].length)),\n          startInternal = [\n            inStart2,\n            inStart3\n          ];\n          step = inStep;\n          condition = inCondition;\n          beforeStep = lispify(constants, new CodeString((iterator[1] || 'let ') + iterator[3] + ' = $$keys[$$keyIndex]'), ['initialize']);\n        }\n      } else if (args.length === 3) {\n        startStep = lispifyExpr(constants, args.shift()!, startingExecpted);\n        condition = lispifyReturnExpr(constants, args.shift()!);\n        step = lispifyExpr(constants, args.shift()!);\n      } else {\n        throw new SyntaxError(\"Invalid for loop definition\");\n      }\n      body = restOfExp(constants, part.substring(i)).trim();\n      if (body.char(0) === \"{\") body = body.slice(1, -1);\n\n      break;\n    case 'do':\n      checkFirst = LispType.None;\n      const isBlock = !!res[3];\n      body = restOfExp(constants, part.substring(res[0].length), isBlock ? [/^\\}/] : [semiColon]);\n      condition = lispifyReturnExpr(constants, restOfExp(constants, part.substring(part.toString().indexOf(\"(\", res[0].length + body.length) + 1), [], \"(\"));\n      break;\n  }\n  const a = [checkFirst, startInternal, getIterator, startStep, step, condition, beforeStep] as LispItem;\n  ctx.lispTree = createLisp<Loop>({\n    op: LispType.Loop,\n    a,\n    b: lispifyBlock(body, constants)\n  });\n});\n\nsetLispType(['block'] as const, (constants, type, part, res, expect, ctx) => {\n  ctx.lispTree = createLisp<Block>({\n    op: LispType.Block,\n    a: lispifyBlock(restOfExp(constants, part.substring(1), [], \"{\"), constants),\n    b: LispType.None\n  });\n});\n\nsetLispType(['loopAction'] as const, (constants, type, part, res, expect, ctx) => {\n  ctx.lispTree = createLisp<LoopAction>({\n    op: LispType.LoopAction,\n    a: res[1],\n    b: LispType.None\n  });\n});\n\nconst catchReg = /^\\s*(catch\\s*(\\(\\s*([a-zA-Z\\$_][a-zA-Z\\d\\$_]*)\\s*\\))?|finally)\\s*\\{/\nsetLispType(['try'] as const, (constants, type, part, res, expect, ctx) => {\n  const body = restOfExp(constants, part.substring(res[0].length), [], \"{\");\n  let catchRes = catchReg.exec(part.substring(res[0].length + body.length + 1).toString());\n  let finallyBody;\n  let exception = \"\";\n  let catchBody;\n  let offset = 0;\n  if (catchRes![1].startsWith('catch')) {\n    catchRes = catchReg.exec(part.substring(res[0].length + body.length + 1).toString());\n    exception = catchRes![2];\n    catchBody = restOfExp(constants, part.substring(res[0].length + body.length + 1 + catchRes![0].length), [], \"{\");\n    offset = res[0].length + body.length + 1 + catchRes![0].length + catchBody.length + 1;\n    if ((catchRes = catchReg.exec(part.substring(offset).toString())) && catchRes[1].startsWith('finally')) {\n      finallyBody = restOfExp(constants, part.substring(offset + catchRes[0].length), [], \"{\");\n    }\n  } else {\n    finallyBody = restOfExp(constants, part.substring(res[0].length + body.length + 1 + catchRes![0].length), [], \"{\");\n  }\n  const b = [\n    exception,\n    lispifyBlock(insertSemicolons(constants, catchBody || emptyString), constants),\n    lispifyBlock(insertSemicolons(constants, finallyBody || emptyString), constants),\n  ] as LispItem;\n  ctx.lispTree = createLisp<Try>({\n    op: LispType.Try,\n    a: lispifyBlock(insertSemicolons(constants, body), constants),\n    b\n  });\n});\n\nsetLispType(['void', 'await'] as const, (constants, type, part, res, expect, ctx) => {\n  const extract = restOfExp(constants, part.substring(res[0].length), [/^([^\\s\\.\\?\\w\\$]|\\?[^\\.])/]);\n  ctx.lispTree = lispify(constants, part.substring(res[0].length + extract.length), expectTypes[expect].next, createLisp<Void|Await>({\n    op: type === 'void' ? LispType.Void : LispType.Await,\n    a: lispify(constants, extract),\n    b: LispType.None\n  }));\n});\n\nsetLispType(['new'] as const, (constants, type, part, res, expect, ctx) => {\n  let i = res[0].length;\n  const obj = restOfExp(constants, part.substring(i), [], undefined, \"(\");\n  i += obj.length + 1;\n  const args: CodeString[] = [];\n  if (part.char(i - 1) === \"(\") {\n    const argsString = restOfExp(constants, part.substring(i), [], \"(\");\n    i += argsString.length + 1;\n    let found: CodeString;\n    let j = 0;\n    while((found = restOfExp(constants, argsString.substring(j), [/^,/])).length) {\n      j += found.length + 1;\n      args.push(found.trim());\n    }\n  }\n  ctx.lispTree = lispify(constants, part.substring(i), expectTypes.expEdge.next, createLisp({\n    op: LispType.New,\n    a: lispify(constants, obj, expectTypes.initialize.next),\n    b: args.map((arg) => lispify(constants, arg, expectTypes.initialize.next)),\n  }));\n});\n\nconst ofStart2 = lispify(undefined as any, new CodeString('let $$iterator = $$obj[Symbol.iterator]()'), ['initialize']);\nconst ofStart3 = lispify(undefined as any, new CodeString('let $$next = $$iterator.next()'), ['initialize']);\nconst ofCondition = lispify(undefined as any, new CodeString('return !$$next.done'), ['initialize']);\nconst ofStep = lispify(undefined as any, new CodeString('$$next = $$iterator.next()'));\nconst inStart2 = lispify(undefined as any, new CodeString('let $$keys = Object.keys($$obj)'), ['initialize']);\nconst inStart3 = lispify(undefined as any, new CodeString('let $$keyIndex = 0'), ['initialize']);\nconst inStep = lispify(undefined as any, new CodeString('$$keyIndex++'));\nconst inCondition = lispify(undefined as any, new CodeString('return $$keyIndex < $$keys.length'), ['initialize']);\n\nvar lastType: CodeString|string;\nvar lastPart: CodeString|string;\nvar lastLastPart: CodeString|string;\nvar lastLastLastPart: CodeString|string;\nvar lastLastLastLastPart: CodeString|string;\nfunction lispify(constants: IConstants, part: CodeString, expected?: readonly string[], lispTree?: Lisp, topLevel = false): Lisp {\n  lispTree = lispTree || NullLisp;\n  expected = expected || expectTypes.initialize.next;\n  if (part === undefined) return lispTree;\n\n  part = part.trimStart();\n  const str = part.toString();\n  if (!part.length && !expected.includes('expEnd')) {\n    throw new SyntaxError(\"Unexpected end of expression\");\n  }\n  if (!part.length) return lispTree;\n\n  let ctx = {lispTree: lispTree};\n\n  let res: any;\n  for (let expect of expected) {\n    if (expect === 'expEnd') {\n      continue;\n    }\n    for (let type in expectTypes[expect].types) {\n      if (type === 'expEnd') {\n        continue;\n      }\n      if(res = expectTypes[expect].types[type].exec(str)) {\n        lastType = type;\n        lastLastLastLastPart = lastLastLastPart;\n        lastLastLastPart = lastLastPart;\n        lastLastPart = lastPart;\n        lastPart = part;\n        try {\n          lispTypes.get(type)?.(constants, type, part, res, expect, ctx);\n        } catch(e) {\n          if (topLevel && e instanceof SyntaxError) {\n            throw new ParseError(e.message, str);\n          }\n          throw e;\n        }\n        break;\n      }\n    }\n    if (res) break;\n  }\n\n  if (!res && part.length) {\n    let msg = `Unexpected token after ${lastType}: ${part.char(0)}`;\n    if (topLevel) {\n      throw new ParseError(`Unexpected token after ${lastType}: ${part.char(0)}`, str);\n    }\n    throw new SyntaxError(`Unexpected token after ${lastType}: ${part.char(0)}`);\n  }\n  return ctx.lispTree;\n}\n\nconst startingExpectedWithoutSingle = startingExecpted.filter((r) => r !== 'expSingle');\n\nfunction lispifyExpr(constants: IConstants, str: CodeString, expected?: readonly string[]): Lisp {\n  if (!str.trimStart().length) return NullLisp;\n  let subExpressions: CodeString[] = [];\n  let sub: CodeString;\n  let pos = 0;\n  expected = expected || expectTypes.initialize.next;\n  if (expected.includes('expSingle')) {\n    if (testMultiple(str.toString(), Object.values(expectTypes.expSingle.types))) {\n      return lispify(constants, str, ['expSingle'], undefined, true);\n    }\n  }\n  if (expected === startingExecpted) expected = startingExpectedWithoutSingle;\n  while ((sub = restOfExp(constants, str.substring(pos), [/^,/])).length) {\n    subExpressions.push(sub.trimStart());\n    pos += sub.length + 1;\n  }\n  if (subExpressions.length === 1) {\n    return lispify(constants, str, expected, undefined, true);\n  }\n  if (expected.includes('initialize')) {\n    let defined = expectTypes.initialize.types.initialize.exec(subExpressions[0].toString());\n    if (defined) {\n      return createLisp<Block>({\n        op: LispType.Block,\n        a: subExpressions.map((str, i) => lispify(constants, i ? new CodeString(defined![1] + ' ' + str) : str, ['initialize'], undefined, true)),\n        b: LispType.None\n      });\n    } else if (expectTypes.initialize.types.return.exec(subExpressions[0].toString())) {\n      return lispify(constants, str, expected, undefined, true);\n    }\n  }\n  const exprs = subExpressions.map((str, i) => lispify(constants, str, expected, undefined, true));\n  return createLisp<Expression>({op: LispType.Expression, a: exprs, b: LispType.None});\n}\n\nexport function lispifyReturnExpr(constants: IConstants, str: CodeString) {\n  return createLisp<Return>({op: LispType.Return, a: LispType.None, b: lispifyExpr(constants, str)})\n}\n\nexport function lispifyBlock(str: CodeString, constants: IConstants, expression = false): Lisp[] {\n  str = insertSemicolons(constants, str);\n  if (!str.trim().length) return [];\n  let parts: CodeString[] = [];\n  let part: CodeString;\n  let pos = 0;\n  let start = 0;\n  let details: restDetails = {};\n  let skipped = false;\n  let isInserted = false;\n  while ((part = restOfExp(constants, str.substring(pos), [semiColon], undefined, undefined, undefined, details)).length) {\n    isInserted = !!(str.char(pos + part.length) && str.char(pos + part.length) !== ';');\n    pos += part.length + (isInserted ? 0 : 1);\n    if (/^\\s*else(?![\\w\\$])/.test(str.substring(pos).toString())) {\n      skipped = true;\n    } else if (details['words']?.includes('do') && /^\\s*while(?![\\w\\$])/.test(str.substring(pos).toString())) {\n      skipped = true;\n    } else {\n      skipped = false;\n      parts.push(str.substring(start, pos - (isInserted ? 0 : 1)));\n      start = pos;\n    }\n    details = {};\n    if (expression) break;\n  }\n  if (skipped) {\n    parts.push(str.substring(start, pos - (isInserted ? 0 : 1)));\n  }\n  return parts.map((str) => str.trimStart()).filter((str) => str.length).map((str, j) => {\n    return lispifyExpr(constants, str.trimStart(), startingExecpted);\n  });\n}\n\nexport function lispifyFunction(str: CodeString, constants: IConstants, expression = false): Lisp[] {\n  if (!str.trim().length) return [];\n  const tree = lispifyBlock(str, constants, expression);\n  let hoisted: Lisp[] = [];\n  hoist(tree, hoisted);\n  return hoisted.concat(tree);\n}\n\nfunction hoist(item: LispItem, res: Lisp[]): boolean {\n  if (isLisp(item)) {\n    if (!isLisp<LispFamily>(item)) return false;\n    const [op, a, b] = item;\n    if (op === LispType.Try || op === LispType.If || op === LispType.Loop || op === LispType.Switch) {\n      hoist(a, res);\n      hoist(b, res);\n    } else if (op === LispType.Var) {\n      res.push(createLisp({op: LispType.Var, a: a, b: LispType.None}));\n    } else if (op === LispType.Function && a[1]) {\n      res.push(item);\n      return true;\n    }\n  } else if (Array.isArray(item)) {\n    const rep: LispItemSingle[] = [];\n    for (let it of item) {\n      if (!hoist(it, res)) {\n        rep.push(it);\n      }\n    }\n    if (rep.length !== item.length) {\n      item.length = 0;\n      item.push(...rep);\n    }\n  }\n  return false;\n}\n\nconst closingsNoInsertion = /^(\\})\\s*(catch|finally|else|while|instanceof)(?![\\w\\$])/\n                    //  \\w|)|] \\n \\w = 2                                  // \\} \\w|\\{ = 5 \nconst colonsRegex = /^((([\\w\\$\\]\\)\\\"\\'\\`]|\\+\\+|\\-\\-)\\s*\\r?\\n\\s*([\\w\\$\\+\\-\\!~]))|(\\}\\s*[\\w\\$\\!~\\+\\-\\{\\(\\\"\\'\\`]))/\n\n// if () \\w \\n; \\w              == \\w \\n \\w    | last === if             a\n// if () { }; \\w                == \\} ^else    | last === if             b\n// if () \\w \\n; else \\n \\w \\n;  == \\w \\n \\w    | last === else           a\n// if () {} else {}; \\w         == \\} \\w       | last === else           b\n// while () \\n \\w \\n; \\w        == \\w \\n \\w    | last === while          a\n// while () { }; \\w             == \\} \\w       | last === while          b\n// do \\w \\n; while (); \\w       == \\w \\n while | last === do             a\n// do { } while (); \\w          == \\) \\w       | last === while          c\n// try {} catch () {}; \\w       == \\} \\w       | last === catch|finally  b\n// \\w \\n; \\w                    == \\w \\n \\w    | last === none           a\n// cb() \\n \\w                   == \\) \\n \\w    | last === none           a\n// obj[a] \\n \\w                 == \\] \\n \\w    | last === none           a\n// {} {}                        == \\} \\{       | last === none           b\n\nexport function insertSemicolons(constants: IConstants, str: CodeString): CodeString {\n  let rest = str;\n  let sub = emptyString;\n  let details: restDetails = {};\n  const inserted = insertedSemicolons.get(str.ref) || new Array(str.ref.str.length);\n  while ((sub = restOfExp(constants, rest, [], undefined, undefined, [colonsRegex], details)).length) {\n    let valid = false;\n    let part = sub;\n    let edge = sub.length;\n    if (details.regRes) {\n      valid = true;\n      const [,, a,,, b] = details.regRes;\n      edge = details.regRes[3] === \"++\" || details.regRes[3] === \"--\" ? sub.length + 1 : sub.length;\n      part = rest.substring(0,  edge);\n      if (b) {\n        let res = closingsNoInsertion.exec(rest.substring(sub.length - 1).toString());\n        if (res) {\n          if (res[2] === 'while') {\n            valid = details.lastWord !== 'do';\n          } else {\n            valid = false;\n          }\n        } else if (details.lastWord === 'function' && details.regRes[5][0] === \"}\" && details.regRes[5].slice(-1) === '(') {\n          valid = false;\n        } \n\n      } else if (a) {\n        if (details.lastWord === 'if' || details.lastWord === 'while' || details.lastWord === 'for' || details.lastWord === 'else') {\n          valid = false;\n        }\n      }\n    }\n    if (valid) {\n      inserted[part.end] = true;\n    }\n    rest = rest.substring(edge);\n    details = {};\n  }\n  insertedSemicolons.set(str.ref, inserted);\n  return str;\n}\n\nexport function checkRegex(str: string): IRegEx | null {\n  let i = 1;\n  let escape = false;\n  let done = false;\n  let cancel = false;\n  while (i < str.length && !done && !cancel) {\n    done = (str[i] === '/' && !escape);\n    escape = str[i] === '\\\\' && !escape;\n    cancel = str[i] === '\\n';\n    i++;\n  }\n  let after = str.substring(i);\n  cancel = (cancel || !done) || /^\\s*\\d/.test(after);\n  if (cancel) return null;\n  let flags = /^[a-z]*/.exec(after);\n  if(/^\\s+[\\w\\$]/.test(str.substring(i + flags![0].length))) {\n    return null;\n  }\n  return {\n    regex: str.substring(1, i-1),\n    flags: (flags && flags[0]) || \"\",\n    length: i + ((flags && flags[0].length) || 0)\n  }\n}\n\nconst notDivide = /(typeof|delete|instanceof|return|in|of|throw|new|void|do|if)$/\nconst possibleDivide = /^([\\w\\$\\]\\)]|\\+\\+|\\-\\-)[\\s\\/]/;\nexport function extractConstants(constants: IConstants, str: string, currentEnclosure = \"\"): {str: string, length: number} {\n  let quote;\n  let extract: (string|number)[] = [];\n  let escape = false;\n  let regexFound: IRegEx|null;\n  let comment = \"\";\n  let commentStart = -1;\n  let currJs: string[] = [];\n  let char: string = \"\";\n  const strRes: (string|number)[] = [];\n  const enclosures: string[] = [];\n  let isPossibleDivide: RegExpExecArray|null = null;\n  for (var i = 0; i < str.length; i++) {\n    char = str[i];\n    if (comment) {\n      if (char === comment) {\n        if (comment === \"*\" && str[i + 1] ===\"/\") {\n          comment = \"\";\n          i++\n        } else if (comment === \"\\n\") {\n          comment = \"\";\n        }\n      }\n    } else {\n      if (escape) {\n        escape = false;\n        extract.push(char);\n        continue;\n      }\n\n      if (quote) {\n        if (quote === \"`\" && char === \"$\" && str[i+1] === \"{\") {\n          let skip = extractConstants(constants, str.substring(i+2), \"{\");\n          currJs.push(skip.str);\n          extract.push('${', currJs.length - 1, `}`);\n          i += skip.length + 2;\n        } else if (quote === char) {\n          if (quote === '`') {\n            const li = createLisp<Literal>({\n              op: LispType.Literal,\n              a:  unraw(extract.join(\"\")),\n              b: [],\n            });\n            li.tempJsStrings = currJs\n            constants.literals.push(li);\n            strRes.push(`\\``, constants.literals.length - 1, `\\``);\n          } else {\n            constants.strings.push(unraw(extract.join(\"\")));\n            strRes.push(`\"`, constants.strings.length - 1, `\"`);\n          }\n          quote = null;\n          extract = [];\n        } else {\n          extract.push(char);\n        }\n      } else {\n        if ((char === \"'\"  || char === '\"'  || char === '`')) {\n          currJs = [];\n          quote = char;\n        } else if (closings[currentEnclosure] === char && !enclosures.length) {\n          return {str: strRes.join(\"\"), length: i}\n        } else if (closings[char]) {\n          enclosures.push(char);\n          strRes.push(char);\n        } else if (closings[enclosures[enclosures.length-1]] === char) {\n          enclosures.pop();\n          strRes.push(char);\n        } else if (char === \"/\" && (str[i+1] === \"*\" || str[i+1] === \"/\")) {\n          comment = str[i+1] === \"*\" ? \"*\" : \"\\n\";\n          commentStart = i;\n        } else if (char === '/' && !isPossibleDivide && (regexFound = checkRegex(str.substring(i)))) {\n          constants.regexes.push(regexFound);\n          strRes.push(`/`, constants.regexes.length - 1, `/r`);\n          i += regexFound.length - 1;\n        } else {\n          strRes.push(char);\n        }\n\n        if (!isPossibleDivide || !space.test(char)) {\n          if (isPossibleDivide = possibleDivide.exec(str.substring(i))) {\n            if (notDivide.test(str.substring(0, i + isPossibleDivide[1].length))) {\n              isPossibleDivide = null;\n            }\n          }\n        }\n      }\n      escape = !!(quote && char === \"\\\\\");\n    }\n  }\n\n  if (comment) {\n    if (comment === \"*\") {\n      throw new SyntaxError(`Unclosed comment '/*': ${str.substring(commentStart)}`)\n    }\n  }\n  return {str: strRes.join(\"\"), length: i}\n}\n\nexport default function parse(code: string, eager = false, expression = false): IExecutionTree {\n  if (typeof code !== 'string') throw new ParseError(`Cannot parse ${code}`, code);\n  let str = ' ' + code;\n  const constants: IConstants = {strings: [], literals: [], regexes: [], eager};\n  str = extractConstants(constants, str).str;\n\n  for (let l of constants.literals) {\n    l[2] = l.tempJsStrings!.map((js: string) => lispifyExpr(constants, new CodeString(js)));\n    delete l.tempJsStrings;\n  }\n  return {tree: lispifyFunction(new CodeString(str), constants, expression), constants};\n}\n","import { createFunction, currentTicks } from \"./executor.js\";\nimport parse, { lispifyFunction } from \"./parser.js\";\nimport { IExecContext, Ticks } from \"./utils.js\";\n\nexport interface IEvalContext {\n  sandboxFunction: typeof sandboxFunction\n  sandboxedEval: typeof sandboxedEval\n  sandboxedSetTimeout: typeof sandboxedSetTimeout\n  sandboxedSetInterval: typeof sandboxedSetInterval,\n  lispifyFunction: typeof lispifyFunction\n}\nexport type SandboxFunction = (code: string, ...args: string[]) => () => unknown;\nexport type SandboxEval = (code: string) => unknown;\nexport type SandboxSetTimeout = (handler: TimerHandler, timeout?: number, ...args: unknown[]) => any;\nexport type SandboxSetInterval = (handler: TimerHandler, timeout?: number, ...args: unknown[]) => any;\n\nexport function createEvalContext(): IEvalContext {\n  return {\n    sandboxFunction,\n    sandboxedEval,\n    sandboxedSetTimeout,\n    sandboxedSetInterval,\n    lispifyFunction\n  }\n}\n\nexport function sandboxFunction(context: IExecContext, ticks?: Ticks): SandboxFunction {\n  return SandboxFunction;\n  function SandboxFunction(...params: string[]) {\n    let code = params.pop() || \"\";\n    let parsed = parse(code);\n    return createFunction(params, parsed.tree, ticks || currentTicks.current, {\n      ...context,\n      constants: parsed.constants,\n      tree: parsed.tree\n    }, undefined, 'anonymous');\n  }\n}\n\nexport function sandboxedEval(func: SandboxFunction): SandboxEval {\n  return sandboxEval;\n  function sandboxEval(code: string) {\n    return func(code)();\n  }\n}\n\nexport function sandboxedSetTimeout(func: SandboxFunction): SandboxSetTimeout {\n  return function sandboxSetTimeout(handler, ...args) {\n    if (typeof handler !== 'string') return setTimeout(handler, ...args);\n    return setTimeout(func(handler), ...args);\n  }\n}\n\nexport function sandboxedSetInterval(func: SandboxFunction): SandboxSetInterval {\n  return function sandboxSetInterval(handler, ...args) {\n    if (typeof handler !== 'string') return setInterval(handler, ...args);\n    return setInterval(func(handler), ...args);\n  }\n}","import { IEvalContext } from \"./eval.js\";\nimport { \n  Change, \n  ExecReturn,\n  executeTree,\n  executeTreeAsync,\n} from \"./executor.js\";\nimport { createContext, IContext, IExecContext, IGlobals, IOptionParams, IOptions, IScope, replacementCallback, SandboxGlobal, SubscriptionSubject } from \"./utils.js\";\n\nfunction subscribeSet(obj: unknown, name: string, callback: (modification: Change) => void, context: {\n  setSubscriptions: WeakMap<SubscriptionSubject, Map<string, Set<(modification: Change) => void>>>, \n  changeSubscriptions: WeakMap<SubscriptionSubject, Set<(modification: Change) => void>>\n}): {unsubscribe: () => void} {\n  if (!(obj instanceof Object)) throw new Error('Invalid subscription object, got ' + (typeof obj === 'object' ? 'null' : typeof obj))\n  const names = context.setSubscriptions.get(obj) || new Map<string, Set<(modification: Change) => void>>();\n  context.setSubscriptions.set(obj, names);\n  const callbacks = names.get(name) || new Set();\n  names.set(name, callbacks);\n  callbacks.add(callback);\n  let changeCbs: Set<(modification: Change) => void>;\n  const val = (obj as any)[name] as unknown;\n  if (val instanceof Object) {\n    changeCbs = context.changeSubscriptions.get(val) || new Set();\n    changeCbs.add(callback);\n    context.changeSubscriptions.set(val, changeCbs);\n  }\n  return {\n    unsubscribe: () => {\n      callbacks.delete(callback);\n      changeCbs?.delete(callback);\n    }\n  }\n}\n\nexport default class SandboxExec {\n  context: IContext;\n  setSubscriptions: WeakMap<SubscriptionSubject, Map<string, Set<(modification: Change) => void>>> = new WeakMap();\n  changeSubscriptions: WeakMap<SubscriptionSubject, Set<(modification: Change) => void>> = new WeakMap();\n  sandboxFunctions: WeakMap<(...args: any[]) => any, IExecContext> = new WeakMap();\n  constructor(options?: IOptionParams, public evalContext?: IEvalContext) {\n    const opt: IOptions = Object.assign({\n      audit: false,\n      forbidFunctionCalls: false,\n      forbidFunctionCreation: false,\n      globals: SandboxExec.SAFE_GLOBALS,\n      prototypeWhitelist: SandboxExec.SAFE_PROTOTYPES, \n      prototypeReplacements: new Map<new() => any, replacementCallback>(),\n    }, options || {});\n    this.context = createContext(this, opt, evalContext)\n  }\n\n  static get SAFE_GLOBALS(): IGlobals {\n    return {\n      Function,\n      console: {\n        debug: console.debug, \n        error: console.error, \n        info: console.info, \n        log: console.log, \n        table: console.table, \n        warn: console.warn\n      },\n      isFinite,\n      isNaN,\n      parseFloat,\n      parseInt,\n      decodeURI,\n      decodeURIComponent,\n      encodeURI,\n      encodeURIComponent,\n      escape,\n      unescape,\n      Boolean,\n      Number,\n      BigInt,\n      String,\n      Object,\n      Array,\n      Symbol,\n      Error,\n      EvalError,\n      RangeError,\n      ReferenceError,\n      SyntaxError,\n      TypeError,\n      URIError,\n      Int8Array,\n      Uint8Array,\n      Uint8ClampedArray,\n      Int16Array,\n      Uint16Array,\n      Int32Array,\n      Uint32Array,\n      Float32Array,\n      Float64Array,\n      Map,\n      Set,\n      WeakMap,\n      WeakSet,\n      Promise,\n      Intl,\n      JSON,\n      Math,\n      Date,\n      RegExp\n    }\n  }\n\n  \n  static get SAFE_PROTOTYPES(): Map<any, Set<string>> {\n    let protos = [\n      SandboxGlobal,\n      Function,\n      Boolean,\n      Number,\n      BigInt,\n      String,\n      Date,\n      Error,\n      Array,\n      Int8Array,\n      Uint8Array,\n      Uint8ClampedArray,\n      Int16Array,\n      Uint16Array,\n      Int32Array,\n      Uint32Array,\n      Float32Array,\n      Float64Array,\n      Map,\n      Set,\n      WeakMap,\n      WeakSet,\n      Promise,\n      Symbol,\n      Date,\n      RegExp\n    ]\n    let map = new Map<any, Set<string>>();\n    protos.forEach((proto) => {\n      map.set(proto, new Set());\n    });\n    map.set(Object, new Set([\n      'entries',\n      'fromEntries',\n      'getOwnPropertyNames',\n      'is',\n      'keys',\n      'hasOwnProperty',\n      'isPrototypeOf',\n      'propertyIsEnumerable',\n      'toLocaleString',\n      'toString',\n      'valueOf',\n      'values'\n    ]));\n    return map;\n  }\n\n  subscribeGet(callback: (obj: SubscriptionSubject, name: string) => void, context: IExecContext): {unsubscribe: () => void} {\n    context.getSubscriptions.add(callback);\n    return {unsubscribe: () => context.getSubscriptions.delete(callback)}\n  }\n\n  subscribeSet(obj: object, name: string, callback: (modification: Change) => void, context: SandboxExec|IExecContext): {unsubscribe: () => void} {\n    return subscribeSet(obj, name, callback, context);\n  }\n\n  subscribeSetGlobal(obj: SubscriptionSubject, name: string, callback: (modification: Change) => void): {unsubscribe: () => void} {\n    return subscribeSet(obj, name, callback, this);\n  }\n\n  getContext(fn: (...args: any[]) => any) {\n    return this.sandboxFunctions.get(fn);\n  }\n\n  executeTree<T>(context: IExecContext, scopes: (IScope)[] = []): ExecReturn<T> {\n    return executeTree({\n      ticks: BigInt(0),\n    }, context, context.tree, scopes);\n  }\n\n  executeTreeAsync<T>(context: IExecContext, scopes: (IScope)[] = []): Promise<ExecReturn<T>> {\n    return executeTreeAsync({\n      ticks: BigInt(0),\n    }, context, context.tree, scopes);\n  }\n}\n","import { createExecContext, IExecContext, IOptionParams, IScope } from \"./utils.js\";\nimport { createEvalContext } from \"./eval.js\";\nimport { ExecReturn } from \"./executor.js\";\nimport parse from \"./parser.js\";\nimport SandboxExec from \"./SandboxExec.js\";\n\nexport default class Sandbox extends SandboxExec {\n  constructor(options?: IOptionParams) {\n    super(options, createEvalContext());\n  }\n\n  static audit<T>(code: string, scopes: (IScope)[] = []): ExecReturn<T> {\n    const globals: Record<string, unknown> = {};\n    for (let i of Object.getOwnPropertyNames(globalThis) as [keyof typeof globalThis]) {\n      globals[i] = globalThis[i];\n    }\n    const sandbox = new SandboxExec({\n      globals,\n      audit: true,\n    });\n    return sandbox.executeTree(createExecContext(sandbox, parse(code, true), createEvalContext()), scopes);\n  }\n\n  static parse(code: string) {\n    return parse(code);\n  }\n  \n  compile<T>(code: string, optimize = false): (...scopes: (IScope)[]) => {context: IExecContext, run: () => T} {\n    const parsed = parse(code, optimize);\n    const exec = (...scopes: (IScope)[]) => {\n      const context = createExecContext(this, parsed, this.evalContext);\n      return {context , run: () => this.executeTree<T>(context, [...scopes]).result};\n    };\n    return exec;\n  };\n  \n  compileAsync<T>(code: string, optimize = false): (...scopes: (IScope)[]) => {context: IExecContext, run: () => Promise<T>} {\n    const parsed = parse(code, optimize);\n    const exec = (...scopes: (IScope)[]) => {\n      const context = createExecContext(this, parsed, this.evalContext);\n      return {context , run: () => this.executeTreeAsync<T>(context, [...scopes]).then((ret) => ret.result)};\n    };\n    return exec;\n  };\n\n  compileExpression<T>(code: string, optimize = false): (...scopes: (IScope)[]) => {context: IExecContext, run: () => T} {\n    const parsed = parse(code, optimize, true);\n    const exec = (...scopes: (IScope)[]) => {\n      const context = createExecContext(this, parsed, this.evalContext);\n      return {context , run: () => this.executeTree<T>(context, [...scopes]).result};\n    };\n    return exec\n  }\n\n  compileExpressionAsync<T>(code: string, optimize = false): (...scopes: (IScope)[]) => {context: IExecContext, run: () => Promise<T>} {\n    const parsed = parse(code, optimize, true);\n    const exec = (...scopes: (IScope)[]) => {\n      const context = createExecContext(this, parsed, this.evalContext);\n      return {context , run: () => this.executeTreeAsync<T>(context, [...scopes]).then((ret) => ret.result)};\n    };\n    return exec;\n  }\n}"],"names":["SandboxGlobal","globals","globalThis","i","this","ExecContext","constructor","ctx","constants","tree","getSubscriptions","setSubscriptions","changeSubscriptions","setSubscriptionsGlobal","changeSubscriptionsGlobal","evals","registerSandboxFunction","allowJit","evalContext","createContext","sandbox","options","sandboxGlobal","context","globalsWhitelist","Set","Object","values","prototypeWhitelist","Map","map","a","prototype","globalScope","Scope","set","getPrototypeOf","Symbol","iterator","createExecContext","executionTree","execContext","WeakMap","fn","sandboxFunctions","func","sandboxFunction","Function","eval","sandboxedEval","setTimeout","sandboxedSetTimeout","setInterval","sandboxedSetInterval","CodeString","str","ref","start","end","length","substring","undefined","code","len","char","toString","trimStart","found","exec","slice","trim","valueOf","keysOnly","obj","ret","assign","key","reservedWords","parent","vars","functionThis","const","let","var","isFuncScope","allVars","get","functionScope","Prop","has","SyntaxError","hasOwnProperty","val","prop","ReferenceError","isConst","TypeError","isGlobal","SandboxError","declare","type","value","LocalScope","Error","isLisp","item","Array","isArray","isVariable","forEach","cb","ExecReturn","auditReport","result","returned","breakLoop","continueLoop","optional","generateArgs","argNames","args","arg","startsWith","sandboxedFunctions","WeakSet","createFunction","parsed","ticks","scope","name","forbidFunctionCreation","executeTree","add","createFunctionAsync","Promise","async","executeTreeAsync","assignCheck","op","arrayChange","push","pop","shift","unshift","splice","reverse","sort","copyWithin","KeyVal","SpreadObject","SpreadArray","If","t","f","literalRegex","ops","addOps","valueOrProp","execMany","done","inLoopOrSwitch","execSync","_execManySync","_execManyAsync","catch","res","syncDone","d","e","ad","asyncDone","execAsync","isInstant","instant","p","callback","resolve","reject","err","r","doneOriginal","_execNoneRecurse","bobj","b","audit","globalsAccess","rep","Number","String","Boolean","isFunction","prototypeAccess","prot","includes","whitelist","replace","prototypeReplacements","size","constuctor","g","forbidFunctionCalls","vals","flat","JSON","stringify","cache","recurse","x","y","keys","change","changed","added","removed","startIndex","deleteCount","Math","min","endIndex","NaN","Infinity","BigInt","strings","parseInt","reg","regexes","RegExp","regex","flags","literals","js","resnums","processed","reses","num","match","$$","$","lispifyFunction","isAsync","checkFirst","startInternal","getIterator","startStep","step","condition","beforeStep","loop","loopScope","internalVars","$$obj","interalScope","innerLoopVars","toTest","isTrue","caseItem","exception","catchBody","finallyBody","executeTreeWithDone","unexecTypes","currentTicks","current","executionQuota","onExecutionQuotaReached","scopes","s","_executeWithDoneSync","_executeWithDoneAsync","parseHexToInt","hex","validateAndParseHex","errorName","enforcedLength","parsedHex","isNaN","parseHexadecimalCode","parsedCode","fromCharCode","parseUnicodeCode","surrogateCode","parsedSurrogateCode","isCurlyBraced","text","charAt","parseUnicodeCodePointCode","codePoint","fromCodePoint","RangeError","singleCharacterEscapes","parseSingleCharacterCode","escapeMatch","unraw","raw","_","backslash","unicodeWithSurrogate","surrogate","unicode","octal","singleCharacter","createLisp","NullLisp","lispTypes","ParseError","message","super","inlineIfElse","elseIf","ifElse","space","expectTypes","splitter","types","opHigh","comparitor","boolOp","bitwise","next","inlineIf","assignment","assignModify","incrementerBefore","expEdge","call","incrementerAfter","modifier","not","inverse","negative","positive","typeof","delete","dot","arrayProp","createObject","createArray","number","string","literal","boolean","null","und","arrowFunctionSingle","arrowFunction","inlineFunction","group","void","await","new","initialize","return","throw","spreadObject","spreadArray","expEnd","expFunction","function","expSingle","for","do","while","loopAction","if","try","block","switch","closings","testMultiple","tests","emptyString","okFirstChars","aNumber","wordReg","semiColon","insertedSemicolons","quoteCache","restOfExp","part","quote","firstOpening","closingsTests","details","words","isStart","hasSemiTest","filter","insertedSemis","escape","lastChar","isOneLiner","lastInertedSemi","skip","regRes","foundWord","foundNumber","sub","lastAnyWord","lastWord","test","oneliner","startingExecpted","setLispType","closingsCreate","typesCreate","expect","extract","l","funcFound","lispifyExpr","lispify","lisptype","lispTree","modifierTypes","incrementTypes","adderTypes","instanceof","in","opTypes","extractIfElse","foundTrue","elseReg","count","foundElse","first","all","max","true","false","quoteCount","ie","startTrue","trueBlock","elseBlock","lispifyBlock","indexOf","caseFound","statement","insertSemicolons","caseTest","cases","defaultFound","cond","bracketFound","exprs","notEmpty","index","matches","lt","isArrow","isReturn","argPos","split","ended","eager","iteratorRegex","body","lispifyReturnExpr","extract2","k","ofStart2","ofStart3","ofCondition","ofStep","inStart2","inStart3","inStep","inCondition","isBlock","catchReg","catchRes","offset","argsString","j","lastType","expected","topLevel","startingExpectedWithoutSingle","subExpressions","pos","defined","expression","parts","skipped","isInserted","hoisted","hoist","concat","it","closingsNoInsertion","colonsRegex","rest","inserted","valid","edge","checkRegex","cancel","after","notDivide","possibleDivide","extractConstants","currentEnclosure","regexFound","comment","commentStart","currJs","strRes","enclosures","isPossibleDivide","li","join","tempJsStrings","parse","createEvalContext","SandboxFunction","params","handler","subscribeSet","names","callbacks","changeCbs","unsubscribe","SandboxExec","opt","SAFE_GLOBALS","SAFE_PROTOTYPES","console","debug","error","info","log","table","warn","isFinite","parseFloat","decodeURI","decodeURIComponent","encodeURI","encodeURIComponent","unescape","EvalError","URIError","Int8Array","Uint8Array","Uint8ClampedArray","Int16Array","Uint16Array","Int32Array","Uint32Array","Float32Array","Float64Array","Intl","Date","protos","proto","subscribeGet","subscribeSetGlobal","getContext","Sandbox","static","getOwnPropertyNames","compile","optimize","run","compileAsync","then","compileExpression","compileExpressionAsync"],"mappings":"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"}