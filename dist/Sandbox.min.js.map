{"version":3,"file":"Sandbox.min.js","sources":["../src/unraw.ts","../src/parser.ts","../src/executor.ts","../src/Sandbox.ts"],"sourcesContent":["/**\n * Parse a string as a base-16 number. This is more strict than `parseInt` as it\n * will not allow any other characters, including (for example) \"+\", \"-\", and\n * \".\".\n * @param hex A string containing a hexadecimal number.\n * @returns The parsed integer, or `NaN` if the string is not a valid hex\n * number.\n */\nfunction parseHexToInt(hex: string): number {\n  const isOnlyHexChars = !hex.match(/[^a-f0-9]/i);\n  return isOnlyHexChars ? parseInt(hex, 16) : NaN;\n}\n\n/**\n * Check the validity and length of a hexadecimal code and optionally enforces\n * a specific number of hex digits.\n * @param hex The string to validate and parse.\n * @param errorName The name of the error message to throw a `SyntaxError` with\n * if `hex` is invalid. This is used to index `errorMessages`.\n * @param enforcedLength If provided, will throw an error if `hex` is not\n * exactly this many characters.\n * @returns The parsed hex number as a normal number.\n * @throws {SyntaxError} If the code is not valid.\n */\nfunction validateAndParseHex(\n  hex: string,\n  errorName: string,\n  enforcedLength?: number\n): number {\n  const parsedHex = parseHexToInt(hex);\n  if (\n    Number.isNaN(parsedHex) ||\n    (enforcedLength !== undefined && enforcedLength !== hex.length)\n  ) {\n    throw new SyntaxError(errorName + ': ' + hex);\n  }\n  return parsedHex;\n}\n\n/**\n * Parse a two-digit hexadecimal character escape code.\n * @param code The two-digit hexadecimal number that represents the character to\n * output.\n * @returns The single character represented by the code.\n * @throws {SyntaxError} If the code is not valid hex or is not the right\n * length.\n */\nfunction parseHexadecimalCode(code: string): string {\n  const parsedCode = validateAndParseHex(\n    code,\n    'Malformed Hexadecimal',\n    2\n  );\n  return String.fromCharCode(parsedCode);\n}\n\n/**\n * Parse a four-digit Unicode character escape code.\n * @param code The four-digit unicode number that represents the character to\n * output.\n * @param surrogateCode Optional four-digit unicode surrogate that represents\n * the other half of the character to output.\n * @returns The single character represented by the code.\n * @throws {SyntaxError} If the codes are not valid hex or are not the right\n * length.\n */\nfunction parseUnicodeCode(code: string, surrogateCode?: string): string {\n  const parsedCode = validateAndParseHex(code, 'Malformed Unicode', 4);\n\n  if (surrogateCode !== undefined) {\n    const parsedSurrogateCode = validateAndParseHex(\n      surrogateCode,\n      'Malformed Unicode',\n      4\n    );\n    return String.fromCharCode(parsedCode, parsedSurrogateCode);\n  }\n\n  return String.fromCharCode(parsedCode);\n}\n\n/**\n * Test if the text is surrounded by curly braces (`{}`).\n * @param text Text to check.\n * @returns `true` if the text is in the form `{*}`.\n */\nfunction isCurlyBraced(text: string): boolean {\n  return text.charAt(0) === \"{\" && text.charAt(text.length - 1) === \"}\";\n}\n\n/**\n * Parse a Unicode code point character escape code.\n * @param codePoint A unicode escape code point, including the surrounding curly\n * braces.\n * @returns The single character represented by the code.\n * @throws {SyntaxError} If the code is not valid hex or does not have the\n * surrounding curly braces.\n */\nfunction parseUnicodeCodePointCode(codePoint: string): string {\n  if (!isCurlyBraced(codePoint)) {\n    throw new SyntaxError('Malformed Unicode: +' + codePoint);\n  }\n  const withoutBraces = codePoint.slice(1, -1);\n  const parsedCode = validateAndParseHex(\n    withoutBraces,\n    'Malformed Unicode'\n  );\n\n  try {\n    return String.fromCodePoint(parsedCode);\n  } catch (err) {\n    throw err instanceof RangeError\n      ? new SyntaxError('Code Point Limit:' + parsedCode)\n      : err;\n  }\n}\n\n/**\n * Map of unescaped letters to their corresponding special JS escape characters.\n * Intentionally does not include characters that map to themselves like \"\\'\".\n */\nconst singleCharacterEscapes = new Map<string, string>([\n  [\"b\", \"\\b\"],\n  [\"f\", \"\\f\"],\n  [\"n\", \"\\n\"],\n  [\"r\", \"\\r\"],\n  [\"t\", \"\\t\"],\n  [\"v\", \"\\v\"],\n  [\"0\", \"\\0\"]\n]);\n\n/**\n * Parse a single character escape sequence and return the matching character.\n * If none is matched, defaults to `code`.\n * @param code A single character code.\n */\nfunction parseSingleCharacterCode(code: string): string {\n  return singleCharacterEscapes.get(code) || code;\n}\n\n/**\n * Matches every escape sequence possible, including invalid ones.\n *\n * All capture groups (described below) are unique (only one will match), except\n * for 4, which can only potentially match if 3 does.\n *\n * **Capture Groups:**\n * 0. A single backslash\n * 1. Hexadecimal code\n * 2. Unicode code point code with surrounding curly braces\n * 3. Unicode escape code with surrogate\n * 4. Surrogate code\n * 5. Unicode escape code without surrogate\n * 6. Octal code _NOTE: includes \"0\"._\n * 7. A single character (will never be \\, x, u, or 0-3)\n */\nconst escapeMatch = /\\\\(?:(\\\\)|x([\\s\\S]{0,2})|u(\\{[^}]*\\}?)|u([\\s\\S]{4})\\\\u([^{][\\s\\S]{0,3})|u([\\s\\S]{0,4})|([0-3]?[0-7]{1,2})|([\\s\\S])|$)/g;\n\n/**\n * Replace raw escape character strings with their escape characters.\n * @param raw A string where escape characters are represented as raw string\n * values like `\\'` rather than `'`.\n * @param allowOctals If `true`, will process the now-deprecated octal escape\n * sequences (ie, `\\111`).\n * @returns The processed string, with escape characters replaced by their\n * respective actual Unicode characters.\n */\nexport function unraw(raw: string): string {\n  return raw.replace(escapeMatch, function(\n    _,\n    backslash?: string,\n    hex?: string,\n    codePoint?: string,\n    unicodeWithSurrogate?: string,\n    surrogate?: string,\n    unicode?: string,\n    octal?: string,\n    singleCharacter?: string\n  ): string {\n    // Compare groups to undefined because empty strings mean different errors\n    // Otherwise, `\\u` would fail the same as `\\` which is wrong.\n    if (backslash !== undefined) {\n      return \"\\\\\";\n    }\n    if (hex !== undefined) {\n      return parseHexadecimalCode(hex);\n    }\n    if (codePoint !== undefined) {\n      return parseUnicodeCodePointCode(codePoint);\n    }\n    if (unicodeWithSurrogate !== undefined) {\n      return parseUnicodeCode(unicodeWithSurrogate, surrogate);\n    }\n    if (unicode !== undefined) {\n      return parseUnicodeCode(unicode);\n    }\n    if (octal === \"0\") {\n      return \"\\0\";\n    }\n    if (octal !== undefined) {\n      throw new SyntaxError('Octal Deprecation: ' + octal);\n    }\n    if (singleCharacter !== undefined) {\n      return parseSingleCharacterCode(singleCharacter);\n    }\n    throw new SyntaxError('End of string');\n  });\n}\nexport default unraw;","import unraw from \"./unraw.js\";\nexport type LispArray = Array<LispItem>&{lisp: boolean}\nexport type LispItem = Lisp|If|KeyVal|SpreadArray|SpreadObject|(LispArray)|{new(): any }|(new (...args: any[]) => any)|String|Number|Boolean|null|undefined;\nexport interface ILiteral extends Lisp {\n  op: 'literal';\n  a: string;\n  b: LispArray;\n}\n\nexport interface IRegEx {\n  regex: string,\n  flags: string,\n  length: number\n}\n\nexport interface IConstants {\n  strings: string[];\n  literals: ILiteral[];\n  regexes: IRegEx[];\n  eager: boolean;\n}\n\nexport interface IExecutionTree {\n  tree: LispArray, \n  constants: IConstants\n}\n\ntype LispCallback = (strings: IConstants, type: string, parts: string, res: string[], expect: string, ctx: {lispTree: LispItem}) => any\nlet lispTypes: Map<string, LispCallback> = new Map();\n\nexport class ParseError extends Error {\n  constructor(message: string, public code: string) {\n    super(message + \": \" + code.substring(0, 40));\n  }\n}\n\nexport class Lisp {\n  op: string;\n  a?: LispItem;\n  b?: LispItem;\n  constructor(obj: Lisp) {\n    this.op = obj.op;\n    this.a = obj.a;\n    this.b = obj.b;\n  }\n}\n\nexport class If {\n  constructor(public t: any, public f: any) {}\n}\n\nexport class KeyVal {\n  constructor(public key: string, public val: any) {}\n}\n\nexport class SpreadObject {\n  constructor(public item: {[key: string]: any}) {}\n}\n\nexport class SpreadArray {\n  constructor(public item: any[]) {}\n}\n\nexport function toLispArray(arr: LispItem[]): LispArray {\n  (arr as LispArray).lisp = true;\n  return arr as LispArray;\n}\n\nconst inlineIfElse =  /^:/;\nconst space = /^\\s/;\n\nexport let expectTypes: {[type:string]: {types: {[type:string]: RegExp}, next: string[]}} = {\n  splitter: {\n    types: {\n      split: /^(&(?!&)|\\|(?!\\|)|\\+(?!(\\+))|\\-(?!(\\-))|\\^|<<|>>(?!>)|>>>|instanceof(?![\\w\\$])|in(?![\\w\\$]))(?!\\=)/,\n      op: /^(\\/|\\*\\*|\\*(?!\\*)|\\%)(?!\\=)/,\n      boolOp: /^(&&|\\|\\|)/,\n      comparitor: /^(<=|>=|<(?!<)|>(?!>)|!==|!=(?!\\=)|===|==)/,\n    },\n    next: [\n      'modifier',\n      'value', \n      'prop', \n      'incrementerBefore',\n    ]\n  },\n  inlineIf: {\n    types: {\n      inlineIf: /^\\?/,\n    },\n    next: [\n      'expEnd'\n    ]\n  },\n  assignment: {\n    types: {\n      assignModify: /^(\\-=|\\+=|\\/=|\\*\\*=|\\*=|%=|\\^=|\\&=|\\|=|>>>=|>>=|<<=)/,\n      assign: /^(=)(?!=)/\n    },\n    next: [\n      'modifier',\n      'value', \n      'prop', \n      'incrementerBefore',\n    ]\n  },\n  incrementerBefore: {\n    types: {incrementerBefore: /^(\\+\\+|\\-\\-)/},\n    next: [\n      'prop',\n    ]\n  },\n  expEdge: {\n    types: {\n      call: /^(\\?\\.)?[\\(]/,\n      incrementerAfter: /^(\\+\\+|\\-\\-)/\n    },\n    next: [\n      'splitter',\n      'expEdge',\n      'inlineIf',\n      'dot',\n      'expEnd'\n    ]\n  },\n  modifier: {\n    types: {\n      not: /^!/,\n      inverse: /^~/,\n      negative: /^\\-(?!\\-)/,\n      positive: /^\\+(?!\\+)/,\n      typeof: /^typeof(?![\\w\\$])/,\n      delete: /^delete(?![\\w\\$])/,\n    },\n    next: [\n      'modifier', \n      'value',\n      'prop',\n      'incrementerBefore',\n    ]\n  },\n  dot: {\n    types: {\n      arrayProp: /^(\\?\\.)?\\[/,\n      dot: /^(\\?)?\\.(?=\\s*[a-zA-Z\\$\\_])/,\n    },\n    next: [\n      'splitter',\n      'assignment',\n      'expEdge',\n      'dot',\n      'inlineIf',\n      'expEnd'\n    ]\n  },\n  prop: {\n    types: {\n      prop: /^[a-zA-Z\\$\\_][a-zA-Z\\d\\$\\_]*/,\n    },\n    next: [\n      'splitter',\n      'assignment',\n      'expEdge',\n      'dot',\n      'inlineIf',\n      'expEnd'\n    ]\n  },\n  value: {\n    types: {\n      createObject: /^\\{/,\n      createArray: /^\\[/,\n      number: /^(0x[\\da-f]+(_[\\da-f]+)*|(\\d+(_\\d+)*(\\.\\d+(_\\d+)*)?|\\.\\d+(_\\d+)*))(e[\\+\\-]?\\d+(_\\d+)*)?(n)?(?!\\d)/i,\n      string: /^\"(\\d+)\"/,\n      literal: /^`(\\d+)`/,\n      regex: /^\\/(\\d+)\\/r(?![\\w\\$])/,\n      boolean: /^(true|false)(?![\\w\\$])/,\n      null: /^null(?![\\w\\$])/,\n      und: /^undefined(?![\\w\\$])/,\n      arrowFunctionSingle: /^(async\\s+)?([a-zA-Z\\$_][a-zA-Z\\d\\$_]*)\\s*=>\\s*({)?/,\n      arrowFunction: /^(async\\s*)?\\(\\s*((\\.\\.\\.)?\\s*[a-zA-Z\\$_][a-zA-Z\\d\\$_]*(\\s*,\\s*(\\.\\.\\.)?\\s*[a-zA-Z\\$_][a-zA-Z\\d\\$_]*)*)?\\s*\\)\\s*=>\\s*({)?/,\n      inlineFunction: /^(async\\s+)?function(\\s*[a-zA-Z\\$_][a-zA-Z\\d\\$_]*)?\\s*\\(\\s*((\\.\\.\\.)?\\s*[a-zA-Z\\$_][a-zA-Z\\d\\$_]*(\\s*,\\s*(\\.\\.\\.)?\\s*[a-zA-Z\\$_][a-zA-Z\\d\\$_]*)*)?\\s*\\)\\s*{/,\n      group: /^\\(/,\n      NaN: /^NaN(?![\\w\\$])/,\n      Infinity: /^Infinity(?![\\w\\$])/,\n      void: /^void(?![\\w\\$])\\s*/,\n      await: /^await(?![\\w\\$])\\s*/,\n      new: /^new(?![\\w\\$])\\s*/,\n      throw: /^throw(?![\\w\\$])\\s*/\n    },\n    next: [\n      'splitter',\n      'expEdge',\n      'dot',\n      'inlineIf',\n      'expEnd'\n    ]\n  },\n  initialize: {\n    types: {\n      initialize: /^(var|let|const)\\s+([a-zA-Z\\$_][a-zA-Z\\d\\$_]*)\\s*(=)?/,\n      return: /^return(?![\\w\\$])/,\n    },\n    next: [\n      'modifier',\n      'value', \n      'prop', \n      'incrementerBefore',\n      'expEnd'\n    ]\n  },\n  spreadObject: {\n    types: {\n      spreadObject: /^\\.\\.\\./\n    },\n    next: [\n      'value',\n      'prop', \n    ]\n  },\n  spreadArray: {\n    types: {\n      spreadArray: /^\\.\\.\\./\n    },\n    next: [\n      'value', \n      'prop', \n    ]\n  },\n  expEnd: {types: {}, next: []},\n  expFunction: {\n    types: {\n      function: /^(async\\s+)?function(\\s*[a-zA-Z\\$_][a-zA-Z\\d\\$_]*)\\s*\\(\\s*((\\.\\.\\.)?\\s*[a-zA-Z\\$_][a-zA-Z\\d\\$_]*(\\s*,\\s*(\\.\\.\\.)?\\s*[a-zA-Z\\$_][a-zA-Z\\d\\$_]*)*)?\\s*\\)\\s*{/,\n    },\n    next: [\n      'expEdge',\n      'expEnd'\n    ]\n  },\n  expSingle: {\n    types: {\n      for: /^(([a-zA-Z\\$\\_][\\w\\$]*)\\s*:)?\\s*for\\s*\\(/,\n      do: /^(([a-zA-Z\\$\\_][\\w\\$]*)\\s*:)?\\s*do(?![\\w\\$])\\s*(\\{)?/,\n      while: /^(([a-zA-Z\\$\\_][\\w\\$]*)\\s*:)?\\s*while\\s*\\(/,\n      loopAction: /^(break|continue)(?![\\w\\$])\\s*([a-zA-Z\\$\\_][\\w\\$]*)?/,\n      if: /^(([a-zA-Z\\$\\_][\\w\\$]*)\\s*:)?\\s*if\\s*\\(/,\n      try: /^try\\s*{/,\n      block: /^{/,\n      switch: /^(([a-zA-Z\\$\\_][\\w\\$]*)\\s*:)?\\s*switch\\s*\\(/,\n    },\n    next: [\n      'expEnd'\n    ]\n  }\n};\n\nlet closings = {\n  \"(\": \")\",\n  \"[\": \"]\",\n  \"{\": \"}\",\n  \"'\": \"'\",\n  '\"': '\"',\n  \"`\": \"`\"\n}\n\nexport function testMultiple(str: string, tests: RegExp[]) {\n  let found: RegExpExecArray;\n  for (let i = 0; i < tests.length; i++) {\n    const test = tests[i];\n    found = test.exec(str);\n    if (found) break;\n  }\n  return found;\n}\n\nconst okFirstChars = /^[\\+\\-~ !]/;\nconst aChar = /^[\\w\\$]/\nconst aNumber = expectTypes.value.types.number;\nconst wordReg = /^((if|for|while|do|function)(?![\\w\\$])|[\\w\\$]+)/;\nexport interface restDetails {oneliner?: boolean, words?: string[], lastWord?: string, lastAnyWord?: string, regRes?: RegExpExecArray}\nexport function restOfExp(constants: IConstants, \n                          part: string, \n                          tests?: RegExp[], \n                          quote?: string, \n                          firstOpening?: string, \n                          closingsTests?: RegExp[], \n                          details: restDetails = {}) {\n  details.words = details.words || [];\n  let isStart = true;\n  tests = tests || [];\n  let escape = false;\n  let done = false;\n  let lastChar = \"\";\n  let isOneLiner = false;\n  let i;\n  for (i = 0; i < part.length && !done; i++) {\n    let char = part[i];\n    if (quote === '\"' || quote === \"'\" || quote === \"`\") {\n      if (quote === \"`\" && char === \"$\" && part[i+1] === \"{\" && !escape) {\n        let skip = restOfExp(constants, part.substring(i+2), [], \"{\");\n        i += skip.length + 2;\n      } else if (char === quote && !escape) {\n        return part.substring(0, i);\n      }\n      escape = !escape && char === \"\\\\\";\n    } else if (closings[char]) {\n      if (isOneLiner && char === \"{\") {\n        isOneLiner = false;\n      }\n      if (char === firstOpening) {\n        done = true;\n        break;\n      } else {\n        let skip = restOfExp(constants, part.substring(i+1), [], char);\n        i += skip.length + 1;\n        isStart = false;\n        if (closingsTests) {\n          let sub = part.substring(i);\n          let found: RegExpExecArray;\n          if (found = testMultiple(sub, closingsTests)) {\n            details.regRes = found;\n            done = true;\n          }\n        }\n      }\n    } else if (!quote) {\n      let sub = part.substring(i);\n      let foundWord: RegExpExecArray;\n      let foundNumber: RegExpExecArray;\n      if (closingsTests) {\n        let found: RegExpExecArray;\n        if (found = testMultiple(sub, closingsTests)) {\n          details.regRes = found;\n          done = true;\n        }\n      }\n      if (foundNumber = aNumber.exec(sub)) {\n        i += foundNumber[0].length - 1;\n        sub = part.substring(i);\n      } else if (lastChar != char) {\n        let found = testMultiple(sub, tests);\n        if (found) {\n          if(closingsTests && found[1].length) {\n            i += found[1].length - 1;\n          }\n          done = true;\n        }\n        if (!done && (foundWord = wordReg.exec(sub))) {\n          isOneLiner = true;\n          details.words.push(foundWord[1]);\n          details.lastAnyWord = foundWord[1];\n          if (foundWord[2]) {\n            details.lastWord = foundWord[2];\n          }\n          if(foundWord[0].length > 2) {\n            i += foundWord[0].length - 2;\n          }\n        }\n      }\n      if (isStart) {\n        if (okFirstChars.test(sub)) {\n          done = false;\n        } else {\n          isStart = false;\n        }\n      }\n      if (done) break;\n    } else if(char === closings[quote]) {\n      return part.substring(0, i);\n    }\n    lastChar = char;\n  }\n  if (quote) {\n    throw new ParseError(\"Unclosed '\" + quote + \"'\", quote + part.substring(0, Math.min(i, 40)));\n  }\n  if (details) {\n    details.oneliner = isOneLiner;\n  }\n  return part.substring(0, i);\n}\nrestOfExp.next = [\n  'splitter',\n  'expEnd',\n  'inlineIf'\n];\n\nconst startingExecpted = ['initialize', 'expSingle', 'expFunction', 'value', 'modifier', 'prop', 'incrementerBefore', 'expEnd'];\n\nexport const setLispType = (types: string[], fn: LispCallback) => {\n  types.forEach((type) => {\n    lispTypes.set(type, fn);\n  })\n}\n\nconst closingsCreate: {[type:string]: RegExp} = {\n  'createArray': /^\\]/,\n  'createObject': /^\\}/,\n  'group': /^\\)/,\n  'arrayProp': /^\\]/,\n  'call': /^\\)/\n}\n\nsetLispType(['createArray', 'createObject', 'group', 'arrayProp','call'], (constants, type, part, res, expect, ctx) => {\n  let extract = \"\";\n  let arg: string[] = [];\n  let end = false;\n  let i = res[0].length;\n  while (i < part.length && !end) {\n    extract = restOfExp(constants, part.substring(i), [\n      closingsCreate[type],\n      /^,/\n    ]);\n    i += extract.length;\n    if (extract) {\n      arg.push(extract);\n    }\n    if (part[i] !== ',') {\n      end = true;\n    } else {\n      i++;\n    }\n  }\n  const next = ['value', 'modifier', 'prop', 'incrementerBefore', 'expEnd'];\n  let l: LispItem;\n\n  let funcFound: RegExpExecArray;\n  switch(type) {\n    case 'group':\n    case 'arrayProp':\n      l = lispifyExpr(constants, arg.join(\",\"));\n      break;\n    case 'call':\n    case 'createArray':\n      // @TODO: support 'empty' values\n      l = toLispArray(arg.map((e) => lispify(constants, e, [...next, 'spreadArray'])));\n      break;\n    case 'createObject':\n      l = toLispArray(arg.map((str) => {\n        str = str.trimStart();\n        let value;\n        let key;\n        funcFound = expectTypes.expFunction.types.function.exec('function ' + str);\n        if (funcFound) {\n          key = funcFound[2].trimStart();\n          value = lispify(constants, 'function ' + str.replace(key, \"\"));\n        } else {\n          let extract = restOfExp(constants, str, [/^:/]);\n          key = lispify(constants, extract, [...next, 'spreadObject']);\n          if (key instanceof Lisp && key.op === 'prop') {\n            key = key.b;\n          }\n          if (extract.length === str.length) return key;\n          value = lispify(constants, str.substring(extract.length + 1));\n        }\n        return new Lisp({\n          op: 'keyVal',\n          a: key,\n          b: value\n        });\n      }));\n      break;\n  }\n  type = type === 'arrayProp' ? (res[1] ? '?prop' : 'prop') : (type === 'call' ? (res[1] ? '?call' : 'call') : type);\n  ctx.lispTree = lispify(constants, part.substring(i + 1), expectTypes[expect].next, new Lisp({\n    op: type, \n    a: ctx.lispTree, \n    b: l,\n  }));\n});\n\nsetLispType(['inverse', 'not', 'negative', 'positive', 'typeof', 'delete'], (constants, type, part, res, expect, ctx) => {\n  let extract = restOfExp(constants, part.substring(res[0].length), [/^[^\\s\\.\\w\\$]/]);\n  ctx.lispTree = lispify(constants, part.substring(extract.length + res[0].length), restOfExp.next, new Lisp({\n    op: ['positive', 'negative'].includes(type) ? '$' + res[0] : res[0],\n    a: ctx.lispTree, \n    b: lispify(constants, extract, expectTypes[expect].next), \n  }));\n});\n\nsetLispType(['incrementerBefore'], (constants, type, part, res, expect, ctx) => {\n  let extract = restOfExp(constants, part.substring(2), [/^[^\\s\\.\\w\\$]/]);\n  ctx.lispTree = lispify(constants, part.substring(extract.length + 2), restOfExp.next, new Lisp({\n    op: res[0] + \"$\", \n    a: lispify(constants, extract, expectTypes[expect].next), \n  }));\n});\n\nsetLispType(['incrementerAfter'], (constants, type, part, res, expect, ctx) => {\n  ctx.lispTree = lispify(constants, part.substring(res[0].length), expectTypes[expect].next, new Lisp({\n    op: \"$\"  + res[0], \n    a: ctx.lispTree, \n  }));\n});\n\nsetLispType(['assign', 'assignModify', 'boolOp'], (constants, type, part, res, expect, ctx) => {\n  ctx.lispTree = new Lisp({\n    op: res[0], \n    a: ctx.lispTree,\n    b: lispify(constants, part.substring(res[0].length), expectTypes[expect].next)\n  });\n});\n\nsetLispType(['split', 'comparitor', 'op'], (constants, type, part, res, expect, ctx) => {\n  const next = [\n    expectTypes.inlineIf.types.inlineIf,\n    inlineIfElse\n  ];\n  switch (type) {\n    case 'op':\n      next.push(expectTypes.splitter.types.op);\n    case 'split':\n      next.push(expectTypes.splitter.types.split);\n    case 'comparitor':\n      next.push(expectTypes.splitter.types.comparitor);\n      next.push(expectTypes.splitter.types.boolOp);\n  }\n  let extract = restOfExp(constants, part.substring(res[0].length), next);\n  ctx.lispTree = lispify(constants, part.substring(extract.length + res[0].length), restOfExp.next, new Lisp({\n    op: res[0],\n    a: ctx.lispTree, \n    b: lispify(constants, extract, expectTypes[expect].next), \n  }));\n});\n\nsetLispType(['inlineIf'], (constants, type, part, res, expect, ctx) => {\n  let found = false;\n  let extract = \"\";\n  let quoteCount = 1;\n  while(!found && extract.length < part.length) {\n    extract += restOfExp(constants, part.substring(extract.length + 1), [\n      expectTypes.inlineIf.types.inlineIf,\n      inlineIfElse\n    ]);\n    if (part[extract.length + 1] === '?') {\n      quoteCount++\n    } else {\n      quoteCount--\n    }\n    if (!quoteCount) {\n      found = true;\n    } else {\n      extract += part[extract.length + 1];\n    }\n  }\n  ctx.lispTree = new Lisp({\n    op: '?',\n    a: ctx.lispTree, \n    b: new Lisp({\n      op: ':',\n      a: lispifyExpr(constants, extract),\n      b: lispifyExpr(constants, part.substring(res[0].length + extract.length + 1))\n    })\n  });\n});\n\nsetLispType(['if'], (constants, type, part, res, expect, ctx) => {\n  let condition = restOfExp(constants, part.substring(res[0].length), [], \"(\");\n  const isBlock = /^\\s*\\{/.exec(part.substring(res[0].length + condition.length + 1));\n  const startTrue = res[0].length + condition.length + 1 + (isBlock ? isBlock[0].length : 0);\n  let trueBlock = restOfExp(constants, part.substring(startTrue), isBlock ? [/^\\}/] : [/^;/]);\n  let elseBlock = \"\";\n  if (startTrue + trueBlock.length + (isBlock ? isBlock[0].length : 0) < part.length) {\n    const end = part.substring(startTrue + trueBlock.length + (isBlock ? isBlock[0].length : 1));\n    const foundElse = /^;?\\s*else(?![\\w\\$])\\s*/.exec(end);\n    if (foundElse) {\n      elseBlock = end.substring(foundElse[0].length);\n    }\n  }\n  \n  condition = condition.trim();\n  trueBlock = trueBlock.trim();\n  elseBlock = elseBlock.trim();\n  // console.log({condition, trueBlock, elseBlock})\n  if (trueBlock[0] === \"{\") trueBlock = trueBlock.slice(1, -1);\n  if (elseBlock[0] === \"{\") elseBlock = elseBlock.slice(1, -1);\n  ctx.lispTree = new Lisp({\n    op: 'if',\n    a: lispifyExpr(constants, condition), \n    b: new If(lispifyBlock(trueBlock, constants), elseBlock ? lispifyBlock(elseBlock, constants) : undefined)\n  });\n});\n\nsetLispType(['switch'], (constants, type, part, res, expect, ctx) => {\n  const test = restOfExp(constants, part.substring(res[0].length), [], \"(\");\n  let start = part.indexOf(\"{\", res[0].length + test.length + 1);\n  if (start === -1) throw new SyntaxError(\"Invalid switch\");\n  let statement = insertSemicolons(constants, restOfExp(constants, part.substring(start + 1), [], \"{\"));\n  let caseFound: RegExpExecArray;\n  const caseTest = /^\\s*(case\\s|default)\\s*/;\n  let cases: Lisp[] = [];\n  let defaultFound = false;\n  while(caseFound = caseTest.exec(statement)) {\n    if (caseFound[1] === 'default') {\n      if (defaultFound) throw new SyntaxError(\"Only one default switch case allowed\");\n      defaultFound = true;\n    }\n    let cond = restOfExp(constants, statement.substring(caseFound[0].length), [/^:/]);\n    let found = \"\";\n    let i = start = caseFound[0].length + cond.length + 1;\n    let bracketFound = /^\\s*\\{/.exec(statement.substring(i));\n    let exprs = [];\n    if (bracketFound) {\n      i += bracketFound[0].length;\n      found = restOfExp(constants, statement.substring(i), [], \"{\");\n      i += found.length + 1;\n      exprs = lispifyBlock(found, constants);\n    } else {\n      let notEmpty = restOfExp(constants, statement.substring(i), [caseTest]);\n      if (!notEmpty.trim()) {\n        exprs = [];\n        i += notEmpty.length;\n      } else {\n        let lines = [];\n        while(found = restOfExp(constants, statement.substring(i), [/^;/])) {\n          lines.push(found);\n          i += found.length + 1;\n          if (caseTest.test(statement.substring(i))) {\n            break;\n          }\n        }\n        exprs = lispifyBlock(lines.join(\";\"), constants);\n      }\n    }\n    statement = statement.substring(i);\n    cases.push(new Lisp({\n      op: \"case\",\n      a: caseFound[1] === \"default\" ? undefined : lispifyExpr(constants, cond),\n      b: toLispArray(exprs)\n    }));\n  }\n  ctx.lispTree = new Lisp({\n    op: 'switch',\n    a: lispifyExpr(constants, test),\n    b: toLispArray(cases)\n  });\n});\n\nsetLispType(['dot', 'prop'], (constants, type, part, res, expect, ctx) => {\n  let prop = res[0];\n  let index = res[0].length;\n  let op = 'prop';\n  if (type === 'dot') {\n    if (res[1]) {\n      op = '?prop';\n    }\n    let matches = part.substring(res[0].length).match(expectTypes.prop.types.prop);\n    if (matches && matches.length) {\n      prop = matches[0];\n      index = prop.length + res[0].length\n    } else {\n      throw new SyntaxError('Hanging  dot');\n    }\n  }\n  ctx.lispTree = lispify(constants, part.substring(index), expectTypes[expect].next, new Lisp({\n    op: op, \n    a: ctx.lispTree, \n    b: prop\n  }));\n});\n\nsetLispType(['spreadArray', 'spreadObject'], (constants, type, part, res, expect, ctx) => {\n  ctx.lispTree = new Lisp({\n    op: type,\n    b: lispify(constants, part.substring(res[0].length), expectTypes[expect].next)\n  });\n});\n\nsetLispType(['return', 'throw'], (constants, type, part, res, expect, ctx) => {\n  ctx.lispTree = new Lisp({\n    op: type,\n    b: lispifyExpr(constants, part.substring(res[0].length))\n  });\n});\n\nconst primitives = {\n  \"true\": true,\n  \"false\": false,\n  \"null\": null,\n  Infinity,\n  NaN,\n  \"und\": undefined\n}\n\nsetLispType(['number', 'boolean', 'null', 'und', 'NaN', 'Infinity'], (constants, type, part, res, expect, ctx) => {\n  ctx.lispTree = lispify(constants, part.substring(res[0].length), expectTypes[expect].next, type === \"number\" ? (res[10] ? BigInt(res[1]) : Number(res[0])) : primitives[type === \"boolean\" ? res[0] : type]);\n});\n\nsetLispType(['string', 'literal', 'regex'], (constants, type, part, res, expect, ctx) => {\n  ctx.lispTree = lispify(constants, part.substring(res[0].length), expectTypes[expect].next, new Lisp({\n    op: type,\n    b: parseInt(JSON.parse(res[1]), 10),\n  }));\n});\n\nsetLispType(['initialize'], (constants, type, part, res, expect, ctx) => {\n  if (!res[3]) {\n    ctx.lispTree = lispify(constants, part.substring(res[0].length), expectTypes[expect].next, new Lisp({\n      op: res[1],\n      a: res[2]\n    }));\n  } else {\n    ctx.lispTree = new Lisp({\n      op: res[1],\n      a: res[2],\n      b: lispify(constants, part.substring(res[0].length), expectTypes[expect].next)\n    });\n  }\n});\n\nsetLispType(['function', 'inlineFunction', 'arrowFunction', 'arrowFunctionSingle'], (constants, type, part, res, expect, ctx) => {\n  const isArrow = type !== 'function' && type !== 'inlineFunction';\n  const isReturn = isArrow && !res[res.length - 1];\n  const argPos = isArrow ? 2 : 3;\n  const isAsync = !!res[1];\n  const args: any[] = res[argPos] ? res[argPos].replace(/\\s+/g, \"\").split(/,/g) : [];\n  if (!isArrow) {\n    args.unshift((res[2] || \"\").trimStart());\n  }\n  let ended = false;\n  args.forEach((arg) => {\n    if (ended) throw new SyntaxError('Rest parameter must be last formal parameter');\n    if (arg.startsWith('...')) ended = true;\n  });\n  args.unshift(isAsync);\n  const func = (isReturn ? 'return ' : '') + restOfExp(constants, part.substring(res[0].length), !isReturn ? [/^}/] : [/^[,;\\)\\}\\]]/]);\n  ctx.lispTree = lispify(constants, part.substring(res[0].length + func.length + 1), expectTypes[expect].next, new Lisp({\n    op: isArrow ? 'arrowFunc' : type,\n    a: toLispArray(args),\n    b: constants.eager ? lispifyFunction(func, constants) : func\n  }));\n});\n\nconst iteratorRegex = /^((let|var|const)\\s+)?\\s*([a-zA-Z\\$_][a-zA-Z\\d\\$_]*)\\s+(in|of)(?![\\w\\$])/\nsetLispType(['for', 'do', 'while'], (constants, type, part, res, expect, ctx) => {\n  let i = 0;\n  let startStep: LispItem = true;\n  let startInternal: LispArray = toLispArray([]);\n  let getIterator: LispItem;\n  let beforeStep: LispItem = false;\n  let checkFirst = true;\n  let condition: LispItem;\n  let step: LispItem = true;\n  let body: string;\n  switch (type) {\n    case 'while':\n      i = part.indexOf(\"(\") + 1;\n      let extract = restOfExp(constants, part.substring(i), [], \"(\");\n      condition = lispifyExpr(constants, extract);\n      body = restOfExp(constants, part.substring(i + extract.length + 1)).trim();\n      if (body[0] === \"{\") body = body.slice(1, -1);\n      break;\n    case 'for':\n      i = part.indexOf(\"(\") + 1;\n      let args: string[] = [];\n      let extract2 = \"\";\n      for (let k = 0; k < 3; k++)  {\n        extract2 = restOfExp(constants, part.substring(i), [/^[;\\)]/]);\n        args.push(extract2.trim());\n        i += extract2.length + 1;\n        if (part[i - 1] === \")\") break;\n      }\n      let iterator: RegExpExecArray;\n      if (args.length === 1 && (iterator = iteratorRegex.exec(args[0]))) {\n        if (iterator[4] === 'of') {\n          getIterator = lispifyExpr(constants, args[0].substring(iterator[0].length)),\n          startInternal = toLispArray([\n            ofStart2, \n            ofStart3\n          ]);\n          condition = ofCondition;\n          step = ofStep;\n          beforeStep = lispify(constants, (iterator[1] || 'let ') + iterator[3]  + ' = $$next.value', ['initialize']);\n        } else {\n          getIterator = lispifyExpr(constants, args[0].substring(iterator[0].length)),\n          startInternal = toLispArray([\n            inStart2,\n            inStart3\n          ]);\n          step = inStep;\n          condition = inCondition;\n          beforeStep = lispify(constants, (iterator[1] || 'let ') + iterator[3] + ' = $$keys[$$keyIndex]', ['initialize']);\n        }\n      } else if (args.length === 3) {\n        startStep = lispifyExpr(constants, args.shift(), startingExecpted);\n        condition = lispifyExpr(constants, args.shift());\n        step = lispifyExpr(constants, args.shift());\n      } else {\n        throw new SyntaxError(\"Invalid for loop definition\");\n      }\n      body = restOfExp(constants, part.substring(i)).trim();\n      if (body[0] === \"{\") body = body.slice(1, -1);\n\n      break;\n    case 'do':\n      checkFirst = false;\n      const isBlock = !!res[3];\n      body = restOfExp(constants, part.substring(res[0].length), isBlock ? [/^\\}/] : [/^;/]);\n      condition = lispifyExpr(constants, restOfExp(constants, part.substring(part.indexOf(\"(\", res[0].length + body.length) + 1), [], \"(\"));\n      break;\n  }\n  const a = [checkFirst, startInternal, getIterator, startStep, step, condition, beforeStep] as any;\n  a.lisp = true;\n  ctx.lispTree = new Lisp({\n    op: 'loop',\n    a,\n    b: lispifyBlock(body, constants)\n  });\n});\n\nsetLispType(['block'], (constants, type, part, res, expect, ctx) => {\n  ctx.lispTree = lispifyBlock(restOfExp(constants, part.substring(1), [], \"{\"), constants);\n});\n\nsetLispType(['loopAction'], (constants, type, part, res, expect, ctx) => {\n  ctx.lispTree = new Lisp({\n    op: 'loopAction',\n    a: res[1],\n  });\n});\n\nconst catchReg = /^\\s*(catch\\s*(\\(\\s*([a-zA-Z\\$_][a-zA-Z\\d\\$_]*)\\s*\\))?|finally)\\s*\\{/\nsetLispType(['try'], (constants, type, part, res, expect, ctx) => {\n  const body = restOfExp(constants, part.substring(res[0].length), [], \"{\");\n  let catchRes = catchReg.exec(part.substring(res[0].length + body.length + 1));\n  let finallyBody;\n  let exception;\n  let catchBody;\n  let offset = 0;\n  if (catchRes[1].startsWith('catch')) {\n    catchRes = catchReg.exec(part.substring(res[0].length + body.length + 1));\n    exception = catchRes[2];\n    catchBody = restOfExp(constants, part.substring(res[0].length + body.length + 1 + catchRes[0].length), [], \"{\");\n    offset = res[0].length + body.length + 1 + catchRes[0].length + catchBody.length + 1;\n    if ((catchRes = catchReg.exec(part.substring(offset))) && catchRes[1].startsWith('finally')) {\n      finallyBody = restOfExp(constants, part.substring(offset + catchRes[0].length), [], \"{\");\n    }\n  } else {\n    finallyBody = restOfExp(constants, part.substring(res[0].length + body.length + 1 + catchRes[0].length), [], \"{\");\n  }\n  const b = [\n    exception,\n    lispifyBlock(insertSemicolons(constants, catchBody || \"\"), constants),\n    lispifyBlock(insertSemicolons(constants, finallyBody || \"\"), constants),\n  ] as any;\n  b.lisp = true;\n  ctx.lispTree = new Lisp({\n    op: 'try',\n    a: lispifyBlock(insertSemicolons(constants, body), constants),\n    b\n  });\n});\n\nsetLispType(['void', 'await'], (constants, type, part, res, expect, ctx) => {\n  const extract = restOfExp(constants, part.substring(res[0].length), [/^[^\\s\\.\\w\\$]/]);\n  ctx.lispTree = lispify(constants, part.substring(res[0].length + extract.length), expectTypes[expect].next, new Lisp({\n    op: type,\n    a: lispify(constants, extract),\n  }));\n});\n\nsetLispType(['new'], (constants, type, part, res, expect, ctx) => {\n  let i = res[0].length;\n  const obj = restOfExp(constants, part.substring(i), [], undefined, \"(\");\n  i += obj.length + 1;\n  const args = [];\n  if (part[i - 1] === \"(\") {\n    const argsString = restOfExp(constants, part.substring(i), [], \"(\");\n    i += argsString.length + 1;\n    let found;\n    let j = 0;\n    while(found = restOfExp(constants, argsString.substring(j), [/^,/])) {\n      j += found.length + 1;\n      args.push(found.trim());\n    } \n  }\n  ctx.lispTree = lispify(constants, part.substring(i), expectTypes.expEdge.next, new Lisp({\n    op: type,\n    a: lispify(constants, obj, expectTypes.initialize.next),\n    b: toLispArray(args.map((arg) => lispify(constants, arg, expectTypes.initialize.next))),\n  }));\n});\n\nconst ofStart2 = lispify(undefined, 'let $$iterator = $$obj[Symbol.iterator]()', ['initialize']);\nconst ofStart3 = lispify(undefined, 'let $$next = $$iterator.next()', ['initialize']);\nconst ofCondition = lispify(undefined, 'return !$$next.done', ['initialize']);\nconst ofStep = lispify(undefined, '$$next = $$iterator.next()');\nconst inStart2 = lispify(undefined, 'let $$keys = Object.keys($$obj)', ['initialize']);\nconst inStart3 = lispify(undefined, 'let $$keyIndex = 0', ['initialize']);\nconst inStep = lispify(undefined, '$$keyIndex++');\nconst inCondition = lispify(undefined, 'return $$keyIndex < $$keys.length', ['initialize']);\n\nvar lastType;\nvar lastPart;\nvar lastLastPart;\nvar lastLastLastPart;\nvar lastLastLastLastPart;\nfunction lispify(constants: IConstants, part: string, expected?: string[], lispTree?: LispItem, topLevel = false): LispItem {\n  expected = expected || expectTypes.initialize.next;\n  if (part === undefined) return lispTree;\n\n  part = part.trim();\n\n  if (!part.length && !expected.includes('expEnd')) {\n    throw new SyntaxError(\"Unexpected end of expression\");\n  }\n  \n  if (!part) return lispTree;\n\n  let ctx = {lispTree: lispTree};\n\n  let res: any;\n  for (let expect of expected) {\n    if (expect === 'expEnd') {\n      continue;\n    }\n    for (let type in expectTypes[expect].types) {\n      if (type === 'expEnd') {\n        continue;\n      }\n      if(res = expectTypes[expect].types[type].exec(part)) {\n        lastType = type;\n        // console.log(type, part)\n        lastLastLastLastPart = lastLastLastPart;\n        lastLastLastPart = lastLastPart;\n        lastLastPart = lastPart;\n        lastPart = part;\n        try {\n          lispTypes.get(type)(constants, type, part, res, expect, ctx);\n        } catch(e) {\n          if (topLevel && e instanceof SyntaxError) {\n            throw new ParseError(e.message, part);\n          }\n          throw e;\n        }\n        break;\n      }\n    }\n    if (res) break;\n  }\n\n  if (!res && part.length) {\n    throw SyntaxError(`Unexpected token after ${lastType}: ${part[0]}`);\n  }\n  return ctx.lispTree;\n}\n\nconst startingExpectedWithoutSingle = startingExecpted.filter((r) => r !== 'expSingle');\n\nfunction lispifyExpr(constants: IConstants, str: string, expected?: string[]): LispItem {\n  if (!str.trim()) return undefined;\n  let subExpressions = [];\n  let sub: string;\n  let pos = 0;\n  expected = expected || expectTypes.initialize.next;\n  if (expected.includes('expSingle')) {\n    if (testMultiple(str, Object.values(expectTypes.expSingle.types))) {\n      return lispify(constants, str, ['expSingle'], undefined, true);\n    }\n  }\n  if (expected === startingExecpted) expected = startingExpectedWithoutSingle;\n  while ((sub = restOfExp(constants, str.substring(pos), [/^,/]))) {\n    subExpressions.push(sub.trimStart());\n    pos += sub.length + 1;\n  }\n  if (subExpressions.length === 1) {\n    return lispify(constants, str, expected, undefined, true);\n  }\n  if (expected.includes('initialize')) {\n    let defined = expectTypes.initialize.types.initialize.exec(subExpressions[0]);\n    if (defined) {\n      return toLispArray(subExpressions.map((str, i) => lispify(constants, i ? defined[1] + ' ' + str : str, ['initialize'], undefined, true)));\n    } else if (expectTypes.initialize.types.return.exec(subExpressions[0])) {\n      return lispify(constants, str, expected, undefined, true);\n    }\n  }\n  const exprs = toLispArray(subExpressions.map((str, i) => lispify(constants, str, expected, undefined, true)));\n  return new Lisp({op: \"multi\", a: exprs});\n}\n\nexport function lispifyBlock(str: string, constants: IConstants): LispArray {\n  // console.log({str})\n  str = insertSemicolons(constants, str);\n  // console.log({str})\n  if (!str.trim()) return toLispArray([]);\n  let parts = [];\n  let part: string;\n  let pos = 0;\n  let details: restDetails = {};\n  let oneliner: string[] = [];\n  while ((part = restOfExp(constants, str.substring(pos), [/^;/], undefined, undefined, undefined, details))) {\n    if (details.words.includes('if') && /^\\s*else(?![\\w\\$])/.test(str.substring(pos + part.length + 1))) {\n      oneliner.push(part, \";\");\n    } else if (details.words.includes('do') && /^\\s*while(?![\\w\\$])/.test(str.substring(pos + part.length + 1))) {\n      oneliner.push(part, \";\");\n    } else {\n      parts.push(oneliner.join(\"\") + part);\n      oneliner = [];\n    }\n    details = {};\n    pos += part.length + 1;\n  }\n  if (oneliner.length) {\n    parts.push(oneliner.join(\"\"));\n  }\n  // console.log({parts, str})\n  return toLispArray(parts.filter(Boolean).map((str, j) => {\n    return lispifyExpr(constants, str.trimStart(), startingExecpted);\n  }).flat());\n}\n\nexport function lispifyFunction(str: string, constants: IConstants): LispArray {\n  if (!str.trim()) return toLispArray([]);\n  const tree = lispifyBlock(str, constants);\n  let hoisted: LispArray = toLispArray([]);\n  hoist(tree, hoisted);\n  return toLispArray(hoisted.concat(tree));\n}\n\nfunction hoist(item: LispItem, res: LispArray): boolean {\n  if (Array.isArray(item)) {\n    const rep = [];\n    for (let it of item) {\n      if (!hoist(it, res)) {\n        rep.push(it);\n      }\n    }\n    if (rep.length !== item.length) {\n      item.length = 0;\n      item.push(...rep);\n    }\n  } else if (item instanceof Lisp) {\n    if (item.op === \"try\" || item.op === \"if\" || item.op === \"loop\" || item.op === \"switch\") {\n      hoist(item.a, res);\n      hoist(item.b, res);\n    } else if (item.op === \"var\") {\n      res.push(new Lisp({op: 'var', a: item.a}));\n    } else if (item.op === \"function\" && item.a[1]) {\n      res.push(item);\n      return true;\n    }\n  }\n  return false;\n}\n\nconst edgesForInsertion = [\n  /^([\\w\\$]|\\+\\+|\\-\\-)\\s*\\r?\\n\\s*([\\w\\$\\+\\-])/,\n  /^([^\\w\\$](return|continue|break|throw))\\s*\\r?\\n\\s*[^\\s]/\n];\nconst closingsForInsertion = [\n  /^([\\)\\]])\\s*\\r?\\n\\s*([\\w\\$\\{\\+\\-])/,\n  /^(\\})\\s*\\r?\\n?\\s*([\\(])/,\n  /^(\\})\\s*(\\r?\\n)?\\s*([\\w\\[\\+\\-])/,\n];\nconst closingsNoInsertion = /^(\\})\\s*(catch|finally|else|while|instanceof)(?![\\w\\$])/\nconst whileEnding = /^\\}\\s*while/\n                    //  \\w|)|] \\n \\w = 2                                  // \\} \\w|\\{ = 5 \nconst colonsRegex = /^((([\\w\\$\\]\\)]|\\+\\+|\\-\\-)\\s*\\r?\\n\\s*([\\w\\$\\+\\-\\!~]))|(\\}\\s*[\\w\\$\\!~\\+\\-\\{\\(]))/\n\n// if () \\w \\n; \\w              == \\w \\n \\w    | last === if             a\n// if () { }; \\w                == \\} ^else    | last === if             b\n// if () \\w \\n; else \\n \\w \\n;  == \\w \\n \\w    | last === else           a\n// if () {} else {}; \\w         == \\} \\w       | last === else           b\n// while () \\n \\w \\n; \\w        == \\w \\n \\w    | last === while          a\n// while () { }; \\w             == \\} \\w       | last === while          b\n// do \\w \\n; while (); \\w       == \\w \\n while | last === do             a\n// do { } while (); \\w          == \\) \\w       | last === while          c\n// try {} catch () {}; \\w       == \\} \\w       | last === catch|finally  b\n// \\w \\n; \\w                    == \\w \\n \\w    | last === none           a\n// cb() \\n \\w                   == \\) \\n \\w    | last === none           a\n// obj[a] \\n \\w                 == \\] \\n \\w    | last === none           a\n// {} {}                        == \\} \\{       | last === none           b\n\nexport function insertSemicolons(constants: IConstants, str: string) {\n  let rest = str;\n  let sub = \"\"\n  let res = [];\n  let details: restDetails = {};\n  while (sub = restOfExp(constants, rest, [], undefined, undefined, [colonsRegex], details)) {\n    let valid = false;\n    let part = sub;\n    let edge = sub.length;\n    if (details.regRes) {\n      valid = true;\n      const [,, a,,, b] = details.regRes;\n      edge = details.regRes[3] === \"++\" || details.regRes[3] === \"--\" ? sub.length + 1 : sub.length;\n      part = rest.substring(0,  edge);\n      if (b) {\n        let res = closingsNoInsertion.exec(rest.substring(sub.length - 1));\n        if (res) {\n          if (res[2] === 'while') {\n            valid = details.lastWord !== 'do';\n          } else {\n            valid = false;\n          }\n        } else if (details.lastWord === 'function' && details.regRes[5][0] === \"}\" && details.regRes[5].slice(-1) === '(') {\n          valid = false;\n        } \n\n      } else if (a) {\n        if (details.lastWord === 'if' || details.lastWord === 'while') {\n          valid = false;\n        }\n      }\n      // console.log({details})\n    }\n    res.push(part);\n    if (valid) {\n      res.push(\";\");\n    }\n    // console.log({res})\n    rest = rest.substring(edge);\n    details = {};\n  }\n  // console.log({res})\n  return res.join(\"\");\n}\n\nexport function checkRegex(str: string): IRegEx | null {\n  let i = 1;\n  let escape = false;\n  let done = false;\n  let cancel = false;\n  while (i < str.length && !done && !cancel) {\n    done = (str[i] === '/' && !escape);\n    escape = str[i] === '\\\\' && !escape;\n    cancel = str[i] === '\\n';\n    i++;\n  }\n  let after = str.substring(i);\n  cancel = (cancel || !done) || /^\\s*\\d/.test(after);\n  if (cancel) return null;\n  let flags = /^[a-z]*/.exec(after);\n  if(/^\\s+[\\w\\$]/.test(str.substring(i + flags[0].length))) {\n    return null;\n  }\n  return {\n    regex: str.substring(1, i-1),\n    flags: (flags && flags[0]) || \"\",\n    length: i + ((flags && flags[0].length) || 0)\n  }\n}\n\nconst notDivide = /(typeof|delete|instanceof|return|in|of|throw|new|void|do|if)$/\nconst possibleDivide = /^([\\w\\$\\]\\)]|\\+\\+|\\-\\-)[\\s\\/]/;\nexport function extractConstants(constants: IConstants, str: string, currentEnclosure = \"\"): {str: string, length: number} {\n  let quote;\n  let extract: (string|number)[] = [];\n  let escape = false;\n  let regexFound: IRegEx;\n  let comment = \"\";\n  let commentStart = -1;\n  let currJs: LispArray = toLispArray([]);\n  let char: string = \"\";\n  const strRes: (string|number)[] = [];\n  const enclosures: string[] = [];\n  let isPossibleDivide: RegExpExecArray;\n  const quotes = [];\n  for (var i = 0; i < str.length; i++) {\n    char = str[i];\n    if (comment) {\n      if (char === comment) {\n        if (comment === \"*\" && str[i + 1] ===\"/\") {\n          comment = \"\";\n          i++\n        } else if (comment === \"\\n\") {\n          comment = \"\";\n        }\n      }\n    } else {\n      if (escape) {\n        escape = false;\n        extract.push(char);\n        continue;\n      }\n\n      if (quote) {\n        if (quote === \"`\" && char === \"$\" && str[i+1] === \"{\") {\n          let skip = extractConstants(constants, str.substring(i+2), \"{\");\n          currJs.push(skip.str);\n          extract.push('${', currJs.length - 1, `}`);\n          i += skip.length + 2;\n        } else if (quote === char) {\n          if (quote === '`') {\n            constants.literals.push({\n              op: 'literal',\n              a:  unraw(extract.join(\"\")),\n              b: currJs\n            });\n            strRes.push(`\\``, constants.literals.length - 1, `\\``);\n          } else {\n            constants.strings.push(unraw(extract.join(\"\")));\n            strRes.push(`\"`, constants.strings.length - 1, `\"`);\n          }\n          quote = null;\n          extract = [];\n        } else {\n          extract.push(char);\n        }\n      } else {\n        if ((char === \"'\"  || char === '\"'  || char === '`')) {\n          currJs = toLispArray([]);\n          quote = char;\n        } else if (closings[currentEnclosure] === char && !enclosures.length) {\n          return {str: strRes.join(\"\"), length: i}\n        } else if (closings[char]) {\n          enclosures.push(char);\n          strRes.push(char);\n        } else if (closings[enclosures[enclosures.length-1]] === char) {\n          enclosures.pop();\n          strRes.push(char);\n        } else if (char === \"/\" && (str[i+1] === \"*\" || str[i+1] === \"/\")) {\n          comment = str[i+1] === \"*\" ? \"*\" : \"\\n\";\n          commentStart = i;\n        } else if (char === '/' && !isPossibleDivide && (regexFound = checkRegex(str.substring(i)))) {\n          constants.regexes.push(regexFound);\n          strRes.push(`/`, constants.regexes.length - 1, `/r`);\n          i += regexFound.length - 1;\n        } else {\n          strRes.push(char);\n        }\n\n        if (!isPossibleDivide || !space.test(char)) {\n          if (isPossibleDivide = possibleDivide.exec(str.substring(i))) {\n            if (notDivide.test(str.substring(0, i + isPossibleDivide[1].length))) {\n              isPossibleDivide = null;\n            }\n          }\n        }\n      }\n      escape = quote && char === \"\\\\\";\n    }\n  }\n\n  if (comment) {\n    if (comment === \"*\") {\n      throw new SyntaxError(`Unclosed comment '/*': ${str.substring(commentStart)}`)\n    }\n  }\n  return {str: strRes.join(\"\"), length: i}\n}\nexport function parse(code: string, eager = false): IExecutionTree {\n  if (typeof code !== 'string') throw new ParseError(`Cannot parse ${code}`, code);\n  // console.log('parse', str);\n  let str = ' ' + code;\n  const constants: IConstants = {strings: [], literals: [], regexes: [], eager};\n  str = extractConstants(constants, str).str;\n  // console.log(str);\n\n  for (let l of constants.literals) {\n    l.b = toLispArray(l.b.map((js: string) => lispifyExpr(constants, js)));\n  }\n  return {tree: lispifyFunction(str, constants), constants};\n}\n","import { SpreadArray, LispItem, KeyVal, SpreadObject, If, Lisp, LispArray, toLispArray, parse, IRegEx, lispifyFunction } from \"./parser.js\";\nimport { IExecContext, IContext, Ticks } from \"./Sandbox.js\";\n\n\nexport type SandboxFunction = (code: string, ...args: any[]) => () => any;\nexport type sandboxedEval = (code: string) => any;\nexport type sandboxSetTimeout = (handler: TimerHandler, timeout?: any, ...args: any[]) => any;\nexport type sandboxSetInterval = (handler: TimerHandler, timeout?: any, ...args: any[]) => any;\nexport type Done = (err?: any, res?: any) => void\nexport class ExecReturn {\n  constructor(public auditReport: IAuditReport, public result: any, public returned: boolean, public breakLoop = false, public continueLoop = false) {}\n}\n\nexport interface IAuditReport {\n  globalsAccess: Set<any>;\n  prototypeAccess: {[name: string]: Set<string>}\n}\n\nexport interface IGlobals {\n  [key: string]: any\n}\n\nexport interface IChange {\n  type: string;\n}\n\nexport interface ICreate extends IChange {\n  type: \"create\";\n  prop: number|string;\n}\n\nexport interface IReplace extends IChange {\n  type: \"replace\";\n}\n\nexport interface IDelete extends IChange {\n  type: \"delete\";\n  prop: number|string;\n}\n\nexport interface IReverse extends IChange {\n  type: \"reverse\";\n}\n\nexport interface ISort extends IChange {\n  type: \"sort\";\n}\n\nexport interface IPush extends IChange {\n  type: \"push\";\n  added: unknown[];\n}\n\nexport interface IPop extends IChange {\n  type: \"pop\";\n  removed: unknown[];\n}\n\nexport interface IShift extends IChange {\n  type: \"shift\";\n  removed: unknown[];\n}\n\nexport interface IUnShift extends IChange {\n  type: \"unshift\";\n  added: unknown[];\n}\n\nexport interface ISplice extends IChange {\n  type: \"splice\";\n  startIndex: number;\n  deleteCount: number; \n  added: unknown[];\n  removed: unknown[];\n\n}\n\nexport interface ICopyWithin extends IChange {\n  type: \"copyWithin\";\n  startIndex: number;\n  endIndex: number;\n  added: unknown[];\n  removed: unknown[];\n}\n\nexport type Change = ICreate | IReplace | IDelete | IReverse | ISort | IPush | IPop | IUnShift | IShift | ISplice | ICopyWithin\n\nexport type replacementCallback = (obj: any, isStaticAccess: boolean) => any\n\nexport class Prop {\n  constructor(public context: {[key:string]: any}, public prop: string, public isConst = false, public isGlobal = false, public isVariable = false) {\n  }\n}\n\nconst optional = Symbol('optional');\n\nconst reservedWords = new Set([\n  'instanceof',\n  'typeof',\n  'return',\n  'try',\n  'catch',\n  'if',\n  'finally',\n  'else',\n  'in',\n  'of',\n  'var',\n  'let',\n  'const',\n  'for',\n  'delete',\n  'false',\n  'true',\n  'while',\n  'do',\n  'break',\n  'continue',\n  'new',\n  'function',\n  'async',\n  'await',\n  'switch',\n  'case'\n]);\n\nenum VarType {\n  let = \"let\",\n  const = \"const\",\n  var = \"var\"\n}\n\nexport class Scope {\n  parent: Scope;\n  const: {[key: string]: any} = {};\n  let: {[key: string]: any} = {};\n  var: {[key: string]: any};\n  globals: {[key: string]: any};\n  allVars: {[key:string]: any} & Object;\n  functionThis?: any;\n  constructor(parent: Scope, vars = {}, functionThis?: any) {\n    const isFuncScope = functionThis !== undefined || parent === null;\n    this.parent = parent;\n    this.allVars = vars;\n    this.let = isFuncScope ? this.let : Object.assign({}, vars);\n    this.var = isFuncScope ? Object.assign({}, vars) : this.var;\n    this.globals = parent === null ? Object.assign({}, vars) : new Set();\n    this.functionThis = functionThis;\n  }\n\n  get(key: string, functionScope = false): any {\n    if (key === 'this' && this.functionThis !== undefined) {\n      return new Prop({this: this.functionThis}, key, true, false, true);\n    }\n    if (reservedWords.has(key)) throw new SyntaxError(\"Unexepected token '\" + key + \"'\");\n    if (this.parent === null || !functionScope || this.functionThis !== undefined) {\n      if (this.globals.hasOwnProperty(key)) {\n        return new Prop(this.functionThis, key, false, true, true);\n      }\n      if (key in this.allVars && (!(key in {}) || this.allVars.hasOwnProperty(key))) {\n        return new Prop(this.allVars, key, this.const.hasOwnProperty(key), this.globals.hasOwnProperty(key), true);\n      }\n      if (this.parent === null) {\n        return new Prop(undefined, key);\n      }\n    }\n    return this.parent.get(key, functionScope)\n  }\n\n  set(key: string, val: any) {\n    if (key === 'this') throw new SyntaxError('\"this\" cannot be assigned')\n    if (reservedWords.has(key)) throw new SyntaxError(\"Unexepected token '\" + key + \"'\");\n    let prop = this.get(key);\n    if(prop.context === undefined) {\n      throw new ReferenceError(`Variable '${key}' was not declared.`);\n    }``\n    if (prop.isConst) {\n      throw new TypeError(`Cannot assign to const variable '${key}'`);\n    }\n    if (prop.isGlobal) {\n      throw new SandboxError(`Cannot override global variable '${key}'`);\n    }\n    prop.context[prop] = val;\n    return prop;\n  }\n\n  declare(key: string, type: VarType = null, value: any = undefined, isGlobal = false) {\n    if (key === 'this') throw new SyntaxError('\"this\" cannot be declared');\n    if (reservedWords.has(key)) throw new SyntaxError(\"Unexepected token '\" + key + \"'\");\n    if (type === 'var' && this.functionThis === undefined && this.parent !== null) {\n      return this.parent.declare(key, type, value, isGlobal)\n    } else if ((this[type].hasOwnProperty(key) && type !== 'const' && !this.globals.hasOwnProperty(key)) || !(key in this.allVars)) {\n      if (isGlobal) {\n        this.globals[key] = true;\n      }\n      this[type][key] = true;\n      this.allVars[key] = value;\n    } else {\n      throw new SandboxError(`Identifier '${key}' has already been declared`);\n    }\n    return new Prop(this.allVars, key, this.const.hasOwnProperty(key), isGlobal);\n  }\n}\n\nexport class SandboxError extends Error {\n\n}\n\nlet currentTicks: Ticks;\n\nexport function sandboxFunction(context: IContext): SandboxFunction {\n  return SandboxFunction;\n  function SandboxFunction(...params: any[]) {\n    let code = params.pop() || \"\";\n    let parsed = parse(code);\n    return createFunction(params, parsed.tree, currentTicks, {\n      ctx: context,\n      constants: parsed.constants,\n      tree: parsed.tree\n    }, undefined, 'anonymous');\n  }\n}\n\nfunction generateArgs(argNames: string[], args: unknown[]) {\n  const vars: any = {};\n  argNames.forEach((arg, i) => {\n    if (arg.startsWith('...')) {\n      vars[arg.substring(3)] = args.slice(i);\n    } else {\n      vars[arg] = args[i];\n    }\n  });\n  return vars;\n}\n\nconst sandboxedFunctions = new WeakSet();\nexport function createFunction(argNames: string[], parsed: LispItem, ticks: Ticks, context: IExecContext, scope?: Scope, name?: string) {\n  if (context.ctx.options.forbidFunctionCreation) {\n    throw new SandboxError(\"Function creation is forbidden\");\n  }\n  let func;\n  if (name === undefined) {\n    func = (...args) => {\n      const vars = generateArgs(argNames, args);\n      const res = executeTree(ticks, context, parsed, scope === undefined ? [] : [new Scope(scope, vars)])\n      return res.result;\n    }\n  } else {\n    func = function sandboxedObject(...args) {\n      const vars = generateArgs(argNames, args);\n      const res = executeTree(ticks, context, parsed, scope === undefined ? [] : [new Scope(scope, vars, this)])\n      return res.result;\n    }\n  }\n  sandboxedFunctions.add(func);\n  return func;\n}\n\nexport function createFunctionAsync(argNames: string[], parsed: LispItem, ticks: Ticks, context: IExecContext, scope?: Scope, name?: string) {\n  if (context.ctx.options.forbidFunctionCreation) {\n    throw new SandboxError(\"Function creation is forbidden\");\n  }\n  if (!context.ctx.options.prototypeWhitelist?.has(Promise)) {\n    throw new SandboxError(\"Async/await not permitted\");\n  }\n  let func;\n  if (name === undefined) {\n    func = async (...args) => {\n      const vars = generateArgs(argNames, args);\n      const res = await executeTreeAsync(ticks, context, parsed, scope === undefined ? [] : [new Scope(scope, vars)])\n      return res.result;\n    }\n  } else {\n    func = async function sandboxedObject(...args) {\n      const vars = generateArgs(argNames, args);\n      const res = await executeTreeAsync(ticks, context, parsed, scope === undefined ? [] : [new Scope(scope, vars, this)])\n      return res.result;\n    }\n  }\n  sandboxedFunctions.add(func);\n  return func;\n}\n\nexport function sandboxedEval(func: SandboxFunction): sandboxedEval {\n  return sandboxEval;\n  function sandboxEval(code: string) {\n    return func(code)();\n  }\n}\n\nexport function sandboxedSetTimeout(func: SandboxFunction): sandboxSetTimeout {\n  return function sandboxSetTimeout(handler, ...args) {\n    if (typeof handler !== 'string') return setTimeout(handler, ...args);\n    return setTimeout(func(handler), ...args);\n  }\n}\n\nexport function sandboxedSetInterval(func: SandboxFunction): sandboxSetInterval {\n  return function sandboxSetInterval(handler, ...args) {\n    if (typeof handler !== 'string') return setInterval(handler, ...args);\n    return setInterval(func(handler), ...args);\n  }\n}\n\nexport function assignCheck(obj: Prop, context: IExecContext, op = 'assign') {\n  if(obj.context === undefined) {\n    throw new ReferenceError(`Cannot ${op} value to undefined.`)\n  }\n  if(typeof obj.context !== 'object' && typeof obj.context !== 'function') {\n    throw new SyntaxError(`Cannot ${op} value to a primitive.`)\n  }\n  if (obj.isConst) {\n    throw new TypeError(`Cannot set value to const variable '${obj.prop}'`);\n  }\n  if (obj.isGlobal) {\n    throw new SandboxError(`Cannot ${op} property '${obj.prop}' of a global object`);\n  }\n  if (typeof obj.context[obj.prop] === 'function' && !obj.context.hasOwnProperty(obj.prop)) {\n    throw new SandboxError(`Override prototype property '${obj.prop}' not allowed`);\n  }\n  if (op === \"delete\") {\n    if (obj.context.hasOwnProperty(obj.prop)) {\n      context.ctx.changeSubscriptions.get(obj.context)?.forEach((cb) => cb({type: \"delete\", prop: obj.prop}));\n    }\n  } else if (obj.context.hasOwnProperty(obj.prop)) {\n    context.ctx.setSubscriptions.get(obj.context)?.get(obj.prop)?.forEach((cb) => cb({\n      type: \"replace\"\n    }));\n  } else {\n    context.ctx.changeSubscriptions.get(obj.context)?.forEach((cb) => cb({type: \"create\", prop: obj.prop}));\n  }\n}\nconst arrayChange = new Set([\n  [].push,\n  [].pop,\n  [].shift,\n  [].unshift,\n  [].splice,\n  [].reverse,\n  [].sort,\n  [].copyWithin\n]);\nconst literalRegex = /(\\$\\$)*(\\$)?\\${(\\d+)}/g;\ntype OpCallback = (exec: Execution, done: Done, ticks: Ticks, a: LispItem|string[], b: LispItem|Lisp[], obj: Prop|any|undefined, context: IExecContext, scope: Scope, bobj?: Prop|any|undefined, inLoopOrSwitch?: string) => void;\nlet ops2: {[op:string]: OpCallback} = {\n  'prop': (exec, done, ticks, a: LispItem|any, b: string, obj, context, scope) => {\n    if(a === null) {\n      throw new TypeError(`Cannot get property ${b} of null`);\n    }\n    const type = typeof a;\n    if (type === 'undefined' && obj === undefined) {\n      let prop = scope.get(b);\n      if (prop.context === undefined) throw new ReferenceError(`${b} is not defined`);\n      if (prop.context === context.ctx.sandboxGlobal) {\n        if (context.ctx.options.audit) {\n          context.ctx.auditReport.globalsAccess.add(b);\n        }\n        const rep = context.ctx.globalsWhitelist.has(context.ctx.sandboxGlobal[b]) ? context.ctx.evals.get(context.ctx.sandboxGlobal[b]) : undefined;\n        if (rep) {\n          done(undefined, rep);\n          return;\n        }\n      }\n      if (prop.context && prop.context[b] === globalThis) {\n        done(undefined, context.ctx.globalScope.get('this'));\n        return;\n      }\n\n      context.ctx.getSubscriptions.forEach((cb) => cb(prop.context, prop.prop));\n      done(undefined, prop);\n      return;\n    } else if (a === undefined) {\n      throw new SandboxError(\"Cannot get property '\" + b + \"' of undefined\")\n    }\n\n    if (type !== 'object') {\n      if(type === 'number') {\n        a = new Number(a);\n      } else if(type === 'string') {\n        a = new String(a);\n      } else if(type === 'boolean') {\n        a = new Boolean(a);\n      }\n    } else if (typeof a.hasOwnProperty === 'undefined') {\n      done(undefined, new Prop(undefined, b));\n      return;\n    }\n\n    const isFunction = type === 'function';\n    let prototypeAccess = isFunction || !(a.hasOwnProperty(b) || typeof b === 'number');\n\n    if (context.ctx.options.audit && prototypeAccess) {\n      if (typeof b === 'string') {\n        let prot = a.constructor.prototype;\n        do {\n          if (prot.hasOwnProperty(b)) {\n            if(!context.ctx.auditReport.prototypeAccess[prot.constructor.name]) {\n              context.ctx.auditReport.prototypeAccess[prot.constructor.name] = new Set();\n            }\n            context.ctx.auditReport.prototypeAccess[prot.constructor.name].add(b);\n          }\n        } while(prot = Object.getPrototypeOf(prot))\n      }\n    }\n\n    if (prototypeAccess) {\n      if (isFunction) {\n        if (!['name', 'length', 'constructor'].includes(b) && a.hasOwnProperty(b)) {\n          const whitelist = context.ctx.options.prototypeWhitelist.get(a);\n          const replace = context.ctx.options.prototypeReplacements.get(a);\n          if (replace) {\n            done(undefined, new Prop(replace(a, true), b));\n            return;\n          }\n          if (whitelist && (!whitelist.size || whitelist.has(b))) {\n          } else {\n            throw new SandboxError(`Static method or property access not permitted: ${a.name}.${b}`);\n          }\n        }\n      } else if (b !== 'constructor') {\n        let prot = a.constructor.prototype;\n        do {\n          if (prot.hasOwnProperty(b)) {\n            const whitelist = context.ctx.options.prototypeWhitelist.get(prot.constructor);\n            const replace = context.ctx.options.prototypeReplacements.get(prot.constuctor);\n            if (replace) {\n              done(undefined, new Prop(replace(a, false), b));\n              return;\n            }\n            if (whitelist && (!whitelist.size || whitelist.has(b))) {\n              break;\n            }\n            throw new SandboxError(`Method or property access not permitted: ${prot.constructor.name}.${b}`);\n          }\n        } while(prot = Object.getPrototypeOf(prot));\n      }\n    }\n\n    if (context.ctx.evals.has(a[b])) {\n      done(undefined, context.ctx.evals.get(a[b]));\n      return;\n    }\n    if (a[b] === globalThis) {\n      done(undefined, context.ctx.globalScope.get('this'));\n      return;\n    }\n\n    let g = obj.isGlobal || (isFunction && !sandboxedFunctions.has(a)) || context.ctx.globalsWhitelist.has(a);\n\n    if (!g) {\n      context.ctx.getSubscriptions.forEach((cb) => cb(a, b));\n    }\n    done(undefined, new Prop(a, b, false, g));\n  },\n  'call': (exec, done, ticks, a, b: LispArray, obj, context, scope) => {\n    if (context.ctx.options.forbidFunctionCalls) throw new SandboxError(\"Method calls are not allowed\");\n    if (typeof a !== 'function') {\n      throw new TypeError(`${obj.prop} is not a function`);\n    }\n    const args = b.map((item) => {\n      if (item instanceof SpreadArray) {\n        return [...item.item];\n      } else {\n        return [item];\n      }\n    }).flat();\n    execMany(ticks, exec, toLispArray(args), (err, vals) => {\n      if (err) {\n        done(err);\n        return;\n      }\n      if (typeof obj === 'function') {\n        done(undefined, obj(...vals));\n        return;\n      }\n      if (obj.context[obj.prop] === JSON.stringify && context.ctx.getSubscriptions.size) {\n        const cache = new Set<any>();\n        const recurse = (x: any) => {\n          if (!x || !(typeof x === 'object') || cache.has(x)) return;\n          cache.add(x);\n          for (let y in x) {\n            context.ctx.getSubscriptions.forEach((cb) => cb(x, y));\n            recurse(x[y]);\n          }\n        };\n        recurse(vals[0]);\n      }\n  \n      if (obj.context instanceof Array && arrayChange.has(obj.context[obj.prop]) && context.ctx.changeSubscriptions.get(obj.context)) {\n        let change: Change;\n        let changed = false;\n        if (obj.prop === \"push\") {\n          change = {\n            type: \"push\",\n            added: vals\n          }\n          changed = !!vals.length;\n        } else if (obj.prop === \"pop\") {\n          change = {\n            type: \"pop\",\n            removed: obj.context.slice(-1)\n          }\n          changed = !!change.removed.length;\n        }  else if (obj.prop === \"shift\") {\n          change = {\n            type: \"shift\",\n            removed: obj.context.slice(0, 1)\n          }\n          changed = !!change.removed.length;\n        } else if (obj.prop === \"unshift\") {\n          change = {\n            type: \"unshift\",\n            added: vals\n          }\n          changed = !!vals.length;\n        } else if (obj.prop === \"splice\") {\n          change = {\n            type: \"splice\",\n            startIndex: vals[0],\n            deleteCount: vals[1] === undefined ? obj.context.length : vals[1],\n            added: vals.slice(2),\n            removed: obj.context.slice(vals[0], vals[1] === undefined ? undefined : vals[0] + vals[1])\n          }\n          changed = !!change.added.length || !!change.removed.length;\n        } else if (obj.prop === \"reverse\" || obj.prop === \"sort\") {\n          change = {type: obj.prop}\n          changed = !!obj.context.length;\n        } else if (obj.prop === \"copyWithin\") {\n          let len = vals[2] === undefined ? obj.context.length - vals[1] : Math.min(obj.context.length, vals[2] - vals[1]);\n          change = {\n            type: \"copyWithin\",\n            startIndex: vals[0],\n            endIndex: vals[0] + len,\n            added: obj.context.slice(vals[1], vals[1] + len),\n            removed: obj.context.slice(vals[0], vals[0] + len)\n          }\n          changed = !!change.added.length || !!change.removed.length;\n        }\n        if (changed) {\n          context.ctx.changeSubscriptions.get(obj.context)?.forEach((cb) => cb(change));\n        }\n      }\n      done(undefined, obj.context[obj.prop](...vals));\n    }, scope, context);\n  },\n  'createObject': (exec, done, ticks, a, b: LispArray, obj, context, scope) => {\n    let res = {} as any;\n    for (let item of b as (KeyVal|SpreadObject)[]) {\n      if (item instanceof SpreadObject) {\n        res = {...res, ...item.item};\n      } else {\n        res[item.key] = item.val;\n      }\n    }\n    done(undefined, res);\n  },\n  'keyVal': (exec, done, ticks, a: string, b: LispItem) => done(undefined, new KeyVal(a, b)),\n  'createArray': (exec, done, ticks, a, b: LispArray, obj, context, scope) => {\n    const items = b.map((item) => {\n      if (item instanceof SpreadArray) {\n        return [...item.item];\n      } else {\n        return [item];\n      }\n    }).flat()\n    execMany(ticks, exec, toLispArray(items), done, scope, context);\n  },\n  'group': (exec, done, ticks, a, b) => done(undefined, b),\n  'string': (exec, done, ticks, a, b: string, obj, context) => done(undefined, context.constants.strings[b]),\n  'regex': (exec, done, ticks, a, b: string, obj, context) => {\n    const reg: IRegEx = context.constants.regexes[b];\n    if (!context.ctx.globalsWhitelist.has(RegExp)) {\n      throw new SandboxError(\"Regex not permitted\");\n    } else {\n      done(undefined, new RegExp(reg.regex, reg.flags));\n    }\n  },\n  'literal': (exec, done, ticks, a, b: number, obj, context, scope) => {\n    let name: string = context.constants.literals[b].a;\n    let found = toLispArray([]);\n    let f;\n    let resnums = [];\n    while(f = literalRegex.exec(name)) {\n      if (!f[2]) {\n        found.push(context.constants.literals[b].b[parseInt(f[3], 10)]);\n        resnums.push(f[3]);\n      }\n    }\n\n    execMany(ticks, exec, found, (err, processed) => {\n      const reses = {};\n      if(err) {\n        done(err);\n        return;\n      }\n      for (let i in resnums) {\n        const num = resnums[i];\n        reses[num] = processed[i];\n      }\n      done(undefined, name.replace(/(\\\\\\\\)*(\\\\)?\\${(\\d+)}/g, (match, $$, $, num) => {\n        if ($) return match;\n        let res = reses[num]\n        res =  res instanceof Prop ? res.context[res.prop] : res;\n        return ($$ ? $$ : '') + `${res}`;\n      }));\n    }, scope, context)\n  },\n  'spreadArray': (exec, done, ticks, a, b: LispItem, obj, context, scope) => {\n    exec(ticks, b, scope, context, (err, res) => {\n      if (err) {\n        done(err);\n        return;\n      }\n      done(undefined, new SpreadArray(res));\n    });\n  },\n  'spreadObject': (exec, done, ticks, a, b: LispItem, obj, context, scope) => {\n    exec(ticks, b, scope, context, (err, res) => {\n      if (err) {\n        done(err);\n        return;\n      }\n      done(undefined, new SpreadObject(res));\n    });\n  },\n  '!': (exec, done, ticks, a, b) => done(undefined, !b),\n  '~': (exec, done, ticks, a, b) => done(undefined, ~b),\n  '++$': (exec, done, ticks, a, b, obj, context) => {\n    assignCheck(obj, context);\n    done(undefined, ++obj.context[obj.prop]);\n  },\n  '$++': (exec, done, ticks, a, b, obj, context) => {\n    assignCheck(obj, context);\n    done(undefined, obj.context[obj.prop]++);\n  },\n  '--$': (exec, done, ticks, a, b, obj, context) => {\n    assignCheck(obj, context);\n    done(undefined, --obj.context[obj.prop]);\n  },\n  '$--': (exec, done, ticks, a, b, obj, context) => {\n    assignCheck(obj, context);\n    done(undefined, obj.context[obj.prop]--);\n  },\n  '=': (exec, done, ticks, a, b, obj, context) => {\n    assignCheck(obj, context);\n    obj.context[obj.prop] = b;\n    done(undefined, new Prop(obj.context, obj.prop, false, obj.isGlobal));\n  },\n  '+=': (exec, done, ticks, a, b, obj, context) => {\n    assignCheck(obj, context);\n    done(undefined, obj.context[obj.prop] += b);\n  },\n  '-=': (exec, done, ticks, a, b: number, obj, context) => {\n    assignCheck(obj, context);\n    done(undefined, obj.context[obj.prop] -= b);\n  },\n  '/=': (exec, done, ticks, a, b: number, obj, context) => {\n    assignCheck(obj, context);\n    done(undefined, obj.context[obj.prop] /= b);\n  },\n  '*=': (exec, done, ticks, a, b: number, obj, context) => {\n    assignCheck(obj, context);\n    done(undefined, obj.context[obj.prop] *= b);\n  },\n  '**=': (exec, done, ticks, a, b: number, obj, context) => {\n    assignCheck(obj, context);\n    done(undefined, obj.context[obj.prop] **= b);\n  },\n  '%=': (exec, done, ticks, a, b: number, obj, context) => {\n    assignCheck(obj, context);\n    done(undefined, obj.context[obj.prop] %= b);\n  },\n  '^=': (exec, done, ticks, a, b: number, obj, context) => {\n    assignCheck(obj, context);\n    done(undefined, obj.context[obj.prop] ^= b);\n  },\n  '&=': (exec, done, ticks, a, b: number, obj, context) => {\n    assignCheck(obj, context);\n    done(undefined, obj.context[obj.prop] &= b);\n  },\n  '|=': (exec, done, ticks, a, b: number, obj, context) => {\n    assignCheck(obj, context);\n    done(undefined, obj.context[obj.prop] |= b);\n  },\n  '<<=': (exec, done, ticks, a, b: number, obj, context) => {\n    assignCheck(obj, context);\n    done(undefined, obj.context[obj.prop] <<= b);\n  },\n  '>>=': (exec, done, ticks, a, b: number, obj, context) => {\n    assignCheck(obj, context);\n    done(undefined, obj.context[obj.prop] >>= b);\n  },\n  '>>>=': (exec, done, ticks, a, b: number, obj, context) => {\n    assignCheck(obj, context);\n    done(undefined, obj.context[obj.prop] >>= b);\n  },\n  '?': (exec, done, ticks, a, b) => {\n    if (!(b instanceof If)) {\n      throw new SyntaxError('Invalid inline if')\n    }\n    done(undefined, a ? (b as any).t : (b as any).f);\n  },\n  '>': (exec, done, ticks, a, b) => done(undefined, a > b),\n  '<': (exec, done, ticks, a, b) => done(undefined, a < b),\n  '>=': (exec, done, ticks, a, b) => done(undefined, a >= b),\n  '<=': (exec, done, ticks, a, b) => done(undefined, a <= b),\n  '==': (exec, done, ticks, a, b) => done(undefined, a == b),\n  '===': (exec, done, ticks, a, b) => done(undefined, a === b),\n  '!=': (exec, done, ticks, a, b) => done(undefined, a != b),\n  '!==': (exec, done, ticks, a, b) => done(undefined, a !== b),\n  '&&': (exec, done, ticks, a, b) => done(undefined, a && b),\n  '||': (exec, done, ticks, a, b) => done(undefined, a || b),\n  '&': (exec, done, ticks, a: number, b: number) => done(undefined, a & b),\n  '|': (exec, done, ticks, a: number, b: number) => done(undefined, a | b),\n  ':': (exec, done, ticks, a, b) => done(undefined, new If(a, b)),\n  '+': (exec, done, ticks, a: number, b: number) => done(undefined, a + b),\n  '-': (exec, done, ticks, a: number, b: number) => done(undefined, a - b),\n  '$+': (exec, done, ticks, a, b) => done(undefined, +b),\n  '$-': (exec, done, ticks, a, b) => done(undefined, -b),\n  '/': (exec, done, ticks, a: number, b: number) => done(undefined, a / b),\n  '^': (exec, done, ticks, a: number, b: number) => done(undefined, a ^ b),\n  '*': (exec, done, ticks, a: number, b: number) => done(undefined, a * b),\n  '%': (exec, done, ticks, a: number, b: number) => done(undefined, a % b),\n  '<<': (exec, done, ticks, a: number, b: number) => done(undefined, a << b),\n  '>>': (exec, done, ticks, a: number, b: number) => done(undefined, a >> b),\n  '>>>': (exec, done, ticks, a: number, b: number) => done(undefined, a >>> b),\n  'typeof': (exec, done, ticks, a, b) => done(undefined, typeof b),\n  'instanceof': (exec, done, ticks, a, b:  { new(): any }) => done(undefined, a instanceof b),\n  'in': (exec, done, ticks, a: string, b) => done(undefined, a in b),\n  'delete': (exec, done, ticks, a, b, obj, context, scope, bobj: Prop) => {\n    if (bobj.context === undefined) {\n      done(undefined, true);\n      return;\n    }\n    assignCheck(bobj, context, 'delete');\n    if (bobj.isVariable) {\n      done(undefined, false);\n      return;\n    }\n    done(undefined, delete bobj.context[bobj.prop]);\n  },\n  'return': (exec, done, ticks, a, b, obj, context) => done(undefined, b),\n  'var': (exec, done, ticks, a: string, b: LispItem, obj, context, scope, bobj) => {\n    exec(ticks, b, scope, context, (err, res) => {\n      if (err) {\n        done(err);\n        return;\n      }\n      done(undefined, scope.declare(a, VarType.var, res));\n    });\n  },\n  'let': (exec, done, ticks, a: string, b: LispItem, obj, context, scope, bobj) => {\n    exec(ticks, b, scope, context, (err, res) => {\n      if (err) {\n        done(err);\n        return;\n      }\n      done(undefined, scope.declare(a, VarType.let, res, bobj && bobj.isGlobal));\n    });\n  },\n  'const': (exec, done, ticks, a: string, b: LispItem, obj, context, scope, bobj) => {\n    exec(ticks, b, scope, context, (err, res) => {\n      if (err) {\n        done(err);\n        return;\n      }\n      done(undefined, scope.declare(a, VarType.const, res));\n    });\n  },\n  'arrowFunc': (exec, done, ticks, a: string[], b: LispItem, obj: Lisp, context, scope) => {\n    a = [...a];\n    if (typeof obj.b === \"string\") {\n      obj.b = b = lispifyFunction(obj.b, context.constants);\n    }\n    if (a.shift()) {\n      done(undefined, createFunctionAsync(a, b, ticks, context, scope));\n    } else {\n      done(undefined, createFunction(a, b, ticks, context, scope));\n    }\n  },\n  'function': (exec, done, ticks, a: string[]&LispArray, b: LispItem, obj: Lisp, context, scope) => {\n    if (typeof obj.b === \"string\") {\n      obj.b = b = lispifyFunction(obj.b, context.constants);\n    }\n    let isAsync = a.shift();\n    let name = a.shift();\n    let func;\n    if (isAsync) {\n      func = createFunctionAsync(a, b, ticks, context, scope, name);\n    } else {\n      func = createFunction(a, b, ticks, context, scope, name);\n    }\n    if (name) {\n      scope.declare(name, VarType.var, func);\n    }\n    done(undefined, func);\n  },\n  'inlineFunction': (exec, done, ticks, a: string[]&LispArray, b: LispItem, obj: Lisp, context, scope) => {\n    if (typeof obj.b === \"string\") {\n      obj.b = b = lispifyFunction(obj.b, context.constants);\n    }\n    let isAsync = a.shift();\n    let name = a.shift();\n    if (name) {\n      scope = new Scope(scope, {})\n    }\n    let func;\n    if (isAsync) {\n      func = createFunctionAsync(a, b, ticks, context, scope, name);\n    } else {\n      func = createFunction(a, b, ticks, context, scope, name);\n    }\n    if (name) {\n      scope.declare(name, VarType.let, func);\n    }\n    done(undefined, func);\n  },\n  'loop': (exec, done, ticks, a: LispArray, b: LispItem, obj, context, scope) => {\n    const [checkFirst, startInternal, getIterator, startStep, step, condition, beforeStep] = a;\n    let loop = true;\n    const loopScope = new Scope(scope, {});\n    let internalVars = {\n      '$$obj': undefined\n    };\n    const interalScope = new Scope(loopScope, internalVars);\n    if (exec === execAsync) {\n      (async() => {\n        await asyncDone((d) => exec(ticks, startStep, loopScope, context, d));\n        internalVars['$$obj'] = (await asyncDone((d) => exec(ticks, getIterator, loopScope, context, d))).result;\n        await asyncDone((d) => exec(ticks, startInternal, interalScope, context, d));\n        if (checkFirst) loop = (await asyncDone((d) => exec(ticks, condition, interalScope, context, d))).result;\n        while (loop) {\n          let innerLoopVars = {};\n          await asyncDone((d) => exec(ticks, beforeStep, new Scope(interalScope, innerLoopVars), context, d));\n          let res = await executeTreeAsync(ticks, context, b, [new Scope(loopScope, innerLoopVars)], \"loop\");\n          if (res instanceof ExecReturn && res.returned) {\n            done(undefined, res);\n            return;\n          }\n          if (res instanceof ExecReturn && res.breakLoop) {\n            break;\n          }\n          await asyncDone((d) => exec(ticks, step, interalScope, context, d));\n          loop = (await asyncDone((d) => exec(ticks, condition, interalScope, context, d))).result;\n        }\n        done();\n      })().catch(done);\n    } else {\n      syncDone((d) => exec(ticks, startStep, loopScope, context, d));\n      internalVars['$$obj'] = syncDone((d) => exec(ticks, getIterator, loopScope, context, d)).result;\n      syncDone((d) => exec(ticks, startInternal, interalScope, context, d));\n      if (checkFirst) loop = (syncDone((d) => exec(ticks, condition, interalScope, context, d))).result;\n      while (loop) {\n        let innerLoopVars = {};\n        syncDone((d) => exec(ticks, beforeStep, new Scope(interalScope, innerLoopVars), context, d));\n        let res = executeTree(ticks, context, b, [new Scope(loopScope, innerLoopVars)], \"loop\");\n        if (res instanceof ExecReturn && res.returned) {\n          done(undefined, res);\n          return;\n        }\n        if (res instanceof ExecReturn && res.breakLoop) {\n          break;\n        }\n        syncDone((d) => exec(ticks, step, interalScope, context, d));\n        loop = (syncDone((d) => exec(ticks, condition, interalScope, context, d))).result;\n      }\n      done();\n    }\n  },\n  'loopAction': (exec, done, ticks, a: LispItem, b: LispItem, obj, context, scope, bobj, inLoopOrSwitch) => {\n    if ((inLoopOrSwitch === \"switch\" && a === \"continue\") || !inLoopOrSwitch) {\n      throw new SandboxError(\"Illegal \" + a + \" statement\");\n    }\n    done(undefined, new ExecReturn(context.ctx.auditReport, undefined, false, a === \"break\", a === \"continue\"));\n  },\n  'if': (exec, done, ticks, a: LispItem, b: If, obj, context, scope, bobj, inLoopOrSwitch) => {\n    if (!(b instanceof If)) {\n      throw new SyntaxError('Invalid if')\n    }\n    exec(ticks, a, scope, context, (err, res) => {\n      if (err) {\n        done(err);\n        return;\n      }\n      executeTreeWithDone(exec, done, ticks, context, res ? b.t : b.f, [new Scope(scope)], inLoopOrSwitch);\n    });\n  },\n  'switch': (exec, done, ticks, a: LispItem, b: Lisp[], obj, context, scope) => {\n    exec(ticks, a, scope, context, (err, toTest) => {\n      if (err) {\n        done(err);\n        return;\n      }\n      if (exec === execSync) {\n        let res: ExecReturn;\n        let isTrue = false;\n        for (let caseItem of b) {\n          if (isTrue || (isTrue = !caseItem.a || toTest === valueOrProp((syncDone((d) => exec(ticks, caseItem.a, scope, context, d))).result))) {\n            if (!caseItem.b) continue;\n            res = executeTree(ticks, context, caseItem.b, [scope], \"switch\");\n            if (res.breakLoop) break;\n            if (res.returned) {\n              done(undefined, res);\n              return;\n            }\n            if (!caseItem.a) { // default case\n              break;\n            }\n          }\n        }\n        done();\n      } else {\n        (async () => {\n          let res: ExecReturn;\n          let isTrue = false;\n          for (let caseItem of b) {\n            if (isTrue || (isTrue = !caseItem.a || toTest === valueOrProp((await asyncDone((d) => exec(ticks, caseItem.a, scope, context, d))).result))) {\n              if (!caseItem.b) continue;\n              res = await executeTreeAsync(ticks, context, caseItem.b, [scope], \"switch\");\n              if (res.breakLoop) break;\n              if (res.returned) {\n                done(undefined, res);\n                return;\n              }\n              if (!caseItem.a) { // default case\n                break;\n              }\n            }\n          }\n          done();\n        })().catch(done)\n      }\n    });\n  },\n  'try': (exec, done, ticks, a: LispItem, b: [string, LispItem, LispItem]&LispArray, obj, context, scope, bobj, inLoopOrSwitch) => {\n    const [exception, catchBody, finallyBody] = b;\n    executeTreeWithDone(exec, (err, res) => {\n      executeTreeWithDone(exec, (e) => {\n        if (e) done(e);\n        else  if (err) {\n          let sc = {};\n          if (exception) sc[exception] = err;\n          executeTreeWithDone(exec, done, ticks, context, catchBody, [new Scope(scope)], inLoopOrSwitch);\n        } else {\n          done(undefined, res);\n        }\n      }, ticks, context, finallyBody, [new Scope(scope, {})]);\n    }, ticks, context, a, [new Scope(scope)], inLoopOrSwitch);\n  },\n  'void': (exec, done, ticks, a) => {done()},\n  'new': (exec, done, ticks, a: new (...args: any[]) => any, b: any, obj, context) => {\n    if (!context.ctx.globalsWhitelist.has(a) && !sandboxedFunctions.has(a)) {\n      throw new SandboxError(`Object construction not allowed: ${a.constructor.name}`)\n    }\n    done(undefined, new a(...b))\n  },\n  'throw': (exec, done, ticks, a) => { done(a) },\n  'multi': (exec, done, ticks, a: any[]) => done(undefined, a.pop())\n}\n\nexport let ops = new Map<string, OpCallback>();\nfor (let op in ops2) {\n  ops.set(op, ops2[op]);\n}\n\nfunction valueOrProp(a: any) {\n  if (a instanceof Prop) return a.context[a.prop];\n  return a;\n}\n\nexport function execMany(ticks: Ticks, exec: Execution, tree: LispArray, done: Done, scope: Scope, context: IExecContext, inLoopOrSwitch?: string) {\n  if (exec === execSync) {\n    _execManySync(ticks, tree, done, scope, context, inLoopOrSwitch);\n  } else {\n    _execManyAsync(ticks, tree, done, scope, context, inLoopOrSwitch).catch(done);\n  }\n}\n\nfunction _execManySync(ticks: Ticks, tree: LispArray, done: Done, scope: Scope, context: IExecContext, inLoopOrSwitch?: string) {\n  let ret = [];\n  for (let i = 0; i < tree.length; i++) {\n    let res;\n    try {\n      res = syncDone((d) => execSync(ticks, tree[i], scope, context, d, inLoopOrSwitch)).result;\n    } catch(e) {\n      done(e);\n      return;\n    }\n    if (res instanceof ExecReturn && (res.returned || res.breakLoop || res.continueLoop)) {\n      done(undefined, res);\n      return;\n    }\n    ret.push(res);\n  }\n  done(undefined, ret);\n}\n\nasync function _execManyAsync(ticks: Ticks, tree: LispArray, done: Done, scope: Scope, context: IExecContext, inLoopOrSwitch?: string) {\n  let ret = [];\n  for (let i = 0; i < tree.length; i++) {\n    let res;\n    try {\n      res = (await asyncDone((d) => execAsync(ticks, tree[i], scope, context, d, inLoopOrSwitch))).result;\n    } catch(e) {\n      done(e);\n      return;\n    }\n    if (res instanceof ExecReturn && (res.returned || res.breakLoop || res.continueLoop)) {\n      done(undefined, res);\n      return;\n    }\n    ret.push(res);\n  }\n  done(undefined, ret);\n}\n\ntype Execution = (ticks: Ticks, tree: LispItem, scope: Scope, context: IExecContext, done: Done, inLoopOrSwitch?: string) => void\n\nexport function asyncDone(callback: (done: Done) => void): Promise<{result: any}> {\n  return new Promise((resolve, reject) => {\n    callback((err, result) => {\n      if (err) reject(err);\n      else resolve({result});\n    });\n  });\n}\n\nexport function syncDone(callback: (done: Done) => void): {result: any} {\n  let result;\n  let err;\n  callback((e, r) => {\n    err = e;\n    result = r;\n  });\n  if (err) throw err;\n  return {result};\n}\n\nexport function execAsync(ticks: Ticks, tree: LispItem, scope: Scope, context: IExecContext, done: Done, inLoopOrSwitch?: string): Promise<void> {\n  return new Promise((resolve, reject) => {\n    execWithDone(ticks, tree, scope, context, (e, r) => {\n      done(e, r);\n      resolve();\n    }, true, inLoopOrSwitch);\n  });\n}\n\n\nexport function execSync(ticks: Ticks, tree: LispItem, scope: Scope, context: IExecContext, done: Done, inLoopOrSwitch?: string): void {\n  execWithDone(ticks, tree, scope, context, done, false, inLoopOrSwitch);\n}\n\nfunction execWithDone(ticks: Ticks, tree: LispItem, scope: Scope, context: IExecContext, done: Done, isAsync: boolean, inLoopOrSwitch?: string): void {\n  const exec = isAsync ? execAsync : execSync;\n\n  if (context.ctx.options.executionQuota <= ticks.ticks) {\n    if (typeof context.ctx.options.onExecutionQuotaReached === 'function' && context.ctx.options.onExecutionQuotaReached(ticks, scope, context, tree)) {\n      \n    } else {\n      throw new SandboxError(\"Execution quota exceeded\");\n    }\n  }\n  ticks.ticks++;\n  currentTicks = ticks;\n\n  if (tree instanceof Prop) {\n    done(undefined, tree.context[tree.prop]);\n  } else if (Array.isArray(tree) && tree.lisp) {\n    execMany(ticks, exec, tree, done, scope, context, inLoopOrSwitch);\n  } else if (!(tree instanceof Lisp)) {\n    done(undefined, tree);\n  } else if (['arrowFunc', 'function', 'inlineFunction', 'loop', 'try', 'switch', 'if'].includes(tree.op)) {\n    try {\n      ops.get(tree.op)(exec, done, ticks, tree.a, tree.b, tree, context, scope, undefined, inLoopOrSwitch);\n    } catch (err) {\n      done(err);\n    }\n  } else if (tree.op === 'await') {\n    if (!isAsync) {\n      done(new SandboxError(\"Illegal use of 'await', must be inside async function\"));\n    } else if (context.ctx.options.prototypeWhitelist?.has(Promise)) {\n      execAsync(ticks, tree.a, scope, context, async (e, r) => {\n        if (e) done(e);\n        else done(undefined, await r);\n      }, inLoopOrSwitch).catch(done);\n    } else {\n      done(new SandboxError('Async/await is not permitted'))\n    }\n  } else {\n    execWithDone(ticks, tree.a, scope, context, (e, obj) => {\n      if (e) {\n        done(e);\n        return;\n      }\n      let a = obj instanceof Prop ? (obj.context ? obj.context[obj.prop] : undefined) : obj;\n      let op = tree.op;\n      if (op === '?prop' || op === '?call') {\n        if (a === undefined || a === null) {\n          done(undefined, optional);\n          return;\n        }\n        op = op.slice(1);\n      }\n      if (a === optional) {\n        if (op === 'prop' || op === 'call') {\n          done(undefined, a);\n          return;\n        } else {\n          a = undefined;\n        }\n      }\n      execWithDone(ticks, tree.b, scope, context, (e, bobj) => {\n        if (e) {\n          done(e);\n          return;\n        }\n        let b = bobj instanceof Prop ? (bobj.context ? bobj.context[bobj.prop] : undefined) : bobj;\n        if (b === optional) {\n          b = undefined;\n        }\n        if (ops.has(op)) {\n          try {\n            ops.get(op)(exec, done, ticks, a, b, obj, context, scope, bobj, inLoopOrSwitch);\n          } catch (err) {\n            done(err);\n          }\n        } else {\n          done(new SyntaxError('Unknown operator: ' + op));\n        }\n      }, isAsync, inLoopOrSwitch);\n    }, isAsync, inLoopOrSwitch);\n  }\n}\n\nexport function executeTree(ticks: Ticks, context: IExecContext, executionTree: LispItem, scopes: ({[key:string]: any}|Scope)[] = [], inLoopOrSwitch?: string): ExecReturn {\n  return syncDone((done) => executeTreeWithDone(execSync, done, ticks, context, executionTree, scopes, inLoopOrSwitch)).result;\n}\n\nexport async function executeTreeAsync(ticks: Ticks, context: IExecContext, executionTree: LispItem, scopes: ({[key:string]: any}|Scope)[] = [], inLoopOrSwitch?: string): Promise<ExecReturn> {\n  return (await asyncDone((done) => executeTreeWithDone(execAsync, done, ticks, context, executionTree, scopes, inLoopOrSwitch))).result;\n}\n\nfunction executeTreeWithDone(exec: Execution, done: Done, ticks: Ticks, context: IExecContext, executionTree: LispItem, scopes: ({[key:string]: any}|Scope)[] = [], inLoopOrSwitch?: string) {\n  if (!executionTree)  {\n    done();\n    return;\n  }\n  if (!(executionTree instanceof Array)) throw new SyntaxError('Bad execution tree');\n  let scope = context.ctx.globalScope;\n  let s;\n  while (s = scopes.shift()) {\n    if (typeof s !== \"object\") continue;\n    if (s instanceof Scope) {\n      scope = s;\n    } else {\n      scope = new Scope(scope, s, null);\n    }\n  }\n  if (context.ctx.options.audit && !context.ctx.auditReport) {\n    context.ctx.auditReport = {\n      globalsAccess: new Set(),\n      prototypeAccess: {},\n    }\n  }\n  if (exec === execSync) {\n    _executeWithDoneSync(done, ticks, context, executionTree, scope, inLoopOrSwitch);\n  } else {\n    _executeWithDoneAsync(done, ticks, context, executionTree, scope, inLoopOrSwitch).catch(done);\n  }\n}\n\nfunction _executeWithDoneSync(done: Done, ticks: Ticks, context: IExecContext, executionTree: LispItem, scope: Scope, inLoopOrSwitch?: string) {\n  if (!(executionTree instanceof Array)) throw new SyntaxError('Bad execution tree');\n  let i = 0;\n  for (i = 0; i < executionTree.length; i++) {\n    let res;\n    let err;\n    const current = executionTree[i];\n    try {\n      execSync(ticks, current, scope, context, (e, r) => {\n        err = e;\n        res = r;\n      }, inLoopOrSwitch);\n    } catch (e) {\n      err = e;\n    }\n    if (err) {\n      done(err);\n      return;\n    }\n    if (res instanceof ExecReturn) {\n      done(undefined, res);\n      return;\n    }\n    if (current instanceof Lisp && current.op === 'return') {\n      done(undefined, new ExecReturn(context.ctx.auditReport, res, true))\n      return;\n    }\n  }\n  done(undefined, new ExecReturn(context.ctx.auditReport, undefined, false));\n}\n\nasync function _executeWithDoneAsync(done: Done, ticks: Ticks, context: IExecContext, executionTree: LispItem, scope: Scope, inLoopOrSwitch?: string) {\n  if (!(executionTree instanceof Array)) throw new SyntaxError('Bad execution tree');\n  let i = 0;\n  for (i = 0; i < executionTree.length; i++) {\n    let res;\n    let err;\n    const current = executionTree[i];\n    try {\n      await execAsync(ticks, current, scope, context, (e, r) => {\n        err = e;\n        res = r;\n      }, inLoopOrSwitch);\n    } catch (e) {\n      err = e;\n    }\n    if (err) {\n      done(err);\n      return;\n    }\n    if (res instanceof ExecReturn) {\n      done(undefined, res);\n      return;\n    }\n    if (current instanceof Lisp && current.op === 'return') {\n      done(undefined, new ExecReturn(context.ctx.auditReport, res, true))\n      return;\n    }\n  }\n  done(undefined, new ExecReturn(context.ctx.auditReport, undefined, false));\n}\n","import { \n  IGlobals, \n  replacementCallback, \n  IAuditReport, \n  Scope, \n  Change, \n  sandboxFunction,\n  sandboxedEval,\n  sandboxedSetTimeout,\n  sandboxedSetInterval,\n  ExecReturn,\n  executeTree,\n  executeTreeAsync,\n  ops,\n  assignCheck,\n  execMany,\n  execAsync,\n  execSync,\n  asyncDone,\n  syncDone\n} from \"./executor.js\";\nimport { parse, IExecutionTree, expectTypes, setLispType, LispItem } from \"./parser.js\";\n\n\nexport const extend = () => ({\n  expectTypes,\n  setLispType,\n  executionOps: ops,\n  assignCheck,\n  execMany,\n  execAsync,\n  execSync,\n  asyncDone,\n  syncDone,\n  executeTree,\n  executeTreeAsync,\n});\n\nexport interface IOptions {\n  audit?: boolean;\n  forbidFunctionCalls?: boolean;\n  forbidFunctionCreation?: boolean;\n  prototypeReplacements?: Map<new () => any, replacementCallback>;\n  prototypeWhitelist?: Map<any, Set<string>>;\n  globals: IGlobals;\n  executionQuota?: bigint;\n  onExecutionQuotaReached?: (ticks: Ticks, scope: Scope, context: IExecutionTree, tree: LispItem) => boolean|void;\n}\n\nexport interface IContext {\n  sandbox: Sandbox;\n  globalScope: Scope;\n  sandboxGlobal: SandboxGlobal;\n  globalsWhitelist?: Set<any>;\n  options: IOptions;\n  evals: Map<any, any>;\n  getSubscriptions: Set<(obj: object, name: string) => void>;\n  setSubscriptions: WeakMap<object, Map<string, Set<(modification: Change) => void>>>;\n  changeSubscriptions: WeakMap<object, Set<(modification: Change) => void>>;\n  auditReport?: IAuditReport;\n}\n\nexport interface Ticks {\n  ticks: bigint;\n}\n\nexport interface IExecContext extends IExecutionTree {\n  ctx: IContext\n}\n\nexport class SandboxGlobal {\n  constructor(globals: IGlobals) {\n    if (globals === globalThis) return globalThis;\n    for (let i in globals) {\n      (this as any)[i] = globals[i];\n    }\n  }\n}\n\nexport default class Sandbox {\n  context: IContext\n  constructor(options?: IOptions) {\n    options = Object.assign({\n      audit: false,\n      forbidFunctionCalls: false,\n      forbidFunctionCreation: false,\n      globals: Sandbox.SAFE_GLOBALS,\n      prototypeWhitelist: Sandbox.SAFE_PROTOTYPES, \n      prototypeReplacements: new Map<new() => any, replacementCallback>(),\n    }, options || {});\n    const sandboxGlobal = new SandboxGlobal(options.globals);\n    this.context = {\n      sandbox: this,\n      globalsWhitelist: new Set(Object.values(options.globals)),\n      options,\n      globalScope: new Scope(null, options.globals, sandboxGlobal),\n      sandboxGlobal,\n      evals: new Map(),\n      getSubscriptions: new Set<(obj: object, name: string) => void>(),\n      setSubscriptions: new WeakMap<object, Map<string, Set<() => void>>>(),\n      changeSubscriptions: new WeakMap()\n    };\n    const func = sandboxFunction(this.context);\n    this.context.evals.set(Function, func);\n    this.context.evals.set(eval, sandboxedEval(func));\n    this.context.evals.set(setTimeout, sandboxedSetTimeout(func));\n    this.context.evals.set(setInterval, sandboxedSetInterval(func));\n  }\n\n  static get SAFE_GLOBALS(): IGlobals {\n    return {\n      Function,\n      console: {\n        debug: console.debug, \n        error: console.error, \n        info: console.info, \n        log: console.log, \n        table: console.table, \n        warn: console.warn\n      },\n      isFinite,\n      isNaN,\n      parseFloat,\n      parseInt,\n      decodeURI,\n      decodeURIComponent,\n      encodeURI,\n      encodeURIComponent,\n      escape,\n      unescape,\n      Boolean,\n      Number,\n      BigInt,\n      String,\n      Object,\n      Array,\n      Symbol,\n      Error,\n      EvalError,\n      RangeError,\n      ReferenceError,\n      SyntaxError,\n      TypeError,\n      URIError,\n      Int8Array,\n      Uint8Array,\n      Uint8ClampedArray,\n      Int16Array,\n      Uint16Array,\n      Int32Array,\n      Uint32Array,\n      Float32Array,\n      Float64Array,\n      Map,\n      Set,\n      WeakMap,\n      WeakSet,\n      Promise,\n      Intl,\n      JSON,\n      Math,\n      Date,\n      RegExp\n    }\n  }\n\n  \n  static get SAFE_PROTOTYPES(): Map<any, Set<string>> {\n    let protos = [\n      SandboxGlobal,\n      Function,\n      Boolean,\n      Number,\n      BigInt,\n      String,\n      Date,\n      Error,\n      Array,\n      Int8Array,\n      Uint8Array,\n      Uint8ClampedArray,\n      Int16Array,\n      Uint16Array,\n      Int32Array,\n      Uint32Array,\n      Float32Array,\n      Float64Array,\n      Map,\n      Set,\n      WeakMap,\n      WeakSet,\n      Promise,\n      Symbol,\n      Date,\n      RegExp\n    ]\n    let map = new Map<any, Set<string>>();\n    protos.forEach((proto) => {\n      map.set(proto, new Set());\n    });\n    map.set(Object, new Set([\n      'entries',\n      'fromEntries',\n      'getOwnPropertyNames',\n      'is',\n      'keys',\n      'hasOwnProperty',\n      'isPrototypeOf',\n      'propertyIsEnumerable',\n      'toLocaleString',\n      'toString',\n      'valueOf',\n      'values'\n    ]));\n    return map;\n  }\n  \n  subscribeGet(callback: (obj: object, name: string) => void): {unsubscribe: () => void} {\n    this.context.getSubscriptions.add(callback);\n    return {unsubscribe: () => this.context.getSubscriptions.delete(callback)}\n  }\n\n  subscribeSet(obj: object, name: string, callback: (modification: Change) => void): {unsubscribe: () => void} {\n    const names = this.context.setSubscriptions.get(obj) || new Map<string, Set<(modification: Change) => void>>();\n    this.context.setSubscriptions.set(obj, names);\n    const callbacks = names.get(name) || new Set();\n    names.set(name, callbacks);\n    callbacks.add(callback);\n    let changeCbs: Set<(modification: Change) => void>;\n    if (obj && obj[name] && typeof obj[name] === \"object\") {\n      changeCbs = this.context.changeSubscriptions.get(obj[name]) || new Set();\n      changeCbs.add(callback);\n      this.context.changeSubscriptions.set(obj[name], changeCbs);\n    }\n    return {unsubscribe: () => {\n      callbacks.delete(callback);\n      if (changeCbs) changeCbs.delete(callback);\n    }}\n  }\n\n  static audit(code: string, scopes: ({[prop: string]: any}|Scope)[] = []): ExecReturn {\n    const globals = {};\n    for (let i of Object.getOwnPropertyNames(globalThis)) {\n      globals[i] = globalThis[i];\n    }\n    return new Sandbox({\n      globals,\n      audit: true,\n    }).executeTree(parse(code), scopes);\n  }\n\n  static parse(code: string) {\n    return parse(code);\n  }\n\n  executeTree(executionTree: IExecutionTree, scopes: ({[key:string]: any}|Scope)[] = []): ExecReturn {\n    return executeTree({\n      ticks: BigInt(0),\n    }, {\n      ctx: this.context,\n      constants: executionTree.constants,\n      tree: executionTree.tree\n    }, executionTree.tree, scopes);\n  }\n\n  executeTreeAsync(executionTree: IExecutionTree, scopes: ({[key:string]: any}|Scope)[] = []): Promise<ExecReturn> {\n    return executeTreeAsync({\n      ticks: BigInt(0),\n    }, {\n      ctx: this.context,\n      constants: executionTree.constants,\n      tree: executionTree.tree\n    }, executionTree.tree, scopes);\n  }\n  \n  compile(code: string, optimize = false): (...scopes: ({[prop: string]: any}|Scope)[]) => any {\n    const executionTree = parse(code, optimize);\n    return (...scopes: ({[prop: string]: any}|Scope)[]) => {\n      return this.executeTree(executionTree, scopes).result;\n    };\n  };\n  \n  compileAsync(code: string, optimize = false): (...scopes: ({[prop: string]: any}|Scope)[]) => Promise<any> {\n    const executionTree = parse(code, optimize);\n    return async (...scopes: ({[prop: string]: any}|Scope)[]) => {\n      return (await this.executeTreeAsync(executionTree, scopes)).result;\n    };\n  };\n\n  compileExpression(code: string, optimize = false): (...scopes: ({[prop: string]: any}|Scope)[]) => any {\n    const executionTree = parse(code, optimize);\n    executionTree.tree.length = 1;\n    return (...scopes: ({[prop: string]: any}|Scope)[]) => {\n      return this.executeTree(executionTree, scopes).result;\n    };\n  }\n\n  compileExpressionAsync(code: string, optimize = false): (...scopes: ({[prop: string]: any}|Scope)[]) => Promise<any> {\n    const executionTree = parse(code, optimize);\n    executionTree.tree.length = 1;\n    return async (...scopes: ({[prop: string]: any}|Scope)[]) => {\n      return (await this.executeTreeAsync(executionTree, scopes)).result;\n    };\n  }\n}\n"],"names":["parseHexToInt","hex","match","parseInt","NaN","validateAndParseHex","errorName","enforcedLength","parsedHex","Number","isNaN","undefined","length","SyntaxError","parseHexadecimalCode","code","parsedCode","String","fromCharCode","parseUnicodeCode","surrogateCode","parsedSurrogateCode","isCurlyBraced","text","charAt","parseUnicodeCodePointCode","codePoint","slice","fromCodePoint","err","RangeError","singleCharacterEscapes","Map","parseSingleCharacterCode","get","escapeMatch","unraw","raw","replace","_","backslash","unicodeWithSurrogate","surrogate","unicode","octal","singleCharacter","lispTypes","ParseError","Error","[object Object]","message","super","substring","this","Lisp","obj","op","a","b","If","t","f","KeyVal","key","val","SpreadObject","item","SpreadArray","toLispArray","arr","lisp","inlineIfElse","space","expectTypes","splitter","types","split","boolOp","comparitor","next","inlineIf","assignment","assignModify","assign","incrementerBefore","expEdge","call","incrementerAfter","modifier","not","inverse","negative","positive","typeof","delete","dot","arrayProp","prop","value","createObject","createArray","number","string","literal","regex","boolean","null","und","arrowFunctionSingle","arrowFunction","inlineFunction","group","Infinity","void","await","new","throw","initialize","return","spreadObject","spreadArray","expEnd","expFunction","function","expSingle","for","do","while","loopAction","if","try","block","switch","closings","(","[","{","'","\"","`","testMultiple","str","tests","found","i","exec","okFirstChars","aNumber","wordReg","restOfExp","constants","part","quote","firstOpening","closingsTests","details","words","isStart","escape","done","lastChar","isOneLiner","char","regRes","foundWord","foundNumber","sub","push","lastAnyWord","lastWord","test","Math","min","oneliner","startingExecpted","setLispType","fn","forEach","type","set","closingsCreate","res","expect","ctx","extract","arg","end","l","funcFound","lispifyExpr","join","map","e","lispify","trimStart","lispTree","includes","quoteCount","condition","isBlock","startTrue","trueBlock","elseBlock","foundElse","trim","lispifyBlock","start","indexOf","caseFound","statement","insertSemicolons","caseTest","cases","defaultFound","cond","bracketFound","exprs","notEmpty","lines","index","matches","primitives","true","false","BigInt","JSON","parse","isArrow","isReturn","argPos","isAsync","args","unshift","ended","startsWith","func","eager","lispifyFunction","iteratorRegex","getIterator","body","startStep","startInternal","beforeStep","checkFirst","step","iterator","extract2","k","ofStart2","ofStart3","ofCondition","ofStep","inStart2","inStart3","inStep","inCondition","shift","catchReg","finallyBody","exception","catchBody","catchRes","offset","argsString","j","lastType","expected","topLevel","startingExpectedWithoutSingle","filter","r","subExpressions","pos","Object","values","defined","parts","Boolean","flat","tree","hoisted","hoist","concat","Array","isArray","rep","it","closingsNoInsertion","colonsRegex","rest","valid","edge","checkRegex","cancel","after","flags","notDivide","possibleDivide","extractConstants","currentEnclosure","regexFound","comment","commentStart","currJs","strRes","enclosures","isPossibleDivide","skip","literals","strings","pop","regexes","js","ExecReturn","auditReport","result","returned","breakLoop","continueLoop","Prop","context","isConst","isGlobal","isVariable","optional","Symbol","reservedWords","Set","VarType","Scope","parent","vars","functionThis","isFuncScope","allVars","let","var","globals","functionScope","has","hasOwnProperty","const","ReferenceError","TypeError","SandboxError","declare","currentTicks","sandboxFunction","SandboxFunction","params","parsed","createFunction","generateArgs","argNames","sandboxedFunctions","WeakSet","ticks","scope","name","options","forbidFunctionCreation","executeTree","add","createFunctionAsync","prototypeWhitelist","Promise","async","executeTreeAsync","sandboxedEval","sandboxedSetTimeout","handler","setTimeout","sandboxedSetInterval","setInterval","assignCheck","changeSubscriptions","cb","setSubscriptions","arrayChange","splice","reverse","sort","copyWithin","literalRegex","ops2","sandboxGlobal","audit","globalsAccess","globalsWhitelist","evals","globalThis","globalScope","getSubscriptions","isFunction","prototypeAccess","prot","constructor","prototype","getPrototypeOf","whitelist","prototypeReplacements","size","constuctor","g","forbidFunctionCalls","execMany","vals","stringify","cache","recurse","x","y","change","changed","added","removed","startIndex","deleteCount","len","endIndex","keyVal","reg","RegExp","resnums","processed","reses","num","$$","$","!","~","++$","$++","--$","$--","=","+=","-=","/=","*=","**=","%=","^=","&=","|=","<<=",">>=",">>>=","?",">","<",">=","<=","==","===","!=","!==","&&","||","&","|",":","+","-","$+","$-","/","^","*","%","<<",">>",">>>","instanceof","in","bobj","arrowFunc","loop","loopScope","internalVars","$$obj","interalScope","execAsync","asyncDone","d","innerLoopVars","catch","syncDone","inLoopOrSwitch","executeTreeWithDone","toTest","execSync","isTrue","caseItem","valueOrProp","multi","ops","_execManySync","_execManyAsync","ret","callback","resolve","reject","execWithDone","executionQuota","onExecutionQuotaReached","executionTree","scopes","s","_executeWithDoneSync","_executeWithDoneAsync","current","extend","executionOps","SandboxGlobal","Sandbox","SAFE_GLOBALS","SAFE_PROTOTYPES","sandbox","WeakMap","Function","eval","console","debug","error","info","log","table","warn","isFinite","parseFloat","decodeURI","decodeURIComponent","encodeURI","encodeURIComponent","unescape","EvalError","URIError","Int8Array","Uint8Array","Uint8ClampedArray","Int16Array","Uint16Array","Int32Array","Uint32Array","Float32Array","Float64Array","Intl","Date","protos","proto","unsubscribe","names","callbacks","changeCbs","getOwnPropertyNames","optimize"],"mappings":"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"}