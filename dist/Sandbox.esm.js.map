{"version":3,"file":"Sandbox.esm.js","sources":["../src/unraw.ts","../src/parser.ts","../src/executor.ts","../src/Sandbox.ts"],"sourcesContent":["/**\n * Parse a string as a base-16 number. This is more strict than `parseInt` as it\n * will not allow any other characters, including (for example) \"+\", \"-\", and\n * \".\".\n * @param hex A string containing a hexadecimal number.\n * @returns The parsed integer, or `NaN` if the string is not a valid hex\n * number.\n */\nfunction parseHexToInt(hex: string): number {\n  const isOnlyHexChars = !hex.match(/[^a-f0-9]/i);\n  return isOnlyHexChars ? parseInt(hex, 16) : NaN;\n}\n\n/**\n * Check the validity and length of a hexadecimal code and optionally enforces\n * a specific number of hex digits.\n * @param hex The string to validate and parse.\n * @param errorName The name of the error message to throw a `SyntaxError` with\n * if `hex` is invalid. This is used to index `errorMessages`.\n * @param enforcedLength If provided, will throw an error if `hex` is not\n * exactly this many characters.\n * @returns The parsed hex number as a normal number.\n * @throws {SyntaxError} If the code is not valid.\n */\nfunction validateAndParseHex(\n  hex: string,\n  errorName: string,\n  enforcedLength?: number\n): number {\n  const parsedHex = parseHexToInt(hex);\n  if (\n    Number.isNaN(parsedHex) ||\n    (enforcedLength !== undefined && enforcedLength !== hex.length)\n  ) {\n    throw new SyntaxError(errorName + ': ' + hex);\n  }\n  return parsedHex;\n}\n\n/**\n * Parse a two-digit hexadecimal character escape code.\n * @param code The two-digit hexadecimal number that represents the character to\n * output.\n * @returns The single character represented by the code.\n * @throws {SyntaxError} If the code is not valid hex or is not the right\n * length.\n */\nfunction parseHexadecimalCode(code: string): string {\n  const parsedCode = validateAndParseHex(\n    code,\n    'Malformed Hexadecimal',\n    2\n  );\n  return String.fromCharCode(parsedCode);\n}\n\n/**\n * Parse a four-digit Unicode character escape code.\n * @param code The four-digit unicode number that represents the character to\n * output.\n * @param surrogateCode Optional four-digit unicode surrogate that represents\n * the other half of the character to output.\n * @returns The single character represented by the code.\n * @throws {SyntaxError} If the codes are not valid hex or are not the right\n * length.\n */\nfunction parseUnicodeCode(code: string, surrogateCode?: string): string {\n  const parsedCode = validateAndParseHex(code, 'Malformed Unicode', 4);\n\n  if (surrogateCode !== undefined) {\n    const parsedSurrogateCode = validateAndParseHex(\n      surrogateCode,\n      'Malformed Unicode',\n      4\n    );\n    return String.fromCharCode(parsedCode, parsedSurrogateCode);\n  }\n\n  return String.fromCharCode(parsedCode);\n}\n\n/**\n * Test if the text is surrounded by curly braces (`{}`).\n * @param text Text to check.\n * @returns `true` if the text is in the form `{*}`.\n */\nfunction isCurlyBraced(text: string): boolean {\n  return text.charAt(0) === \"{\" && text.charAt(text.length - 1) === \"}\";\n}\n\n/**\n * Parse a Unicode code point character escape code.\n * @param codePoint A unicode escape code point, including the surrounding curly\n * braces.\n * @returns The single character represented by the code.\n * @throws {SyntaxError} If the code is not valid hex or does not have the\n * surrounding curly braces.\n */\nfunction parseUnicodeCodePointCode(codePoint: string): string {\n  if (!isCurlyBraced(codePoint)) {\n    throw new SyntaxError('Malformed Unicode: +' + codePoint);\n  }\n  const withoutBraces = codePoint.slice(1, -1);\n  const parsedCode = validateAndParseHex(\n    withoutBraces,\n    'Malformed Unicode'\n  );\n\n  try {\n    return String.fromCodePoint(parsedCode);\n  } catch (err) {\n    throw err instanceof RangeError\n      ? new SyntaxError('Code Point Limit:' + parsedCode)\n      : err;\n  }\n}\n\n/**\n * Map of unescaped letters to their corresponding special JS escape characters.\n * Intentionally does not include characters that map to themselves like \"\\'\".\n */\nconst singleCharacterEscapes = new Map<string, string>([\n  [\"b\", \"\\b\"],\n  [\"f\", \"\\f\"],\n  [\"n\", \"\\n\"],\n  [\"r\", \"\\r\"],\n  [\"t\", \"\\t\"],\n  [\"v\", \"\\v\"],\n  [\"0\", \"\\0\"]\n]);\n\n/**\n * Parse a single character escape sequence and return the matching character.\n * If none is matched, defaults to `code`.\n * @param code A single character code.\n */\nfunction parseSingleCharacterCode(code: string): string {\n  return singleCharacterEscapes.get(code) || code;\n}\n\n/**\n * Matches every escape sequence possible, including invalid ones.\n *\n * All capture groups (described below) are unique (only one will match), except\n * for 4, which can only potentially match if 3 does.\n *\n * **Capture Groups:**\n * 0. A single backslash\n * 1. Hexadecimal code\n * 2. Unicode code point code with surrounding curly braces\n * 3. Unicode escape code with surrogate\n * 4. Surrogate code\n * 5. Unicode escape code without surrogate\n * 6. Octal code _NOTE: includes \"0\"._\n * 7. A single character (will never be \\, x, u, or 0-3)\n */\nconst escapeMatch = /\\\\(?:(\\\\)|x([\\s\\S]{0,2})|u(\\{[^}]*\\}?)|u([\\s\\S]{4})\\\\u([^{][\\s\\S]{0,3})|u([\\s\\S]{0,4})|([0-3]?[0-7]{1,2})|([\\s\\S])|$)/g;\n\n/**\n * Replace raw escape character strings with their escape characters.\n * @param raw A string where escape characters are represented as raw string\n * values like `\\'` rather than `'`.\n * @param allowOctals If `true`, will process the now-deprecated octal escape\n * sequences (ie, `\\111`).\n * @returns The processed string, with escape characters replaced by their\n * respective actual Unicode characters.\n */\nexport function unraw(raw: string): string {\n  return raw.replace(escapeMatch, function(\n    _,\n    backslash?: string,\n    hex?: string,\n    codePoint?: string,\n    unicodeWithSurrogate?: string,\n    surrogate?: string,\n    unicode?: string,\n    octal?: string,\n    singleCharacter?: string\n  ): string {\n    // Compare groups to undefined because empty strings mean different errors\n    // Otherwise, `\\u` would fail the same as `\\` which is wrong.\n    if (backslash !== undefined) {\n      return \"\\\\\";\n    }\n    if (hex !== undefined) {\n      return parseHexadecimalCode(hex);\n    }\n    if (codePoint !== undefined) {\n      return parseUnicodeCodePointCode(codePoint);\n    }\n    if (unicodeWithSurrogate !== undefined) {\n      return parseUnicodeCode(unicodeWithSurrogate, surrogate);\n    }\n    if (unicode !== undefined) {\n      return parseUnicodeCode(unicode);\n    }\n    if (octal === \"0\") {\n      return \"\\0\";\n    }\n    if (octal !== undefined) {\n      throw new SyntaxError('Octal Deprecation: ' + octal);\n    }\n    if (singleCharacter !== undefined) {\n      return parseSingleCharacterCode(singleCharacter);\n    }\n    throw new SyntaxError('End of string');\n  });\n}\nexport default unraw;","import unraw from \"./unraw.js\";\nexport type LispItem = Lisp|If|KeyVal|SpreadArray|SpreadObject|(LispItem[])|{new(): any }|String|Number|Boolean|null|undefined;\nexport interface ILiteral extends Lisp {\n  op: 'literal';\n  a: string;\n  b: LispItem[];\n}\n\nexport interface IRegEx {\n  regex: string,\n  flags: string,\n  length: number\n}\n\nexport interface IConstants {\n  strings: string[];\n  literals: ILiteral[];\n  regexes: IRegEx[];\n}\n\nexport interface IExecutionTree {\n  tree: LispItem[], \n  constants: IConstants\n}\n\ntype LispCallback = (strings: IConstants, type: string, parts: string, res: string[], expect: string, ctx: {lispTree: LispItem}) => any\nlet lispTypes: Map<string, LispCallback> = new Map();\n\nexport class ParseError extends Error {\n  constructor(message: string, public code: string) {\n    super(message);\n  }\n}\n\nexport class Lisp {\n  op: string;\n  a?: LispItem;\n  b?: LispItem;\n  constructor(obj: Lisp) {\n    this.op = obj.op;\n    this.a = obj.a;\n    this.b = obj.b;\n  }\n}\n\nexport class If {\n  constructor(public t: any, public f: any) {}\n}\n\nexport class KeyVal {\n  constructor(public key: string, public val: any) {}\n}\n\nexport class SpreadObject {\n  constructor(public item: {[key: string]: any}) {}\n}\n\nexport class SpreadArray {\n  constructor(public item: any[]) {}\n}\n\nconst inlineIfElse =  /^:/;\nconst space = /^\\s/;\n\nlet expectTypes: {[type:string]: {types: {[type:string]: RegExp}, next: string[]}} = {\n  splitter: {\n    types: {\n      split: /^(&&|&(?!&)|\\|\\||\\|(?!\\|)|<=|>=|<(?!<)|>(?!>)|!==|!=(?!\\=)|===|==(?!\\=)|\\+(?!\\+)|\\-(?!\\-)|\\^|<<|>>(?!>)|>>>|instanceof(?![\\w\\$\\_])|in(?![\\w\\$\\_]))(?!\\=)/,\n      op: /^(\\/|\\*\\*|\\*(?!\\*)|\\%)(?!\\=)/,\n    },\n    next: [\n      'modifier',\n      'value', \n      'prop', \n      'incrementerBefore',\n    ]\n  },\n  inlineIf: {\n    types: {\n      inlineIf: /^\\?/,\n    },\n    next: [\n      'expEnd'\n    ]\n  },\n  assignment: {\n    types: {\n      assignModify: /^(\\-=|\\+=|\\/=|\\*\\*=|\\*=|%=|\\^=|\\&=|\\|=|>>>=|>>=|<<=)/,\n      assign: /^(=)(?!=)/\n    },\n    next: [\n      'modifier',\n      'value', \n      'prop', \n      'incrementerBefore',\n    ]\n  },\n  incrementerBefore: {\n    types: {incrementerBefore: /^(\\+\\+|\\-\\-)/},\n    next: [\n      'prop',\n    ]\n  },\n  expEdge: {\n    types: {\n      call: /^[\\(]/,\n      incrementerAfter: /^(\\+\\+|\\-\\-)/\n    },\n    next: [\n      'splitter',\n      'expEdge',\n      'inlineIf',\n      'dot',\n      'expEnd'\n    ]\n  },\n  modifier: {\n    types: {\n      not: /^!/,\n      inverse: /^~/,\n      negative: /^\\-(?!\\-)/,\n      positive: /^\\+(?!\\+)/,\n      typeof: /^typeof(?![\\w\\$\\_])/,\n      delete: /^delete(?![\\w\\$\\_])/,\n    },\n    next: [\n      'modifier', \n      'value',\n      'prop',\n      'incrementerBefore',\n    ]\n  },\n  dot: {\n    types: {\n      arrayProp: /^[\\[]/,\n      dot: /^\\.(?!\\.)/\n    },\n    next: [\n      'splitter',\n      'assignment',\n      'expEdge',\n      'inlineIf',\n      'dot',\n      'expEnd'\n    ]\n  },\n  prop: {\n    types: {\n      prop: /^[a-zA-Z\\$\\_][a-zA-Z\\d\\$\\_]*/,\n    },\n    next: [\n      'splitter',\n      'assignment',\n      'expEdge',\n      'inlineIf',\n      'dot',\n      'expEnd'\n    ]\n  },\n  value: {\n    types: {\n      createObject: /^\\{/,\n      createArray: /^\\[/,\n      number: /^(0x[\\da-f]+|\\d+(\\.\\d+)?(e[\\+\\-]?\\d+)?)/i,\n      string: /^\"(\\d+)\"/,\n      literal: /^`(\\d+)`/,\n      regex: /^\\/(\\d+)\\/r(?![\\w\\$\\_])/,\n      boolean: /^(true|false)(?![\\w\\$\\_])/,\n      null: /^null(?![\\w\\$\\_])/,\n      und: /^undefined(?![\\w\\$\\_])/,\n      arrowFunctionSingle: /^(async\\s+)?([a-zA-Z\\$_][a-zA-Z\\d\\$_]*)\\s*=>\\s*({)?/,\n      arrowFunction: /^(async\\s*)?\\(\\s*((\\.\\.\\.)?\\s*[a-zA-Z\\$_][a-zA-Z\\d\\$_]*(\\s*,\\s*(\\.\\.\\.)?\\s*[a-zA-Z\\$_][a-zA-Z\\d\\$_]*)*)?\\s*\\)\\s*=>\\s*({)?/,\n      inlineFunction: /^(async\\s+)?function(\\s*[a-zA-Z\\$_][a-zA-Z\\d\\$_]*)?\\s*\\(\\s*((\\.\\.\\.)?\\s*[a-zA-Z\\$_][a-zA-Z\\d\\$_]*(\\s*,\\s*(\\.\\.\\.)?\\s*[a-zA-Z\\$_][a-zA-Z\\d\\$_]*)*)?\\s*\\)\\s*{/,\n      group: /^\\(/,\n      NaN: /^NaN(?![\\w\\$\\_])/,\n      Infinity: /^Infinity(?![\\w\\$\\_])/,\n      void: /^void(?![\\w\\$\\_])\\s*/,\n      await: /^await(?![\\w\\$\\_])\\s*/,\n      new: /^new(?![\\w\\$\\_])\\s*/,\n      throw: /^throw(?![\\w\\$\\_])\\s*/\n    },\n    next: [\n      'splitter',\n      'expEdge',\n      'inlineIf',\n      'dot',\n      'expEnd'\n    ]\n  },\n  initialize: {\n    types: {\n      initialize: /^(var|let|const)\\s+([a-zA-Z\\$_][a-zA-Z\\d\\$_]*)\\s*(=)?/,\n      return: /^return(?![\\w\\$\\_])/,\n    },\n    next: [\n      'modifier',\n      'value', \n      'prop', \n      'incrementerBefore',\n      'expEnd'\n    ]\n  },\n  spreadObject: {\n    types: {\n      spreadObject: /^\\.\\.\\./\n    },\n    next: [\n      'value',\n      'prop', \n    ]\n  },\n  spreadArray: {\n    types: {\n      spreadArray: /^\\.\\.\\./\n    },\n    next: [\n      'value', \n      'prop', \n    ]\n  },\n  expEnd: {types: {}, next: []},\n  expSingle: {\n    types: {\n      for: /^(([a-zA-Z\\$\\_][\\w\\$\\_]*)\\s*:)?\\s*for\\s*\\(/,\n      do: /^(([a-zA-Z\\$\\_][\\w\\$\\_]*)\\s*:)?\\s*do\\s*\\{/,\n      while: /^(([a-zA-Z\\$\\_][\\w\\$\\_]*)\\s*:)?\\s*while\\s*\\(/,\n      loopAction: /^(break|continue)(?![\\w\\$\\_])/,\n      if: /^if\\s*\\(/,\n      try: /^try\\s*{/,\n      // block: /^{/,\n      function: /^(async\\s+)?function(\\s*[a-zA-Z\\$_][a-zA-Z\\d\\$_]*)\\s*\\(\\s*((\\.\\.\\.)?\\s*[a-zA-Z\\$_][a-zA-Z\\d\\$_]*(\\s*,\\s*(\\.\\.\\.)?\\s*[a-zA-Z\\$_][a-zA-Z\\d\\$_]*)*)?\\s*\\)\\s*{/,\n      switch: /^(([a-zA-Z\\$\\_][\\w\\$\\_]*)\\s*:)?\\s*switch\\s*\\(/,\n    },\n    next: [\n      'expEnd'\n    ]\n  }\n};\n\nlet closings = {\n  \"(\": \")\",\n  \"[\": \"]\",\n  \"{\": \"}\",\n  \"'\": \"'\",\n  '\"': '\"',\n  \"`\": \"`\"\n}\n\nlet closingsRegex: any = {\n  \"(\": /^\\)/,\n  \"[\": /^\\]/,\n  \"{\": /^\\}/,\n  \"'\": /^\\'/,\n  '\"': /^\\\"/,\n  \"`\": /^\\`/\n}\n\nconst okFirstChars = /^[\\+\\-~ !]/;\nconst aChar = /^[\\w\\$]/\nconst aNumber = expectTypes.value.types.number;\nexport function restOfExp(constants: IConstants, \n                          part: string, \n                          tests?: RegExp[], \n                          quote?: string, \n                          firstOpening?: string, \n                          closingsTests?: RegExp[], \n                          details: {[k: string]: string} = {}, \n                          allChars?: boolean) {\n  let isStart = true;\n  tests = tests || [];\n  let escape = false;\n  let done = false;\n  let lastIsChar = false;\n  let currentIsChar = false;\n  let lastChar = \"\";\n  let word = \"\";\n  let i;\n  for (i = 0; i < part.length && !done; i++) {\n    let char = part[i];\n    lastIsChar = currentIsChar;\n    currentIsChar = aChar.test(char);\n    if (!currentIsChar && !space.test(char) && !closings[char]) word = \"\";\n    if (currentIsChar && closingsTests) word += char;\n    if (quote === '\"' || quote === \"'\" || quote === \"`\") {\n      if (quote === \"`\" && char === \"$\" && part[i+1] === \"{\" && !escape) {\n        let skip = restOfExp(constants, part.substring(i+2), [], \"{\");\n        i += skip.length + 2;\n      } else if (char === quote && !escape) {\n        return part.substring(0, i);\n      }\n      escape = !escape && char === \"\\\\\";\n    } else if (closings[char]) {\n      if (char === firstOpening) {\n        done = true;\n        break;\n      } else {\n        let skip = restOfExp(constants, part.substring(i+1), [], char);\n        i += skip.length + 1;\n        isStart = false;\n        if (closingsTests) {\n          let sub = part.substring(i);\n          for (let test of closingsTests) {\n            test.lastIndex = 0;\n            const found = test.exec(sub);\n            if (!found) continue;\n            i += found[1].length - 1;\n            details['word'] = word;\n            done = true;\n            if (done) break;\n          }\n        }\n      }\n    } else if (!quote) {\n      let sub = part.substring(i);\n      let foundNumber: RegExpExecArray;\n      if (foundNumber = aNumber.exec(sub)) {\n        i += foundNumber[0].length - 1;\n        sub = part.substring(i);\n      }\n      if (allChars || (!lastIsChar || !currentIsChar) && lastChar !== char) {\n        for (let test of tests) {\n          const found = test.exec(sub);\n          if (!found) continue;\n          if (closingsTests) {\n            i += found[1].length;\n          }\n          done = true;\n          break;\n        }\n      }\n      if (isStart) {\n        if (okFirstChars.test(sub)) {\n          done = false;\n        } else {\n          isStart = false;\n        }\n      }\n      if (done) break;\n    } else if(char === closings[quote]) {\n      return part.substring(0, i);\n    }\n    lastChar = char;\n  }\n  if (quote) {\n    throw new SyntaxError(\"Unclosed '\" + quote + \"': \" + quote + part.substring(0, Math.min(i, 40)));\n  }\n  return part.substring(0, i);\n}\nrestOfExp.next = [\n  'splitter',\n  'expEnd',\n  'inlineIf'\n];\n\nconst setLispType = (types: string[], fn: LispCallback) => {\n  types.forEach((type) => {\n    lispTypes.set(type, fn);\n  })\n}\n\nconst closingsCreate: {[type:string]: RegExp} = {\n  'createArray': /^\\]/,\n  'createObject': /^\\}/,\n  'group': /^\\)/,\n  'arrayProp': /^\\]/,\n  'call': /^\\)/\n}\n\nsetLispType(['createArray', 'createObject', 'group', 'arrayProp','call'], (constants, type, part, res, expect, ctx) => {\n  let extract = \"\";\n  let arg: string[] = [];\n  let end = false;\n  let i = 1;\n  while (i < part.length && !end) {\n    extract = restOfExp(constants, part.substring(i), [\n      closingsCreate[type],\n      /^,/\n    ]);\n    i += extract.length;\n    if (extract) {\n      arg.push(extract);\n    }\n    if (part[i] !== ',') {\n      end = true;\n    } else {\n      i++;\n    }\n  }\n  const next = ['value', 'modifier', 'prop', 'incrementerBefore', 'expEnd'];\n  let l: LispItem;\n\n  let funcFound: RegExpExecArray;\n  switch(type) {\n    case 'group':\n    case 'arrayProp':\n      l = lispifyExpr(constants, arg.join(\",\"));\n      break;\n    case 'call':\n    case 'createArray':\n      // @TODO: support 'empty' values\n      l = arg.map((e) => lispify(constants, e, [...next, 'spreadArray']));\n      break;\n    case 'createObject':\n      l = arg.map((str) => {\n        str = str.trimStart();\n        let value;\n        let key;\n        funcFound = expectTypes.expSingle.types.function.exec('function ' + str);\n        if (funcFound) {\n          key = funcFound[2].trimStart();\n          value = lispify(constants, 'function ' + str.replace(key, \"\"));\n        } else {\n          let extract = restOfExp(constants, str, [/^:/]);\n          key = lispify(constants, extract, [...next, 'spreadObject']);\n          if (key instanceof Lisp && key.op === 'prop') {\n            key = key.b;\n          }\n          if (extract.length === str.length) return key;\n          value = lispify(constants, str.substring(extract.length + 1));\n        }\n        return new Lisp({\n          op: 'keyVal',\n          a: key,\n          b: value\n        });\n      })\n      break;\n  }\n  type = type === 'arrayProp' ? 'prop' : type;\n  ctx.lispTree = lispify(constants, part.substring(i + 1), expectTypes[expect].next, new Lisp({\n    op: type, \n    a: ctx.lispTree, \n    b: l,\n  }));\n});\n\nsetLispType(['inverse', 'not', 'negative', 'positive', 'typeof', 'delete', 'op'], (constants, type, part, res, expect, ctx) => {\n  let extract = restOfExp(constants, part.substring(res[0].length), [/^[^\\s\\.\\w\\d\\$]/]);\n  ctx.lispTree = lispify(constants, part.substring(extract.length + res[0].length), restOfExp.next, new Lisp({\n    op: ['positive', 'negative'].includes(type) ? '$' + res[0] : res[0],\n    a: ctx.lispTree, \n    b: lispify(constants, extract, expectTypes[expect].next), \n  }));\n});\n\nsetLispType(['incrementerBefore'], (constants, type, part, res, expect, ctx) => {\n  let extract = restOfExp(constants, part.substring(2), [/^[^\\s\\.\\w\\d\\$]/]);\n  ctx.lispTree = lispify(constants, part.substring(extract.length + 2), restOfExp.next, new Lisp({\n    op: res[0] + \"$\", \n    a: lispify(constants, extract, expectTypes[expect].next), \n  }));\n});\n\nsetLispType(['incrementerAfter'], (constants, type, part, res, expect, ctx) => {\n  ctx.lispTree = lispify(constants, part.substring(res[0].length), expectTypes[expect].next, new Lisp({\n    op: \"$\"  + res[0], \n    a: ctx.lispTree, \n  }));\n});\n\nsetLispType(['assign', 'assignModify'], (constants, type, part, res, expect, ctx) => {\n  ctx.lispTree = new Lisp({\n    op: res[0], \n    a: ctx.lispTree,\n    b: lispify(constants, part.substring(res[0].length), expectTypes[expect].next)\n  });\n});\n\nsetLispType(['split'], (constants, type, part, res, expect, ctx) => {\n  let extract = restOfExp(constants, part.substring(res[0].length),[\n    expectTypes.splitter.types.split,\n    expectTypes.inlineIf.types.inlineIf,\n    inlineIfElse\n  ]);\n  ctx.lispTree = lispify(constants, part.substring(extract.length + res[0].length).trim(), restOfExp.next, new Lisp({\n    op: res[0].trim(),\n    a: ctx.lispTree, \n    b: lispify(constants, extract, expectTypes[expect].next), \n  }));\n});\n\nsetLispType(['inlineIf'], (constants, type, part, res, expect, ctx) => {\n  let found = false;\n  let extract = \"\";\n  let quoteCount = 1;\n  while(!found && extract.length < part.length) {\n    extract += restOfExp(constants, part.substring(extract.length + 1), [\n      expectTypes.inlineIf.types.inlineIf,\n      inlineIfElse\n    ]);\n    if (part[extract.length + 1] === '?') {\n      quoteCount++\n    } else {\n      quoteCount--\n    }\n    if (!quoteCount) {\n      found = true;\n    } else {\n      extract += part[extract.length + 1];\n    }\n  }\n  ctx.lispTree = new Lisp({\n    op: '?',\n    a: ctx.lispTree, \n    b: new Lisp({\n      op: ':',\n      a: lispifyExpr(constants, extract),\n      b: lispifyExpr(constants, part.substring(res[0].length + extract.length + 1))\n    })\n  });\n});\n\nsetLispType(['if'], (constants, type, part, res, expect, ctx) => {\n  let condition = restOfExp(constants, part.substring(res[0].length), [], \"(\");\n  const isBlock = /^\\s*\\{/.exec(part.substring(res[0].length + condition.length + 1));\n  const startTrue = res[0].length + condition.length + 1 + (isBlock ? isBlock[0].length : 0);\n  let trueBlock = restOfExp(constants, part.substring(startTrue), isBlock ? [/^\\}/] : [/^else(?!\\w\\$)/]);\n  let elseBlock = \"\";\n  if (startTrue + trueBlock.length + (isBlock ? isBlock[0].length : 0) < part.length) {\n    const end = part.substring(startTrue + trueBlock.length + (isBlock ? isBlock[0].length : 0));\n    const foundElse = /\\s*else(?!\\w\\$\\s)\\s*/.exec(end);\n    if (foundElse) {\n      elseBlock = end.substring(foundElse[0].length);\n    }\n  }\n  \n  condition = condition.trim();\n  trueBlock = trueBlock.trim();\n  elseBlock = elseBlock.trim();\n  if (trueBlock[0] === \"{\") trueBlock = trueBlock.slice(1, -1);\n  if (elseBlock[0] === \"{\") elseBlock = elseBlock.slice(1, -1);\n  ctx.lispTree = new Lisp({\n    op: 'if',\n    a: lispifyExpr(constants, condition), \n    b: new If(lispifyBlock(trueBlock, constants), elseBlock ? lispifyBlock(elseBlock, constants) : undefined)\n  });\n});\n\nsetLispType(['switch'], (constants, type, part, res, expect, ctx) => {\n  const test = restOfExp(constants, part.substring(res[0].length), [], \"(\");\n  let start = part.indexOf(\"{\", res[0].length + test.length + 1);\n  if (start === -1) throw new SyntaxError(\"Invalid switch: \" + part);\n  let statement = insertSemicolons(constants, restOfExp(constants, part.substring(start + 1), [], \"{\"), false);\n  let caseFound: RegExpExecArray;\n  const caseTest = /^\\s*(case\\s|default)\\s*/;\n  let cases: Lisp[] = [];\n  let defaultFound = false;\n  while(caseFound = caseTest.exec(statement)) {\n    if (caseFound[1] === 'default') {\n      if (defaultFound) throw new SyntaxError(\"Only one default switch case allowed:\" + statement);\n      defaultFound = true;\n    }\n    let cond = restOfExp(constants, statement.substring(caseFound[0].length), [/^:/]);\n    let found = \"\";\n    let i = start = caseFound[0].length + cond.length + 1;\n    let bracketFound = /^\\s*\\{/.exec(statement.substring(i));\n    let exprs = [];\n    if (bracketFound) {\n      i += bracketFound[0].length;\n      found = restOfExp(constants, statement.substring(i), [], \"{\");\n      i += found.length + 1;\n      exprs = lispifyBlock(found, constants);\n    } else {\n      let notEmpty = restOfExp(constants, statement.substring(i), [caseTest]);\n      if (!notEmpty.trim()) {\n        exprs = undefined;\n        i += notEmpty.length;\n      } else {\n        let lines = [];\n        while(found = restOfExp(constants, statement.substring(i), [/^;/])) {\n          lines.push(found);\n          i += found.length + 1;\n          if (caseTest.test(statement.substring(i))) {\n            break;\n          }\n        }\n        exprs = lispifyBlock(lines.join(\";\"), constants);\n      }\n    }\n    statement = statement.substring(i);\n    cases.push(new Lisp({\n      op: \"case\",\n      a: caseFound[1] === \"default\" ? undefined : lispifyExpr(constants, cond),\n      b: exprs\n    }));\n  }\n  ctx.lispTree = new Lisp({\n    op: 'switch',\n    a: lispifyExpr(constants, test),\n    b: cases\n  });\n});\n\nsetLispType(['dot', 'prop'], (constants, type, part, res, expect, ctx) => {\n  let prop = res[0];\n  let index = res[0].length;\n  if (res[0] === '.') {\n    let matches = part.substring(res[0].length).match(expectTypes.prop.types.prop);\n    if (matches && matches.length) {\n      prop = matches[0];\n      index = prop.length + res[0].length\n    } else {\n      throw new SyntaxError('Hanging  dot:' + part);\n    }\n  }\n  ctx.lispTree = lispify(constants, part.substring(index), expectTypes[expect].next, new Lisp({\n    op: 'prop', \n    a: ctx.lispTree, \n    b: prop\n  }));\n});\n\nsetLispType(['spreadArray', 'spreadObject'], (constants, type, part, res, expect, ctx) => {\n  ctx.lispTree = new Lisp({\n    op: type,\n    b: lispify(constants, part.substring(res[0].length), expectTypes[expect].next)\n  });\n});\n\nsetLispType(['return'], (constants, type, part, res, expect, ctx) => {\n  ctx.lispTree = new Lisp({\n    op: type,\n    b: lispifyExpr(constants, part.substring(res[0].length))\n  });\n});\n\nconst primitives = {\n  \"true\": true,\n  \"false\": false,\n  \"null\": null,\n  Infinity,\n  NaN,\n  \"und\": undefined\n}\n\nsetLispType(['number', 'boolean', 'null', 'und', 'NaN', 'Infinity'], (constants, type, part, res, expect, ctx) => {\n  ctx.lispTree = lispify(constants, part.substring(res[0].length), expectTypes[expect].next, type === \"number\" ? Number(res[0]) : primitives[type === \"boolean\" ? res[0] : type]);\n});\n\nsetLispType(['string', 'literal', 'regex'], (constants, type, part, res, expect, ctx) => {\n  ctx.lispTree = lispify(constants, part.substring(res[0].length), expectTypes[expect].next, new Lisp({\n    op: type,\n    b: parseInt(JSON.parse(res[1]), 10),\n  }));\n});\n\nsetLispType(['initialize'], (constants, type, part, res, expect, ctx) => {\n  if (!res[3]) {\n    ctx.lispTree = lispify(constants, part.substring(res[0].length), expectTypes[expect].next, new Lisp({\n      op: res[1],\n      a: res[2]\n    }));\n  } else {\n    ctx.lispTree = new Lisp({\n      op: res[1],\n      a: res[2],\n      b: lispify(constants, part.substring(res[0].length), expectTypes[expect].next)\n    });\n  }\n});\n\nsetLispType(['function', 'inlineFunction', 'arrowFunction', 'arrowFunctionSingle'], (constants, type, part, res, expect, ctx) => {\n  const isArrow = type !== 'function' && type !== 'inlineFunction';\n  const isReturn = isArrow && !res[res.length - 1];\n  const argPos = isArrow ? 2 : 3;\n  const isAsync = !!res[1];\n  const args: any[] = res[argPos] ? res[argPos].replace(/\\s+/g, \"\").split(/,/g) : [];\n  if (!isArrow) {\n    args.unshift((res[2] || \"\").trimStart());\n  }\n  let ended = false;\n  args.forEach((arg) => {\n    if (ended) throw new SyntaxError('Rest parameter must be last formal parameter');\n    if (arg.startsWith('...')) ended = true;\n  });\n  args.unshift(isAsync);\n  const func = (isReturn ? 'return ' : '') + restOfExp(constants, part.substring(res[0].length), !isReturn ? [/^}/] : [/^[,;\\)\\}\\]]/]);\n  ctx.lispTree = lispify(constants, part.substring(res[0].length + func.length + 1), expectTypes[expect].next, new Lisp({\n    op: isArrow ? 'arrowFunc' : type,\n    a: args,\n    b: lispifyFunction(func, constants)\n  }));\n});\n\nconst iteratorRegex = /^((let|var|const)\\s+)?\\s*([a-zA-Z\\$_][a-zA-Z\\d\\$_]*)\\s+(in|of)\\s+/\nsetLispType(['for', 'do', 'while'], (constants, type, part, res, expect, ctx) => {\n  let i = part.indexOf(\"(\") + 1;\n  let startStep: LispItem = true;\n  let startInternal: LispItem[] = [];\n  let beforeStep: LispItem = false;\n  let checkFirst = true;\n  let condition: LispItem;\n  let step: LispItem = true;\n  let body: string;\n  switch (type) {\n    case 'while':\n      let extract = restOfExp(constants, part.substring(i), [], \"(\");\n      condition = lispifyExpr(constants, extract);\n      body = restOfExp(constants, part.substring(i + extract.length + 1)).trim();\n      if (body[0] === \"{\") body = body.slice(1, -1);\n      break;\n    case 'for':\n      let args: string[] = [];\n      let extract2 = \"\";\n      for (let k = 0; k < 3; k++)  {\n        extract2 = restOfExp(constants, part.substring(i), [/^[;\\)]/]);\n        args.push(extract2.trim());\n        i += extract2.length + 1;\n        if (part[i - 1] === \")\") break;\n      }\n      let iterator: RegExpExecArray;\n      if (args.length === 1 && (iterator = iteratorRegex.exec(args[0]))) {\n        if (iterator[4] === 'of') {\n          startInternal = [\n            lispify(constants, 'let $$obj = '+ args[0].substring(iterator[0].length), ['initialize']),\n            ofStart2, \n            ofStart3\n          ];\n          condition = ofCondition;\n          step = ofStep;\n          beforeStep = lispify(constants, (iterator[1] || 'let ') + iterator[3]  + ' = $$next.value', ['initialize']);\n        } else {\n          startInternal = [\n            lispify(constants, 'let $$obj = '+ args[0].substring(iterator[0].length), ['initialize']),\n            inStart2,\n            inStart3\n          ];\n          step = inStep;\n          condition = inCondition;\n          beforeStep = lispify(constants, (iterator[1] || 'let ') + iterator[3] + ' = $$keys[$$keyIndex]', ['initialize']);\n        }\n      } else if (args.length === 3) {\n        startStep = lispifyExpr(constants, args.shift(), startingExecpted);\n        condition = lispifyExpr(constants, args.shift());\n        step = lispifyExpr(constants, args.shift());\n      } else {\n        throw new SyntaxError(\"Invalid for loop definition\");\n      }\n      body = restOfExp(constants, part.substring(i)).trim();\n      if (body[0] === \"{\") body = body.slice(1, -1);\n\n      break;\n    case 'do':\n      checkFirst = false;\n      const start = part.indexOf(\"{\") + 1;\n      body = restOfExp(constants, part.substring(start), [], \"{\");\n      condition = lispifyExpr(constants, restOfExp(constants, part.substring(part.indexOf(\"(\", start + body.length) + 1), [], \"(\"));\n      break;\n  }\n  ctx.lispTree = new Lisp({\n    op: 'loop',\n    a: [checkFirst, startInternal, startStep, step, condition, beforeStep],\n    b: lispifyBlock(body, constants)\n  });\n});\n\nsetLispType(['block'], (constants, type, part, res, expect, ctx) => {\n  ctx.lispTree = lispifyBlock(restOfExp(constants, part.substring(1), [], \"{\"), constants);\n});\n\nsetLispType(['loopAction'], (constants, type, part, res, expect, ctx) => {\n  ctx.lispTree = new Lisp({\n    op: 'loopAction',\n    a: res[1],\n  });\n});\n\nconst catchReg = /^\\s*(catch\\s*(\\(\\s*([a-zA-Z\\$_][a-zA-Z\\d\\$_]*)\\s*\\))?|finally)\\s*\\{/\nsetLispType(['try'], (constants, type, part, res, expect, ctx) => {\n  const body = restOfExp(constants, part.substring(res[0].length), [], \"{\");\n  let catchRes = catchReg.exec(part.substring(res[0].length + body.length + 1));\n  let finallyBody;\n  let exception;\n  let catchBody;\n  let offset = 0;\n  if (catchRes[1].startsWith('catch')) {\n    catchRes = catchReg.exec(part.substring(res[0].length + body.length + 1));\n    exception = catchRes[2];\n    catchBody = restOfExp(constants, part.substring(res[0].length + body.length + 1 + catchRes[0].length), [], \"{\");\n    offset = res[0].length + body.length + 1 + catchRes[0].length + catchBody.length + 1;\n    if ((catchRes = catchReg.exec(part.substring(offset))) && catchRes[1].startsWith('finally')) {\n      finallyBody = restOfExp(constants, part.substring(offset + catchRes[0].length), [], \"{\");\n    }\n  } else {\n    finallyBody = restOfExp(constants, part.substring(res[0].length + body.length + 1 + catchRes[0].length), [], \"{\");\n  }\n  ctx.lispTree = new Lisp({\n    op: 'try',\n    a: lispifyBlock(insertSemicolons(constants, body, false), constants),\n    b: [\n      exception,\n      lispifyBlock(insertSemicolons(constants, catchBody || \"\", false), constants),\n      lispifyBlock(insertSemicolons(constants, finallyBody || \"\", false), constants),\n    ]\n  });\n});\n\nsetLispType(['void', 'await', 'throw'], (constants, type, part, res, expect, ctx) => {\n  const extract = restOfExp(constants, part.substring(res[0].length), [/^[^\\s\\.\\w\\d\\$]/]);\n  ctx.lispTree = lispify(constants, part.substring(res[0].length + extract.length), expectTypes[expect].next, new Lisp({\n    op: type,\n    a: lispify(constants, extract),\n  }));\n});\n\nsetLispType(['new'], (constants, type, part, res, expect, ctx) => {\n  let i = res[0].length;\n  const obj = restOfExp(constants, part.substring(i), [], undefined, \"(\");\n  i += obj.length + 1;\n  const args = [];\n  if (part[i - 1] === \"(\") {\n    const argsString = restOfExp(constants, part.substring(i), [], \"(\");\n    i += argsString.length + 1;\n    let found;\n    let j = 0;\n    while(found = restOfExp(constants, argsString.substring(j), [/^,/])) {\n      j += found.length + 1;\n      args.push(found.trim());\n    } \n  }\n  ctx.lispTree = lispify(constants, part.substring(i), expectTypes.expEdge.next, new Lisp({\n    op: type,\n    a: lispify(constants, obj, expectTypes.initialize.next),\n    b: args.map((arg) => lispify(constants, arg, expectTypes.initialize.next)),\n  }));\n});\n\nconst ofStart2 = lispify(undefined, 'let $$iterator = $$obj[Symbol.iterator]()', ['initialize']);\nconst ofStart3 = lispify(undefined, 'let $$next = $$iterator.next()', ['initialize']);\nconst ofCondition = lispify(undefined, 'return !$$next.done', ['initialize']);\nconst ofStep = lispify(undefined, '$$next = $$iterator.next()');\nconst inStart2 = lispify(undefined, 'let $$keys = Object.keys($$obj)', ['initialize']);\nconst inStart3 = lispify(undefined, 'let $$keyIndex = 0', ['initialize']);\nconst inStep = lispify(undefined, '$$keyIndex++');\nconst inCondition = lispify(undefined, 'return $$keyIndex < $$keys.length', ['initialize']);\n\nconst startingExecpted = ['initialize', 'expSingle', 'value', 'modifier', 'prop', 'incrementerBefore', 'expEnd'];\nvar lastType;\nvar lastPart;\n// var lastLastPart;\n// var lastLastLastPart;\n// var lastLastLastLastPart;\nfunction lispify(constants: IConstants, part: string, expected?: string[], lispTree?: LispItem): LispItem {\n  expected = expected || expectTypes.initialize.next;\n  if (part === undefined) return lispTree;\n\n  part = part.trimStart();\n\n  if (!part.length && !expected.includes('expEnd')) {\n    throw new SyntaxError(\"Unexpected end of expression: \" + lastPart);\n  }\n  \n  if (!part) return lispTree;\n\n  let ctx = {lispTree: lispTree};\n\n  let res: any;\n  for (let expect of expected) {\n    if (expect === 'expEnd') {\n      continue;\n    }\n    for (let type in expectTypes[expect].types) {\n      if (type === 'expEnd') {\n        continue;\n      }\n      if(res = expectTypes[expect].types[type].exec(part)) {\n        lastType = type;\n        // lastLastLastLastPart = lastLastLastPart;\n        // lastLastLastPart = lastLastPart;\n        // lastLastPart = lastPart;\n        lastPart = part;\n        lispTypes.get(type)(constants, type, part, res, expect, ctx);\n        break;\n      }\n    }\n    if (res) break;\n  }\n\n  if (!res && part.length) {\n    throw SyntaxError(`Unexpected token (${lastType}): ${part.substring(0, 40)}`);\n  }\n  return ctx.lispTree;\n}\n\nfunction lispifyExpr(constants: IConstants, str: string, expected?: string[]): LispItem {\n  if (!str.trim()) return undefined;\n  let subExpressions = [];\n  let sub: string;\n  let pos = 0;\n  expected = expected || expectTypes.initialize.next;\n  while ((sub = restOfExp(constants, str.substring(pos), [/^,/]))) {\n    subExpressions.push(sub.trimStart());\n    pos += sub.length + 1;\n  }\n  if (subExpressions.length === 1) {\n    return lispify(constants, str, expected);\n  }\n  if (expected === startingExecpted) {\n    let defined = expectTypes.initialize.types.initialize.exec(subExpressions[0]);\n    if (defined) {\n      return subExpressions.map((str, i) => lispify(constants, i ? defined[1] + ' ' + str : str, ['initialize']));\n    } else if (expectTypes.initialize.types.return.exec(subExpressions[0])) {\n      return lispify(constants, str, expected);\n    }\n  }\n  const exprs = subExpressions.map((str, i) => lispify(constants, str, expected));\n  return new Lisp({op: \"multi\", a: exprs});\n}\n\nexport function lispifyBlock(str: string, constants: IConstants): LispItem[] {\n  str = insertSemicolons(constants, str, false);\n  if (!str.trim()) return [];\n  let parts = [];\n  let part: string;\n  let pos = 0;\n  while ((part = restOfExp(constants, str.substring(pos), [/^;/]))) {\n    parts.push(part.trim());\n    pos += part.length + 1;\n  }\n  return parts.filter(Boolean).map((str, j) => {\n    return lispifyExpr(constants, str, startingExecpted);\n  }).flat();\n}\n\nexport function lispifyFunction(str: string, constants: IConstants): LispItem[] {\n  if (!str.trim()) return [];\n  const tree = lispifyBlock(str, constants);\n  let hoisted: LispItem[] = [];\n  hoist(tree, hoisted);\n  return hoisted.concat(tree);\n}\n\nfunction hoist(item: LispItem, res: LispItem[]): boolean {\n  if (Array.isArray(item)) {\n    const rep = [];\n    for (let it of item) {\n      if (!hoist(it, res)) {\n        rep.push(it);\n      }\n    }\n    if (rep.length !== item.length) {\n      item.length = 0;\n      item.push(...rep);\n    }\n  } else if (item instanceof Lisp) {\n    if (item.op === \"try\" || item.op === \"if\" || item.op === \"loop\" || item.op === \"switch\") {\n      hoist(item.a, res);\n      hoist(item.b, res);\n    } else if (item.op === \"var\") {\n      res.push(new Lisp({op: 'var', a: item.a}));\n    } else if (item.op === \"function\" && item.a[1]) {\n      res.push(item);\n      return true;\n    }\n  }\n  return false;\n}\n\nconst edgesForInsertion = [\n  /^([\\w\\$]|\\+\\+|\\-\\-)\\s*\\r?\\n\\s*([\\w\\$\\+\\-])/,\n  /^([^\\w\\$](return|continue|break|throw))\\s*\\r?\\n\\s*[^\\s]/\n];\nconst closingsForInsertion = [\n  /^([\\)\\]])\\s*\\r?\\n\\s*([\\w\\$\\{\\+\\-])/,\n  /^(\\})\\s*\\r?\\n?\\s*([\\(])/,\n  /^(\\})\\s*(\\r?\\n)?\\s*([\\w\\[\\+\\-])/,\n];\nconst closingsNoInsertion = /^(\\})\\s*(catch|finally|else|while|instanceof)(?![\\w\\$])/\nconst whileEnding = /^\\}\\s*while/\n\nexport function insertSemicolons(constants: IConstants, part: string, type: boolean) {\n  let rest = part;\n  let sub = \"\"\n  let res = [];\n  let details: any = {};\n  while (sub = restOfExp(constants, rest, edgesForInsertion, undefined, undefined, !type ? closingsForInsertion : undefined, details, true)) {\n    res.push(sub);\n    if (!closingsNoInsertion.test(rest.substring(sub.length - 1))) {\n      res.push(\";\");\n    } else if (details.word !== \"do\" && whileEnding.test(rest.substring(sub.length - 1))) {\n      res.push(\";\");\n    }\n    rest = rest.substring(sub.length);\n  }\n  res.pop();\n  return res.join(\"\");\n}\n\nconst oneLinerBlocks = /[^\\w\\$](if|do)(?![\\w\\$])/g;\nexport function convertOneLiners(constants: IConstants, str: string): string {\n  let res: RegExpExecArray;\n  let lastIndex = 0;\n  let parts: Array<string|string[]> = [];\n  while (res = oneLinerBlocks.exec(str)) {\n    let sub = str.substring(res.index + res[0].length);\n    let nextIndex = res.index + res[0].length;\n    if (res[1] === 'if') {\n      let c = sub.indexOf(\"(\") + 1;\n      nextIndex += c\n      let condition = restOfExp(constants, sub.substring(c), [], \"(\");\n      oneLinerBlocks.lastIndex = res.index + c + condition.length + 1;\n      parts.push(str.substring(lastIndex, nextIndex), [condition], ')');\n      nextIndex += condition.length + 1;\n    } else {\n      parts.push(str.substring(lastIndex, nextIndex));\n    }\n    const spaceCount = /^\\s*/.exec(str.substring(nextIndex));\n    nextIndex += spaceCount[0].length;\n    sub = str.substring(nextIndex);\n    if (sub[0] !== '{') {\n      let body = restOfExp(constants, sub, [/^([;\\)\\]\\}]|\\r?\\n)/]);\n      let semi = 0;\n      if (sub[body.length] === \";\") semi = 1;\n      parts.push(\"{\", body, \"}\");\n      let rest = sub.substring(body.length + semi);\n      if (res[1] === 'if' && !/^\\s*else(?![\\w\\$])/.test(rest)) {\n        parts.push(\";\");\n      }\n      lastIndex = nextIndex + body.length + semi;\n    } else {\n      lastIndex = nextIndex;\n    }\n  }\n  parts.push(str.substring(lastIndex));\n  for (let p of parts) {\n    if (p instanceof Array) {\n      let c = convertOneLiners(constants, p[0]);\n      p.length = 0;\n      p.push(c)\n    }\n  }\n  return parts.flat().join(\"\");\n}\n\nexport function checkRegex(str: string): IRegEx | null {\n  let i = 1;\n  let escape = false;\n  let done = false;\n  let cancel = false;\n  while (i < str.length && !done && !cancel) {\n    done = (str[i] === '/' && !escape);\n    escape = str[i] === '\\\\' && !escape;\n    cancel = str[i] === '\\n';\n    i++;\n  }\n  let after = str.substring(i);\n  cancel = (cancel || !done) || /^\\s*\\d/.test(after);\n  if (cancel) return null;\n  let flags = /^[a-z]*/.exec(after);\n  if(/^\\s+[\\w\\$]/.test(str.substring(i + flags[0].length))) {\n    return null;\n  }\n  return {\n    regex: str.substring(1, i-1),\n    flags: (flags && flags[0]) || \"\",\n    length: i + ((flags && flags[0].length) || 0)\n  }\n}\n\nconst notDivide = /(typeof|delete|instanceof|return|in|of|throw|new|void|do|if)$/\nconst possibleDivide = /^([\\w\\$\\]\\)]|\\+\\+|\\-\\-)[^\\w\\$\\]\\)\\+\\-]/;\nexport function extractConstants(constants: IConstants, str: string, currentEnclosure = \"\"): {str: string, length: number} {\n  let quote;\n  let extract: string[] = [];\n  let escape = false;\n  let regexFound: IRegEx;\n  let comment = \"\";\n  let commentStart = -1;\n  let currJs: LispItem[] = [];\n  let char: string = \"\";\n  const strRes: string[] = []\n  const enclosures: string[] = [];\n  let isPossibleDivide: RegExpExecArray;\n  for (var i = 0; i < str.length; i++) {\n    char = str[i];\n    if (comment) {\n      if (char === comment) {\n        if (comment === \"*\" && str[i + 1] ===\"/\") {\n          comment = \"\";\n          i++\n        } else if (comment === \"\\n\") {\n          comment = \"\";\n        }\n      }\n    } else {\n      if (escape) {\n        escape = false;\n        extract.push(char);\n        continue;\n      }\n\n      if (quote) {\n        if (quote === \"`\" && char === \"$\" && str[i+1] === \"{\") {\n          let skip = extractConstants(constants, str.substring(i+2), \"{\");\n          currJs.push(skip.str);\n          extract.push(`\\${${currJs.length - 1}}`);\n          i += skip.length + 2;\n        } else if (quote === char) {\n          if (quote === '`') {\n            constants.literals.push({\n              op: 'literal',\n              a:  unraw(extract.join(\"\")),\n              b: currJs\n            });\n            strRes.push(`\\`${constants.literals.length - 1}\\``);\n          } else {\n            constants.strings.push(unraw(extract.join(\"\")));\n            strRes.push( `\"${constants.strings.length - 1}\"`);\n          }\n          quote = null;\n          extract = [];\n        } else {\n          extract.push(char);\n        }\n      } else {\n        if ((char === \"'\"  || char === '\"'  || char === '`')) {\n          currJs = [];\n          quote = char;\n        } else if (closings[currentEnclosure] === char && !enclosures.length) {\n          return {str: strRes.join(\"\"), length: i}\n        } else if (closings[char]) {\n          enclosures.push(char);\n          strRes.push(char);\n        } else if (closings[enclosures[enclosures.length-1]] === char) {\n          enclosures.pop();\n          strRes.push(char);\n        } else if (char === \"/\" && (str[i+1] === \"*\" || str[i+1] === \"/\")) {\n          comment = str[i+1] === \"*\" ? \"*\" : \"\\n\";\n          commentStart = i;\n        } else if (char === '/' && !isPossibleDivide && (regexFound = checkRegex(str.substring(i)))) {\n          constants.regexes.push(regexFound);\n          strRes.push(`/${constants.regexes.length - 1}/r`);\n          i += regexFound.length - 1;\n        } else {\n          strRes.push(char);\n        }\n\n        if (!(isPossibleDivide && space.test(char))) {\n          if (isPossibleDivide = possibleDivide.exec(str.substring(i))) {\n            if (notDivide.test(str.substring(0, i + isPossibleDivide[1].length))) {\n              isPossibleDivide = null;\n            }\n          }\n        }\n      }\n      escape = quote && char === \"\\\\\";\n    }\n  }\n\n  if (comment) {\n    if (comment === \"*\") {\n      throw new SyntaxError(`Unclosed comment '/*': ${str.substring(commentStart)}`)\n    }\n  }\n  return {str: strRes.join(\"\"), length: i}\n}\nexport function parse(code: string): IExecutionTree {\n  if (typeof code !== 'string') throw new ParseError(`Cannot parse ${code}`, code);\n  // console.log('parse', str);\n  let str = ' ' + code;\n  const constants: IConstants = {strings: [], literals: [], regexes: []};\n  str = extractConstants(constants, str).str;\n  str = insertSemicolons(constants, str, true);\n  str = convertOneLiners(constants, str);\n  // console.log(str);\n\n  try {\n    for (let l of constants.literals) {\n      l.b = l.b.map((js: string) => lispifyExpr(constants, js));\n    }\n    return {tree: lispifyFunction(str, constants), constants};\n  } catch (e) {\n    throw e;\n    throw new ParseError(e.message + \": \" + str.substring(0, 100) + '...', str);\n  }\n}\n","import { SpreadArray, LispItem, KeyVal, SpreadObject, If, Lisp, parse, IRegEx } from \"./parser.js\";\nimport { IExecContext, IContext } from \"./Sandbox.js\";\n\n\nexport type SandboxFunction = (code: string, ...args: any[]) => () => any;\nexport type sandboxedEval = (code: string) => any;\nexport type sandboxSetTimeout = (handler: TimerHandler, timeout?: any, ...args: any[]) => any;\nexport type sandboxSetInterval = (handler: TimerHandler, timeout?: any, ...args: any[]) => any;\nexport type Done = (err?: any, res?: any) => void\nexport class ExecReturn {\n  constructor(public auditReport: IAuditReport, public result: any, public returned: boolean, public breakLoop = false, public continueLoop = false) {}\n}\n\nexport interface IAuditReport {\n  globalsAccess: Set<any>;\n  prototypeAccess: {[name: string]: Set<string>}\n}\n\nexport interface IGlobals {\n  [key: string]: any\n}\n\nexport interface IChange {\n  type: string;\n}\n\nexport interface ICreate extends IChange {\n  type: \"create\";\n  prop: number|string;\n}\n\nexport interface IReplace extends IChange {\n  type: \"replace\";\n}\n\nexport interface IDelete extends IChange {\n  type: \"delete\";\n  prop: number|string;\n}\n\nexport interface IReverse extends IChange {\n  type: \"reverse\";\n}\n\nexport interface ISort extends IChange {\n  type: \"sort\";\n}\n\nexport interface IPush extends IChange {\n  type: \"push\";\n  added: unknown[];\n}\n\nexport interface IPop extends IChange {\n  type: \"pop\";\n  removed: unknown[];\n}\n\nexport interface IShift extends IChange {\n  type: \"shift\";\n  removed: unknown[];\n}\n\nexport interface IUnShift extends IChange {\n  type: \"unshift\";\n  added: unknown[];\n}\n\nexport interface ISplice extends IChange {\n  type: \"splice\";\n  startIndex: number;\n  deleteCount: number; \n  added: unknown[];\n  removed: unknown[];\n\n}\n\nexport interface ICopyWithin extends IChange {\n  type: \"copyWithin\";\n  startIndex: number;\n  endIndex: number;\n  added: unknown[];\n  removed: unknown[];\n}\n\nexport type Change = ICreate | IReplace | IDelete | IReverse | ISort | IPush | IPop | IUnShift | IShift | ISplice | ICopyWithin\n\nexport type replacementCallback = (obj: any, isStaticAccess: boolean) => any\n\nexport class Prop {\n  constructor(public context: {[key:string]: any}, public prop: string, public isConst = false, public isGlobal = false, public isVariable = false) {\n  }\n}\n\nconst reservedWords = new Set([\n  'instanceof',\n  'typeof',\n  'return',\n  'try',\n  'catch',\n  'if',\n  'finally',\n  'else',\n  'in',\n  'of',\n  'var',\n  'let',\n  'const',\n  'for',\n  'delete',\n  'false',\n  'true',\n  'while',\n  'do',\n  'break',\n  'continue',\n  'new',\n  'function',\n  'async',\n  'await',\n  'switch',\n  'case'\n]);\n\nenum VarType {\n  let = \"let\",\n  const = \"const\",\n  var = \"var\"\n}\n\nexport class Scope {\n  parent: Scope;\n  const = new Set<string>();\n  let = new Set<string>();\n  var: Set<string>;\n  globals: Set<string>;\n  allVars: {[key:string]: any} & Object;\n  functionThis?: any;\n  constructor(parent: Scope, vars = {}, functionThis?: any) {\n    const isFuncScope = functionThis !== undefined || parent === null;\n    this.parent = parent;\n    this.allVars = vars;\n    this.let = isFuncScope ? this.let : new Set(Object.keys(vars));\n    this.var = isFuncScope ? new Set(Object.keys(vars)) : this.var;\n    this.globals = parent === null ? new Set(Object.keys(vars)) : new Set();\n    this.functionThis = functionThis;\n  }\n\n  get(key: string, functionScope = false): any {\n    if (key === 'this' && this.functionThis !== undefined) {\n      return new Prop({this: this.functionThis}, key, true, false, true);\n    }\n    if (reservedWords.has(key)) throw new SyntaxError(\"Unexepected token '\" + key + \"'\");\n    if (this.parent === null || !functionScope || this.functionThis !== undefined) {\n      if (this.globals.has(key)) {\n        return new Prop(this.functionThis, key, false, true, true);\n      }\n      if (key in this.allVars && (!(key in {}) || this.allVars.hasOwnProperty(key))) {\n        return new Prop(this.allVars, key, this.const.has(key), this.globals.has(key), true);\n      }\n      if (this.parent === null) {\n        return new Prop(undefined, key);\n      }\n    }\n    return this.parent.get(key, functionScope)\n  }\n\n  set(key: string, val: any) {\n    if (key === 'this') throw new SyntaxError('\"this\" cannot be assigned')\n    if (reservedWords.has(key)) throw new SyntaxError(\"Unexepected token '\" + key + \"'\");\n    let prop = this.get(key);\n    if(prop.context === undefined) {\n      throw new ReferenceError(`Variable '${key}' was not declared.`);\n    }``\n    if (prop.isConst) {\n      throw new TypeError(`Cannot assign to const variable '${key}'`);\n    }\n    if (prop.isGlobal) {\n      throw new SandboxError(`Cannot override global variable '${key}'`);\n    }\n    prop.context[prop] = val;\n    return prop;\n  }\n\n  declare(key: string, type: VarType = null, value: any = undefined, isGlobal = false) {\n    if (key === 'this') throw new SyntaxError('\"this\" cannot be declared');\n    if (reservedWords.has(key)) throw new SyntaxError(\"Unexepected token '\" + key + \"'\");\n    if (type === 'var' && this.functionThis === undefined && this.parent !== null) {\n      return this.parent.declare(key, type, value, isGlobal)\n    } else if ((this[type].has(key) && type !== 'const' && !this.globals.has(key)) || !(key in this.allVars)) {\n      if (isGlobal) {\n        this.globals.add(key);\n      }\n      this[type].add(key);\n      this.allVars[key] = value;\n    } else {\n      throw new SandboxError(`Identifier '${key}' has already been declared`);\n    }\n    return new Prop(this.allVars, key, this.const.has(key), isGlobal);\n  }\n}\n\nexport class SandboxError extends Error {\n\n}\n\nexport function sandboxFunction(context: IContext): SandboxFunction {\n  return SandboxFunction;\n  function SandboxFunction(...params: any[]) {\n    let code = params.pop() || \"\";\n    let parsed = parse(code);\n    return createFunction(params, parsed.tree, {\n      ctx: context,\n      constants: parsed.constants\n    }, undefined, 'anonymous');\n  }\n}\n\nconst sandboxedFunctions = new WeakSet();\nexport function createFunction(argNames: string[], parsed: LispItem, context: IExecContext, scope?: Scope, name?: string) {\n  let func = function sandboxedObject(...args) {\n    const vars: any = {};\n    argNames.forEach((arg, i) => {\n      if (arg.startsWith('...')) {\n        vars[arg.substring(3)] = args.slice(i);\n      } else {\n        vars[arg] = args[i];\n      }\n    });\n    const res = executeTree(context, parsed, scope === undefined ? [] : [new Scope(scope, vars, name === undefined ? undefined : this)])\n    return res.result;\n  };\n  sandboxedFunctions.add(func);\n  return func;\n}\n\nexport function createFunctionAsync(argNames: string[], parsed: LispItem, context: IExecContext, scope?: Scope, name?: string) {\n  let func = async function sandboxedObject(...args) {\n    const vars: any = {};\n    argNames.forEach((arg, i) => {\n      if (arg.startsWith('...')) {\n        vars[arg.substring(3)] = args.slice(i);\n      } else {\n        vars[arg] = args[i];\n      }\n    });\n    const res = await executeTreeAsync(context, parsed, scope === undefined ? [] : [new Scope(scope, vars, name === undefined ? undefined : this)])\n    return res.result;\n  }\n  sandboxedFunctions.add(func);\n  return func;\n}\n\nexport function sandboxedEval(func: SandboxFunction): sandboxedEval {\n  return sandboxEval;\n  function sandboxEval(code: string) {\n    return func(code)();\n  }\n}\n\nexport function sandboxedSetTimeout(func: SandboxFunction): sandboxSetTimeout {\n  return function sandboxSetTimeout(handler, ...args) {\n    if (typeof handler !== 'string') return setTimeout(handler, ...args);\n    return setTimeout(func(handler), ...args);\n  }\n}\n\nexport function sandboxedSetInterval(func: SandboxFunction): sandboxSetInterval {\n  return function sandboxSetInterval(handler, ...args) {\n    if (typeof handler !== 'string') return setInterval(handler, ...args);\n    return setInterval(func(handler), ...args);\n  }\n}\n\nfunction assignCheck(obj: Prop, context: IExecContext, op = 'assign') {\n  if(obj.context === undefined) {\n    throw new ReferenceError(`Cannot ${op} value to undefined.`)\n  }\n  if(typeof obj.context !== 'object' && typeof obj.context !== 'function') {\n    throw new SyntaxError(`Cannot ${op} value to a primitive.`)\n  }\n  if (obj.isConst) {\n    throw new TypeError(`Cannot set value to const variable '${obj.prop}'`);\n  }\n  if (obj.isGlobal) {\n    throw new SandboxError(`Cannot ${op} property '${obj.prop}' of a global object`);\n  }\n  if (typeof obj.context[obj.prop] === 'function' && !obj.context.hasOwnProperty(obj.prop)) {\n    throw new SandboxError(`Override prototype property '${obj.prop}' not allowed`);\n  }\n  if (op === \"delete\") {\n    if (obj.context.hasOwnProperty(obj.prop)) {\n      context.ctx.changeSubscriptions.get(obj.context)?.forEach((cb) => cb({type: \"delete\", prop: obj.prop}));\n    }\n  } else if (obj.context.hasOwnProperty(obj.prop)) {\n    context.ctx.setSubscriptions.get(obj.context)?.get(obj.prop)?.forEach((cb) => cb({\n      type: \"replace\"\n    }));\n  } else {\n    context.ctx.changeSubscriptions.get(obj.context)?.forEach((cb) => cb({type: \"create\", prop: obj.prop}));\n  }\n}\nconst arrayChange = new Set([\n  [].push,\n  [].pop,\n  [].shift,\n  [].unshift,\n  [].splice,\n  [].reverse,\n  [].sort,\n  [].copyWithin\n]);\nconst literalRegex = /(\\$\\$)*(\\$)?\\${(\\d+)}/g;\ntype OpCallback = (exec: Execution, done: Done, a: LispItem, b: LispItem, obj: Prop|any|undefined, context: IExecContext, scope: Scope, bobj?: Prop|any|undefined) => void;\nlet ops2: {[op:string]: OpCallback} = {\n  'prop': (exec, done, a: LispItem|any, b: string, obj, context, scope) => {\n    if(a === null) {\n      throw new TypeError(`Cannot get property ${b} of null`);\n    }\n    const type = typeof a;\n    if (type === 'undefined' && obj === undefined) {\n      let prop = scope.get(b);\n      if (prop.context === undefined) throw new ReferenceError(`${b} is not defined`);\n      if (prop.context === context.ctx.sandboxGlobal) {\n        if (context.ctx.options.audit) {\n          context.ctx.auditReport.globalsAccess.add(b);\n        }\n        const rep = context.ctx.globalsWhitelist.has(context.ctx.sandboxGlobal[b]) ? context.ctx.evals.get(context.ctx.sandboxGlobal[b]) : undefined;\n        if (rep) {\n          done(undefined, rep);\n          return;\n        }\n      }\n      if (prop.context && prop.context[b] === globalThis) {\n        done(undefined, context.ctx.globalScope.get('this'));\n        return;\n      }\n\n      context.ctx.getSubscriptions.forEach((cb) => cb(prop.context, prop.prop));\n      done(undefined, prop);\n      return;\n    } else if (a === undefined) {\n      throw new SandboxError(\"Cannot get property '\" + b + \"' of undefined\")\n    }\n\n    if (type !== 'object') {\n      if(type === 'number') {\n        a = new Number(a);\n      } else if(type === 'string') {\n        a = new String(a);\n      } else if(type === 'boolean') {\n        a = new Boolean(a);\n      }\n    } else if (typeof a.hasOwnProperty === 'undefined') {\n      done(undefined, new Prop(undefined, b));\n      return;\n    }\n\n    const isFunction = type === 'function';\n    let prototypeAccess = isFunction || !(a.hasOwnProperty(b) || typeof b === 'number');\n\n    if (context.ctx.options.audit && prototypeAccess) {\n      if (typeof b === 'string') {\n        let prot = a.constructor.prototype;\n        do {\n          if (prot.hasOwnProperty(b)) {\n            if(!context.ctx.auditReport.prototypeAccess[prot.constructor.name]) {\n              context.ctx.auditReport.prototypeAccess[prot.constructor.name] = new Set();\n            }\n            context.ctx.auditReport.prototypeAccess[prot.constructor.name].add(b);\n          }\n        } while(prot = Object.getPrototypeOf(prot))\n      }\n    }\n\n    if (prototypeAccess) {\n      if (isFunction) {\n        if (!['name', 'length', 'constructor'].includes(b) && a.hasOwnProperty(b)) {\n          const whitelist = context.ctx.prototypeWhitelist.get(a);\n          const replace = context.ctx.prototypeReplacements.get(a);\n          if (replace) {\n            done(undefined, new Prop(replace(a, true), b));\n            return;\n          }\n          if (whitelist && (!whitelist.size || whitelist.has(b))) {\n          } else {\n            throw new SandboxError(`Static method or property access not permitted: ${a.name}.${b}`);\n          }\n        }\n      } else if (b !== 'constructor') {\n        let prot = a.constructor.prototype;\n        do {\n          if (prot.hasOwnProperty(b)) {\n            const whitelist = context.ctx.prototypeWhitelist.get(prot.constructor);\n            const replace = context.ctx.prototypeReplacements.get(prot.constuctor);\n            if (replace) {\n              done(undefined, new Prop(replace(a, false), b));\n              return;\n            }\n            if (whitelist && (!whitelist.size || whitelist.has(b))) {\n              break;\n            }\n            throw new SandboxError(`Method or property access not permitted: ${prot.constructor.name}.${b}`);\n          }\n        } while(prot = Object.getPrototypeOf(prot));\n      }\n    }\n\n    const rep = context.ctx.globalsWhitelist.has(a[b]) ? context.ctx.evals.get(a[b]) : undefined;\n    if (rep) {\n      done(undefined, rep);\n      return;\n    }\n    if (a[b] === globalThis) {\n      done(undefined, context.ctx.globalScope.get('this'));\n      return;\n    }\n\n    let g = obj.isGlobal || (isFunction && !sandboxedFunctions.has(a)) || context.ctx.globalsWhitelist.has(a);\n\n    if (!g) {\n      context.ctx.getSubscriptions.forEach((cb) => cb(a, b));\n    }\n    done(undefined, new Prop(a, b, false, g));\n  },\n  'call': (exec, done, a, b: LispItem[], obj, context, scope) => {\n    if (context.ctx.options.forbidMethodCalls) throw new SandboxError(\"Method calls are not allowed\");\n    if (typeof a !== 'function') {\n      throw new TypeError(`${obj.prop} is not a function`);\n    }\n    const args = b.map((item) => {\n      if (item instanceof SpreadArray) {\n        return [...item.item];\n      } else {\n        return [item];\n      }\n    }).flat();\n    execMany(exec, args, (err, vals) => {\n      if (err) {\n        done(err);\n        return;\n      }\n      if (typeof obj === 'function') {\n        done(undefined, obj(...vals));\n        return;\n      }\n      if (obj.context[obj.prop] === JSON.stringify && context.ctx.getSubscriptions.size) {\n        const cache = new Set<any>();\n        const recurse = (x: any) => {\n          if (!x || !(typeof x === 'object') || cache.has(x)) return;\n          cache.add(x);\n          for (let y in x) {\n            context.ctx.getSubscriptions.forEach((cb) => cb(x, y));\n            recurse(x[y]);\n          }\n        };\n        recurse(vals[0]);\n      }\n  \n      if (obj.context instanceof Array && arrayChange.has(obj.context[obj.prop]) && context.ctx.changeSubscriptions.get(obj.context)) {\n        let change: Change;\n        let changed = false;\n        if (obj.prop === \"push\") {\n          change = {\n            type: \"push\",\n            added: vals\n          }\n          changed = !!vals.length;\n        } else if (obj.prop === \"pop\") {\n          change = {\n            type: \"pop\",\n            removed: obj.context.slice(-1)\n          }\n          changed = !!change.removed.length;\n        }  else if (obj.prop === \"shift\") {\n          change = {\n            type: \"shift\",\n            removed: obj.context.slice(0, 1)\n          }\n          changed = !!change.removed.length;\n        } else if (obj.prop === \"unshift\") {\n          change = {\n            type: \"unshift\",\n            added: vals\n          }\n          changed = !!vals.length;\n        } else if (obj.prop === \"splice\") {\n          change = {\n            type: \"splice\",\n            startIndex: vals[0],\n            deleteCount: vals[1] === undefined ? obj.context.length : vals[1],\n            added: vals.slice(2),\n            removed: obj.context.slice(vals[0], vals[1] === undefined ? undefined : vals[0] + vals[1])\n          }\n          changed = !!change.added.length || !!change.removed.length;\n        } else if (obj.prop === \"reverse\" || obj.prop === \"sort\") {\n          change = {type: obj.prop}\n          changed = !!obj.context.length;\n        } else if (obj.prop === \"copyWithin\") {\n          let len = vals[2] === undefined ? obj.context.length - vals[1] : Math.min(obj.context.length, vals[2] - vals[1]);\n          change = {\n            type: \"copyWithin\",\n            startIndex: vals[0],\n            endIndex: vals[0] + len,\n            added: obj.context.slice(vals[1], vals[1] + len),\n            removed: obj.context.slice(vals[0], vals[0] + len)\n          }\n          changed = !!change.added.length || !!change.removed.length;\n        }\n        if (changed) {\n          context.ctx.changeSubscriptions.get(obj.context)?.forEach((cb) => cb(change));\n        }\n      }\n      done(undefined, obj.context[obj.prop](...vals));\n    }, scope, context);\n  },\n  'createObject': (exec, done, a, b: (KeyVal|SpreadObject)[], obj, context, scope) => {\n    let res = {} as any;\n    for (let item of b) {\n      if (item instanceof SpreadObject) {\n        res = {...res, ...item.item};\n      } else {\n        res[item.key] = item.val;\n      }\n    }\n    done(undefined, res);\n  },\n  'keyVal': (exec, done, a: string, b: LispItem) => done(undefined, new KeyVal(a, b)),\n  'createArray': (exec, done, a, b: LispItem[], obj, context, scope) => {\n    const items = b.map((item) => {\n      if (item instanceof SpreadArray) {\n        return [...item.item];\n      } else {\n        return [item];\n      }\n    }).flat()\n    execMany(exec, items, done, scope, context);\n  },\n  'group': (exec, done, a, b) => done(undefined, b),\n  'string': (exec, done, a, b: string, obj, context) => done(undefined, context.constants.strings[b]),\n  'regex': (exec, done, a, b: string, obj, context) => {\n    const reg: IRegEx = context.constants.regexes[b];\n    if (!context.ctx.globalsWhitelist.has(RegExp)) {\n      throw new SandboxError(\"Regex not permitted\");\n    } else {\n      done(undefined, new RegExp(reg.regex, reg.flags));\n    }\n  },\n  'literal': (exec, done, a, b: number, obj, context, scope) => {\n    let name: string = context.constants.literals[b].a;\n    let found = [];\n    let f;\n    let resnums = [];\n    while(f = literalRegex.exec(name)) {\n      if (!f[2]) {\n        found.push(context.constants.literals[b].b[parseInt(f[3], 10)]);\n        resnums.push(f[3]);\n      }\n    }\n\n    execMany(exec, found, (err, processed) => {\n      const reses = {};\n      if(err) {\n        done(err);\n        return;\n      }\n      for (let i in resnums) {\n        const num = resnums[i];\n        reses[num] = processed[i];\n      }\n      done(undefined, name.replace(/(\\\\\\\\)*(\\\\)?\\${(\\d+)}/g, (match, $$, $, num) => {\n        if ($) return match;\n        let res = reses[num]\n        res =  res instanceof Prop ? res.context[res.prop] : res;\n        return ($$ ? $$ : '') + `${res}`;\n      }));\n    }, scope, context)\n  },\n  'spreadArray': (exec, done, a, b, obj, context, scope) => {\n    exec(b, scope, context, (err, res) => {\n      if (err) {\n        done(err);\n        return;\n      }\n      done(undefined, new SpreadArray(res));\n    });\n  },\n  'spreadObject': (exec, done, a, b, obj, context, scope) => {\n    exec(b, scope, context, (err, res) => {\n      if (err) {\n        done(err);\n        return;\n      }\n      done(undefined, new SpreadObject(res));\n    });\n  },\n  '!': (exec, done, a, b) => done(undefined, !b),\n  '~': (exec, done, a, b) => done(undefined, ~b),\n  '++$': (exec, done, a, b, obj, context) => {\n    assignCheck(obj, context);\n    done(undefined, ++obj.context[obj.prop]);\n  },\n  '$++': (exec, done, a, b, obj, context) => {\n    assignCheck(obj, context);\n    done(undefined, obj.context[obj.prop]++);\n  },\n  '--$': (exec, done, a, b, obj, context) => {\n    assignCheck(obj, context);\n    done(undefined, --obj.context[obj.prop]);\n  },\n  '$--': (exec, done, a, b, obj, context) => {\n    assignCheck(obj, context);\n    done(undefined, obj.context[obj.prop]--);\n  },\n  '=': (exec, done, a, b, obj, context) => {\n    assignCheck(obj, context);\n    obj.context[obj.prop] = b;\n    done(undefined, new Prop(obj.context, obj.prop, false, obj.isGlobal));\n  },\n  '+=': (exec, done, a, b, obj, context) => {\n    assignCheck(obj, context);\n    done(undefined, obj.context[obj.prop] += b);\n  },\n  '-=': (exec, done, a, b: number, obj, context) => {\n    assignCheck(obj, context);\n    done(undefined, obj.context[obj.prop] -= b);\n  },\n  '/=': (exec, done, a, b: number, obj, context) => {\n    assignCheck(obj, context);\n    done(undefined, obj.context[obj.prop] /= b);\n  },\n  '*=': (exec, done, a, b: number, obj, context) => {\n    assignCheck(obj, context);\n    done(undefined, obj.context[obj.prop] *= b);\n  },\n  '**=': (exec, done, a, b: number, obj, context) => {\n    assignCheck(obj, context);\n    done(undefined, obj.context[obj.prop] **= b);\n  },\n  '%=': (exec, done, a, b: number, obj, context) => {\n    assignCheck(obj, context);\n    done(undefined, obj.context[obj.prop] %= b);\n  },\n  '^=': (exec, done, a, b: number, obj, context) => {\n    assignCheck(obj, context);\n    done(undefined, obj.context[obj.prop] ^= b);\n  },\n  '&=': (exec, done, a, b: number, obj, context) => {\n    assignCheck(obj, context);\n    done(undefined, obj.context[obj.prop] &= b);\n  },\n  '|=': (exec, done, a, b: number, obj, context) => {\n    assignCheck(obj, context);\n    done(undefined, obj.context[obj.prop] |= b);\n  },\n  '<<=': (exec, done, a, b: number, obj, context) => {\n    assignCheck(obj, context);\n    done(undefined, obj.context[obj.prop] <<= b);\n  },\n  '>>=': (exec, done, a, b: number, obj, context) => {\n    assignCheck(obj, context);\n    done(undefined, obj.context[obj.prop] >>= b);\n  },\n  '>>>=': (exec, done, a, b: number, obj, context) => {\n    assignCheck(obj, context);\n    done(undefined, obj.context[obj.prop] >>= b);\n  },\n  '?': (exec, done, a, b) => {\n    if (!(b instanceof If)) {\n      throw new SyntaxError('Invalid inline if')\n    }\n    done(undefined, a ? (b as any).t : (b as any).f);\n  },\n  '>': (exec, done, a, b) => done(undefined, a > b),\n  '<': (exec, done, a, b) => done(undefined, a < b),\n  '>=': (exec, done, a, b) => done(undefined, a >= b),\n  '<=': (exec, done, a, b) => done(undefined, a <= b),\n  '==': (exec, done, a, b) => done(undefined, a == b),\n  '===': (exec, done, a, b) => done(undefined, a === b),\n  '!=': (exec, done, a, b) => done(undefined, a != b),\n  '!==': (exec, done, a, b) => done(undefined, a !== b),\n  '&&': (exec, done, a, b) => done(undefined, a && b),\n  '||': (exec, done, a, b) => done(undefined, a || b),\n  '&': (exec, done, a: number, b: number) => done(undefined, a & b),\n  '|': (exec, done, a: number, b: number) => done(undefined, a | b),\n  ':': (exec, done, a, b) => done(undefined, new If(a, b)),\n  '+': (exec, done, a: number, b: number) => done(undefined, a + b),\n  '-': (exec, done, a: number, b: number) => done(undefined, a - b),\n  '$+': (exec, done, a, b) => done(undefined, +b),\n  '$-': (exec, done, a, b) => done(undefined, -b),\n  '/': (exec, done, a: number, b: number) => done(undefined, a / b),\n  '^': (exec, done, a: number, b: number) => done(undefined, a ^ b),\n  '*': (exec, done, a: number, b: number) => done(undefined, a * b),\n  '%': (exec, done, a: number, b: number) => done(undefined, a % b),\n  '<<': (exec, done, a: number, b: number) => done(undefined, a << b),\n  '>>': (exec, done, a: number, b: number) => done(undefined, a >> b),\n  '>>>': (exec, done, a: number, b: number) => done(undefined, a >>> b),\n  'typeof': (exec, done, a, b) => done(undefined, typeof b),\n  'instanceof': (exec, done, a, b:  { new(): any }) => done(undefined, a instanceof b),\n  'in': (exec, done, a: string, b) => done(undefined, a in b),\n  'delete': (exec, done, a, b, obj, context, scope, bobj: Prop) => {\n    if (bobj.context === undefined) {\n      done(undefined, true);\n      return;\n    }\n    assignCheck(bobj, context, 'delete');\n    if (bobj.isVariable) {\n      done(undefined, false);\n      return;\n    }\n    done(undefined, delete bobj.context[bobj.prop]);\n  },\n  'return': (exec, done, a, b, obj, context) => done(undefined, b),\n  'var': (exec, done, a: string, b, obj, context, scope, bobj) => {\n    exec(b, scope, context, (err, res) => {\n      if (err) {\n        done(err);\n        return;\n      }\n      done(undefined, scope.declare(a, VarType.var, res));\n    });\n  },\n  'let': (exec, done, a: string, b, obj, context, scope, bobj) => {\n    exec(b, scope, context, (err, res) => {\n      if (err) {\n        done(err);\n        return;\n      }\n      done(undefined, scope.declare(a, VarType.let, res, bobj && bobj.isGlobal));\n    });\n  },\n  'const': (exec, done, a: string, b, obj, context, scope, bobj) => {\n    exec(b, scope, context, (err, res) => {\n      if (err) {\n        done(err);\n        return;\n      }\n      done(undefined, scope.declare(a, VarType.const, res));\n    });\n  },\n  'arrowFunc': (exec, done, a: string[], b: LispItem, obj, context, scope) => {\n    if (a.shift()) {\n      done(undefined, createFunctionAsync(a, b, context, scope));\n    } else {\n      done(undefined, createFunction(a, b, context, scope));\n    }\n  },\n  'function': (exec, done, a: string[], b: LispItem, obj, context, scope) => {\n    let isAsync = a.shift();\n    let name = a.shift();\n    let func;\n    if (isAsync) {\n      func = createFunctionAsync(a, b, context, scope, name);\n    } else {\n      func = createFunction(a, b, context, scope, name);\n    }\n    if (name) {\n      scope.declare(name, VarType.var, func);\n    }\n    done(undefined, func);\n  },\n  'inlineFunction': (exec, done, a: string[], b: LispItem, obj, context, scope) => {\n    let isAsync = a.shift();\n    let name = a.shift();\n    if (name) {\n      scope = new Scope(scope, {})\n    }\n    let func;\n    if (isAsync) {\n      func = createFunctionAsync(a, b, context, scope, name);\n    } else {\n      func = createFunction(a, b, context, scope, name);\n    }\n    if (name) {\n      scope.declare(name, VarType.let, func);\n    }\n    done(undefined, func);\n  },\n  'loop': (exec, done, a: LispItem[], b: LispItem, obj, context, scope) => {\n    const [checkFirst, startInternal, startStep, step, condition, beforeStep] = a;\n    let loop = true;\n    const loopScope = new Scope(scope, {});\n    const interalScope = new Scope(loopScope, {});\n    if (exec === execAsync) {\n      (async() => {\n        await asyncDone((d) => exec(startStep, loopScope, context, d));\n        await asyncDone((d) => exec(startInternal, interalScope, context, d));\n        if (checkFirst) loop = (await asyncDone((d) => exec(condition, interalScope, context, d))).result;\n        while (loop) {\n          let innerLoopVars = {};\n          await asyncDone((d) => exec(beforeStep, new Scope(interalScope, innerLoopVars), context, d));\n          let res = await executeTreeAsync(context, b, [new Scope(loopScope, innerLoopVars)], \"loop\");\n          if (res instanceof ExecReturn && res.returned) {\n            done(undefined, res);\n            return;\n          }\n          if (res instanceof ExecReturn && res.breakLoop) {\n            break;\n          }\n          await asyncDone((d) => exec(step, interalScope, context, d));\n          loop = (await asyncDone((d) => exec(condition, interalScope, context, d))).result;\n        }\n        done();\n      })().catch(done);\n    } else {\n      syncDone((d) => exec(startStep, loopScope, context, d));\n      syncDone((d) => exec(startInternal, interalScope, context, d));\n      if (checkFirst) loop = (syncDone((d) => exec(condition, interalScope, context, d))).result;\n      while (loop) {\n        let innerLoopVars = {};\n        syncDone((d) => exec(beforeStep, new Scope(interalScope, innerLoopVars), context, d));\n        let res = executeTree(context, b, [new Scope(loopScope, innerLoopVars)], \"loop\");\n        if (res instanceof ExecReturn && res.returned) {\n          done(undefined, res);\n          return;\n        }\n        if (res instanceof ExecReturn && res.breakLoop) {\n          break;\n        }\n        syncDone((d) => exec(step, interalScope, context, d));\n        loop = (syncDone((d) => exec(condition, interalScope, context, d))).result;\n      }\n      done();\n    }\n  },\n  'loopAction': (exec, done, a: LispItem, b: LispItem, obj, context, scope) => {\n    if ((context.inLoopOrSwitch === \"switch\" && a === \"continue\") || !context.inLoopOrSwitch) {\n      throw new SandboxError(\"Illegal \" + a + \" statement\");\n    }\n    done(undefined, new ExecReturn(context.ctx.auditReport, undefined, false, a === \"break\", a === \"continue\"));\n  },\n  'if': (exec, done, a: LispItem, b: If, obj, context, scope) => {\n    if (!(b instanceof If)) {\n      throw new SyntaxError('Invalid if')\n    }\n    exec(a, scope, context, (err, res) => {\n      if (err) {\n        done(err);\n        return;\n      }\n      executeTreeWithDone(exec, done, context, res ? b.t : b.f, [new Scope(scope)], context.inLoopOrSwitch);\n    });\n  },\n  'switch': (exec, done, a: LispItem, b: Lisp[], obj, context, scope) => {\n    exec(a, scope, context, (err, toTest) => {\n      if (err) {\n        done(err);\n        return;\n      }\n      if (exec === execSync) {\n        let res: ExecReturn;\n        let isTrue = false;\n        for (let caseItem of b) {\n          if (isTrue || (isTrue = !caseItem.a || toTest === valueOrProp((syncDone((d) => exec(caseItem.a, scope, context, d))).result))) {\n            if (!caseItem.b) continue;\n            res = executeTree(context, caseItem.b, [scope], \"switch\");\n            if (res.breakLoop) break;\n            if (res.returned) {\n              done(undefined, res);\n              return;\n            }\n            if (!caseItem.a) { // default case\n              break;\n            }\n          }\n        }\n        done();\n      } else {\n        (async () => {\n          let res: ExecReturn;\n          let isTrue = false;\n          for (let caseItem of b) {\n            if (isTrue || (isTrue = !caseItem.a || toTest === valueOrProp((await asyncDone((d) => exec(caseItem.a, scope, context, d))).result))) {\n              if (!caseItem.b) continue;\n              res = await executeTreeAsync(context, caseItem.b, [scope], \"switch\");\n              if (res.breakLoop) break;\n              if (res.returned) {\n                done(undefined, res);\n                return;\n              }\n              if (!caseItem.a) { // default case\n                break;\n              }\n            }\n          }\n          done();\n        })().catch(done)\n      }\n    });\n  },\n  'try': (exec, done, a: LispItem, b: [string, LispItem, LispItem], obj, context, scope) => {\n    const [exception, catchBody, finallyBody] = b;\n    executeTreeWithDone(exec, (err, res) => {\n      executeTreeWithDone(exec, (e) => {\n        if (e) done(e);\n        else  if (err) {\n          let sc = {};\n          if (exception) sc[exception] = err;\n          executeTreeWithDone(exec, done, context, catchBody, [new Scope(scope)], context.inLoopOrSwitch);\n        } else {\n          done(undefined, res);\n        }\n      }, context, finallyBody, [new Scope(scope, {})]);\n    }, context, a, [new Scope(scope)], context.inLoopOrSwitch);\n  },\n  'void': (exec, done, a) => {done()},\n  'new': (exec, done, a: new (...args: any[]) => any, b: any[], obj, context) => {\n    if (!context.ctx.globalsWhitelist.has(a) && !sandboxedFunctions.has(a)) {\n      throw new SandboxError(`Object construction not allowed: ${a.constructor.name}`)\n    }\n    done(undefined, new a(...b))\n  },\n  'throw': (exec, done, a) => { done(a) },\n  'multi': (exec, done, a: any[], b, obj, context, scope) => done(undefined, a.pop())\n}\n\nlet ops = new Map<string, OpCallback>();\nfor (let op in ops2) {\n  ops.set(op, ops2[op]);\n}\n\nfunction valueOrProp(a: any) {\n  if (a instanceof Prop) return a.context[a.prop];\n  return a;\n}\n\nfunction execMany(exec: Execution, tree: LispItem[], done: Done, scope: Scope, context: IExecContext) {\n  let ret = [];\n  let i = 0;\n  if (!tree.length) {\n    done(undefined, []);\n    return;\n  }\n  const next = (err, res) => {\n    if (err) {\n      done(err);\n      return;\n    }\n    ret.push(res);\n    if (++i < tree.length) {\n      exec(tree[i], scope, context, next);\n    } else {\n      done(undefined, ret);\n    }\n  }\n  exec(tree[i], scope, context, next);\n}\n\ntype Execution = (tree: LispItem, scope: Scope, context: IExecContext, done: Done) => void\n\nfunction asyncDone(callback: (done: Done) => void): Promise<{result: any}> {\n  return new Promise((resolve, reject) => {\n    callback((err, result) => {\n      if (err) reject(err);\n      else resolve({result});\n    });\n  });\n}\n\nfunction syncDone(callback: (done: Done) => void): {result: any} {\n  let result;\n  let err;\n  callback((e, r) => {\n    err = e;\n    result = r;\n  });\n  // console.log(result);\n  if (err) throw err;\n  return {result};\n}\n\nasync function execAsync(tree: LispItem, scope: Scope, context: IExecContext, done: Done): Promise<any> {\n  let result;\n  try {\n    if (tree instanceof Prop) {\n      result = tree.context[tree.prop];\n    } else if (Array.isArray(tree)) {\n      let res: any[]|ExecReturn = [];\n      for (let item of tree) {\n        const ret = (await asyncDone((done) => execAsync(item, scope, context, done))).result;\n        if (ret instanceof ExecReturn) {\n          res.push(ret.result);\n          if (ret.returned || ret.breakLoop || ret.continueLoop) {\n            res = ret;\n            break;\n          }\n        } else {\n          res.push(ret);\n        }\n      }\n      result =  res;\n    } else if (!(tree instanceof Lisp)) {\n      result = tree;\n    } else if (['arrowFunc', 'function', 'inlineFunction', 'loop', 'try', 'switch', 'if'].includes(tree.op)) {\n      result = (await asyncDone((d) => ops.get(tree.op)(execAsync, d, tree.a, tree.b, undefined, context, scope))).result;\n    } else if (tree.op === 'await') {\n      result = await (await asyncDone((done) => execAsync(tree.a, scope, context, done))).result;\n    } else {\n      let obj = (await asyncDone((done) => execAsync(tree.a, scope, context, done))).result;\n      let a = obj instanceof Prop ? (obj.context ? obj.context[obj.prop] : undefined) : obj;\n      let bobj = (await asyncDone((done) => execAsync(tree.b, scope, context, done))).result;\n      let b = bobj instanceof Prop ? (bobj.context ? bobj.context[bobj.prop] : undefined) : bobj;\n      if (ops.has(tree.op)) {\n        result = (await asyncDone((d) => ops.get(tree.op)(execAsync, d, a, b, obj, context, scope, bobj))).result;\n      } else {\n        throw new SyntaxError('Unknown operator: ' + tree.op);\n      }\n    }\n    done(undefined, result);\n  } catch (err) {\n    done(err);\n  }\n}\n\nfunction syncDoneExec(tree: LispItem, scope: Scope, context: IExecContext) {\n  let result;\n  let err;\n  execSync(tree, scope, context, (e, r) => {\n    err = e;\n    result = r;\n  });\n  if (err) throw err;\n  return {result}\n}\n\nfunction syncDoneOp(op: string, a: LispItem, b: LispItem, obj: Prop|any|undefined, context: IExecContext, scope: Scope, bobj?: Prop|any|undefined) {\n  let result;\n  let err;\n  ops.get(op)(execSync, (e, r) => {\n    err = e;\n    result = r;\n  }, a, b , obj, context, scope, bobj);\n  if (err) throw err;\n  return {result}\n}\n\nfunction execSync(tree: LispItem, scope: Scope, context: IExecContext, done: Done): any {\n  let result;\n  if (tree instanceof Prop) {\n    result = tree.context[tree.prop];\n  } else if (Array.isArray(tree)) {\n    let res: any[]|ExecReturn = [];\n    for (let item of tree) {\n      const ret = syncDoneExec(item, scope, context).result;\n      if (ret instanceof ExecReturn) {\n        res.push(ret.result);\n        if (ret.returned || ret.breakLoop || ret.continueLoop) {\n          res = ret;\n          break;\n        }\n      } else {\n        res.push(ret);\n      }\n    }\n    result =  res;\n  } else if (!(tree instanceof Lisp)) {\n    result = tree;\n  } else if (['arrowFunc', 'function', 'inlineFunction', 'loop', 'try', 'switch', 'if'].includes(tree.op)) {\n    result = syncDoneOp(tree.op, tree.a, tree.b, undefined, context, scope).result;\n  } else if (tree.op === 'await') {\n      throw new SandboxError(\"Illegal use of 'await', must be inside async function\");\n  } else {\n    let obj = syncDoneExec(tree.a, scope, context).result;\n    let a = obj instanceof Prop ? (obj.context ? obj.context[obj.prop] : undefined) : obj;\n    let bobj = syncDoneExec(tree.b, scope, context).result;\n    let b = bobj instanceof Prop ? (bobj.context ? bobj.context[bobj.prop] : undefined) : bobj;\n    if (ops.has(tree.op)) {\n      result = syncDoneOp(tree.op, a, b, obj, context, scope, bobj).result;\n    } else {\n      throw new SyntaxError('Unknown operator: ' + tree.op);\n    }\n  }\n  done(undefined, result);\n}\n\nexport function executeTree(context: IExecContext, executionTree: LispItem, scopes: ({[key:string]: any}|Scope)[] = [], inLoopOrSwitch?: string): ExecReturn {\n  return syncDone((done) => executeTreeWithDone(execSync, done, context, executionTree, scopes, inLoopOrSwitch)).result;\n}\n\nexport async function executeTreeAsync(context: IExecContext, executionTree: LispItem, scopes: ({[key:string]: any}|Scope)[] = [], inLoopOrSwitch?: string): Promise<ExecReturn> {\n  return (await asyncDone((done) => executeTreeWithDone(execAsync, done, context, executionTree, scopes, inLoopOrSwitch))).result;\n}\n\nfunction executeTreeWithDone(exec: Execution, done: Done, context: IExecContext, executionTree: LispItem, scopes: ({[key:string]: any}|Scope)[] = [], inLoopOrSwitch?: string) {\n  if (!executionTree)  {\n    done();\n    return;\n  }\n  if (!(executionTree instanceof Array)) throw new SyntaxError('Bad execution tree')\n  context = {\n    ctx: context.ctx,\n    constants: context.constants, \n    inLoopOrSwitch\n  };\n  let scope = context.ctx.globalScope;\n  let s;\n  while (s = scopes.shift()) {\n    if (typeof s !== \"object\") continue;\n    if (s instanceof Scope) {\n      scope = s;\n    } else {\n      scope = new Scope(scope, s, null);\n    }\n  }\n  if (context.ctx.options.audit && !context.ctx.auditReport) {\n    context.ctx.auditReport = {\n      globalsAccess: new Set(),\n      prototypeAccess: {},\n    }\n  }\n  let i = 0;\n  let current = executionTree[i];\n  const next = (err, res) => {\n    if (err) {\n      done(new err.constructor(err.message));\n      return;\n    }\n    if (res instanceof ExecReturn) {\n      done(undefined, res);\n      return;\n    }\n    if (current instanceof Lisp && current.op === 'return') {\n      done(undefined, new ExecReturn(context.ctx.auditReport, res, true))\n      return;\n    }\n    if (++i < executionTree.length) {\n      current = executionTree[i];\n      try {\n        exec(current, scope, context, next);\n      } catch (e) {\n        done(e);\n      }\n    } else {\n      done(undefined, new ExecReturn(context.ctx.auditReport, undefined, false));\n    }\n  }\n  try {\n    exec(current, scope, context, next);\n  } catch (e) {\n    done(e);\n  }\n}\n","import { \n  IGlobals, \n  replacementCallback, \n  IAuditReport, \n  Scope, \n  Change, \n  sandboxFunction,\n  sandboxedEval,\n  sandboxedSetTimeout,\n  sandboxedSetInterval,\n  ExecReturn,\n  executeTree,\n  executeTreeAsync\n} from \"./executor.js\";\nimport { IConstants, parse, IExecutionTree } from \"./parser.js\";\n\nexport interface IOptions {\n  audit?: boolean;\n  forbidMethodCalls?: boolean;\n}\n\nexport interface IContext {\n  sandbox: Sandbox;\n  globals: IGlobals;\n  globalsWhitelist: Set<any>;\n  prototypeWhitelist: Map<Function, Set<string>>;\n  prototypeReplacements: Map<Function, replacementCallback>;\n  globalScope: Scope;\n  sandboxGlobal: SandboxGlobal;\n  options: IOptions;\n  evals: Map<any, any>;\n  getSubscriptions: Set<(obj: object, name: string) => void>;\n  setSubscriptions: WeakMap<object, Map<string, Set<(modification: Change) => void>>>;\n  changeSubscriptions: WeakMap<object, Set<(modification: Change) => void>>;\n  auditReport?: IAuditReport;\n}\n\nexport interface IExecContext {\n  ctx: IContext\n  inLoopOrSwitch?: string;\n  constants: IConstants\n}\n\nexport class SandboxGlobal {\n  constructor(globals: IGlobals) {\n    if (globals === globalThis) return globalThis;\n    for (let i in globals) {\n      (this as any)[i] = globals[i];\n    }\n  }\n}\n\nexport default class Sandbox {\n  context: IContext\n  constructor(globals: IGlobals = Sandbox.SAFE_GLOBALS, prototypeWhitelist: Map<Function, Set<string>> = Sandbox.SAFE_PROTOTYPES, prototypeReplacements = new Map<Function, replacementCallback>(),  options: IOptions = {audit: false}) {\n    const sandboxGlobal = new SandboxGlobal(globals);\n    this.context = {\n      sandbox: this,\n      globals,\n      prototypeWhitelist,\n      prototypeReplacements,\n      globalsWhitelist: new Set(Object.values(globals)),\n      options,\n      globalScope: new Scope(null, globals, sandboxGlobal),\n      sandboxGlobal,\n      evals: new Map(),\n      getSubscriptions: new Set<(obj: object, name: string) => void>(),\n      setSubscriptions: new WeakMap<object, Map<string, Set<() => void>>>(),\n      changeSubscriptions: new WeakMap()\n    };\n    const func = sandboxFunction(this.context);\n    this.context.evals.set(Function, func);\n    this.context.evals.set(eval, sandboxedEval(func));\n    this.context.evals.set(setTimeout, sandboxedSetTimeout(func));\n    this.context.evals.set(setInterval, sandboxedSetInterval(func));\n  }\n\n  static get SAFE_GLOBALS(): IGlobals {\n    return {\n      Function,\n      console: {\n        debug: console.debug, \n        error: console.error, \n        info: console.info, \n        log: console.log, \n        table: console.table, \n        warn: console.warn\n      },\n      isFinite,\n      isNaN,\n      parseFloat,\n      parseInt,\n      decodeURI,\n      decodeURIComponent,\n      encodeURI,\n      encodeURIComponent,\n      escape,\n      unescape,\n      Boolean,\n      Number,\n      String,\n      Object,\n      Array,\n      Symbol,\n      Error,\n      EvalError,\n      RangeError,\n      ReferenceError,\n      SyntaxError,\n      TypeError,\n      URIError,\n      Int8Array,\n      Uint8Array,\n      Uint8ClampedArray,\n      Int16Array,\n      Uint16Array,\n      Int32Array,\n      Uint32Array,\n      Float32Array,\n      Float64Array,\n      Map,\n      Set,\n      WeakMap,\n      WeakSet,\n      Promise,\n      Intl,\n      JSON,\n      Math,\n      Date,\n    }\n  }\n\n  \n  static get SAFE_PROTOTYPES(): Map<any, Set<string>> {\n    let protos = [\n      SandboxGlobal,\n      Function,\n      Boolean,\n      Number,\n      String,\n      Date,\n      Error,\n      Array,\n      Int8Array,\n      Uint8Array,\n      Uint8ClampedArray,\n      Int16Array,\n      Uint16Array,\n      Int32Array,\n      Uint32Array,\n      Float32Array,\n      Float64Array,\n      Map,\n      Set,\n      WeakMap,\n      WeakSet,\n      Promise,\n      Symbol,\n      Date,\n    ]\n    let map = new Map<any, Set<string>>();\n    protos.forEach((proto) => {\n      map.set(proto, new Set());\n    });\n    map.set(Object, new Set([\n      'entries',\n      'fromEntries',\n      'getOwnPropertyNames',\n      'is',\n      'keys',\n      'hasOwnProperty',\n      'isPrototypeOf',\n      'propertyIsEnumerable',\n      'toLocaleString',\n      'toString',\n      'valueOf',\n      'values'\n    ]));\n    return map;\n  }\n  \n  subscribeGet(callback: (obj: object, name: string) => void): {unsubscribe: () => void} {\n    this.context.getSubscriptions.add(callback);\n    return {unsubscribe: () => this.context.getSubscriptions.delete(callback)}\n  }\n\n  subscribeSet(obj: object, name: string, callback: (modification: Change) => void): {unsubscribe: () => void} {\n    const names = this.context.setSubscriptions.get(obj) || new Map<string, Set<(modification: Change) => void>>();\n    this.context.setSubscriptions.set(obj, names);\n    const callbacks = names.get(name) || new Set();\n    names.set(name, callbacks);\n    callbacks.add(callback);\n    let changeCbs: Set<(modification: Change) => void>;\n    if (obj && obj[name] && typeof obj[name] === \"object\") {\n      changeCbs = this.context.changeSubscriptions.get(obj[name]) || new Set();\n      changeCbs.add(callback);\n      this.context.changeSubscriptions.set(obj[name], changeCbs);\n    }\n    return {unsubscribe: () => {\n      callbacks.delete(callback);\n      if (changeCbs) changeCbs.delete(callback);\n    }}\n  }\n\n  static audit(code: string, scopes: ({[prop: string]: any}|Scope)[] = []): ExecReturn {\n    return new Sandbox(globalThis, new Map(), new Map(), {\n      audit: true,\n    }).executeTree(parse(code), scopes);\n  }\n\n  static parse(code: string) {\n    return parse(code);\n  }\n\n  executeTree(executionTree: IExecutionTree, scopes: ({[key:string]: any}|Scope)[] = []): ExecReturn {\n    return executeTree({\n      ctx: this.context,\n      constants: executionTree.constants\n    }, executionTree.tree, scopes);\n  }\n\n  executeTreeAsync(executionTree: IExecutionTree, scopes: ({[key:string]: any}|Scope)[] = []): Promise<ExecReturn> {\n    return executeTreeAsync({\n      ctx: this.context,\n      constants: executionTree.constants\n    }, executionTree.tree, scopes);\n  }\n  \n  compile(code: string): (...scopes: ({[prop: string]: any}|Scope)[]) => any {\n    const executionTree = parse(code);\n    return (...scopes: {[key:string]: any}[]) => {\n      return this.executeTree(executionTree, scopes).result;\n    };\n  };\n  \n  compileAsync(code: string): (...scopes: ({[prop: string]: any}|Scope)[]) => Promise<any> {\n    const executionTree = parse(code);\n    return async (...scopes: {[key:string]: any}[]) => {\n      return (await this.executeTreeAsync(executionTree, scopes)).result;\n    };\n  };\n}\n"],"names":["parseHexToInt","hex","match","parseInt","NaN","validateAndParseHex","errorName","enforcedLength","parsedHex","Number","isNaN","undefined","length","SyntaxError","parseHexadecimalCode","code","parsedCode","String","fromCharCode","parseUnicodeCode","surrogateCode","parsedSurrogateCode","isCurlyBraced","text","charAt","parseUnicodeCodePointCode","codePoint","slice","fromCodePoint","err","RangeError","singleCharacterEscapes","Map","parseSingleCharacterCode","get","escapeMatch","unraw","raw","replace","_","backslash","unicodeWithSurrogate","surrogate","unicode","octal","singleCharacter","lispTypes","ParseError","Error","constructor","message","Lisp","obj","op","a","b","If","t","f","KeyVal","key","val","SpreadObject","item","SpreadArray","inlineIfElse","space","expectTypes","splitter","types","split","next","inlineIf","assignment","assignModify","assign","incrementerBefore","expEdge","call","incrementerAfter","modifier","not","inverse","negative","positive","typeof","delete","dot","arrayProp","prop","value","createObject","createArray","number","string","literal","regex","boolean","null","und","arrowFunctionSingle","arrowFunction","inlineFunction","group","Infinity","void","await","new","throw","initialize","return","spreadObject","spreadArray","expEnd","expSingle","for","do","while","loopAction","if","try","function","switch","closings","okFirstChars","aChar","aNumber","restOfExp","constants","part","tests","quote","firstOpening","closingsTests","details","allChars","isStart","i","escape","done","lastIsChar","currentIsChar","lastChar","word","char","test","substring","skip","sub","lastIndex","found","exec","foundNumber","Math","min","setLispType","fn","forEach","type","set","closingsCreate","res","expect","ctx","extract","arg","end","push","l","funcFound","lispifyExpr","join","map","e","lispify","str","trimStart","lispTree","includes","trim","quoteCount","condition","isBlock","startTrue","trueBlock","elseBlock","foundElse","lispifyBlock","start","indexOf","caseFound","statement","insertSemicolons","caseTest","cases","defaultFound","cond","bracketFound","exprs","notEmpty","lines","index","matches","primitives","JSON","parse","isArrow","isReturn","argPos","isAsync","args","unshift","ended","startsWith","func","lispifyFunction","iteratorRegex","body","startStep","startInternal","beforeStep","checkFirst","step","iterator","extract2","k","ofStart2","ofStart3","ofCondition","ofStep","inStart2","inStart3","inStep","inCondition","shift","startingExecpted","catchReg","finallyBody","exception","catchBody","catchRes","offset","argsString","j","lastType","lastPart","expected","subExpressions","pos","defined","parts","filter","Boolean","flat","tree","hoisted","hoist","concat","Array","isArray","rep","it","edgesForInsertion","closingsForInsertion","closingsNoInsertion","whileEnding","rest","pop","oneLinerBlocks","convertOneLiners","nextIndex","c","semi","p","checkRegex","cancel","after","flags","notDivide","possibleDivide","extractConstants","regexFound","isPossibleDivide","currentEnclosure","comment","commentStart","currJs","strRes","enclosures","literals","strings","regexes","js","ExecReturn","auditReport","result","returned","breakLoop","continueLoop","Prop","context","isConst","isGlobal","isVariable","reservedWords","Set","VarType","Scope","parent","vars","functionThis","isFuncScope","allVars","let","this","Object","keys","var","globals","functionScope","has","hasOwnProperty","const","ReferenceError","TypeError","SandboxError","declare","add","sandboxFunction","SandboxFunction","params","parsed","createFunction","sandboxedFunctions","WeakSet","argNames","scope","name","executeTree","createFunctionAsync","executeTreeAsync","sandboxedEval","sandboxedSetTimeout","handler","setTimeout","sandboxedSetInterval","setInterval","assignCheck","changeSubscriptions","cb","setSubscriptions","arrayChange","splice","reverse","sort","copyWithin","literalRegex","ops2","sandboxGlobal","options","audit","globalsAccess","globalsWhitelist","evals","globalThis","globalScope","getSubscriptions","isFunction","prototypeAccess","prot","prototype","getPrototypeOf","whitelist","prototypeWhitelist","prototypeReplacements","size","constuctor","g","forbidMethodCalls","execMany","vals","stringify","cache","recurse","x","y","change","changed","added","removed","startIndex","deleteCount","len","endIndex","reg","RegExp","resnums","processed","reses","num","$$","$","bobj","loop","loopScope","interalScope","execAsync","asyncDone","d","innerLoopVars","catch","syncDone","inLoopOrSwitch","executeTreeWithDone","toTest","execSync","isTrue","caseItem","valueOrProp","ops","ret","callback","Promise","resolve","reject","r","syncDoneExec","syncDoneOp","executionTree","scopes","s","current","SandboxGlobal","Sandbox","SAFE_GLOBALS","SAFE_PROTOTYPES","sandbox","values","WeakMap","Function","eval","console","debug","error","info","log","table","warn","isFinite","parseFloat","decodeURI","decodeURIComponent","encodeURI","encodeURIComponent","unescape","Symbol","EvalError","URIError","Int8Array","Uint8Array","Uint8ClampedArray","Int16Array","Uint16Array","Int32Array","Uint32Array","Float32Array","Float64Array","Intl","Date","protos","proto","subscribeGet","unsubscribe","subscribeSet","names","changeCbs","callbacks","compile","_this","compileAsync","_this2"],"mappings":"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"}